/* automatically generated by rust-bindgen 0.59.2 */

pub const LZ4F_VERSION: u32 = 100;
pub const LZ4F_HEADER_SIZE_MIN: u32 = 7;
pub const LZ4F_HEADER_SIZE_MAX: u32 = 19;
pub const LZ4F_BLOCK_HEADER_SIZE: u32 = 4;
pub const LZ4F_BLOCK_CHECKSUM_SIZE: u32 = 4;
pub const LZ4F_CONTENT_CHECKSUM_SIZE: u32 = 4;
pub const LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH: u32 = 5;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type LZ4F_errorCode_t = size_t;
extern "C" {
    pub fn LZ4F_isError(code: LZ4F_errorCode_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn LZ4F_getErrorName(code: LZ4F_errorCode_t) -> *const ::std::os::raw::c_char;
}
pub const LZ4F_blockSizeID_t_LZ4F_default: LZ4F_blockSizeID_t = 0;
pub const LZ4F_blockSizeID_t_LZ4F_max64KB: LZ4F_blockSizeID_t = 4;
pub const LZ4F_blockSizeID_t_LZ4F_max256KB: LZ4F_blockSizeID_t = 5;
pub const LZ4F_blockSizeID_t_LZ4F_max1MB: LZ4F_blockSizeID_t = 6;
pub const LZ4F_blockSizeID_t_LZ4F_max4MB: LZ4F_blockSizeID_t = 7;
pub type LZ4F_blockSizeID_t = ::std::os::raw::c_uint;
pub const LZ4F_blockMode_t_LZ4F_blockLinked: LZ4F_blockMode_t = 0;
pub const LZ4F_blockMode_t_LZ4F_blockIndependent: LZ4F_blockMode_t = 1;
pub type LZ4F_blockMode_t = ::std::os::raw::c_uint;
pub const LZ4F_contentChecksum_t_LZ4F_noContentChecksum: LZ4F_contentChecksum_t = 0;
pub const LZ4F_contentChecksum_t_LZ4F_contentChecksumEnabled: LZ4F_contentChecksum_t = 1;
pub type LZ4F_contentChecksum_t = ::std::os::raw::c_uint;
pub const LZ4F_blockChecksum_t_LZ4F_noBlockChecksum: LZ4F_blockChecksum_t = 0;
pub const LZ4F_blockChecksum_t_LZ4F_blockChecksumEnabled: LZ4F_blockChecksum_t = 1;
pub type LZ4F_blockChecksum_t = ::std::os::raw::c_uint;
pub const LZ4F_frameType_t_LZ4F_frame: LZ4F_frameType_t = 0;
pub const LZ4F_frameType_t_LZ4F_skippableFrame: LZ4F_frameType_t = 1;
pub type LZ4F_frameType_t = ::std::os::raw::c_uint;
#[doc = " LZ4F_frameInfo_t :"]
#[doc = "  makes it possible to set or read frame parameters."]
#[doc = "  Structure must be first init to 0, using memset() or LZ4F_INIT_FRAMEINFO,"]
#[doc = "  setting all parameters to default."]
#[doc = "  It's then possible to update selectively some parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_frameInfo_t {
    pub blockSizeID: LZ4F_blockSizeID_t,
    pub blockMode: LZ4F_blockMode_t,
    pub contentChecksumFlag: LZ4F_contentChecksum_t,
    pub frameType: LZ4F_frameType_t,
    pub contentSize: ::std::os::raw::c_ulonglong,
    pub dictID: ::std::os::raw::c_uint,
    pub blockChecksumFlag: LZ4F_blockChecksum_t,
}
#[test]
fn bindgen_test_layout_LZ4F_frameInfo_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4F_frameInfo_t>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4F_frameInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_frameInfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_frameInfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).blockSizeID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockSizeID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).blockMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).contentChecksumFlag as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(contentChecksumFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).frameType as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(frameType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).contentSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(contentSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).dictID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(dictID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_frameInfo_t>())).blockChecksumFlag as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockChecksumFlag)
        )
    );
}
#[doc = " LZ4F_preferences_t :"]
#[doc = "  makes it possible to supply advanced compression instructions to streaming interface."]
#[doc = "  Structure must be first init to 0, using memset() or LZ4F_INIT_PREFERENCES,"]
#[doc = "  setting all parameters to default."]
#[doc = "  All reserved fields must be set to zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_preferences_t {
    pub frameInfo: LZ4F_frameInfo_t,
    pub compressionLevel: ::std::os::raw::c_int,
    pub autoFlush: ::std::os::raw::c_uint,
    pub favorDecSpeed: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_preferences_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4F_preferences_t>(),
        56usize,
        concat!("Size of: ", stringify!(LZ4F_preferences_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_preferences_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_preferences_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_preferences_t>())).frameInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(frameInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_preferences_t>())).compressionLevel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_preferences_t>())).autoFlush as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(autoFlush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_preferences_t>())).favorDecSpeed as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(favorDecSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_preferences_t>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn LZ4F_compressionLevel_max() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4F_compressFrameBound() :"]
    #[doc = "  Returns the maximum possible compressed size with LZ4F_compressFrame() given srcSize and preferences."]
    #[doc = " `preferencesPtr` is optional. It can be replaced by NULL, in which case, the function will assume default preferences."]
    #[doc = "  Note : this result is only usable with LZ4F_compressFrame()."]
    #[doc = "         It may also be used with LZ4F_compressUpdate() _if no flush() operation_ is performed."]
    pub fn LZ4F_compressFrameBound(
        srcSize: size_t,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_compressFrame() :"]
    #[doc = "  Compress an entire srcBuffer into a valid LZ4 frame."]
    #[doc = "  dstCapacity MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr)."]
    #[doc = "  The LZ4F_preferences_t structure is optional : you can provide NULL as argument. All preferences will be set to default."]
    #[doc = " @return : number of bytes written into dstBuffer."]
    #[doc = "           or an error code if it fails (can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressFrame(
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: size_t,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: size_t,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_cctx_s {
    _unused: [u8; 0],
}
pub type LZ4F_cctx = LZ4F_cctx_s;
pub type LZ4F_compressionContext_t = *mut LZ4F_cctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_compressOptions_t {
    pub stableSrc: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_compressOptions_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4F_compressOptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4F_compressOptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_compressOptions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4F_compressOptions_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_compressOptions_t>())).stableSrc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_compressOptions_t),
            "::",
            stringify!(stableSrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4F_compressOptions_t>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_compressOptions_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn LZ4F_getVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " LZ4F_createCompressionContext() :"]
    #[doc = " The first thing to do is to create a compressionContext object, which will be used in all compression operations."]
    #[doc = " This is achieved using LZ4F_createCompressionContext(), which takes as argument a version."]
    #[doc = " The version provided MUST be LZ4F_VERSION. It is intended to track potential version mismatch, notably when using DLL."]
    #[doc = " The function will provide a pointer to a fully allocated LZ4F_cctx object."]
    #[doc = " If @return != zero, there was an error during context creation."]
    #[doc = " Object can release its memory using LZ4F_freeCompressionContext();"]
    pub fn LZ4F_createCompressionContext(
        cctxPtr: *mut *mut LZ4F_cctx,
        version: ::std::os::raw::c_uint,
    ) -> LZ4F_errorCode_t;
}
extern "C" {
    pub fn LZ4F_freeCompressionContext(cctx: *mut LZ4F_cctx) -> LZ4F_errorCode_t;
}
extern "C" {
    #[doc = " LZ4F_compressBegin() :"]
    #[doc = "  will write the frame header into dstBuffer."]
    #[doc = "  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes."]
    #[doc = " `prefsPtr` is optional : you can provide NULL as argument, all preferences will then be set to default."]
    #[doc = " @return : number of bytes written into dstBuffer for the header"]
    #[doc = "           or an error code (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressBegin(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: size_t,
        prefsPtr: *const LZ4F_preferences_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_compressBound() :"]
    #[doc = "  Provides minimum dstCapacity required to guarantee success of"]
    #[doc = "  LZ4F_compressUpdate(), given a srcSize and preferences, for a worst case scenario."]
    #[doc = "  When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() instead."]
    #[doc = "  Note that the result is only valid for a single invocation of LZ4F_compressUpdate()."]
    #[doc = "  When invoking LZ4F_compressUpdate() multiple times,"]
    #[doc = "  if the output buffer is gradually filled up instead of emptied and re-used from its start,"]
    #[doc = "  one must check if there is enough remaining capacity before each invocation, using LZ4F_compressBound()."]
    #[doc = " @return is always the same for a srcSize and prefsPtr."]
    #[doc = "  prefsPtr is optional : when NULL is provided, preferences will be set to cover worst case scenario."]
    #[doc = "  tech details :"]
    #[doc = " @return if automatic flushing is not enabled, includes the possibility that internal buffer might already be filled by up to (blockSize-1) bytes."]
    #[doc = "  It also includes frame footer (ending + checksum), since it might be generated by LZ4F_compressEnd()."]
    #[doc = " @return doesn't include frame header, as it was already generated by LZ4F_compressBegin()."]
    pub fn LZ4F_compressBound(srcSize: size_t, prefsPtr: *const LZ4F_preferences_t) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_compressUpdate() :"]
    #[doc = "  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary."]
    #[doc = "  Important rule: dstCapacity MUST be large enough to ensure operation success even in worst case situations."]
    #[doc = "  This value is provided by LZ4F_compressBound()."]
    #[doc = "  If this condition is not respected, LZ4F_compress() will fail (result is an errorCode)."]
    #[doc = "  LZ4F_compressUpdate() doesn't guarantee error recovery."]
    #[doc = "  When an error occurs, compression context must be freed or resized."]
    #[doc = " `cOptPtr` is optional : NULL can be provided, in which case all options are set to default."]
    #[doc = " @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered)."]
    #[doc = "           or an error code if it fails (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressUpdate(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: size_t,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: size_t,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_flush() :"]
    #[doc = "  When data must be generated and sent immediately, without waiting for a block to be completely filled,"]
    #[doc = "  it's possible to call LZ4_flush(). It will immediately compress any data buffered within cctx."]
    #[doc = " `dstCapacity` must be large enough to ensure the operation will be successful."]
    #[doc = " `cOptPtr` is optional : it's possible to provide NULL, all options will be set to default."]
    #[doc = " @return : nb of bytes written into dstBuffer (can be zero, when there is no data stored within cctx)"]
    #[doc = "           or an error code if it fails (which can be tested using LZ4F_isError())"]
    #[doc = "  Note : LZ4F_flush() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr)."]
    pub fn LZ4F_flush(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: size_t,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_compressEnd() :"]
    #[doc = "  To properly finish an LZ4 frame, invoke LZ4F_compressEnd()."]
    #[doc = "  It will flush whatever data remained within `cctx` (like LZ4_flush())"]
    #[doc = "  and properly finalize the frame, with an endMark and a checksum."]
    #[doc = " `cOptPtr` is optional : NULL can be provided, in which case all options will be set to default."]
    #[doc = " @return : nb of bytes written into dstBuffer, necessarily >= 4 (endMark),"]
    #[doc = "           or an error code if it fails (which can be tested using LZ4F_isError())"]
    #[doc = "  Note : LZ4F_compressEnd() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr)."]
    #[doc = "  A successful call to LZ4F_compressEnd() makes `cctx` available again for another compression task."]
    pub fn LZ4F_compressEnd(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: size_t,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_dctx_s {
    _unused: [u8; 0],
}
pub type LZ4F_dctx = LZ4F_dctx_s;
pub type LZ4F_decompressionContext_t = *mut LZ4F_dctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_decompressOptions_t {
    pub stableDst: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_decompressOptions_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4F_decompressOptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4F_decompressOptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_decompressOptions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4F_decompressOptions_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_decompressOptions_t>())).stableDst as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(stableDst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4F_decompressOptions_t>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[doc = " LZ4F_createDecompressionContext() :"]
    #[doc = "  Create an LZ4F_dctx object, to track all decompression operations."]
    #[doc = "  The version provided MUST be LZ4F_VERSION."]
    #[doc = "  The function provides a pointer to an allocated and initialized LZ4F_dctx object."]
    #[doc = "  The result is an errorCode, which can be tested using LZ4F_isError()."]
    #[doc = "  dctx memory can be released using LZ4F_freeDecompressionContext();"]
    #[doc = "  Result of LZ4F_freeDecompressionContext() indicates current state of decompressionContext when being released."]
    #[doc = "  That is, it should be == 0 if decompression has been completed fully and correctly."]
    pub fn LZ4F_createDecompressionContext(
        dctxPtr: *mut *mut LZ4F_dctx,
        version: ::std::os::raw::c_uint,
    ) -> LZ4F_errorCode_t;
}
extern "C" {
    pub fn LZ4F_freeDecompressionContext(dctx: *mut LZ4F_dctx) -> LZ4F_errorCode_t;
}
extern "C" {
    #[doc = " LZ4F_headerSize() : v1.9.0+"]
    #[doc = "  Provide the header size of a frame starting at `src`."]
    #[doc = " `srcSize` must be >= LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH,"]
    #[doc = "  which is enough to decode the header length."]
    #[doc = " @return : size of frame header"]
    #[doc = "           or an error code, which can be tested using LZ4F_isError()"]
    #[doc = "  note : Frame header size is variable, but is guaranteed to be"]
    #[doc = "         >= LZ4F_HEADER_SIZE_MIN bytes, and <= LZ4F_HEADER_SIZE_MAX bytes."]
    pub fn LZ4F_headerSize(src: *const ::std::os::raw::c_void, srcSize: size_t) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_getFrameInfo() :"]
    #[doc = "  This function extracts frame parameters (max blockSize, dictID, etc.)."]
    #[doc = "  Its usage is optional: user can call LZ4F_decompress() directly."]
    #[doc = ""]
    #[doc = "  Extracted information will fill an existing LZ4F_frameInfo_t structure."]
    #[doc = "  This can be useful for allocation and dictionary identification purposes."]
    #[doc = ""]
    #[doc = "  LZ4F_getFrameInfo() can work in the following situations :"]
    #[doc = ""]
    #[doc = "  1) At the beginning of a new frame, before any invocation of LZ4F_decompress()."]
    #[doc = "     It will decode header from `srcBuffer`,"]
    #[doc = "     consuming the header and starting the decoding process."]
    #[doc = ""]
    #[doc = "     Input size must be large enough to contain the full frame header."]
    #[doc = "     Frame header size can be known beforehand by LZ4F_headerSize()."]
    #[doc = "     Frame header size is variable, but is guaranteed to be >= LZ4F_HEADER_SIZE_MIN bytes,"]
    #[doc = "     and not more than <= LZ4F_HEADER_SIZE_MAX bytes."]
    #[doc = "     Hence, blindly providing LZ4F_HEADER_SIZE_MAX bytes or more will always work."]
    #[doc = "     It's allowed to provide more input data than the header size,"]
    #[doc = "     LZ4F_getFrameInfo() will only consume the header."]
    #[doc = ""]
    #[doc = "     If input size is not large enough,"]
    #[doc = "     aka if it's smaller than header size,"]
    #[doc = "     function will fail and return an error code."]
    #[doc = ""]
    #[doc = "  2) After decoding has been started,"]
    #[doc = "     it's possible to invoke LZ4F_getFrameInfo() anytime"]
    #[doc = "     to extract already decoded frame parameters stored within dctx."]
    #[doc = ""]
    #[doc = "     Note that, if decoding has barely started,"]
    #[doc = "     and not yet read enough information to decode the header,"]
    #[doc = "     LZ4F_getFrameInfo() will fail."]
    #[doc = ""]
    #[doc = "  The number of bytes consumed from srcBuffer will be updated in *srcSizePtr (necessarily <= original value)."]
    #[doc = "  LZ4F_getFrameInfo() only consumes bytes when decoding has not yet started,"]
    #[doc = "  and when decoding the header has been successful."]
    #[doc = "  Decompression must then resume from (srcBuffer + *srcSizePtr)."]
    #[doc = ""]
    #[doc = " @return : a hint about how many srcSize bytes LZ4F_decompress() expects for next call,"]
    #[doc = "           or an error code which can be tested using LZ4F_isError()."]
    #[doc = "  note 1 : in case of error, dctx is not modified. Decoding operation can resume from beginning safely."]
    #[doc = "  note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure."]
    pub fn LZ4F_getFrameInfo(
        dctx: *mut LZ4F_dctx,
        frameInfoPtr: *mut LZ4F_frameInfo_t,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_decompress() :"]
    #[doc = "  Call this function repetitively to regenerate data compressed in `srcBuffer`."]
    #[doc = ""]
    #[doc = "  The function requires a valid dctx state."]
    #[doc = "  It will read up to *srcSizePtr bytes from srcBuffer,"]
    #[doc = "  and decompress data into dstBuffer, of capacity *dstSizePtr."]
    #[doc = ""]
    #[doc = "  The nb of bytes consumed from srcBuffer will be written into *srcSizePtr (necessarily <= original value)."]
    #[doc = "  The nb of bytes decompressed into dstBuffer will be written into *dstSizePtr (necessarily <= original value)."]
    #[doc = ""]
    #[doc = "  The function does not necessarily read all input bytes, so always check value in *srcSizePtr."]
    #[doc = "  Unconsumed source data must be presented again in subsequent invocations."]
    #[doc = ""]
    #[doc = " `dstBuffer` can freely change between each consecutive function invocation."]
    #[doc = " `dstBuffer` content will be overwritten."]
    #[doc = ""]
    #[doc = " @return : an hint of how many `srcSize` bytes LZ4F_decompress() expects for next call."]
    #[doc = "  Schematically, it's the size of the current (or remaining) compressed block + header of next block."]
    #[doc = "  Respecting the hint provides some small speed benefit, because it skips intermediate buffers."]
    #[doc = "  This is just a hint though, it's always possible to provide any srcSize."]
    #[doc = ""]
    #[doc = "  When a frame is fully decoded, @return will be 0 (no more data expected)."]
    #[doc = "  When provided with more bytes than necessary to decode a frame,"]
    #[doc = "  LZ4F_decompress() will stop reading exactly at end of current frame, and @return 0."]
    #[doc = ""]
    #[doc = "  If decompression failed, @return is an error code, which can be tested using LZ4F_isError()."]
    #[doc = "  After a decompression error, the `dctx` context is not resumable."]
    #[doc = "  Use LZ4F_resetDecompressionContext() to return to clean state."]
    #[doc = ""]
    #[doc = "  After a frame is fully decoded, dctx can be used again to decompress another frame."]
    pub fn LZ4F_decompress(
        dctx: *mut LZ4F_dctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstSizePtr: *mut size_t,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut size_t,
        dOptPtr: *const LZ4F_decompressOptions_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " LZ4F_resetDecompressionContext() : added in v1.8.0"]
    #[doc = "  In case of an error, the context is left in \"undefined\" state."]
    #[doc = "  In which case, it's necessary to reset it, before re-using it."]
    #[doc = "  This method can also be used to abruptly stop any unfinished decompression,"]
    #[doc = "  and start a new one using same context resources."]
    pub fn LZ4F_resetDecompressionContext(dctx: *mut LZ4F_dctx);
}
