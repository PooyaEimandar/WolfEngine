/* automatically generated by rust-bindgen 0.64.0 */

#![allow(dead_code, 
                    non_camel_case_types, 
                    non_snake_case, 
                    non_upper_case_globals,
                    trivial_numeric_casts)]
#![allow(clippy::cast_lossless,
                clippy::approx_constant,
                clippy::cast_possible_truncation,
                clippy::default_trait_access,
                clippy::missing_const_for_fn,
                clippy::missing_safety_doc,
                clippy::must_use_candidate,
                clippy::octal_escapes,        
                clippy::ptr_as_ptr,
                clippy::semicolon_if_nothing_returned,
                clippy::too_many_arguments,
                clippy::too_many_lines,
                clippy::transmute_ptr_to_ptr,
                clippy::type_complexity,
                clippy::unnecessary_cast,
                clippy::unreadable_literal, 
                clippy::upper_case_acronyms,
                clippy::use_self,
                clippy::used_underscore_binding,
                clippy::useless_transmute)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_GAMES: u32 = 6;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY: u32 = 100;
pub const _WIN32_WINNT_NT4: u32 = 1024;
pub const _WIN32_WINNT_WIN2K: u32 = 1280;
pub const _WIN32_WINNT_WINXP: u32 = 1281;
pub const _WIN32_WINNT_WS03: u32 = 1282;
pub const _WIN32_WINNT_WIN6: u32 = 1536;
pub const _WIN32_WINNT_VISTA: u32 = 1536;
pub const _WIN32_WINNT_WS08: u32 = 1536;
pub const _WIN32_WINNT_LONGHORN: u32 = 1536;
pub const _WIN32_WINNT_WIN7: u32 = 1537;
pub const _WIN32_WINNT_WIN8: u32 = 1538;
pub const _WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_WINNT_WIN10: u32 = 2560;
pub const _WIN32_IE_IE20: u32 = 512;
pub const _WIN32_IE_IE30: u32 = 768;
pub const _WIN32_IE_IE302: u32 = 770;
pub const _WIN32_IE_IE40: u32 = 1024;
pub const _WIN32_IE_IE401: u32 = 1025;
pub const _WIN32_IE_IE50: u32 = 1280;
pub const _WIN32_IE_IE501: u32 = 1281;
pub const _WIN32_IE_IE55: u32 = 1360;
pub const _WIN32_IE_IE60: u32 = 1536;
pub const _WIN32_IE_IE60SP1: u32 = 1537;
pub const _WIN32_IE_IE60SP2: u32 = 1539;
pub const _WIN32_IE_IE70: u32 = 1792;
pub const _WIN32_IE_IE80: u32 = 2048;
pub const _WIN32_IE_IE90: u32 = 2304;
pub const _WIN32_IE_IE100: u32 = 2560;
pub const _WIN32_IE_IE110: u32 = 2560;
pub const _WIN32_IE_NT4: u32 = 512;
pub const _WIN32_IE_NT4SP1: u32 = 512;
pub const _WIN32_IE_NT4SP2: u32 = 512;
pub const _WIN32_IE_NT4SP3: u32 = 770;
pub const _WIN32_IE_NT4SP4: u32 = 1025;
pub const _WIN32_IE_NT4SP5: u32 = 1025;
pub const _WIN32_IE_NT4SP6: u32 = 1280;
pub const _WIN32_IE_WIN98: u32 = 1025;
pub const _WIN32_IE_WIN98SE: u32 = 1280;
pub const _WIN32_IE_WINME: u32 = 1360;
pub const _WIN32_IE_WIN2K: u32 = 1281;
pub const _WIN32_IE_WIN2KSP1: u32 = 1281;
pub const _WIN32_IE_WIN2KSP2: u32 = 1281;
pub const _WIN32_IE_WIN2KSP3: u32 = 1281;
pub const _WIN32_IE_WIN2KSP4: u32 = 1281;
pub const _WIN32_IE_XP: u32 = 1536;
pub const _WIN32_IE_XPSP1: u32 = 1537;
pub const _WIN32_IE_XPSP2: u32 = 1539;
pub const _WIN32_IE_WS03: u32 = 1538;
pub const _WIN32_IE_WS03SP1: u32 = 1539;
pub const _WIN32_IE_WIN6: u32 = 1792;
pub const _WIN32_IE_LONGHORN: u32 = 1792;
pub const _WIN32_IE_WIN7: u32 = 2048;
pub const _WIN32_IE_WIN8: u32 = 2560;
pub const _WIN32_IE_WINBLUE: u32 = 2560;
pub const _WIN32_IE_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_IE_WIN10: u32 = 2560;
pub const NTDDI_WIN4: u32 = 67108864;
pub const NTDDI_WIN2K: u32 = 83886080;
pub const NTDDI_WIN2KSP1: u32 = 83886336;
pub const NTDDI_WIN2KSP2: u32 = 83886592;
pub const NTDDI_WIN2KSP3: u32 = 83886848;
pub const NTDDI_WIN2KSP4: u32 = 83887104;
pub const NTDDI_WINXP: u32 = 83951616;
pub const NTDDI_WINXPSP1: u32 = 83951872;
pub const NTDDI_WINXPSP2: u32 = 83952128;
pub const NTDDI_WINXPSP3: u32 = 83952384;
pub const NTDDI_WINXPSP4: u32 = 83952640;
pub const NTDDI_WS03: u32 = 84017152;
pub const NTDDI_WS03SP1: u32 = 84017408;
pub const NTDDI_WS03SP2: u32 = 84017664;
pub const NTDDI_WS03SP3: u32 = 84017920;
pub const NTDDI_WS03SP4: u32 = 84018176;
pub const NTDDI_WIN6: u32 = 100663296;
pub const NTDDI_WIN6SP1: u32 = 100663552;
pub const NTDDI_WIN6SP2: u32 = 100663808;
pub const NTDDI_WIN6SP3: u32 = 100664064;
pub const NTDDI_WIN6SP4: u32 = 100664320;
pub const NTDDI_VISTA: u32 = 100663296;
pub const NTDDI_VISTASP1: u32 = 100663552;
pub const NTDDI_VISTASP2: u32 = 100663808;
pub const NTDDI_VISTASP3: u32 = 100664064;
pub const NTDDI_VISTASP4: u32 = 100664320;
pub const NTDDI_LONGHORN: u32 = 100663296;
pub const NTDDI_WS08: u32 = 100663552;
pub const NTDDI_WS08SP2: u32 = 100663808;
pub const NTDDI_WS08SP3: u32 = 100664064;
pub const NTDDI_WS08SP4: u32 = 100664320;
pub const NTDDI_WIN7: u32 = 100728832;
pub const NTDDI_WIN8: u32 = 100794368;
pub const NTDDI_WINBLUE: u32 = 100859904;
pub const NTDDI_WINTHRESHOLD: u32 = 167772160;
pub const NTDDI_WIN10: u32 = 167772160;
pub const NTDDI_WIN10_TH2: u32 = 167772161;
pub const NTDDI_WIN10_RS1: u32 = 167772162;
pub const NTDDI_WIN10_RS2: u32 = 167772163;
pub const NTDDI_WIN10_RS3: u32 = 167772164;
pub const NTDDI_WIN10_RS4: u32 = 167772165;
pub const NTDDI_WIN10_RS5: u32 = 167772166;
pub const NTDDI_WIN10_19H1: u32 = 167772167;
pub const NTDDI_WIN10_VB: u32 = 167772168;
pub const NTDDI_WIN10_MN: u32 = 167772169;
pub const NTDDI_WIN10_FE: u32 = 167772170;
pub const NTDDI_WIN10_CO: u32 = 167772171;
pub const NTDDI_WIN10_NI: u32 = 167772172;
pub const WDK_NTDDI_VERSION: u32 = 167772172;
pub const OSVERSION_MASK: u32 = 4294901760;
pub const SPVERSION_MASK: u32 = 65280;
pub const SUBVERSION_MASK: u32 = 255;
pub const _WIN32_WINNT: u32 = 2560;
pub const NTDDI_VERSION: u32 = 167772172;
pub const WINVER: u32 = 2560;
pub const _WIN32_IE: u32 = 2560;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 1;
pub const _HAS_CXX20: u32 = 1;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __SAL_H_FULL_VER: u32 = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: u32 = 1;
pub const __drv_typeConst: u32 = 0;
pub const __drv_typeCond: u32 = 1;
pub const __drv_typeBitset: u32 = 2;
pub const __drv_typeExpr: u32 = 3;
pub const STRICT: u32 = 1;
pub const MAX_PATH: u32 = 260;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 1;
pub const _CRT_HAS_C11: u32 = 0;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const ANYSIZE_ARRAY: u32 = 1;
pub const DISPATCH_LEVEL: u32 = 2;
pub const APC_LEVEL: u32 = 1;
pub const PASSIVE_LEVEL: u32 = 0;
pub const HIGH_LEVEL: u32 = 15;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16;
pub const X86_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const ARM_CACHE_ALIGNMENT_SIZE: u32 = 128;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const PRAGMA_DEPRECATED_DDK: u32 = 0;
pub const UCSCHAR_INVALID_CHARACTER: u32 = 4294967295;
pub const MIN_UCSCHAR: u32 = 0;
pub const MAX_UCSCHAR: u32 = 1114111;
pub const ALL_PROCESSOR_GROUPS: u32 = 65535;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64;
pub const MAXIMUM_PROCESSORS: u32 = 64;
pub const APPLICATION_ERROR_MASK: u32 = 536870912;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINCHAR: u32 = 128;
pub const MAXCHAR: u32 = 127;
pub const MINSHORT: u32 = 32768;
pub const MAXSHORT: u32 = 32767;
pub const MINLONG: u32 = 2147483648;
pub const MAXLONG: u32 = 2147483647;
pub const MAXBYTE: u32 = 255;
pub const MAXWORD: u32 = 65535;
pub const MAXDWORD: u32 = 4294967295;
pub const ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const VER_SERVER_NT: u32 = 2147483648;
pub const VER_WORKSTATION_NT: u32 = 1073741824;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1;
pub const VER_SUITE_ENTERPRISE: u32 = 2;
pub const VER_SUITE_BACKOFFICE: u32 = 4;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8;
pub const VER_SUITE_TERMINAL: u32 = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64;
pub const VER_SUITE_DATACENTER: u32 = 128;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256;
pub const VER_SUITE_PERSONAL: u32 = 512;
pub const VER_SUITE_BLADE: u32 = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384;
pub const VER_SUITE_WH_SERVER: u32 = 32768;
pub const VER_SUITE_MULTIUSERTS: u32 = 131072;
pub const PRODUCT_UNDEFINED: u32 = 0;
pub const PRODUCT_ULTIMATE: u32 = 1;
pub const PRODUCT_HOME_BASIC: u32 = 2;
pub const PRODUCT_HOME_PREMIUM: u32 = 3;
pub const PRODUCT_ENTERPRISE: u32 = 4;
pub const PRODUCT_HOME_BASIC_N: u32 = 5;
pub const PRODUCT_BUSINESS: u32 = 6;
pub const PRODUCT_STANDARD_SERVER: u32 = 7;
pub const PRODUCT_DATACENTER_SERVER: u32 = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: u32 = 9;
pub const PRODUCT_ENTERPRISE_SERVER: u32 = 10;
pub const PRODUCT_STARTER: u32 = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: u32 = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: u32 = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: u32 = 15;
pub const PRODUCT_BUSINESS_N: u32 = 16;
pub const PRODUCT_WEB_SERVER: u32 = 17;
pub const PRODUCT_CLUSTER_SERVER: u32 = 18;
pub const PRODUCT_HOME_SERVER: u32 = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: u32 = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: u32 = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: u32 = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: u32 = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: u32 = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: u32 = 25;
pub const PRODUCT_HOME_PREMIUM_N: u32 = 26;
pub const PRODUCT_ENTERPRISE_N: u32 = 27;
pub const PRODUCT_ULTIMATE_N: u32 = 28;
pub const PRODUCT_WEB_SERVER_CORE: u32 = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: u32 = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: u32 = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: u32 = 32;
pub const PRODUCT_SERVER_FOUNDATION: u32 = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: u32 = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: u32 = 35;
pub const PRODUCT_STANDARD_SERVER_V: u32 = 36;
pub const PRODUCT_DATACENTER_SERVER_V: u32 = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: u32 = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: u32 = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: u32 = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: u32 = 41;
pub const PRODUCT_HYPERV: u32 = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: u32 = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: u32 = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: u32 = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: u32 = 46;
pub const PRODUCT_STARTER_N: u32 = 47;
pub const PRODUCT_PROFESSIONAL: u32 = 48;
pub const PRODUCT_PROFESSIONAL_N: u32 = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: u32 = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: u32 = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: u32 = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: u32 = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: u32 = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: u32 = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: u32 = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: u32 = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: u32 = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: u32 = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: u32 = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: u32 = 63;
pub const PRODUCT_CLUSTER_SERVER_V: u32 = 64;
pub const PRODUCT_EMBEDDED: u32 = 65;
pub const PRODUCT_STARTER_E: u32 = 66;
pub const PRODUCT_HOME_BASIC_E: u32 = 67;
pub const PRODUCT_HOME_PREMIUM_E: u32 = 68;
pub const PRODUCT_PROFESSIONAL_E: u32 = 69;
pub const PRODUCT_ENTERPRISE_E: u32 = 70;
pub const PRODUCT_ULTIMATE_E: u32 = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: u32 = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: u32 = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: u32 = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: u32 = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: u32 = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: u32 = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86;
pub const PRODUCT_THINPC: u32 = 87;
pub const PRODUCT_EMBEDDED_A: u32 = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89;
pub const PRODUCT_EMBEDDED_E: u32 = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: u32 = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: u32 = 96;
pub const PRODUCT_CORE_ARM: u32 = 97;
pub const PRODUCT_CORE_N: u32 = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: u32 = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: u32 = 100;
pub const PRODUCT_CORE: u32 = 101;
pub const PRODUCT_PROFESSIONAL_WMC: u32 = 103;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108;
pub const PRODUCT_NANO_SERVER: u32 = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110;
pub const PRODUCT_CORE_CONNECTED: u32 = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116;
pub const PRODUCT_CONNECTED_CAR: u32 = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118;
pub const PRODUCT_PPI_PRO: u32 = 119;
pub const PRODUCT_ARM64_SERVER: u32 = 120;
pub const PRODUCT_EDUCATION: u32 = 121;
pub const PRODUCT_EDUCATION_N: u32 = 122;
pub const PRODUCT_IOTUAP: u32 = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124;
pub const PRODUCT_ENTERPRISE_S: u32 = 125;
pub const PRODUCT_ENTERPRISE_S_N: u32 = 126;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: u32 = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: u32 = 130;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135;
pub const PRODUCT_HOLOGRAPHIC_BUSINESS: u32 = 136;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138;
pub const PRODUCT_PRO_CHINA: u32 = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: u32 = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: u32 = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148;
pub const PRODUCT_UTILITY_VM: u32 = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160;
pub const PRODUCT_PRO_WORKSTATION: u32 = 161;
pub const PRODUCT_PRO_WORKSTATION_N: u32 = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169;
pub const PRODUCT_ENTERPRISEG: u32 = 171;
pub const PRODUCT_ENTERPRISEGN: u32 = 172;
pub const PRODUCT_SERVERRDSH: u32 = 175;
pub const PRODUCT_CLOUD: u32 = 178;
pub const PRODUCT_CLOUDN: u32 = 179;
pub const PRODUCT_HUBOS: u32 = 180;
pub const PRODUCT_ONECOREUPDATEOS: u32 = 182;
pub const PRODUCT_CLOUDE: u32 = 183;
pub const PRODUCT_IOTOS: u32 = 185;
pub const PRODUCT_CLOUDEN: u32 = 186;
pub const PRODUCT_IOTEDGEOS: u32 = 187;
pub const PRODUCT_IOTENTERPRISE: u32 = 188;
pub const PRODUCT_LITE: u32 = 189;
pub const PRODUCT_IOTENTERPRISES: u32 = 191;
pub const PRODUCT_XBOX_SYSTEMOS: u32 = 192;
pub const PRODUCT_XBOX_GAMEOS: u32 = 194;
pub const PRODUCT_XBOX_ERAOS: u32 = 195;
pub const PRODUCT_XBOX_DURANGOHOSTOS: u32 = 196;
pub const PRODUCT_XBOX_SCARLETTHOSTOS: u32 = 197;
pub const PRODUCT_XBOX_KEYSTONE: u32 = 198;
pub const PRODUCT_AZURE_SERVER_CLOUDHOST: u32 = 199;
pub const PRODUCT_AZURE_SERVER_CLOUDMOS: u32 = 200;
pub const PRODUCT_CLOUDEDITIONN: u32 = 202;
pub const PRODUCT_CLOUDEDITION: u32 = 203;
pub const PRODUCT_AZURESTACKHCI_SERVER_CORE: u32 = 406;
pub const PRODUCT_DATACENTER_SERVER_AZURE_EDITION: u32 = 407;
pub const PRODUCT_DATACENTER_SERVER_CORE_AZURE_EDITION: u32 = 408;
pub const PRODUCT_UNLICENSED: u32 = 2882382797;
pub const LANG_NEUTRAL: u32 = 0;
pub const LANG_INVARIANT: u32 = 127;
pub const LANG_AFRIKAANS: u32 = 54;
pub const LANG_ALBANIAN: u32 = 28;
pub const LANG_ALSATIAN: u32 = 132;
pub const LANG_AMHARIC: u32 = 94;
pub const LANG_ARABIC: u32 = 1;
pub const LANG_ARMENIAN: u32 = 43;
pub const LANG_ASSAMESE: u32 = 77;
pub const LANG_AZERI: u32 = 44;
pub const LANG_AZERBAIJANI: u32 = 44;
pub const LANG_BANGLA: u32 = 69;
pub const LANG_BASHKIR: u32 = 109;
pub const LANG_BASQUE: u32 = 45;
pub const LANG_BELARUSIAN: u32 = 35;
pub const LANG_BENGALI: u32 = 69;
pub const LANG_BRETON: u32 = 126;
pub const LANG_BOSNIAN: u32 = 26;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746;
pub const LANG_BULGARIAN: u32 = 2;
pub const LANG_CATALAN: u32 = 3;
pub const LANG_CENTRAL_KURDISH: u32 = 146;
pub const LANG_CHEROKEE: u32 = 92;
pub const LANG_CHINESE: u32 = 4;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748;
pub const LANG_CORSICAN: u32 = 131;
pub const LANG_CROATIAN: u32 = 26;
pub const LANG_CZECH: u32 = 5;
pub const LANG_DANISH: u32 = 6;
pub const LANG_DARI: u32 = 140;
pub const LANG_DIVEHI: u32 = 101;
pub const LANG_DUTCH: u32 = 19;
pub const LANG_ENGLISH: u32 = 9;
pub const LANG_ESTONIAN: u32 = 37;
pub const LANG_FAEROESE: u32 = 56;
pub const LANG_FARSI: u32 = 41;
pub const LANG_FILIPINO: u32 = 100;
pub const LANG_FINNISH: u32 = 11;
pub const LANG_FRENCH: u32 = 12;
pub const LANG_FRISIAN: u32 = 98;
pub const LANG_FULAH: u32 = 103;
pub const LANG_GALICIAN: u32 = 86;
pub const LANG_GEORGIAN: u32 = 55;
pub const LANG_GERMAN: u32 = 7;
pub const LANG_GREEK: u32 = 8;
pub const LANG_GREENLANDIC: u32 = 111;
pub const LANG_GUJARATI: u32 = 71;
pub const LANG_HAUSA: u32 = 104;
pub const LANG_HAWAIIAN: u32 = 117;
pub const LANG_HEBREW: u32 = 13;
pub const LANG_HINDI: u32 = 57;
pub const LANG_HUNGARIAN: u32 = 14;
pub const LANG_ICELANDIC: u32 = 15;
pub const LANG_IGBO: u32 = 112;
pub const LANG_INDONESIAN: u32 = 33;
pub const LANG_INUKTITUT: u32 = 93;
pub const LANG_IRISH: u32 = 60;
pub const LANG_ITALIAN: u32 = 16;
pub const LANG_JAPANESE: u32 = 17;
pub const LANG_KANNADA: u32 = 75;
pub const LANG_KASHMIRI: u32 = 96;
pub const LANG_KAZAK: u32 = 63;
pub const LANG_KHMER: u32 = 83;
pub const LANG_KICHE: u32 = 134;
pub const LANG_KINYARWANDA: u32 = 135;
pub const LANG_KONKANI: u32 = 87;
pub const LANG_KOREAN: u32 = 18;
pub const LANG_KYRGYZ: u32 = 64;
pub const LANG_LAO: u32 = 84;
pub const LANG_LATVIAN: u32 = 38;
pub const LANG_LITHUANIAN: u32 = 39;
pub const LANG_LOWER_SORBIAN: u32 = 46;
pub const LANG_LUXEMBOURGISH: u32 = 110;
pub const LANG_MACEDONIAN: u32 = 47;
pub const LANG_MALAY: u32 = 62;
pub const LANG_MALAYALAM: u32 = 76;
pub const LANG_MALTESE: u32 = 58;
pub const LANG_MANIPURI: u32 = 88;
pub const LANG_MAORI: u32 = 129;
pub const LANG_MAPUDUNGUN: u32 = 122;
pub const LANG_MARATHI: u32 = 78;
pub const LANG_MOHAWK: u32 = 124;
pub const LANG_MONGOLIAN: u32 = 80;
pub const LANG_NEPALI: u32 = 97;
pub const LANG_NORWEGIAN: u32 = 20;
pub const LANG_OCCITAN: u32 = 130;
pub const LANG_ODIA: u32 = 72;
pub const LANG_ORIYA: u32 = 72;
pub const LANG_PASHTO: u32 = 99;
pub const LANG_PERSIAN: u32 = 41;
pub const LANG_POLISH: u32 = 21;
pub const LANG_PORTUGUESE: u32 = 22;
pub const LANG_PULAR: u32 = 103;
pub const LANG_PUNJABI: u32 = 70;
pub const LANG_QUECHUA: u32 = 107;
pub const LANG_ROMANIAN: u32 = 24;
pub const LANG_ROMANSH: u32 = 23;
pub const LANG_RUSSIAN: u32 = 25;
pub const LANG_SAKHA: u32 = 133;
pub const LANG_SAMI: u32 = 59;
pub const LANG_SANSKRIT: u32 = 79;
pub const LANG_SCOTTISH_GAELIC: u32 = 145;
pub const LANG_SERBIAN: u32 = 26;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770;
pub const LANG_SINDHI: u32 = 89;
pub const LANG_SINHALESE: u32 = 91;
pub const LANG_SLOVAK: u32 = 27;
pub const LANG_SLOVENIAN: u32 = 36;
pub const LANG_SOTHO: u32 = 108;
pub const LANG_SPANISH: u32 = 10;
pub const LANG_SWAHILI: u32 = 65;
pub const LANG_SWEDISH: u32 = 29;
pub const LANG_SYRIAC: u32 = 90;
pub const LANG_TAJIK: u32 = 40;
pub const LANG_TAMAZIGHT: u32 = 95;
pub const LANG_TAMIL: u32 = 73;
pub const LANG_TATAR: u32 = 68;
pub const LANG_TELUGU: u32 = 74;
pub const LANG_THAI: u32 = 30;
pub const LANG_TIBETAN: u32 = 81;
pub const LANG_TIGRIGNA: u32 = 115;
pub const LANG_TIGRINYA: u32 = 115;
pub const LANG_TSWANA: u32 = 50;
pub const LANG_TURKISH: u32 = 31;
pub const LANG_TURKMEN: u32 = 66;
pub const LANG_UIGHUR: u32 = 128;
pub const LANG_UKRAINIAN: u32 = 34;
pub const LANG_UPPER_SORBIAN: u32 = 46;
pub const LANG_URDU: u32 = 32;
pub const LANG_UZBEK: u32 = 67;
pub const LANG_VALENCIAN: u32 = 3;
pub const LANG_VIETNAMESE: u32 = 42;
pub const LANG_WELSH: u32 = 82;
pub const LANG_WOLOF: u32 = 136;
pub const LANG_XHOSA: u32 = 52;
pub const LANG_YAKUT: u32 = 133;
pub const LANG_YI: u32 = 120;
pub const LANG_YORUBA: u32 = 106;
pub const LANG_ZULU: u32 = 53;
pub const SUBLANG_NEUTRAL: u32 = 0;
pub const SUBLANG_DEFAULT: u32 = 1;
pub const SUBLANG_SYS_DEFAULT: u32 = 2;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7;
pub const SUBLANG_ARABIC_OMAN: u32 = 8;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13;
pub const SUBLANG_ARABIC_UAE: u32 = 14;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15;
pub const SUBLANG_ARABIC_QATAR: u32 = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1;
pub const SUBLANG_AZERI_LATIN: u32 = 1;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2;
pub const SUBLANG_BANGLA_INDIA: u32 = 1;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1;
pub const SUBLANG_BENGALI_INDIA: u32 = 1;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8;
pub const SUBLANG_BRETON_FRANCE: u32 = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4;
pub const SUBLANG_CHINESE_MACAU: u32 = 5;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4;
pub const SUBLANG_DANISH_DENMARK: u32 = 1;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1;
pub const SUBLANG_DUTCH: u32 = 1;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2;
pub const SUBLANG_ENGLISH_US: u32 = 1;
pub const SUBLANG_ENGLISH_UK: u32 = 2;
pub const SUBLANG_ENGLISH_AUS: u32 = 3;
pub const SUBLANG_ENGLISH_CAN: u32 = 4;
pub const SUBLANG_ENGLISH_NZ: u32 = 5;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1;
pub const SUBLANG_FRENCH: u32 = 1;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3;
pub const SUBLANG_FRENCH_SWISS: u32 = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5;
pub const SUBLANG_FRENCH_MONACO: u32 = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1;
pub const SUBLANG_GERMAN: u32 = 1;
pub const SUBLANG_GERMAN_SWISS: u32 = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5;
pub const SUBLANG_GREEK_GREECE: u32 = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1;
pub const SUBLANG_HAWAIIAN_US: u32 = 1;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1;
pub const SUBLANG_HINDI_INDIA: u32 = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2;
pub const SUBLANG_IRISH_IRELAND: u32 = 2;
pub const SUBLANG_ITALIAN: u32 = 1;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1;
pub const SUBLANG_KANNADA_INDIA: u32 = 1;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1;
pub const SUBLANG_KONKANI_INDIA: u32 = 1;
pub const SUBLANG_KOREAN: u32 = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1;
pub const SUBLANG_LAO_LAO: u32 = 1;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1;
pub const SUBLANG_LITHUANIAN: u32 = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1;
pub const SUBLANG_MALTESE_MALTA: u32 = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1;
pub const SUBLANG_MARATHI_INDIA: u32 = 1;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2;
pub const SUBLANG_NEPALI_INDIA: u32 = 2;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1;
pub const SUBLANG_ODIA_INDIA: u32 = 1;
pub const SUBLANG_ORIYA_INDIA: u32 = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1;
pub const SUBLANG_POLISH_POLAND: u32 = 1;
pub const SUBLANG_PORTUGUESE: u32 = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2;
pub const SUBLANG_QUECHUA_PERU: u32 = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3;
pub const SUBLANG_SINDHI_INDIA: u32 = 1;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1;
pub const SUBLANG_SPANISH: u32 = 1;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2;
pub const SUBLANG_SPANISH_MODERN: u32 = 3;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9;
pub const SUBLANG_SPANISH_PERU: u32 = 10;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12;
pub const SUBLANG_SPANISH_CHILE: u32 = 13;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20;
pub const SUBLANG_SPANISH_US: u32 = 21;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1;
pub const SUBLANG_SWEDISH: u32 = 1;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4;
pub const SUBLANG_TAMIL_INDIA: u32 = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1;
pub const SUBLANG_TELUGU_INDIA: u32 = 1;
pub const SUBLANG_THAI_THAILAND: u32 = 1;
pub const SUBLANG_TIBETAN_PRC: u32 = 1;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1;
pub const SUBLANG_UIGHUR_PRC: u32 = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1;
pub const SUBLANG_URDU_INDIA: u32 = 2;
pub const SUBLANG_UZBEK_LATIN: u32 = 1;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1;
pub const SUBLANG_YI_PRC: u32 = 1;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1;
pub const SORT_DEFAULT: u32 = 0;
pub const SORT_INVARIANT_MATH: u32 = 1;
pub const SORT_JAPANESE_XJIS: u32 = 0;
pub const SORT_JAPANESE_UNICODE: u32 = 1;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4;
pub const SORT_CHINESE_BIG5: u32 = 0;
pub const SORT_CHINESE_PRCP: u32 = 0;
pub const SORT_CHINESE_UNICODE: u32 = 1;
pub const SORT_CHINESE_PRC: u32 = 2;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4;
pub const SORT_KOREAN_KSC: u32 = 0;
pub const SORT_KOREAN_UNICODE: u32 = 1;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0;
pub const SORT_GEORGIAN_MODERN: u32 = 1;
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127;
pub const _MM_HINT_T0: u32 = 1;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 3;
pub const _MM_HINT_NTA: u32 = 0;
pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const EXCEPTION_READ_FAULT: u32 = 0;
pub const EXCEPTION_WRITE_FAULT: u32 = 1;
pub const EXCEPTION_EXECUTE_FAULT: u32 = 8;
pub const CONTEXT_AMD64: u32 = 1048576;
pub const CONTEXT_CONTROL: u32 = 1048577;
pub const CONTEXT_INTEGER: u32 = 1048578;
pub const CONTEXT_SEGMENTS: u32 = 1048580;
pub const CONTEXT_FLOATING_POINT: u32 = 1048584;
pub const CONTEXT_DEBUG_REGISTERS: u32 = 1048592;
pub const CONTEXT_FULL: u32 = 1048587;
pub const CONTEXT_ALL: u32 = 1048607;
pub const CONTEXT_XSTATE: u32 = 1048640;
pub const CONTEXT_KERNEL_CET: u32 = 1048704;
pub const CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const CONTEXT_UNWOUND_TO_CALL: u32 = 536870912;
pub const INITIAL_MXCSR: u32 = 8064;
pub const INITIAL_FPCSR: u32 = 639;
pub const RUNTIME_FUNCTION_INDIRECT: u32 = 1;
pub const UNW_FLAG_NHANDLER: u32 = 0;
pub const UNW_FLAG_EHANDLER: u32 = 1;
pub const UNW_FLAG_UHANDLER: u32 = 2;
pub const UNW_FLAG_CHAININFO: u32 = 4;
pub const UNW_FLAG_NO_EPILOGUE: u32 = 2147483648;
pub const UNWIND_CHAIN_LIMIT: u32 = 32;
pub const OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME: &[u8; 34usize] =
    b"OutOfProcessFunctionTableCallback\0";
pub const CONTEXT_ARM64: u32 = 4194304;
pub const CONTEXT_ARM64_CONTROL: u32 = 4194305;
pub const CONTEXT_ARM64_INTEGER: u32 = 4194306;
pub const CONTEXT_ARM64_FLOATING_POINT: u32 = 4194308;
pub const CONTEXT_ARM64_DEBUG_REGISTERS: u32 = 4194312;
pub const CONTEXT_ARM64_X18: u32 = 4194320;
pub const CONTEXT_ARM64_FULL: u32 = 4194311;
pub const CONTEXT_ARM64_ALL: u32 = 4194335;
pub const CONTEXT_ARM64_UNWOUND_TO_CALL: u32 = 536870912;
pub const CONTEXT_ARM64_RET_TO_GUEST: u32 = 67108864;
pub const ARM64_MAX_BREAKPOINTS: u32 = 8;
pub const ARM64_MAX_WATCHPOINTS: u32 = 2;
pub const NONVOL_INT_NUMREG_ARM64: u32 = 11;
pub const NONVOL_FP_NUMREG_ARM64: u32 = 8;
pub const WOW64_CONTEXT_i386: u32 = 65536;
pub const WOW64_CONTEXT_i486: u32 = 65536;
pub const WOW64_CONTEXT_CONTROL: u32 = 65537;
pub const WOW64_CONTEXT_INTEGER: u32 = 65538;
pub const WOW64_CONTEXT_SEGMENTS: u32 = 65540;
pub const WOW64_CONTEXT_FLOATING_POINT: u32 = 65544;
pub const WOW64_CONTEXT_DEBUG_REGISTERS: u32 = 65552;
pub const WOW64_CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const WOW64_CONTEXT_FULL: u32 = 65543;
pub const WOW64_CONTEXT_ALL: u32 = 65599;
pub const WOW64_CONTEXT_XSTATE: u32 = 65600;
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const WOW64_CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const WOW64_CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const WOW64_CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const WOW64_SIZE_OF_80387_REGISTERS: u32 = 80;
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION: u32 = 512;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_SOFTWARE_ORIGINATE: u32 = 128;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const SID_REVISION: u32 = 1;
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15;
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1;
pub const SECURITY_MAX_SID_STRING_CHARACTERS: u32 = 187;
pub const SID_HASH_SIZE: u32 = 32;
pub const SECURITY_NULL_RID: u32 = 0;
pub const SECURITY_WORLD_RID: u32 = 0;
pub const SECURITY_LOCAL_RID: u32 = 0;
pub const SECURITY_LOCAL_LOGON_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_RID: u32 = 0;
pub const SECURITY_CREATOR_GROUP_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_SERVER_RID: u32 = 2;
pub const SECURITY_CREATOR_GROUP_SERVER_RID: u32 = 3;
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID: u32 = 4;
pub const SECURITY_DIALUP_RID: u32 = 1;
pub const SECURITY_NETWORK_RID: u32 = 2;
pub const SECURITY_BATCH_RID: u32 = 3;
pub const SECURITY_INTERACTIVE_RID: u32 = 4;
pub const SECURITY_LOGON_IDS_RID: u32 = 5;
pub const SECURITY_LOGON_IDS_RID_COUNT: u32 = 3;
pub const SECURITY_SERVICE_RID: u32 = 6;
pub const SECURITY_ANONYMOUS_LOGON_RID: u32 = 7;
pub const SECURITY_PROXY_RID: u32 = 8;
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID: u32 = 9;
pub const SECURITY_SERVER_LOGON_RID: u32 = 9;
pub const SECURITY_PRINCIPAL_SELF_RID: u32 = 10;
pub const SECURITY_AUTHENTICATED_USER_RID: u32 = 11;
pub const SECURITY_RESTRICTED_CODE_RID: u32 = 12;
pub const SECURITY_TERMINAL_SERVER_RID: u32 = 13;
pub const SECURITY_REMOTE_LOGON_RID: u32 = 14;
pub const SECURITY_THIS_ORGANIZATION_RID: u32 = 15;
pub const SECURITY_IUSER_RID: u32 = 17;
pub const SECURITY_LOCAL_SYSTEM_RID: u32 = 18;
pub const SECURITY_LOCAL_SERVICE_RID: u32 = 19;
pub const SECURITY_NETWORK_SERVICE_RID: u32 = 20;
pub const SECURITY_NT_NON_UNIQUE: u32 = 21;
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT: u32 = 3;
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID: u32 = 22;
pub const SECURITY_BUILTIN_DOMAIN_RID: u32 = 32;
pub const SECURITY_WRITE_RESTRICTED_CODE_RID: u32 = 33;
pub const SECURITY_PACKAGE_BASE_RID: u32 = 64;
pub const SECURITY_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_PACKAGE_NTLM_RID: u32 = 10;
pub const SECURITY_PACKAGE_SCHANNEL_RID: u32 = 14;
pub const SECURITY_PACKAGE_DIGEST_RID: u32 = 21;
pub const SECURITY_CRED_TYPE_BASE_RID: u32 = 65;
pub const SECURITY_CRED_TYPE_RID_COUNT: u32 = 2;
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID: u32 = 1;
pub const SECURITY_MIN_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_RID_COUNT: u32 = 6;
pub const SECURITY_RESERVED_ID_BASE_RID: u32 = 81;
pub const SECURITY_APPPOOL_ID_BASE_RID: u32 = 82;
pub const SECURITY_APPPOOL_ID_RID_COUNT: u32 = 6;
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID: u32 = 83;
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID: u32 = 84;
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID: u32 = 85;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WMIHOST_ID_BASE_RID: u32 = 86;
pub const SECURITY_WMIHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_TASK_ID_BASE_RID: u32 = 87;
pub const SECURITY_NFS_ID_BASE_RID: u32 = 88;
pub const SECURITY_COM_ID_BASE_RID: u32 = 89;
pub const SECURITY_WINDOW_MANAGER_BASE_RID: u32 = 90;
pub const SECURITY_RDV_GFX_BASE_RID: u32 = 91;
pub const SECURITY_DASHOST_ID_BASE_RID: u32 = 92;
pub const SECURITY_DASHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMANAGER_ID_BASE_RID: u32 = 93;
pub const SECURITY_USERMANAGER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WINRM_ID_BASE_RID: u32 = 94;
pub const SECURITY_WINRM_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CCG_ID_BASE_RID: u32 = 95;
pub const SECURITY_UMFD_BASE_RID: u32 = 96;
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT: u32 = 6;
pub const SECURITY_MAX_BASE_RID: u32 = 111;
pub const SECURITY_MAX_ALWAYS_FILTERED: u32 = 999;
pub const SECURITY_MIN_NEVER_FILTERED: u32 = 1000;
pub const SECURITY_OTHER_ORGANIZATION_RID: u32 = 1000;
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID: u32 = 112;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10;
pub const SECURITY_LOCAL_ACCOUNT_RID: u32 = 113;
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID: u32 = 114;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED: u32 = 496;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS: u32 = 497;
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS: u32 = 498;
pub const FOREST_USER_RID_MAX: u32 = 499;
pub const DOMAIN_USER_RID_ADMIN: u32 = 500;
pub const DOMAIN_USER_RID_GUEST: u32 = 501;
pub const DOMAIN_USER_RID_KRBTGT: u32 = 502;
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT: u32 = 503;
pub const DOMAIN_USER_RID_WDAG_ACCOUNT: u32 = 504;
pub const DOMAIN_USER_RID_MAX: u32 = 999;
pub const DOMAIN_GROUP_RID_ADMINS: u32 = 512;
pub const DOMAIN_GROUP_RID_USERS: u32 = 513;
pub const DOMAIN_GROUP_RID_GUESTS: u32 = 514;
pub const DOMAIN_GROUP_RID_COMPUTERS: u32 = 515;
pub const DOMAIN_GROUP_RID_CONTROLLERS: u32 = 516;
pub const DOMAIN_GROUP_RID_CERT_ADMINS: u32 = 517;
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS: u32 = 518;
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS: u32 = 519;
pub const DOMAIN_GROUP_RID_POLICY_ADMINS: u32 = 520;
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS: u32 = 521;
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS: u32 = 522;
pub const DOMAIN_GROUP_RID_CDC_RESERVED: u32 = 524;
pub const DOMAIN_GROUP_RID_PROTECTED_USERS: u32 = 525;
pub const DOMAIN_GROUP_RID_KEY_ADMINS: u32 = 526;
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS: u32 = 527;
pub const DOMAIN_ALIAS_RID_ADMINS: u32 = 544;
pub const DOMAIN_ALIAS_RID_USERS: u32 = 545;
pub const DOMAIN_ALIAS_RID_GUESTS: u32 = 546;
pub const DOMAIN_ALIAS_RID_POWER_USERS: u32 = 547;
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS: u32 = 548;
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS: u32 = 549;
pub const DOMAIN_ALIAS_RID_PRINT_OPS: u32 = 550;
pub const DOMAIN_ALIAS_RID_BACKUP_OPS: u32 = 551;
pub const DOMAIN_ALIAS_RID_REPLICATOR: u32 = 552;
pub const DOMAIN_ALIAS_RID_RAS_SERVERS: u32 = 553;
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS: u32 = 554;
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS: u32 = 555;
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS: u32 = 556;
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS: u32 = 557;
pub const DOMAIN_ALIAS_RID_MONITORING_USERS: u32 = 558;
pub const DOMAIN_ALIAS_RID_LOGGING_USERS: u32 = 559;
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS: u32 = 560;
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS: u32 = 561;
pub const DOMAIN_ALIAS_RID_DCOM_USERS: u32 = 562;
pub const DOMAIN_ALIAS_RID_IUSERS: u32 = 568;
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS: u32 = 569;
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP: u32 = 571;
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP: u32 = 572;
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP: u32 = 573;
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP: u32 = 574;
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS: u32 = 575;
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS: u32 = 576;
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS: u32 = 577;
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS: u32 = 578;
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS: u32 = 579;
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS: u32 = 580;
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT: u32 = 581;
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS: u32 = 582;
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS: u32 = 583;
pub const SECURITY_APP_PACKAGE_BASE_RID: u32 = 2;
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_APP_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CAPABILITY_BASE_RID: u32 = 3;
pub const SECURITY_CAPABILITY_APP_RID: u32 = 1024;
pub const SECURITY_CAPABILITY_APP_SILO_RID: u32 = 65536;
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT: u32 = 2;
pub const SECURITY_CAPABILITY_RID_COUNT: u32 = 5;
pub const SECURITY_PARENT_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CHILD_PACKAGE_RID_COUNT: u32 = 12;
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE: u32 = 1;
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE: u32 = 2;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT: u32 = 1;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER: u32 = 2;
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER: u32 = 3;
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY: u32 = 4;
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY: u32 = 5;
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY: u32 = 6;
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY: u32 = 7;
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION: u32 = 8;
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES: u32 = 9;
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE: u32 = 10;
pub const SECURITY_CAPABILITY_APPOINTMENTS: u32 = 11;
pub const SECURITY_CAPABILITY_CONTACTS: u32 = 12;
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER: u32 = 4096;
pub const SECURITY_MANDATORY_UNTRUSTED_RID: u32 = 0;
pub const SECURITY_MANDATORY_LOW_RID: u32 = 4096;
pub const SECURITY_MANDATORY_MEDIUM_RID: u32 = 8192;
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID: u32 = 8448;
pub const SECURITY_MANDATORY_HIGH_RID: u32 = 12288;
pub const SECURITY_MANDATORY_SYSTEM_RID: u32 = 16384;
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID: u32 = 20480;
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID: u32 = 16384;
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT: u32 = 1;
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID: u32 = 1;
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID: u32 = 2;
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID: u32 = 3;
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID: u32 = 4;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID: u32 = 5;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID: u32 = 6;
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT: u32 = 2;
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID: u32 = 512;
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID: u32 = 0;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID: u32 = 8192;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID: u32 = 4096;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID: u32 = 2048;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID: u32 = 1536;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID: u32 = 0;
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885;
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649;
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044;
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631;
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464;
pub const SE_GROUP_MANDATORY: u32 = 1;
pub const SE_GROUP_ENABLED_BY_DEFAULT: u32 = 2;
pub const SE_GROUP_ENABLED: u32 = 4;
pub const SE_GROUP_OWNER: u32 = 8;
pub const SE_GROUP_USE_FOR_DENY_ONLY: u32 = 16;
pub const SE_GROUP_INTEGRITY: u32 = 32;
pub const SE_GROUP_INTEGRITY_ENABLED: u32 = 64;
pub const SE_GROUP_LOGON_ID: u32 = 3221225472;
pub const SE_GROUP_RESOURCE: u32 = 536870912;
pub const SE_GROUP_VALID_ATTRIBUTES: u32 = 3758096511;
pub const ACL_REVISION: u32 = 2;
pub const ACL_REVISION_DS: u32 = 4;
pub const ACL_REVISION1: u32 = 1;
pub const ACL_REVISION2: u32 = 2;
pub const ACL_REVISION3: u32 = 3;
pub const ACL_REVISION4: u32 = 4;
pub const MAX_ACL_REVISION: u32 = 4;
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0;
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0;
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1;
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2;
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3;
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4;
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7;
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8;
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16;
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19;
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20;
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21;
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21;
pub const OBJECT_INHERIT_ACE: u32 = 1;
pub const CONTAINER_INHERIT_ACE: u32 = 2;
pub const NO_PROPAGATE_INHERIT_ACE: u32 = 4;
pub const INHERIT_ONLY_ACE: u32 = 8;
pub const INHERITED_ACE: u32 = 16;
pub const VALID_INHERIT_FLAGS: u32 = 31;
pub const CRITICAL_ACE_FLAG: u32 = 32;
pub const SUCCESSFUL_ACCESS_ACE_FLAG: u32 = 64;
pub const FAILED_ACCESS_ACE_FLAG: u32 = 128;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4;
pub const SYSTEM_MANDATORY_LABEL_VALID_MASK: u32 = 7;
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const ACE_OBJECT_TYPE_PRESENT: u32 = 1;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT: u32 = 2;
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1;
pub const SE_OWNER_DEFAULTED: u32 = 1;
pub const SE_GROUP_DEFAULTED: u32 = 2;
pub const SE_DACL_PRESENT: u32 = 4;
pub const SE_DACL_DEFAULTED: u32 = 8;
pub const SE_SACL_PRESENT: u32 = 16;
pub const SE_SACL_DEFAULTED: u32 = 32;
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256;
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512;
pub const SE_DACL_AUTO_INHERITED: u32 = 1024;
pub const SE_SACL_AUTO_INHERITED: u32 = 2048;
pub const SE_DACL_PROTECTED: u32 = 4096;
pub const SE_SACL_PROTECTED: u32 = 8192;
pub const SE_RM_CONTROL_VALID: u32 = 16384;
pub const SE_SELF_RELATIVE: u32 = 32768;
pub const ACCESS_OBJECT_GUID: u32 = 0;
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1;
pub const ACCESS_PROPERTY_GUID: u32 = 2;
pub const ACCESS_MAX_LEVEL: u32 = 4;
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1;
pub const ACCESS_DS_SOURCE_A: &[u8; 3usize] = b"DS\0";
pub const ACCESS_DS_SOURCE_W: &[u8; 3usize] = b"DS\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_A: &[u8; 25usize] = b"Directory Service Object\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_W: &[u8; 25usize] = b"Directory Service Object\0";
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT: u32 = 1;
pub const SE_PRIVILEGE_ENABLED: u32 = 2;
pub const SE_PRIVILEGE_REMOVED: u32 = 4;
pub const SE_PRIVILEGE_USED_FOR_ACCESS: u32 = 2147483648;
pub const SE_PRIVILEGE_VALID_ATTRIBUTES: u32 = 2147483655;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1;
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680;
pub const ACCESS_REASON_DATA_MASK: u32 = 65535;
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648;
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7;
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING: u32 = 8;
pub const SE_ACCESS_CHECK_VALID_FLAGS: u32 = 8;
pub const SE_ACTIVATE_AS_USER_CAPABILITY: &[u8; 15usize] = b"activateAsUser\0";
pub const SE_CONSTRAINED_IMPERSONATION_CAPABILITY: &[u8; 25usize] = b"constrainedImpersonation\0";
pub const SE_SESSION_IMPERSONATION_CAPABILITY: &[u8; 21usize] = b"sessionImpersonation\0";
pub const SE_MUMA_CAPABILITY: &[u8; 5usize] = b"muma\0";
pub const SE_DEVELOPMENT_MODE_NETWORK_CAPABILITY: &[u8; 23usize] = b"developmentModeNetwork\0";
pub const SE_LEARNING_MODE_LOGGING_CAPABILITY: &[u8; 20usize] = b"learningModeLogging\0";
pub const SE_PERMISSIVE_LEARNING_MODE_CAPABILITY: &[u8; 23usize] = b"permissiveLearningMode\0";
pub const SE_APP_SILO_VOLUME_ROOT_MINIMAL_CAPABILITY: &[u8; 32usize] =
    b"isolatedWin32-volumeRootMinimal\0";
pub const SE_APP_SILO_PROFILES_ROOT_MINIMAL_CAPABILITY: &[u8; 34usize] =
    b"isolatedWin32-profilesRootMinimal\0";
pub const SE_APP_SILO_USER_PROFILE_MINIMAL_CAPABILITY: &[u8; 33usize] =
    b"isolatedWin32-userProfileMinimal\0";
pub const SE_APP_SILO_PRINT_CAPABILITY: &[u8; 20usize] = b"isolatedWin32-print\0";
pub const TOKEN_ASSIGN_PRIMARY: u32 = 1;
pub const TOKEN_DUPLICATE: u32 = 2;
pub const TOKEN_IMPERSONATE: u32 = 4;
pub const TOKEN_QUERY: u32 = 8;
pub const TOKEN_QUERY_SOURCE: u32 = 16;
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 32;
pub const TOKEN_ADJUST_GROUPS: u32 = 64;
pub const TOKEN_ADJUST_DEFAULT: u32 = 128;
pub const TOKEN_ADJUST_SESSIONID: u32 = 256;
pub const TOKEN_ALL_ACCESS_P: u32 = 983295;
pub const TOKEN_ALL_ACCESS: u32 = 983551;
pub const TOKEN_READ: u32 = 131080;
pub const TOKEN_WRITE: u32 = 131296;
pub const TOKEN_EXECUTE: u32 = 131072;
pub const TOKEN_TRUST_CONSTRAINT_MASK: u32 = 131096;
pub const TOKEN_TRUST_ALLOWED_MASK: u32 = 131102;
pub const TOKEN_ACCESS_PSEUDO_HANDLE_WIN8: u32 = 24;
pub const TOKEN_ACCESS_PSEUDO_HANDLE: u32 = 24;
pub const TOKEN_MANDATORY_POLICY_OFF: u32 = 0;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP: u32 = 1;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN: u32 = 2;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK: u32 = 3;
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 59;
pub const TOKEN_SOURCE_LENGTH: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const SECURITY_DYNAMIC_TRACKING: u32 = 1;
pub const SECURITY_STATIC_TRACKING: u32 = 0;
pub const DISABLE_MAX_PRIVILEGE: u32 = 1;
pub const SANDBOX_INERT: u32 = 2;
pub const LUA_TOKEN: u32 = 4;
pub const WRITE_RESTRICTED: u32 = 8;
pub const OWNER_SECURITY_INFORMATION: u32 = 1;
pub const GROUP_SECURITY_INFORMATION: u32 = 2;
pub const DACL_SECURITY_INFORMATION: u32 = 4;
pub const SACL_SECURITY_INFORMATION: u32 = 8;
pub const LABEL_SECURITY_INFORMATION: u32 = 16;
pub const ATTRIBUTE_SECURITY_INFORMATION: u32 = 32;
pub const SCOPE_SECURITY_INFORMATION: u32 = 64;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: u32 = 128;
pub const ACCESS_FILTER_SECURITY_INFORMATION: u32 = 256;
pub const BACKUP_SECURITY_INFORMATION: u32 = 65536;
pub const PROTECTED_DACL_SECURITY_INFORMATION: u32 = 2147483648;
pub const PROTECTED_SACL_SECURITY_INFORMATION: u32 = 1073741824;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION: u32 = 536870912;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION: u32 = 268435456;
pub const SE_SIGNING_LEVEL_UNCHECKED: u32 = 0;
pub const SE_SIGNING_LEVEL_UNSIGNED: u32 = 1;
pub const SE_SIGNING_LEVEL_ENTERPRISE: u32 = 2;
pub const SE_SIGNING_LEVEL_CUSTOM_1: u32 = 3;
pub const SE_SIGNING_LEVEL_DEVELOPER: u32 = 3;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: u32 = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_2: u32 = 5;
pub const SE_SIGNING_LEVEL_STORE: u32 = 6;
pub const SE_SIGNING_LEVEL_CUSTOM_3: u32 = 7;
pub const SE_SIGNING_LEVEL_ANTIMALWARE: u32 = 7;
pub const SE_SIGNING_LEVEL_MICROSOFT: u32 = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4: u32 = 9;
pub const SE_SIGNING_LEVEL_CUSTOM_5: u32 = 10;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: u32 = 11;
pub const SE_SIGNING_LEVEL_WINDOWS: u32 = 12;
pub const SE_SIGNING_LEVEL_CUSTOM_7: u32 = 13;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: u32 = 14;
pub const SE_SIGNING_LEVEL_CUSTOM_6: u32 = 15;
pub const PROCESS_TERMINATE: u32 = 1;
pub const PROCESS_CREATE_THREAD: u32 = 2;
pub const PROCESS_SET_SESSIONID: u32 = 4;
pub const PROCESS_VM_OPERATION: u32 = 8;
pub const PROCESS_VM_READ: u32 = 16;
pub const PROCESS_VM_WRITE: u32 = 32;
pub const PROCESS_DUP_HANDLE: u32 = 64;
pub const PROCESS_CREATE_PROCESS: u32 = 128;
pub const PROCESS_SET_QUOTA: u32 = 256;
pub const PROCESS_SET_INFORMATION: u32 = 512;
pub const PROCESS_QUERY_INFORMATION: u32 = 1024;
pub const PROCESS_SUSPEND_RESUME: u32 = 2048;
pub const PROCESS_QUERY_LIMITED_INFORMATION: u32 = 4096;
pub const PROCESS_SET_LIMITED_INFORMATION: u32 = 8192;
pub const PROCESS_ALL_ACCESS: u32 = 2097151;
pub const THREAD_TERMINATE: u32 = 1;
pub const THREAD_SUSPEND_RESUME: u32 = 2;
pub const THREAD_GET_CONTEXT: u32 = 8;
pub const THREAD_SET_CONTEXT: u32 = 16;
pub const THREAD_QUERY_INFORMATION: u32 = 64;
pub const THREAD_SET_INFORMATION: u32 = 32;
pub const THREAD_SET_THREAD_TOKEN: u32 = 128;
pub const THREAD_IMPERSONATE: u32 = 256;
pub const THREAD_DIRECT_IMPERSONATION: u32 = 512;
pub const THREAD_SET_LIMITED_INFORMATION: u32 = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: u32 = 2048;
pub const THREAD_RESUME: u32 = 4096;
pub const THREAD_ALL_ACCESS: u32 = 2097151;
pub const JOB_OBJECT_ASSIGN_PROCESS: u32 = 1;
pub const JOB_OBJECT_SET_ATTRIBUTES: u32 = 2;
pub const JOB_OBJECT_QUERY: u32 = 4;
pub const JOB_OBJECT_TERMINATE: u32 = 8;
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES: u32 = 16;
pub const JOB_OBJECT_IMPERSONATE: u32 = 32;
pub const JOB_OBJECT_ALL_ACCESS: u32 = 2031679;
pub const FLS_MAXIMUM_AVAILABLE: u32 = 4080;
pub const TLS_MINIMUM_AVAILABLE: u32 = 64;
pub const THREAD_DYNAMIC_CODE_ALLOW: u32 = 1;
pub const THREAD_BASE_PRIORITY_LOWRT: u32 = 15;
pub const THREAD_BASE_PRIORITY_MAX: u32 = 2;
pub const THREAD_BASE_PRIORITY_MIN: i32 = -2;
pub const THREAD_BASE_PRIORITY_IDLE: i32 = -15;
pub const COMPONENT_KTM: u32 = 1;
pub const COMPONENT_VALID_FLAGS: u32 = 1;
pub const MEMORY_PRIORITY_LOWEST: u32 = 0;
pub const MEMORY_PRIORITY_VERY_LOW: u32 = 1;
pub const MEMORY_PRIORITY_LOW: u32 = 2;
pub const MEMORY_PRIORITY_MEDIUM: u32 = 3;
pub const MEMORY_PRIORITY_BELOW_NORMAL: u32 = 4;
pub const MEMORY_PRIORITY_NORMAL: u32 = 5;
pub const DYNAMIC_EH_CONTINUATION_TARGET_ADD: u32 = 1;
pub const DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED: u32 = 2;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_ADD: u32 = 1;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_PROCESSED: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: u32 = 1;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: u32 = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: u32 = 8;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: u32 = 16;
pub const MAX_HW_COUNTERS: u32 = 16;
pub const THREAD_PROFILING_FLAG_DISPATCH: u32 = 1;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG: u32 = 64;
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB: u32 = 0;
pub const JOB_OBJECT_POST_AT_END_OF_JOB: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: u32 = 3;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO: u32 = 4;
pub const JOB_OBJECT_MSG_NEW_PROCESS: u32 = 6;
pub const JOB_OBJECT_MSG_EXIT_PROCESS: u32 = 7;
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: u32 = 8;
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT: u32 = 9;
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT: u32 = 10;
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT: u32 = 11;
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT: u32 = 12;
pub const JOB_OBJECT_MSG_SILO_TERMINATED: u32 = 13;
pub const JOB_OBJECT_MSG_MINIMUM: u32 = 1;
pub const JOB_OBJECT_MSG_MAXIMUM: u32 = 13;
pub const JOB_OBJECT_VALID_COMPLETION_FILTER: u32 = 16382;
pub const JOB_OBJECT_LIMIT_WORKINGSET: u32 = 1;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_LIMIT_JOB_TIME: u32 = 4;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS: u32 = 8;
pub const JOB_OBJECT_LIMIT_AFFINITY: u32 = 16;
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS: u32 = 32;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME: u32 = 64;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS: u32 = 128;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY: u32 = 256;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY: u32 = 512;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH: u32 = 512;
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION: u32 = 1024;
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK: u32 = 2048;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK: u32 = 4096;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: u32 = 8192;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY: u32 = 16384;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW: u32 = 32768;
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES: u32 = 65536;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES: u32 = 131072;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL: u32 = 524288;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL: u32 = 1048576;
pub const JOB_OBJECT_LIMIT_VALID_FLAGS: u32 = 524287;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS: u32 = 32767;
pub const JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS: u32 = 2064900;
pub const JOB_OBJECT_UILIMIT_NONE: u32 = 0;
pub const JOB_OBJECT_UILIMIT_HANDLES: u32 = 1;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD: u32 = 2;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD: u32 = 4;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS: u32 = 8;
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS: u32 = 16;
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS: u32 = 32;
pub const JOB_OBJECT_UILIMIT_DESKTOP: u32 = 64;
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS: u32 = 128;
pub const JOB_OBJECT_UILIMIT_IME: u32 = 256;
pub const JOB_OBJECT_UILIMIT_ALL: u32 = 511;
pub const JOB_OBJECT_UI_VALID_FLAGS: u32 = 511;
pub const JOB_OBJECT_SECURITY_NO_ADMIN: u32 = 1;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN: u32 = 2;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN: u32 = 4;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS: u32 = 8;
pub const JOB_OBJECT_SECURITY_VALID_FLAGS: u32 = 15;
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE: u32 = 1;
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED: u32 = 2;
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP: u32 = 4;
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY: u32 = 8;
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE: u32 = 16;
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS: u32 = 31;
pub const MEMORY_PARTITION_QUERY_ACCESS: u32 = 1;
pub const MEMORY_PARTITION_MODIFY_ACCESS: u32 = 2;
pub const MEMORY_PARTITION_ALL_ACCESS: u32 = 2031619;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const EVENT_ALL_ACCESS: u32 = 2031619;
pub const MUTANT_QUERY_STATE: u32 = 1;
pub const MUTANT_ALL_ACCESS: u32 = 2031617;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const SEMAPHORE_ALL_ACCESS: u32 = 2031619;
pub const TIMER_QUERY_STATE: u32 = 1;
pub const TIMER_MODIFY_STATE: u32 = 2;
pub const TIMER_ALL_ACCESS: u32 = 2031619;
pub const TIME_ZONE_ID_UNKNOWN: u32 = 0;
pub const TIME_ZONE_ID_STANDARD: u32 = 1;
pub const TIME_ZONE_ID_DAYLIGHT: u32 = 2;
pub const LTP_PC_SMT: u32 = 1;
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8;
pub const PROCESSOR_INTEL_386: u32 = 386;
pub const PROCESSOR_INTEL_486: u32 = 486;
pub const PROCESSOR_INTEL_PENTIUM: u32 = 586;
pub const PROCESSOR_INTEL_IA64: u32 = 2200;
pub const PROCESSOR_AMD_X8664: u32 = 8664;
pub const PROCESSOR_MIPS_R4000: u32 = 4000;
pub const PROCESSOR_ALPHA_21064: u32 = 21064;
pub const PROCESSOR_PPC_601: u32 = 601;
pub const PROCESSOR_PPC_603: u32 = 603;
pub const PROCESSOR_PPC_604: u32 = 604;
pub const PROCESSOR_PPC_620: u32 = 620;
pub const PROCESSOR_HITACHI_SH3: u32 = 10003;
pub const PROCESSOR_HITACHI_SH3E: u32 = 10004;
pub const PROCESSOR_HITACHI_SH4: u32 = 10005;
pub const PROCESSOR_MOTOROLA_821: u32 = 821;
pub const PROCESSOR_SHx_SH3: u32 = 103;
pub const PROCESSOR_SHx_SH4: u32 = 104;
pub const PROCESSOR_STRONGARM: u32 = 2577;
pub const PROCESSOR_ARM720: u32 = 1824;
pub const PROCESSOR_ARM820: u32 = 2080;
pub const PROCESSOR_ARM920: u32 = 2336;
pub const PROCESSOR_ARM_7TDMI: u32 = 70001;
pub const PROCESSOR_OPTIL: u32 = 18767;
pub const PROCESSOR_ARCHITECTURE_INTEL: u32 = 0;
pub const PROCESSOR_ARCHITECTURE_MIPS: u32 = 1;
pub const PROCESSOR_ARCHITECTURE_ALPHA: u32 = 2;
pub const PROCESSOR_ARCHITECTURE_PPC: u32 = 3;
pub const PROCESSOR_ARCHITECTURE_SHX: u32 = 4;
pub const PROCESSOR_ARCHITECTURE_ARM: u32 = 5;
pub const PROCESSOR_ARCHITECTURE_IA64: u32 = 6;
pub const PROCESSOR_ARCHITECTURE_ALPHA64: u32 = 7;
pub const PROCESSOR_ARCHITECTURE_MSIL: u32 = 8;
pub const PROCESSOR_ARCHITECTURE_AMD64: u32 = 9;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: u32 = 10;
pub const PROCESSOR_ARCHITECTURE_NEUTRAL: u32 = 11;
pub const PROCESSOR_ARCHITECTURE_ARM64: u32 = 12;
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64: u32 = 13;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64: u32 = 14;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN: u32 = 65535;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE: u32 = 34;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41;
pub const PF_ERMS_AVAILABLE: u32 = 42;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44;
pub const PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE: u32 = 45;
pub const XSTATE_LEGACY_FLOATING_POINT: u32 = 0;
pub const XSTATE_LEGACY_SSE: u32 = 1;
pub const XSTATE_GSSE: u32 = 2;
pub const XSTATE_AVX: u32 = 2;
pub const XSTATE_MPX_BNDREGS: u32 = 3;
pub const XSTATE_MPX_BNDCSR: u32 = 4;
pub const XSTATE_AVX512_KMASK: u32 = 5;
pub const XSTATE_AVX512_ZMM_H: u32 = 6;
pub const XSTATE_AVX512_ZMM: u32 = 7;
pub const XSTATE_IPT: u32 = 8;
pub const XSTATE_PASID: u32 = 10;
pub const XSTATE_CET_U: u32 = 11;
pub const XSTATE_CET_S: u32 = 12;
pub const XSTATE_AMX_TILE_CONFIG: u32 = 17;
pub const XSTATE_AMX_TILE_DATA: u32 = 18;
pub const XSTATE_LWP: u32 = 62;
pub const MAXIMUM_XSTATE_FEATURES: u32 = 64;
pub const XSTATE_COMPACTION_ENABLE: u32 = 63;
pub const XSTATE_ALIGN_BIT: u32 = 1;
pub const XSTATE_XFD_BIT: u32 = 2;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: u32 = 2;
pub const XSTATE_CONTROLFLAG_XFD_MASK: u32 = 4;
pub const XSTATE_CONTROLFLAG_VALID_MASK: u32 = 7;
pub const CFG_CALL_TARGET_VALID: u32 = 1;
pub const CFG_CALL_TARGET_PROCESSED: u32 = 2;
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID: u32 = 4;
pub const CFG_CALL_TARGET_VALID_XFG: u32 = 8;
pub const CFG_CALL_TARGET_CONVERT_XFG_TO_CFG: u32 = 16;
pub const SECTION_QUERY: u32 = 1;
pub const SECTION_MAP_WRITE: u32 = 2;
pub const SECTION_MAP_READ: u32 = 4;
pub const SECTION_MAP_EXECUTE: u32 = 8;
pub const SECTION_EXTEND_SIZE: u32 = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: u32 = 32;
pub const SECTION_ALL_ACCESS: u32 = 983071;
pub const SESSION_QUERY_ACCESS: u32 = 1;
pub const SESSION_MODIFY_ACCESS: u32 = 2;
pub const SESSION_ALL_ACCESS: u32 = 983043;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_GRAPHICS_NOACCESS: u32 = 2048;
pub const PAGE_GRAPHICS_READONLY: u32 = 4096;
pub const PAGE_GRAPHICS_READWRITE: u32 = 8192;
pub const PAGE_GRAPHICS_EXECUTE: u32 = 16384;
pub const PAGE_GRAPHICS_EXECUTE_READ: u32 = 32768;
pub const PAGE_GRAPHICS_EXECUTE_READWRITE: u32 = 65536;
pub const PAGE_GRAPHICS_COHERENT: u32 = 131072;
pub const PAGE_GRAPHICS_NOCACHE: u32 = 262144;
pub const PAGE_ENCLAVE_THREAD_CONTROL: u32 = 2147483648;
pub const PAGE_REVERT_TO_FILE_MAP: u32 = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: u32 = 1073741824;
pub const PAGE_TARGETS_INVALID: u32 = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: u32 = 536870912;
pub const PAGE_ENCLAVE_MASK: u32 = 268435456;
pub const PAGE_ENCLAVE_DECOMMIT: u32 = 268435456;
pub const PAGE_ENCLAVE_SS_FIRST: u32 = 268435457;
pub const PAGE_ENCLAVE_SS_REST: u32 = 268435458;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_REPLACE_PLACEHOLDER: u32 = 16384;
pub const MEM_RESERVE_PLACEHOLDER: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_WRITE_WATCH: u32 = 2097152;
pub const MEM_PHYSICAL: u32 = 4194304;
pub const MEM_ROTATE: u32 = 8388608;
pub const MEM_DIFFERENT_IMAGE_BASE_OK: u32 = 8388608;
pub const MEM_RESET_UNDO: u32 = 16777216;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const MEM_64K_PAGES: u32 = 541065216;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST: u32 = 1;
pub const MEM_COALESCE_PLACEHOLDERS: u32 = 1;
pub const MEM_PRESERVE_PLACEHOLDER: u32 = 2;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS: u32 = 1;
pub const MEM_EXTENDED_PARAMETER_NONPAGED: u32 = 2;
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL: u32 = 4;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE: u32 = 8;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE: u32 = 16;
pub const MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES: u32 = 32;
pub const MEM_EXTENDED_PARAMETER_EC_CODE: u32 = 64;
pub const MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT: u32 = 128;
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const SEC_HUGE_PAGES: u32 = 131072;
pub const SEC_PARTITION_OWNER_HANDLE: u32 = 262144;
pub const SEC_64K_PAGES: u32 = 524288;
pub const SEC_FILE: u32 = 8388608;
pub const SEC_IMAGE: u32 = 16777216;
pub const SEC_PROTECTED_IMAGE: u32 = 33554432;
pub const SEC_RESERVE: u32 = 67108864;
pub const SEC_COMMIT: u32 = 134217728;
pub const SEC_NOCACHE: u32 = 268435456;
pub const SEC_WRITECOMBINE: u32 = 1073741824;
pub const SEC_LARGE_PAGES: u32 = 2147483648;
pub const SEC_IMAGE_NO_EXECUTE: u32 = 285212672;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_IMAGE: u32 = 16777216;
pub const WRITE_WATCH_FLAG_RESET: u32 = 1;
pub const ENCLAVE_TYPE_SGX: u32 = 1;
pub const ENCLAVE_TYPE_SGX2: u32 = 2;
pub const ENCLAVE_TYPE_VBS: u32 = 16;
pub const ENCLAVE_VBS_FLAG_DEBUG: u32 = 1;
pub const ENCLAVE_TYPE_VBS_BASIC: u32 = 17;
pub const VBS_BASIC_PAGE_MEASURED_DATA: u32 = 1;
pub const VBS_BASIC_PAGE_UNMEASURED_DATA: u32 = 2;
pub const VBS_BASIC_PAGE_ZERO_FILL: u32 = 3;
pub const VBS_BASIC_PAGE_THREAD_DESCRIPTOR: u32 = 4;
pub const VBS_BASIC_PAGE_SYSTEM_CALL: u32 = 5;
pub const DEDICATED_MEMORY_CACHE_ELIGIBLE: u32 = 1;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: u32 = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: u32 = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: u32 = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: u32 = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u32 = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: u32 = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: u32 = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: u32 = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: u32 = 131072;
pub const FILE_ATTRIBUTE_EA: u32 = 262144;
pub const FILE_ATTRIBUTE_PINNED: u32 = 524288;
pub const FILE_ATTRIBUTE_UNPINNED: u32 = 1048576;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN: u32 = 262144;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u32 = 4194304;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768;
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4;
pub const TREE_CONNECT_ATTRIBUTE_PINNED: u32 = 2;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912;
pub const FILE_NOTIFY_CHANGE_FILE_NAME: u32 = 1;
pub const FILE_NOTIFY_CHANGE_DIR_NAME: u32 = 2;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES: u32 = 4;
pub const FILE_NOTIFY_CHANGE_SIZE: u32 = 8;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE: u32 = 16;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS: u32 = 32;
pub const FILE_NOTIFY_CHANGE_CREATION: u32 = 64;
pub const FILE_NOTIFY_CHANGE_SECURITY: u32 = 256;
pub const FILE_ACTION_ADDED: u32 = 1;
pub const FILE_ACTION_REMOVED: u32 = 2;
pub const FILE_ACTION_MODIFIED: u32 = 3;
pub const FILE_ACTION_RENAMED_OLD_NAME: u32 = 4;
pub const FILE_ACTION_RENAMED_NEW_NAME: u32 = 5;
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1;
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2;
pub const FILE_UNICODE_ON_DISK: u32 = 4;
pub const FILE_PERSISTENT_ACLS: u32 = 8;
pub const FILE_FILE_COMPRESSION: u32 = 16;
pub const FILE_VOLUME_QUOTAS: u32 = 32;
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64;
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128;
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024;
pub const FILE_SUPPORTS_BYPASS_IO: u32 = 2048;
pub const FILE_SUPPORTS_STREAM_SNAPSHOTS: u32 = 4096;
pub const FILE_SUPPORTS_CASE_SENSITIVE_DIRS: u32 = 8192;
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768;
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536;
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072;
pub const FILE_NAMED_STREAMS: u32 = 262144;
pub const FILE_READ_ONLY_VOLUME: u32 = 524288;
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576;
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152;
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304;
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216;
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728;
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456;
pub const FILE_DAX_VOLUME: u32 = 536870912;
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824;
pub const FILE_NAME_FLAG_HARDLINK: u32 = 0;
pub const FILE_NAME_FLAG_NTFS: u32 = 1;
pub const FILE_NAME_FLAG_DOS: u32 = 2;
pub const FILE_NAME_FLAG_BOTH: u32 = 3;
pub const FILE_NAME_FLAGS_UNSPECIFIED: u32 = 128;
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR: u32 = 1;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4;
pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: u32 = 16384;
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0;
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1;
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2;
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2;
pub const IO_REPARSE_TAG_MOUNT_POINT: u32 = 2684354563;
pub const IO_REPARSE_TAG_HSM: u32 = 3221225476;
pub const IO_REPARSE_TAG_HSM2: u32 = 2147483654;
pub const IO_REPARSE_TAG_SIS: u32 = 2147483655;
pub const IO_REPARSE_TAG_WIM: u32 = 2147483656;
pub const IO_REPARSE_TAG_CSV: u32 = 2147483657;
pub const IO_REPARSE_TAG_DFS: u32 = 2147483658;
pub const IO_REPARSE_TAG_SYMLINK: u32 = 2684354572;
pub const IO_REPARSE_TAG_DFSR: u32 = 2147483666;
pub const IO_REPARSE_TAG_DEDUP: u32 = 2147483667;
pub const IO_REPARSE_TAG_NFS: u32 = 2147483668;
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER: u32 = 2147483669;
pub const IO_REPARSE_TAG_WOF: u32 = 2147483671;
pub const IO_REPARSE_TAG_WCI: u32 = 2147483672;
pub const IO_REPARSE_TAG_WCI_1: u32 = 2415923224;
pub const IO_REPARSE_TAG_GLOBAL_REPARSE: u32 = 2684354585;
pub const IO_REPARSE_TAG_CLOUD: u32 = 2415919130;
pub const IO_REPARSE_TAG_CLOUD_1: u32 = 2415923226;
pub const IO_REPARSE_TAG_CLOUD_2: u32 = 2415927322;
pub const IO_REPARSE_TAG_CLOUD_3: u32 = 2415931418;
pub const IO_REPARSE_TAG_CLOUD_4: u32 = 2415935514;
pub const IO_REPARSE_TAG_CLOUD_5: u32 = 2415939610;
pub const IO_REPARSE_TAG_CLOUD_6: u32 = 2415943706;
pub const IO_REPARSE_TAG_CLOUD_7: u32 = 2415947802;
pub const IO_REPARSE_TAG_CLOUD_8: u32 = 2415951898;
pub const IO_REPARSE_TAG_CLOUD_9: u32 = 2415955994;
pub const IO_REPARSE_TAG_CLOUD_A: u32 = 2415960090;
pub const IO_REPARSE_TAG_CLOUD_B: u32 = 2415964186;
pub const IO_REPARSE_TAG_CLOUD_C: u32 = 2415968282;
pub const IO_REPARSE_TAG_CLOUD_D: u32 = 2415972378;
pub const IO_REPARSE_TAG_CLOUD_E: u32 = 2415976474;
pub const IO_REPARSE_TAG_CLOUD_F: u32 = 2415980570;
pub const IO_REPARSE_TAG_CLOUD_MASK: u32 = 61440;
pub const IO_REPARSE_TAG_APPEXECLINK: u32 = 2147483675;
pub const IO_REPARSE_TAG_PROJFS: u32 = 2415919132;
pub const IO_REPARSE_TAG_STORAGE_SYNC: u32 = 2147483678;
pub const IO_REPARSE_TAG_WCI_TOMBSTONE: u32 = 2684354591;
pub const IO_REPARSE_TAG_UNHANDLED: u32 = 2147483680;
pub const IO_REPARSE_TAG_ONEDRIVE: u32 = 2147483681;
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE: u32 = 2684354594;
pub const IO_REPARSE_TAG_AF_UNIX: u32 = 2147483683;
pub const IO_REPARSE_TAG_WCI_LINK: u32 = 2684354599;
pub const IO_REPARSE_TAG_WCI_LINK_1: u32 = 2684358695;
pub const IO_REPARSE_TAG_DATALESS_CIM: u32 = 2684354600;
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4;
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32;
pub const SCRUB_DATA_INPUT_FLAG_OPLOCK_NOT_ACQUIRED: u32 = 64;
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1;
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536;
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144;
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS: u32 = 1;
pub const IO_COMPLETION_MODIFY_STATE: u32 = 2;
pub const IO_COMPLETION_ALL_ACCESS: u32 = 2031619;
pub const IO_QOS_MAX_RESERVATION: u32 = 1000000000;
pub const SMB_CCF_APP_INSTANCE_EA_NAME: &[u8; 29usize] = b"ClusteredApplicationInstance\0";
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1;
pub const DUPLICATE_CLOSE_SOURCE: u32 = 1;
pub const DUPLICATE_SAME_ACCESS: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: u32 = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: u32 = 8;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: u32 = 3;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: u32 = 3;
pub const PROCESSOR_THROTTLE_DISABLED: u32 = 0;
pub const PROCESSOR_THROTTLE_ENABLED: u32 = 1;
pub const PROCESSOR_THROTTLE_AUTOMATIC: u32 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: u32 = 5;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED: u32 = 6;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 6;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: u32 = 255;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: u32 = 0;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: u32 = 0;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: u32 = 1270000000;
pub const PROCESSOR_DUTY_CYCLING_DISABLED: u32 = 0;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3;
pub const PARKING_TOPOLOGY_POLICY_DISABLED: u32 = 0;
pub const PARKING_TOPOLOGY_POLICY_ROUNDROBIN: u32 = 1;
pub const PARKING_TOPOLOGY_POLICY_SEQUENTIAL: u32 = 2;
pub const SMT_UNPARKING_POLICY_CORE: u32 = 0;
pub const SMT_UNPARKING_POLICY_CORE_PER_THREAD: u32 = 1;
pub const SMT_UNPARKING_POLICY_LP_ROUNDROBIN: u32 = 2;
pub const SMT_UNPARKING_POLICY_LP_SEQUENTIAL: u32 = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: u32 = 0;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED: u32 = 2;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL: u32 = 0;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE: u32 = 1;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: i64 = -2147483656;
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: u32 = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: u32 = 2;
pub const PDCAP_D0_SUPPORTED: u32 = 1;
pub const PDCAP_D1_SUPPORTED: u32 = 2;
pub const PDCAP_D2_SUPPORTED: u32 = 4;
pub const PDCAP_D3_SUPPORTED: u32 = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256;
pub const POWER_SETTING_VALUE_VERSION: u32 = 1;
pub const POWER_PLATFORM_ROLE_V1: u32 = 1;
pub const POWER_PLATFORM_ROLE_V2: u32 = 2;
pub const POWER_PLATFORM_ROLE_VERSION: u32 = 2;
pub const PROC_IDLE_BUCKET_COUNT: u32 = 6;
pub const PROC_IDLE_BUCKET_COUNT_EX: u32 = 16;
pub const ACPI_PPM_SOFTWARE_ALL: u32 = 252;
pub const ACPI_PPM_SOFTWARE_ANY: u32 = 253;
pub const ACPI_PPM_HARDWARE_ALL: u32 = 254;
pub const MS_PPM_SOFTWARE_ALL: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C2: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C3: u32 = 2;
pub const PPM_FIRMWARE_ACPI1TSTATES: u32 = 4;
pub const PPM_FIRMWARE_CST: u32 = 8;
pub const PPM_FIRMWARE_CSD: u32 = 16;
pub const PPM_FIRMWARE_PCT: u32 = 32;
pub const PPM_FIRMWARE_PSS: u32 = 64;
pub const PPM_FIRMWARE_XPSS: u32 = 128;
pub const PPM_FIRMWARE_PPC: u32 = 256;
pub const PPM_FIRMWARE_PSD: u32 = 512;
pub const PPM_FIRMWARE_PTC: u32 = 1024;
pub const PPM_FIRMWARE_TSS: u32 = 2048;
pub const PPM_FIRMWARE_TPC: u32 = 4096;
pub const PPM_FIRMWARE_TSD: u32 = 8192;
pub const PPM_FIRMWARE_PCCH: u32 = 16384;
pub const PPM_FIRMWARE_PCCP: u32 = 32768;
pub const PPM_FIRMWARE_OSC: u32 = 65536;
pub const PPM_FIRMWARE_PDC: u32 = 131072;
pub const PPM_FIRMWARE_CPC: u32 = 262144;
pub const PPM_FIRMWARE_LPI: u32 = 524288;
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES: u32 = 1;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1: u32 = 2;
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC: u32 = 3;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP: u32 = 4;
pub const PPM_IDLE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_IDLE_IMPLEMENTATION_CSTATES: u32 = 1;
pub const PPM_IDLE_IMPLEMENTATION_PEP: u32 = 2;
pub const PPM_IDLE_IMPLEMENTATION_MICROPEP: u32 = 3;
pub const PPM_IDLE_IMPLEMENTATION_LPISTATES: u32 = 4;
pub const POWER_ACTION_QUERY_ALLOWED: u32 = 1;
pub const POWER_ACTION_UI_ALLOWED: u32 = 2;
pub const POWER_ACTION_OVERRIDE_APPS: u32 = 4;
pub const POWER_ACTION_HIBERBOOT: u32 = 8;
pub const POWER_ACTION_USER_NOTIFY: u32 = 16;
pub const POWER_ACTION_DOZE_TO_HIBERNATE: u32 = 32;
pub const POWER_ACTION_ACPI_CRITICAL: u32 = 16777216;
pub const POWER_ACTION_ACPI_USER_NOTIFY: u32 = 33554432;
pub const POWER_ACTION_DIRECTED_DRIPS: u32 = 67108864;
pub const POWER_ACTION_PSEUDO_TRANSITION: u32 = 134217728;
pub const POWER_ACTION_LIGHTEST_FIRST: u32 = 268435456;
pub const POWER_ACTION_LOCK_CONSOLE: u32 = 536870912;
pub const POWER_ACTION_DISABLE_WAKES: u32 = 1073741824;
pub const POWER_ACTION_CRITICAL: u32 = 2147483648;
pub const POWER_LEVEL_USER_NOTIFY_TEXT: u32 = 1;
pub const POWER_LEVEL_USER_NOTIFY_SOUND: u32 = 2;
pub const POWER_LEVEL_USER_NOTIFY_EXEC: u32 = 4;
pub const POWER_USER_NOTIFY_BUTTON: u32 = 8;
pub const POWER_USER_NOTIFY_SHUTDOWN: u32 = 16;
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN: u32 = 32;
pub const POWER_FORCE_TRIGGER_RESET: u32 = 2147483648;
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK: u32 = 7;
pub const BATTERY_DISCHARGE_FLAGS_ENABLE: u32 = 2147483648;
pub const NUM_DISCHARGE_POLICIES: u32 = 4;
pub const DISCHARGE_POLICY_CRITICAL: u32 = 0;
pub const DISCHARGE_POLICY_LOW: u32 = 1;
pub const PROCESSOR_IDLESTATE_POLICY_COUNT: u32 = 3;
pub const PO_THROTTLE_NONE: u32 = 0;
pub const PO_THROTTLE_CONSTANT: u32 = 1;
pub const PO_THROTTLE_DEGRADE: u32 = 2;
pub const PO_THROTTLE_ADAPTIVE: u32 = 3;
pub const PO_THROTTLE_MAXIMUM: u32 = 4;
pub const HIBERFILE_TYPE_NONE: u32 = 0;
pub const HIBERFILE_TYPE_REDUCED: u32 = 1;
pub const HIBERFILE_TYPE_FULL: u32 = 2;
pub const HIBERFILE_TYPE_MAX: u32 = 3;
pub const IMAGE_DOS_SIGNATURE: u32 = 23117;
pub const IMAGE_OS2_SIGNATURE: u32 = 17742;
pub const IMAGE_OS2_SIGNATURE_LE: u32 = 17740;
pub const IMAGE_VXD_SIGNATURE: u32 = 17740;
pub const IMAGE_NT_SIGNATURE: u32 = 17744;
pub const IMAGE_SIZEOF_FILE_HEADER: u32 = 20;
pub const IMAGE_FILE_RELOCS_STRIPPED: u32 = 1;
pub const IMAGE_FILE_EXECUTABLE_IMAGE: u32 = 2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED: u32 = 4;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED: u32 = 8;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM: u32 = 16;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE: u32 = 32;
pub const IMAGE_FILE_BYTES_REVERSED_LO: u32 = 128;
pub const IMAGE_FILE_32BIT_MACHINE: u32 = 256;
pub const IMAGE_FILE_DEBUG_STRIPPED: u32 = 512;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: u32 = 1024;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP: u32 = 2048;
pub const IMAGE_FILE_SYSTEM: u32 = 4096;
pub const IMAGE_FILE_DLL: u32 = 8192;
pub const IMAGE_FILE_UP_SYSTEM_ONLY: u32 = 16384;
pub const IMAGE_FILE_BYTES_REVERSED_HI: u32 = 32768;
pub const IMAGE_FILE_MACHINE_UNKNOWN: u32 = 0;
pub const IMAGE_FILE_MACHINE_TARGET_HOST: u32 = 1;
pub const IMAGE_FILE_MACHINE_I386: u32 = 332;
pub const IMAGE_FILE_MACHINE_R3000: u32 = 354;
pub const IMAGE_FILE_MACHINE_R4000: u32 = 358;
pub const IMAGE_FILE_MACHINE_R10000: u32 = 360;
pub const IMAGE_FILE_MACHINE_WCEMIPSV2: u32 = 361;
pub const IMAGE_FILE_MACHINE_ALPHA: u32 = 388;
pub const IMAGE_FILE_MACHINE_SH3: u32 = 418;
pub const IMAGE_FILE_MACHINE_SH3DSP: u32 = 419;
pub const IMAGE_FILE_MACHINE_SH3E: u32 = 420;
pub const IMAGE_FILE_MACHINE_SH4: u32 = 422;
pub const IMAGE_FILE_MACHINE_SH5: u32 = 424;
pub const IMAGE_FILE_MACHINE_ARM: u32 = 448;
pub const IMAGE_FILE_MACHINE_THUMB: u32 = 450;
pub const IMAGE_FILE_MACHINE_ARMNT: u32 = 452;
pub const IMAGE_FILE_MACHINE_AM33: u32 = 467;
pub const IMAGE_FILE_MACHINE_POWERPC: u32 = 496;
pub const IMAGE_FILE_MACHINE_POWERPCFP: u32 = 497;
pub const IMAGE_FILE_MACHINE_IA64: u32 = 512;
pub const IMAGE_FILE_MACHINE_MIPS16: u32 = 614;
pub const IMAGE_FILE_MACHINE_ALPHA64: u32 = 644;
pub const IMAGE_FILE_MACHINE_MIPSFPU: u32 = 870;
pub const IMAGE_FILE_MACHINE_MIPSFPU16: u32 = 1126;
pub const IMAGE_FILE_MACHINE_AXP64: u32 = 644;
pub const IMAGE_FILE_MACHINE_TRICORE: u32 = 1312;
pub const IMAGE_FILE_MACHINE_CEF: u32 = 3311;
pub const IMAGE_FILE_MACHINE_EBC: u32 = 3772;
pub const IMAGE_FILE_MACHINE_AMD64: u32 = 34404;
pub const IMAGE_FILE_MACHINE_M32R: u32 = 36929;
pub const IMAGE_FILE_MACHINE_ARM64: u32 = 43620;
pub const IMAGE_FILE_MACHINE_CEE: u32 = 49390;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES: u32 = 16;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC: u32 = 267;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC: u32 = 523;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC: u32 = 263;
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC: u32 = 523;
pub const IMAGE_SUBSYSTEM_UNKNOWN: u32 = 0;
pub const IMAGE_SUBSYSTEM_NATIVE: u32 = 1;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI: u32 = 2;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI: u32 = 3;
pub const IMAGE_SUBSYSTEM_OS2_CUI: u32 = 5;
pub const IMAGE_SUBSYSTEM_POSIX_CUI: u32 = 7;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS: u32 = 8;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI: u32 = 9;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION: u32 = 10;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: u32 = 11;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: u32 = 12;
pub const IMAGE_SUBSYSTEM_EFI_ROM: u32 = 13;
pub const IMAGE_SUBSYSTEM_XBOX: u32 = 14;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION: u32 = 16;
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG: u32 = 17;
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA: u32 = 32;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE: u32 = 64;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY: u32 = 128;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT: u32 = 256;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION: u32 = 512;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH: u32 = 1024;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND: u32 = 2048;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER: u32 = 4096;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER: u32 = 8192;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF: u32 = 16384;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE: u32 = 32768;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT: u32 = 0;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT: u32 = 1;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE: u32 = 2;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION: u32 = 3;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY: u32 = 4;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC: u32 = 5;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG: u32 = 6;
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: u32 = 7;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR: u32 = 8;
pub const IMAGE_DIRECTORY_ENTRY_TLS: u32 = 9;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: u32 = 10;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: u32 = 11;
pub const IMAGE_DIRECTORY_ENTRY_IAT: u32 = 12;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: u32 = 13;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: u32 = 14;
pub const IMAGE_SIZEOF_SHORT_NAME: u32 = 8;
pub const IMAGE_SIZEOF_SECTION_HEADER: u32 = 40;
pub const IMAGE_SCN_TYPE_NO_PAD: u32 = 8;
pub const IMAGE_SCN_CNT_CODE: u32 = 32;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA: u32 = 64;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA: u32 = 128;
pub const IMAGE_SCN_LNK_OTHER: u32 = 256;
pub const IMAGE_SCN_LNK_INFO: u32 = 512;
pub const IMAGE_SCN_LNK_REMOVE: u32 = 2048;
pub const IMAGE_SCN_LNK_COMDAT: u32 = 4096;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC: u32 = 16384;
pub const IMAGE_SCN_GPREL: u32 = 32768;
pub const IMAGE_SCN_MEM_FARDATA: u32 = 32768;
pub const IMAGE_SCN_MEM_PURGEABLE: u32 = 131072;
pub const IMAGE_SCN_MEM_16BIT: u32 = 131072;
pub const IMAGE_SCN_MEM_LOCKED: u32 = 262144;
pub const IMAGE_SCN_MEM_PRELOAD: u32 = 524288;
pub const IMAGE_SCN_ALIGN_1BYTES: u32 = 1048576;
pub const IMAGE_SCN_ALIGN_2BYTES: u32 = 2097152;
pub const IMAGE_SCN_ALIGN_4BYTES: u32 = 3145728;
pub const IMAGE_SCN_ALIGN_8BYTES: u32 = 4194304;
pub const IMAGE_SCN_ALIGN_16BYTES: u32 = 5242880;
pub const IMAGE_SCN_ALIGN_32BYTES: u32 = 6291456;
pub const IMAGE_SCN_ALIGN_64BYTES: u32 = 7340032;
pub const IMAGE_SCN_ALIGN_128BYTES: u32 = 8388608;
pub const IMAGE_SCN_ALIGN_256BYTES: u32 = 9437184;
pub const IMAGE_SCN_ALIGN_512BYTES: u32 = 10485760;
pub const IMAGE_SCN_ALIGN_1024BYTES: u32 = 11534336;
pub const IMAGE_SCN_ALIGN_2048BYTES: u32 = 12582912;
pub const IMAGE_SCN_ALIGN_4096BYTES: u32 = 13631488;
pub const IMAGE_SCN_ALIGN_8192BYTES: u32 = 14680064;
pub const IMAGE_SCN_ALIGN_MASK: u32 = 15728640;
pub const IMAGE_SCN_LNK_NRELOC_OVFL: u32 = 16777216;
pub const IMAGE_SCN_MEM_DISCARDABLE: u32 = 33554432;
pub const IMAGE_SCN_MEM_NOT_CACHED: u32 = 67108864;
pub const IMAGE_SCN_MEM_NOT_PAGED: u32 = 134217728;
pub const IMAGE_SCN_MEM_SHARED: u32 = 268435456;
pub const IMAGE_SCN_MEM_EXECUTE: u32 = 536870912;
pub const IMAGE_SCN_MEM_READ: u32 = 1073741824;
pub const IMAGE_SCN_MEM_WRITE: u32 = 2147483648;
pub const IMAGE_SCN_SCALE_INDEX: u32 = 1;
pub const IMAGE_SIZEOF_SYMBOL: u32 = 18;
pub const IMAGE_SYM_SECTION_MAX: u32 = 65279;
pub const IMAGE_SYM_SECTION_MAX_EX: u32 = 2147483647;
pub const IMAGE_SYM_TYPE_NULL: u32 = 0;
pub const IMAGE_SYM_TYPE_VOID: u32 = 1;
pub const IMAGE_SYM_TYPE_CHAR: u32 = 2;
pub const IMAGE_SYM_TYPE_SHORT: u32 = 3;
pub const IMAGE_SYM_TYPE_INT: u32 = 4;
pub const IMAGE_SYM_TYPE_LONG: u32 = 5;
pub const IMAGE_SYM_TYPE_FLOAT: u32 = 6;
pub const IMAGE_SYM_TYPE_DOUBLE: u32 = 7;
pub const IMAGE_SYM_TYPE_STRUCT: u32 = 8;
pub const IMAGE_SYM_TYPE_UNION: u32 = 9;
pub const IMAGE_SYM_TYPE_ENUM: u32 = 10;
pub const IMAGE_SYM_TYPE_MOE: u32 = 11;
pub const IMAGE_SYM_TYPE_BYTE: u32 = 12;
pub const IMAGE_SYM_TYPE_WORD: u32 = 13;
pub const IMAGE_SYM_TYPE_UINT: u32 = 14;
pub const IMAGE_SYM_TYPE_DWORD: u32 = 15;
pub const IMAGE_SYM_TYPE_PCODE: u32 = 32768;
pub const IMAGE_SYM_DTYPE_NULL: u32 = 0;
pub const IMAGE_SYM_DTYPE_POINTER: u32 = 1;
pub const IMAGE_SYM_DTYPE_FUNCTION: u32 = 2;
pub const IMAGE_SYM_DTYPE_ARRAY: u32 = 3;
pub const IMAGE_SYM_CLASS_NULL: u32 = 0;
pub const IMAGE_SYM_CLASS_AUTOMATIC: u32 = 1;
pub const IMAGE_SYM_CLASS_EXTERNAL: u32 = 2;
pub const IMAGE_SYM_CLASS_STATIC: u32 = 3;
pub const IMAGE_SYM_CLASS_REGISTER: u32 = 4;
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF: u32 = 5;
pub const IMAGE_SYM_CLASS_LABEL: u32 = 6;
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL: u32 = 7;
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: u32 = 8;
pub const IMAGE_SYM_CLASS_ARGUMENT: u32 = 9;
pub const IMAGE_SYM_CLASS_STRUCT_TAG: u32 = 10;
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION: u32 = 11;
pub const IMAGE_SYM_CLASS_UNION_TAG: u32 = 12;
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION: u32 = 13;
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC: u32 = 14;
pub const IMAGE_SYM_CLASS_ENUM_TAG: u32 = 15;
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM: u32 = 16;
pub const IMAGE_SYM_CLASS_REGISTER_PARAM: u32 = 17;
pub const IMAGE_SYM_CLASS_BIT_FIELD: u32 = 18;
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL: u32 = 68;
pub const IMAGE_SYM_CLASS_BLOCK: u32 = 100;
pub const IMAGE_SYM_CLASS_FUNCTION: u32 = 101;
pub const IMAGE_SYM_CLASS_END_OF_STRUCT: u32 = 102;
pub const IMAGE_SYM_CLASS_FILE: u32 = 103;
pub const IMAGE_SYM_CLASS_SECTION: u32 = 104;
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL: u32 = 105;
pub const IMAGE_SYM_CLASS_CLR_TOKEN: u32 = 107;
pub const N_BTMASK: u32 = 15;
pub const N_TMASK: u32 = 48;
pub const N_TMASK1: u32 = 192;
pub const N_TMASK2: u32 = 240;
pub const N_BTSHFT: u32 = 4;
pub const N_TSHIFT: u32 = 2;
pub const IMAGE_COMDAT_SELECT_NODUPLICATES: u32 = 1;
pub const IMAGE_COMDAT_SELECT_ANY: u32 = 2;
pub const IMAGE_COMDAT_SELECT_SAME_SIZE: u32 = 3;
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH: u32 = 4;
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE: u32 = 5;
pub const IMAGE_COMDAT_SELECT_LARGEST: u32 = 6;
pub const IMAGE_COMDAT_SELECT_NEWEST: u32 = 7;
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY: u32 = 1;
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY: u32 = 2;
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS: u32 = 3;
pub const IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY: u32 = 4;
pub const IMAGE_REL_I386_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_I386_DIR16: u32 = 1;
pub const IMAGE_REL_I386_REL16: u32 = 2;
pub const IMAGE_REL_I386_DIR32: u32 = 6;
pub const IMAGE_REL_I386_DIR32NB: u32 = 7;
pub const IMAGE_REL_I386_SEG12: u32 = 9;
pub const IMAGE_REL_I386_SECTION: u32 = 10;
pub const IMAGE_REL_I386_SECREL: u32 = 11;
pub const IMAGE_REL_I386_TOKEN: u32 = 12;
pub const IMAGE_REL_I386_SECREL7: u32 = 13;
pub const IMAGE_REL_I386_REL32: u32 = 20;
pub const IMAGE_REL_MIPS_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_MIPS_REFHALF: u32 = 1;
pub const IMAGE_REL_MIPS_REFWORD: u32 = 2;
pub const IMAGE_REL_MIPS_JMPADDR: u32 = 3;
pub const IMAGE_REL_MIPS_REFHI: u32 = 4;
pub const IMAGE_REL_MIPS_REFLO: u32 = 5;
pub const IMAGE_REL_MIPS_GPREL: u32 = 6;
pub const IMAGE_REL_MIPS_LITERAL: u32 = 7;
pub const IMAGE_REL_MIPS_SECTION: u32 = 10;
pub const IMAGE_REL_MIPS_SECREL: u32 = 11;
pub const IMAGE_REL_MIPS_SECRELLO: u32 = 12;
pub const IMAGE_REL_MIPS_SECRELHI: u32 = 13;
pub const IMAGE_REL_MIPS_TOKEN: u32 = 14;
pub const IMAGE_REL_MIPS_JMPADDR16: u32 = 16;
pub const IMAGE_REL_MIPS_REFWORDNB: u32 = 34;
pub const IMAGE_REL_MIPS_PAIR: u32 = 37;
pub const IMAGE_REL_ALPHA_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ALPHA_REFLONG: u32 = 1;
pub const IMAGE_REL_ALPHA_REFQUAD: u32 = 2;
pub const IMAGE_REL_ALPHA_GPREL32: u32 = 3;
pub const IMAGE_REL_ALPHA_LITERAL: u32 = 4;
pub const IMAGE_REL_ALPHA_LITUSE: u32 = 5;
pub const IMAGE_REL_ALPHA_GPDISP: u32 = 6;
pub const IMAGE_REL_ALPHA_BRADDR: u32 = 7;
pub const IMAGE_REL_ALPHA_HINT: u32 = 8;
pub const IMAGE_REL_ALPHA_INLINE_REFLONG: u32 = 9;
pub const IMAGE_REL_ALPHA_REFHI: u32 = 10;
pub const IMAGE_REL_ALPHA_REFLO: u32 = 11;
pub const IMAGE_REL_ALPHA_PAIR: u32 = 12;
pub const IMAGE_REL_ALPHA_MATCH: u32 = 13;
pub const IMAGE_REL_ALPHA_SECTION: u32 = 14;
pub const IMAGE_REL_ALPHA_SECREL: u32 = 15;
pub const IMAGE_REL_ALPHA_REFLONGNB: u32 = 16;
pub const IMAGE_REL_ALPHA_SECRELLO: u32 = 17;
pub const IMAGE_REL_ALPHA_SECRELHI: u32 = 18;
pub const IMAGE_REL_ALPHA_REFQ3: u32 = 19;
pub const IMAGE_REL_ALPHA_REFQ2: u32 = 20;
pub const IMAGE_REL_ALPHA_REFQ1: u32 = 21;
pub const IMAGE_REL_ALPHA_GPRELLO: u32 = 22;
pub const IMAGE_REL_ALPHA_GPRELHI: u32 = 23;
pub const IMAGE_REL_PPC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_PPC_ADDR64: u32 = 1;
pub const IMAGE_REL_PPC_ADDR32: u32 = 2;
pub const IMAGE_REL_PPC_ADDR24: u32 = 3;
pub const IMAGE_REL_PPC_ADDR16: u32 = 4;
pub const IMAGE_REL_PPC_ADDR14: u32 = 5;
pub const IMAGE_REL_PPC_REL24: u32 = 6;
pub const IMAGE_REL_PPC_REL14: u32 = 7;
pub const IMAGE_REL_PPC_TOCREL16: u32 = 8;
pub const IMAGE_REL_PPC_TOCREL14: u32 = 9;
pub const IMAGE_REL_PPC_ADDR32NB: u32 = 10;
pub const IMAGE_REL_PPC_SECREL: u32 = 11;
pub const IMAGE_REL_PPC_SECTION: u32 = 12;
pub const IMAGE_REL_PPC_IFGLUE: u32 = 13;
pub const IMAGE_REL_PPC_IMGLUE: u32 = 14;
pub const IMAGE_REL_PPC_SECREL16: u32 = 15;
pub const IMAGE_REL_PPC_REFHI: u32 = 16;
pub const IMAGE_REL_PPC_REFLO: u32 = 17;
pub const IMAGE_REL_PPC_PAIR: u32 = 18;
pub const IMAGE_REL_PPC_SECRELLO: u32 = 19;
pub const IMAGE_REL_PPC_SECRELHI: u32 = 20;
pub const IMAGE_REL_PPC_GPREL: u32 = 21;
pub const IMAGE_REL_PPC_TOKEN: u32 = 22;
pub const IMAGE_REL_PPC_TYPEMASK: u32 = 255;
pub const IMAGE_REL_PPC_NEG: u32 = 256;
pub const IMAGE_REL_PPC_BRTAKEN: u32 = 512;
pub const IMAGE_REL_PPC_BRNTAKEN: u32 = 1024;
pub const IMAGE_REL_PPC_TOCDEFN: u32 = 2048;
pub const IMAGE_REL_SH3_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_SH3_DIRECT16: u32 = 1;
pub const IMAGE_REL_SH3_DIRECT32: u32 = 2;
pub const IMAGE_REL_SH3_DIRECT8: u32 = 3;
pub const IMAGE_REL_SH3_DIRECT8_WORD: u32 = 4;
pub const IMAGE_REL_SH3_DIRECT8_LONG: u32 = 5;
pub const IMAGE_REL_SH3_DIRECT4: u32 = 6;
pub const IMAGE_REL_SH3_DIRECT4_WORD: u32 = 7;
pub const IMAGE_REL_SH3_DIRECT4_LONG: u32 = 8;
pub const IMAGE_REL_SH3_PCREL8_WORD: u32 = 9;
pub const IMAGE_REL_SH3_PCREL8_LONG: u32 = 10;
pub const IMAGE_REL_SH3_PCREL12_WORD: u32 = 11;
pub const IMAGE_REL_SH3_STARTOF_SECTION: u32 = 12;
pub const IMAGE_REL_SH3_SIZEOF_SECTION: u32 = 13;
pub const IMAGE_REL_SH3_SECTION: u32 = 14;
pub const IMAGE_REL_SH3_SECREL: u32 = 15;
pub const IMAGE_REL_SH3_DIRECT32_NB: u32 = 16;
pub const IMAGE_REL_SH3_GPREL4_LONG: u32 = 17;
pub const IMAGE_REL_SH3_TOKEN: u32 = 18;
pub const IMAGE_REL_SHM_PCRELPT: u32 = 19;
pub const IMAGE_REL_SHM_REFLO: u32 = 20;
pub const IMAGE_REL_SHM_REFHALF: u32 = 21;
pub const IMAGE_REL_SHM_RELLO: u32 = 22;
pub const IMAGE_REL_SHM_RELHALF: u32 = 23;
pub const IMAGE_REL_SHM_PAIR: u32 = 24;
pub const IMAGE_REL_SH_NOMODE: u32 = 32768;
pub const IMAGE_REL_ARM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM_BRANCH24: u32 = 3;
pub const IMAGE_REL_ARM_BRANCH11: u32 = 4;
pub const IMAGE_REL_ARM_TOKEN: u32 = 5;
pub const IMAGE_REL_ARM_GPREL12: u32 = 6;
pub const IMAGE_REL_ARM_GPREL7: u32 = 7;
pub const IMAGE_REL_ARM_BLX24: u32 = 8;
pub const IMAGE_REL_ARM_BLX11: u32 = 9;
pub const IMAGE_REL_ARM_SECTION: u32 = 14;
pub const IMAGE_REL_ARM_SECREL: u32 = 15;
pub const IMAGE_REL_ARM_MOV32A: u32 = 16;
pub const IMAGE_REL_ARM_MOV32: u32 = 16;
pub const IMAGE_REL_ARM_MOV32T: u32 = 17;
pub const IMAGE_REL_THUMB_MOV32: u32 = 17;
pub const IMAGE_REL_ARM_BRANCH20T: u32 = 18;
pub const IMAGE_REL_THUMB_BRANCH20: u32 = 18;
pub const IMAGE_REL_ARM_BRANCH24T: u32 = 20;
pub const IMAGE_REL_THUMB_BRANCH24: u32 = 20;
pub const IMAGE_REL_ARM_BLX23T: u32 = 21;
pub const IMAGE_REL_THUMB_BLX23: u32 = 21;
pub const IMAGE_REL_AM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AM_ADDR32: u32 = 1;
pub const IMAGE_REL_AM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_AM_CALL32: u32 = 3;
pub const IMAGE_REL_AM_FUNCINFO: u32 = 4;
pub const IMAGE_REL_AM_REL32_1: u32 = 5;
pub const IMAGE_REL_AM_REL32_2: u32 = 6;
pub const IMAGE_REL_AM_SECREL: u32 = 7;
pub const IMAGE_REL_AM_SECTION: u32 = 8;
pub const IMAGE_REL_AM_TOKEN: u32 = 9;
pub const IMAGE_REL_ARM64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM64_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM64_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM64_BRANCH26: u32 = 3;
pub const IMAGE_REL_ARM64_PAGEBASE_REL21: u32 = 4;
pub const IMAGE_REL_ARM64_REL21: u32 = 5;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12A: u32 = 6;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12L: u32 = 7;
pub const IMAGE_REL_ARM64_SECREL: u32 = 8;
pub const IMAGE_REL_ARM64_SECREL_LOW12A: u32 = 9;
pub const IMAGE_REL_ARM64_SECREL_HIGH12A: u32 = 10;
pub const IMAGE_REL_ARM64_SECREL_LOW12L: u32 = 11;
pub const IMAGE_REL_ARM64_TOKEN: u32 = 12;
pub const IMAGE_REL_ARM64_SECTION: u32 = 13;
pub const IMAGE_REL_ARM64_ADDR64: u32 = 14;
pub const IMAGE_REL_ARM64_BRANCH19: u32 = 15;
pub const IMAGE_REL_AMD64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AMD64_ADDR64: u32 = 1;
pub const IMAGE_REL_AMD64_ADDR32: u32 = 2;
pub const IMAGE_REL_AMD64_ADDR32NB: u32 = 3;
pub const IMAGE_REL_AMD64_REL32: u32 = 4;
pub const IMAGE_REL_AMD64_REL32_1: u32 = 5;
pub const IMAGE_REL_AMD64_REL32_2: u32 = 6;
pub const IMAGE_REL_AMD64_REL32_3: u32 = 7;
pub const IMAGE_REL_AMD64_REL32_4: u32 = 8;
pub const IMAGE_REL_AMD64_REL32_5: u32 = 9;
pub const IMAGE_REL_AMD64_SECTION: u32 = 10;
pub const IMAGE_REL_AMD64_SECREL: u32 = 11;
pub const IMAGE_REL_AMD64_SECREL7: u32 = 12;
pub const IMAGE_REL_AMD64_TOKEN: u32 = 13;
pub const IMAGE_REL_AMD64_SREL32: u32 = 14;
pub const IMAGE_REL_AMD64_PAIR: u32 = 15;
pub const IMAGE_REL_AMD64_SSPAN32: u32 = 16;
pub const IMAGE_REL_AMD64_EHANDLER: u32 = 17;
pub const IMAGE_REL_AMD64_IMPORT_BR: u32 = 18;
pub const IMAGE_REL_AMD64_IMPORT_CALL: u32 = 19;
pub const IMAGE_REL_AMD64_CFG_BR: u32 = 20;
pub const IMAGE_REL_AMD64_CFG_BR_REX: u32 = 21;
pub const IMAGE_REL_AMD64_CFG_CALL: u32 = 22;
pub const IMAGE_REL_AMD64_INDIR_BR: u32 = 23;
pub const IMAGE_REL_AMD64_INDIR_BR_REX: u32 = 24;
pub const IMAGE_REL_AMD64_INDIR_CALL: u32 = 25;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_FIRST: u32 = 32;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_LAST: u32 = 47;
pub const IMAGE_REL_IA64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_IA64_IMM14: u32 = 1;
pub const IMAGE_REL_IA64_IMM22: u32 = 2;
pub const IMAGE_REL_IA64_IMM64: u32 = 3;
pub const IMAGE_REL_IA64_DIR32: u32 = 4;
pub const IMAGE_REL_IA64_DIR64: u32 = 5;
pub const IMAGE_REL_IA64_PCREL21B: u32 = 6;
pub const IMAGE_REL_IA64_PCREL21M: u32 = 7;
pub const IMAGE_REL_IA64_PCREL21F: u32 = 8;
pub const IMAGE_REL_IA64_GPREL22: u32 = 9;
pub const IMAGE_REL_IA64_LTOFF22: u32 = 10;
pub const IMAGE_REL_IA64_SECTION: u32 = 11;
pub const IMAGE_REL_IA64_SECREL22: u32 = 12;
pub const IMAGE_REL_IA64_SECREL64I: u32 = 13;
pub const IMAGE_REL_IA64_SECREL32: u32 = 14;
pub const IMAGE_REL_IA64_DIR32NB: u32 = 16;
pub const IMAGE_REL_IA64_SREL14: u32 = 17;
pub const IMAGE_REL_IA64_SREL22: u32 = 18;
pub const IMAGE_REL_IA64_SREL32: u32 = 19;
pub const IMAGE_REL_IA64_UREL32: u32 = 20;
pub const IMAGE_REL_IA64_PCREL60X: u32 = 21;
pub const IMAGE_REL_IA64_PCREL60B: u32 = 22;
pub const IMAGE_REL_IA64_PCREL60F: u32 = 23;
pub const IMAGE_REL_IA64_PCREL60I: u32 = 24;
pub const IMAGE_REL_IA64_PCREL60M: u32 = 25;
pub const IMAGE_REL_IA64_IMMGPREL64: u32 = 26;
pub const IMAGE_REL_IA64_TOKEN: u32 = 27;
pub const IMAGE_REL_IA64_GPREL32: u32 = 28;
pub const IMAGE_REL_IA64_ADDEND: u32 = 31;
pub const IMAGE_REL_CEF_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEF_ADDR32: u32 = 1;
pub const IMAGE_REL_CEF_ADDR64: u32 = 2;
pub const IMAGE_REL_CEF_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEF_SECTION: u32 = 4;
pub const IMAGE_REL_CEF_SECREL: u32 = 5;
pub const IMAGE_REL_CEF_TOKEN: u32 = 6;
pub const IMAGE_REL_CEE_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEE_ADDR32: u32 = 1;
pub const IMAGE_REL_CEE_ADDR64: u32 = 2;
pub const IMAGE_REL_CEE_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEE_SECTION: u32 = 4;
pub const IMAGE_REL_CEE_SECREL: u32 = 5;
pub const IMAGE_REL_CEE_TOKEN: u32 = 6;
pub const IMAGE_REL_M32R_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_M32R_ADDR32: u32 = 1;
pub const IMAGE_REL_M32R_ADDR32NB: u32 = 2;
pub const IMAGE_REL_M32R_ADDR24: u32 = 3;
pub const IMAGE_REL_M32R_GPREL16: u32 = 4;
pub const IMAGE_REL_M32R_PCREL24: u32 = 5;
pub const IMAGE_REL_M32R_PCREL16: u32 = 6;
pub const IMAGE_REL_M32R_PCREL8: u32 = 7;
pub const IMAGE_REL_M32R_REFHALF: u32 = 8;
pub const IMAGE_REL_M32R_REFHI: u32 = 9;
pub const IMAGE_REL_M32R_REFLO: u32 = 10;
pub const IMAGE_REL_M32R_PAIR: u32 = 11;
pub const IMAGE_REL_M32R_SECTION: u32 = 12;
pub const IMAGE_REL_M32R_SECREL32: u32 = 13;
pub const IMAGE_REL_M32R_TOKEN: u32 = 14;
pub const IMAGE_REL_EBC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_EBC_ADDR32NB: u32 = 1;
pub const IMAGE_REL_EBC_REL32: u32 = 2;
pub const IMAGE_REL_EBC_SECTION: u32 = 3;
pub const IMAGE_REL_EBC_SECREL: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM7B_SIZE_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM9D_SIZE_X: u32 = 9;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X: u32 = 18;
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM5C_SIZE_X: u32 = 5;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X: u32 = 13;
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X: u32 = 16;
pub const EMARCH_ENC_I17_IC_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IC_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X: u32 = 12;
pub const EMARCH_ENC_I17_IC_VAL_POS_X: u32 = 21;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41a_SIZE_X: u32 = 10;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X: u32 = 14;
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X: u32 = 22;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41b_SIZE_X: u32 = 8;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X: u32 = 24;
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X: u32 = 32;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X: u32 = 2;
pub const EMARCH_ENC_I17_IMM41c_SIZE_X: u32 = 23;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X: u32 = 40;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_SIGN_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X: u32 = 27;
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X: u32 = 63;
pub const X3_OPCODE_INST_WORD_X: u32 = 3;
pub const X3_OPCODE_SIZE_X: u32 = 4;
pub const X3_OPCODE_INST_WORD_POS_X: u32 = 28;
pub const X3_OPCODE_SIGN_VAL_POS_X: u32 = 0;
pub const X3_I_INST_WORD_X: u32 = 3;
pub const X3_I_SIZE_X: u32 = 1;
pub const X3_I_INST_WORD_POS_X: u32 = 27;
pub const X3_I_SIGN_VAL_POS_X: u32 = 59;
pub const X3_D_WH_INST_WORD_X: u32 = 3;
pub const X3_D_WH_SIZE_X: u32 = 3;
pub const X3_D_WH_INST_WORD_POS_X: u32 = 24;
pub const X3_D_WH_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM20_INST_WORD_X: u32 = 3;
pub const X3_IMM20_SIZE_X: u32 = 20;
pub const X3_IMM20_INST_WORD_POS_X: u32 = 4;
pub const X3_IMM20_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM39_1_INST_WORD_X: u32 = 2;
pub const X3_IMM39_1_SIZE_X: u32 = 23;
pub const X3_IMM39_1_INST_WORD_POS_X: u32 = 0;
pub const X3_IMM39_1_SIGN_VAL_POS_X: u32 = 36;
pub const X3_IMM39_2_INST_WORD_X: u32 = 1;
pub const X3_IMM39_2_SIZE_X: u32 = 16;
pub const X3_IMM39_2_INST_WORD_POS_X: u32 = 16;
pub const X3_IMM39_2_SIGN_VAL_POS_X: u32 = 20;
pub const X3_P_INST_WORD_X: u32 = 3;
pub const X3_P_SIZE_X: u32 = 4;
pub const X3_P_INST_WORD_POS_X: u32 = 0;
pub const X3_P_SIGN_VAL_POS_X: u32 = 0;
pub const X3_TMPLT_INST_WORD_X: u32 = 0;
pub const X3_TMPLT_SIZE_X: u32 = 4;
pub const X3_TMPLT_INST_WORD_POS_X: u32 = 0;
pub const X3_TMPLT_SIGN_VAL_POS_X: u32 = 0;
pub const X3_BTYPE_QP_INST_WORD_X: u32 = 2;
pub const X3_BTYPE_QP_SIZE_X: u32 = 9;
pub const X3_BTYPE_QP_INST_WORD_POS_X: u32 = 23;
pub const X3_BTYPE_QP_INST_VAL_POS_X: u32 = 0;
pub const X3_EMPTY_INST_WORD_X: u32 = 1;
pub const X3_EMPTY_SIZE_X: u32 = 2;
pub const X3_EMPTY_INST_WORD_POS_X: u32 = 14;
pub const X3_EMPTY_INST_VAL_POS_X: u32 = 0;
pub const IMAGE_REL_BASED_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_BASED_HIGH: u32 = 1;
pub const IMAGE_REL_BASED_LOW: u32 = 2;
pub const IMAGE_REL_BASED_HIGHLOW: u32 = 3;
pub const IMAGE_REL_BASED_HIGHADJ: u32 = 4;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_5: u32 = 5;
pub const IMAGE_REL_BASED_RESERVED: u32 = 6;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_7: u32 = 7;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_8: u32 = 8;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_9: u32 = 9;
pub const IMAGE_REL_BASED_DIR64: u32 = 10;
pub const IMAGE_REL_BASED_IA64_IMM64: u32 = 9;
pub const IMAGE_REL_BASED_MIPS_JMPADDR: u32 = 5;
pub const IMAGE_REL_BASED_MIPS_JMPADDR16: u32 = 9;
pub const IMAGE_REL_BASED_ARM_MOV32: u32 = 5;
pub const IMAGE_REL_BASED_THUMB_MOV32: u32 = 7;
pub const IMAGE_ARCHIVE_START_SIZE: u32 = 8;
pub const IMAGE_ARCHIVE_START: &[u8; 9usize] = b"!<arch>\n\0";
pub const IMAGE_ARCHIVE_END: &[u8; 3usize] = b"`\n\0";
pub const IMAGE_ARCHIVE_PAD: &[u8; 2usize] = b"\n\0";
pub const IMAGE_ARCHIVE_LINKER_MEMBER: &[u8; 17usize] = b"/               \0";
pub const IMAGE_ARCHIVE_LONGNAMES_MEMBER: &[u8; 17usize] = b"//              \0";
pub const IMAGE_ARCHIVE_HYBRIDMAP_MEMBER: &[u8; 17usize] = b"/<HYBRIDMAP>/   \0";
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR: u32 = 60;
pub const IMAGE_ORDINAL_FLAG64: i64 = -9223372036854775808;
pub const IMAGE_ORDINAL_FLAG32: u32 = 2147483648;
pub const IMAGE_ORDINAL_FLAG: i64 = -9223372036854775808;
pub const IMAGE_RESOURCE_NAME_IS_STRING: u32 = 2147483648;
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY: u32 = 2147483648;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE: u32 = 1;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE: u32 = 2;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER: u32 = 3;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER: u32 = 4;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH: u32 = 5;
pub const IMAGE_DYNAMIC_RELOCATION_FUNCTION_OVERRIDE: u32 = 7;
pub const IMAGE_FUNCTION_OVERRIDE_INVALID: u32 = 0;
pub const IMAGE_FUNCTION_OVERRIDE_X64_REL32: u32 = 1;
pub const IMAGE_FUNCTION_OVERRIDE_ARM64_BRANCH26: u32 = 2;
pub const IMAGE_FUNCTION_OVERRIDE_ARM64_THUNK: u32 = 3;
pub const IMAGE_HOT_PATCH_BASE_OBLIGATORY: u32 = 1;
pub const IMAGE_HOT_PATCH_BASE_CAN_ROLL_BACK: u32 = 2;
pub const IMAGE_HOT_PATCH_CHUNK_INVERSE: u32 = 2147483648;
pub const IMAGE_HOT_PATCH_CHUNK_OBLIGATORY: u32 = 1073741824;
pub const IMAGE_HOT_PATCH_CHUNK_RESERVED: u32 = 1072705536;
pub const IMAGE_HOT_PATCH_CHUNK_TYPE: u32 = 1032192;
pub const IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA: u32 = 32768;
pub const IMAGE_HOT_PATCH_CHUNK_TARGET_RVA: u32 = 16384;
pub const IMAGE_HOT_PATCH_CHUNK_SIZE: u32 = 4095;
pub const IMAGE_HOT_PATCH_NONE: u32 = 0;
pub const IMAGE_HOT_PATCH_FUNCTION: u32 = 114688;
pub const IMAGE_HOT_PATCH_ABSOLUTE: u32 = 180224;
pub const IMAGE_HOT_PATCH_REL32: u32 = 245760;
pub const IMAGE_HOT_PATCH_CALL_TARGET: u32 = 278528;
pub const IMAGE_HOT_PATCH_INDIRECT: u32 = 376832;
pub const IMAGE_HOT_PATCH_NO_CALL_TARGET: u32 = 409600;
pub const IMAGE_HOT_PATCH_DYNAMIC_VALUE: u32 = 491520;
pub const IMAGE_GUARD_CF_INSTRUMENTED: u32 = 256;
pub const IMAGE_GUARD_CFW_INSTRUMENTED: u32 = 512;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT: u32 = 1024;
pub const IMAGE_GUARD_SECURITY_COOKIE_UNUSED: u32 = 2048;
pub const IMAGE_GUARD_PROTECT_DELAYLOAD_IAT: u32 = 4096;
pub const IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION: u32 = 8192;
pub const IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT: u32 = 16384;
pub const IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION: u32 = 32768;
pub const IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT: u32 = 65536;
pub const IMAGE_GUARD_RF_INSTRUMENTED: u32 = 131072;
pub const IMAGE_GUARD_RF_ENABLE: u32 = 262144;
pub const IMAGE_GUARD_RF_STRICT: u32 = 524288;
pub const IMAGE_GUARD_RETPOLINE_PRESENT: u32 = 1048576;
pub const IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT: u32 = 4194304;
pub const IMAGE_GUARD_XFG_ENABLED: u32 = 8388608;
pub const IMAGE_GUARD_CASTGUARD_PRESENT: u32 = 16777216;
pub const IMAGE_GUARD_MEMCPY_PRESENT: u32 = 33554432;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK: u32 = 4026531840;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT: u32 = 28;
pub const IMAGE_GUARD_FLAG_FID_SUPPRESSED: u32 = 1;
pub const IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED: u32 = 2;
pub const IMAGE_GUARD_FLAG_FID_LANGEXCPTHANDLER: u32 = 4;
pub const IMAGE_GUARD_FLAG_FID_XFG: u32 = 8;
pub const IMAGE_ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const IMAGE_ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const IMAGE_ENCLAVE_POLICY_DEBUGGABLE: u32 = 1;
pub const IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE: u32 = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_NONE: u32 = 0;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID: u32 = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID: u32 = 2;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID: u32 = 3;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID: u32 = 4;
pub const IMAGE_DEBUG_TYPE_UNKNOWN: u32 = 0;
pub const IMAGE_DEBUG_TYPE_COFF: u32 = 1;
pub const IMAGE_DEBUG_TYPE_CODEVIEW: u32 = 2;
pub const IMAGE_DEBUG_TYPE_FPO: u32 = 3;
pub const IMAGE_DEBUG_TYPE_MISC: u32 = 4;
pub const IMAGE_DEBUG_TYPE_EXCEPTION: u32 = 5;
pub const IMAGE_DEBUG_TYPE_FIXUP: u32 = 6;
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC: u32 = 7;
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: u32 = 8;
pub const IMAGE_DEBUG_TYPE_BORLAND: u32 = 9;
pub const IMAGE_DEBUG_TYPE_RESERVED10: u32 = 10;
pub const IMAGE_DEBUG_TYPE_BBT: u32 = 10;
pub const IMAGE_DEBUG_TYPE_CLSID: u32 = 11;
pub const IMAGE_DEBUG_TYPE_VC_FEATURE: u32 = 12;
pub const IMAGE_DEBUG_TYPE_POGO: u32 = 13;
pub const IMAGE_DEBUG_TYPE_ILTCG: u32 = 14;
pub const IMAGE_DEBUG_TYPE_MPX: u32 = 15;
pub const IMAGE_DEBUG_TYPE_REPRO: u32 = 16;
pub const IMAGE_DEBUG_TYPE_SPGO: u32 = 18;
pub const IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS: u32 = 20;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT: u32 = 1;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT_STRICT_MODE: u32 = 2;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE: u32 = 4;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC: u32 = 8;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_1: u32 = 16;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_2: u32 = 32;
pub const FRAME_FPO: u32 = 0;
pub const FRAME_TRAP: u32 = 1;
pub const FRAME_TSS: u32 = 2;
pub const FRAME_NONFPO: u32 = 3;
pub const SIZEOF_RFPO_DATA: u32 = 16;
pub const IMAGE_DEBUG_MISC_EXENAME: u32 = 1;
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE: u32 = 18756;
pub const NON_PAGED_DEBUG_SIGNATURE: u32 = 18766;
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK: u32 = 32768;
pub const IMAGE_SEPARATE_DEBUG_MISMATCH: u32 = 32768;
pub const IMPORT_OBJECT_HDR_SIG2: u32 = 65535;
pub const UNWIND_HISTORY_TABLE_SIZE: u32 = 12;
pub const RTL_RUN_ONCE_CHECK_ONLY: u32 = 1;
pub const RTL_RUN_ONCE_ASYNC: u32 = 2;
pub const RTL_RUN_ONCE_INIT_FAILED: u32 = 4;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4;
pub const FAST_FAIL_INVALID_ARG: u32 = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: u32 = 10;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: u32 = 11;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: u32 = 12;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: u32 = 13;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: u32 = 14;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: u32 = 18;
pub const FAST_FAIL_MRDATA_MODIFIED: u32 = 19;
pub const FAST_FAIL_CERTIFICATION_FAILURE: u32 = 20;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: u32 = 21;
pub const FAST_FAIL_CRYPTO_LIBRARY: u32 = 22;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: u32 = 23;
pub const FAST_FAIL_INVALID_IMAGE_BASE: u32 = 24;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: u32 = 25;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: u32 = 26;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: u32 = 27;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: u32 = 28;
pub const FAST_FAIL_INVALID_BALANCED_TREE: u32 = 29;
pub const FAST_FAIL_INVALID_NEXT_THREAD: u32 = 30;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: u32 = 31;
pub const FAST_FAIL_APCS_DISABLED: u32 = 32;
pub const FAST_FAIL_INVALID_IDLE_STATE: u32 = 33;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: u32 = 34;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: u32 = 35;
pub const FAST_FAIL_INVALID_LOCK_STATE: u32 = 36;
pub const FAST_FAIL_GUARD_JUMPTABLE: u32 = 37;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: u32 = 38;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: u32 = 39;
pub const FAST_FAIL_INVALID_THREAD: u32 = 40;
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER: u32 = 41;
pub const FAST_FAIL_INVALID_FILE_OPERATION: u32 = 42;
pub const FAST_FAIL_LPAC_ACCESS_DENIED: u32 = 43;
pub const FAST_FAIL_GUARD_SS_FAILURE: u32 = 44;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE: u32 = 45;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE: u32 = 46;
pub const FAST_FAIL_INVALID_CONTROL_STACK: u32 = 47;
pub const FAST_FAIL_SET_CONTEXT_DENIED: u32 = 48;
pub const FAST_FAIL_INVALID_IAT: u32 = 49;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION: u32 = 50;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION: u32 = 51;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED: u32 = 52;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE: u32 = 53;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON: u32 = 54;
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED: u32 = 55;
pub const FAST_FAIL_UNEXPECTED_CALL: u32 = 56;
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS: u32 = 57;
pub const FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR: u32 = 58;
pub const FAST_FAIL_FLAGS_CORRUPTION: u32 = 59;
pub const FAST_FAIL_VEH_CORRUPTION: u32 = 60;
pub const FAST_FAIL_ETW_CORRUPTION: u32 = 61;
pub const FAST_FAIL_RIO_ABORT: u32 = 62;
pub const FAST_FAIL_INVALID_PFN: u32 = 63;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE_XFG: u32 = 64;
pub const FAST_FAIL_CAST_GUARD: u32 = 65;
pub const FAST_FAIL_HOST_VISIBILITY_CHANGE: u32 = 66;
pub const FAST_FAIL_KERNEL_CET_SHADOW_STACK_ASSIST: u32 = 67;
pub const FAST_FAIL_PATCH_CALLBACK_FAILED: u32 = 68;
pub const FAST_FAIL_NTDLL_PATCH_FAILED: u32 = 69;
pub const FAST_FAIL_INVALID_FLS_DATA: u32 = 70;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295;
pub const HEAP_NO_SERIALIZE: u32 = 1;
pub const HEAP_GROWABLE: u32 = 2;
pub const HEAP_GENERATE_EXCEPTIONS: u32 = 4;
pub const HEAP_ZERO_MEMORY: u32 = 8;
pub const HEAP_REALLOC_IN_PLACE_ONLY: u32 = 16;
pub const HEAP_TAIL_CHECKING_ENABLED: u32 = 32;
pub const HEAP_FREE_CHECKING_ENABLED: u32 = 64;
pub const HEAP_DISABLE_COALESCE_ON_FREE: u32 = 128;
pub const HEAP_CREATE_ALIGN_16: u32 = 65536;
pub const HEAP_CREATE_ENABLE_TRACING: u32 = 131072;
pub const HEAP_CREATE_ENABLE_EXECUTE: u32 = 262144;
pub const HEAP_MAXIMUM_TAG: u32 = 4095;
pub const HEAP_PSEUDO_TAG_FLAG: u32 = 32768;
pub const HEAP_TAG_SHIFT: u32 = 18;
pub const HEAP_CREATE_SEGMENT_HEAP: u32 = 256;
pub const HEAP_CREATE_HARDENED: u32 = 512;
pub const IS_TEXT_UNICODE_ASCII16: u32 = 1;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16: u32 = 16;
pub const IS_TEXT_UNICODE_STATISTICS: u32 = 2;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS: u32 = 32;
pub const IS_TEXT_UNICODE_CONTROLS: u32 = 4;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS: u32 = 64;
pub const IS_TEXT_UNICODE_SIGNATURE: u32 = 8;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE: u32 = 128;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS: u32 = 256;
pub const IS_TEXT_UNICODE_ODD_LENGTH: u32 = 512;
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE: u32 = 1024;
pub const IS_TEXT_UNICODE_UTF8: u32 = 2048;
pub const IS_TEXT_UNICODE_NULL_BYTES: u32 = 4096;
pub const IS_TEXT_UNICODE_UNICODE_MASK: u32 = 15;
pub const IS_TEXT_UNICODE_REVERSE_MASK: u32 = 240;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK: u32 = 3840;
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK: u32 = 61440;
pub const COMPRESSION_FORMAT_NONE: u32 = 0;
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1;
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2;
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3;
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4;
pub const COMPRESSION_FORMAT_XP10: u32 = 5;
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0;
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256;
pub const COMPRESSION_ENGINE_HIBER: u32 = 512;
pub const SEF_DACL_AUTO_INHERIT: u32 = 1;
pub const SEF_SACL_AUTO_INHERIT: u32 = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8;
pub const SEF_AVOID_OWNER_CHECK: u32 = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64;
pub const SEF_MACL_NO_WRITE_UP: u32 = 256;
pub const SEF_MACL_NO_READ_UP: u32 = 512;
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024;
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048;
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096;
pub const SEF_FORCE_USER_MODE: u32 = 8192;
pub const SEF_NORMALIZE_OUTPUT_DESCRIPTOR: u32 = 16384;
pub const SEF_MACL_VALID_FLAGS: u32 = 1792;
pub const MESSAGE_RESOURCE_UNICODE: u32 = 1;
pub const MESSAGE_RESOURCE_UTF8: u32 = 2;
pub const VER_EQUAL: u32 = 1;
pub const VER_GREATER: u32 = 2;
pub const VER_GREATER_EQUAL: u32 = 3;
pub const VER_LESS: u32 = 4;
pub const VER_LESS_EQUAL: u32 = 5;
pub const VER_AND: u32 = 6;
pub const VER_OR: u32 = 7;
pub const VER_CONDITION_MASK: u32 = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3;
pub const VER_MINORVERSION: u32 = 1;
pub const VER_MAJORVERSION: u32 = 2;
pub const VER_BUILDNUMBER: u32 = 4;
pub const VER_PLATFORMID: u32 = 8;
pub const VER_SERVICEPACKMINOR: u32 = 16;
pub const VER_SERVICEPACKMAJOR: u32 = 32;
pub const VER_SUITENAME: u32 = 64;
pub const VER_PRODUCT_TYPE: u32 = 128;
pub const VER_NT_WORKSTATION: u32 = 1;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2;
pub const VER_NT_SERVER: u32 = 3;
pub const VER_PLATFORM_WIN32s: u32 = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: u32 = 1;
pub const VER_PLATFORM_WIN32_NT: u32 = 2;
pub const RTL_UMS_VERSION: u32 = 256;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256;
pub const VRL_CLASS_CONSISTENCY: u32 = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648;
pub const CTMF_INCLUDE_APPCONTAINER: u32 = 1;
pub const CTMF_INCLUDE_LPAC: u32 = 2;
pub const CTMF_VALID_FLAGS: u32 = 3;
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN: u32 = 1;
pub const WRITE_NV_MEMORY_FLAG_FLUSH: u32 = 1;
pub const WRITE_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2;
pub const WRITE_NV_MEMORY_FLAG_PERSIST: u32 = 3;
pub const WRITE_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256;
pub const FILL_NV_MEMORY_FLAG_FLUSH: u32 = 1;
pub const FILL_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2;
pub const FILL_NV_MEMORY_FLAG_PERSIST: u32 = 3;
pub const FILL_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256;
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH: u32 = 129;
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH: u32 = 16;
pub const RTL_CORRELATION_VECTOR_V1_LENGTH: u32 = 64;
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH: u32 = 22;
pub const RTL_CORRELATION_VECTOR_V2_LENGTH: u32 = 128;
pub const IMAGE_POLICY_METADATA_VERSION: u32 = 1;
pub const IMAGE_POLICY_SECTION_NAME: &[u8; 9usize] = b".tPolicy\0";
pub const RTL_VIRTUAL_UNWIND2_VALIDATE_PAC: u32 = 1;
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO: u32 = 16777216;
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN: u32 = 33554432;
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT: u32 = 67108864;
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE: u32 = 134217728;
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO: u32 = 268435456;
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS: u32 = 4278190080;
pub const RTL_CRITICAL_SECTION_FLAG_RESERVED: u32 = 3758096384;
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT: u32 = 1;
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION: u32 = 1;
pub const WT_EXECUTEDEFAULT: u32 = 0;
pub const WT_EXECUTEINIOTHREAD: u32 = 1;
pub const WT_EXECUTEINUITHREAD: u32 = 2;
pub const WT_EXECUTEINWAITTHREAD: u32 = 4;
pub const WT_EXECUTEONLYONCE: u32 = 8;
pub const WT_EXECUTEINTIMERTHREAD: u32 = 32;
pub const WT_EXECUTELONGFUNCTION: u32 = 16;
pub const WT_EXECUTEINPERSISTENTIOTHREAD: u32 = 64;
pub const WT_EXECUTEINPERSISTENTTHREAD: u32 = 128;
pub const WT_TRANSFER_IMPERSONATION: u32 = 256;
pub const WT_EXECUTEINLONGTHREAD: u32 = 16;
pub const WT_EXECUTEDELETEWAIT: u32 = 8;
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE: u32 = 1;
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE: u32 = 2;
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL: u32 = 3;
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF: u32 = 4;
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1;
pub const PERFORMANCE_DATA_VERSION: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS: u32 = 2;
pub const UNIFIEDBUILDREVISION_KEY: &[u8; 63usize] =
    b"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\0";
pub const UNIFIEDBUILDREVISION_VALUE: &[u8; 4usize] = b"UBR\0";
pub const UNIFIEDBUILDREVISION_MIN: u32 = 0;
pub const DEVICEFAMILYDEVICEFORM_KEY: &[u8; 67usize] =
    b"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\OEM\0";
pub const DEVICEFAMILYDEVICEFORM_VALUE: &[u8; 11usize] = b"DeviceForm\0";
pub const DEVICEFAMILYINFOENUM_UAP: u32 = 0;
pub const DEVICEFAMILYINFOENUM_WINDOWS_8X: u32 = 1;
pub const DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X: u32 = 2;
pub const DEVICEFAMILYINFOENUM_DESKTOP: u32 = 3;
pub const DEVICEFAMILYINFOENUM_MOBILE: u32 = 4;
pub const DEVICEFAMILYINFOENUM_XBOX: u32 = 5;
pub const DEVICEFAMILYINFOENUM_TEAM: u32 = 6;
pub const DEVICEFAMILYINFOENUM_IOT: u32 = 7;
pub const DEVICEFAMILYINFOENUM_IOT_HEADLESS: u32 = 8;
pub const DEVICEFAMILYINFOENUM_SERVER: u32 = 9;
pub const DEVICEFAMILYINFOENUM_HOLOGRAPHIC: u32 = 10;
pub const DEVICEFAMILYINFOENUM_XBOXSRA: u32 = 11;
pub const DEVICEFAMILYINFOENUM_XBOXERA: u32 = 12;
pub const DEVICEFAMILYINFOENUM_SERVER_NANO: u32 = 13;
pub const DEVICEFAMILYINFOENUM_8828080: u32 = 14;
pub const DEVICEFAMILYINFOENUM_7067329: u32 = 15;
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE: u32 = 16;
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE_HEADLESS: u32 = 17;
pub const DEVICEFAMILYINFOENUM_MAX: u32 = 17;
pub const DEVICEFAMILYDEVICEFORM_UNKNOWN: u32 = 0;
pub const DEVICEFAMILYDEVICEFORM_PHONE: u32 = 1;
pub const DEVICEFAMILYDEVICEFORM_TABLET: u32 = 2;
pub const DEVICEFAMILYDEVICEFORM_DESKTOP: u32 = 3;
pub const DEVICEFAMILYDEVICEFORM_NOTEBOOK: u32 = 4;
pub const DEVICEFAMILYDEVICEFORM_CONVERTIBLE: u32 = 5;
pub const DEVICEFAMILYDEVICEFORM_DETACHABLE: u32 = 6;
pub const DEVICEFAMILYDEVICEFORM_ALLINONE: u32 = 7;
pub const DEVICEFAMILYDEVICEFORM_STICKPC: u32 = 8;
pub const DEVICEFAMILYDEVICEFORM_PUCK: u32 = 9;
pub const DEVICEFAMILYDEVICEFORM_LARGESCREEN: u32 = 10;
pub const DEVICEFAMILYDEVICEFORM_HMD: u32 = 11;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD: u32 = 12;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET: u32 = 13;
pub const DEVICEFAMILYDEVICEFORM_BANKING: u32 = 14;
pub const DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION: u32 = 15;
pub const DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE: u32 = 16;
pub const DEVICEFAMILYDEVICEFORM_GAMING: u32 = 17;
pub const DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION: u32 = 18;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION: u32 = 19;
pub const DEVICEFAMILYDEVICEFORM_KIOSK: u32 = 20;
pub const DEVICEFAMILYDEVICEFORM_MAKER_BOARD: u32 = 21;
pub const DEVICEFAMILYDEVICEFORM_MEDICAL: u32 = 22;
pub const DEVICEFAMILYDEVICEFORM_NETWORKING: u32 = 23;
pub const DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE: u32 = 24;
pub const DEVICEFAMILYDEVICEFORM_PRINTING: u32 = 25;
pub const DEVICEFAMILYDEVICEFORM_THIN_CLIENT: u32 = 26;
pub const DEVICEFAMILYDEVICEFORM_TOY: u32 = 27;
pub const DEVICEFAMILYDEVICEFORM_VENDING: u32 = 28;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER: u32 = 29;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE: u32 = 30;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_S: u32 = 31;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X: u32 = 32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT: u32 = 33;
pub const DEVICEFAMILYDEVICEFORM_XBOX_SERIES_X: u32 = 34;
pub const DEVICEFAMILYDEVICEFORM_XBOX_SERIES_X_DEVKIT: u32 = 35;
pub const DEVICEFAMILYDEVICEFORM_XBOX_SERIES_S: u32 = 36;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_01: u32 = 37;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_02: u32 = 38;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_03: u32 = 39;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_04: u32 = 40;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_05: u32 = 41;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_06: u32 = 42;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_07: u32 = 43;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_08: u32 = 44;
pub const DEVICEFAMILYDEVICEFORM_XBOX_RESERVED_09: u32 = 45;
pub const DEVICEFAMILYDEVICEFORM_MAX: u32 = 45;
pub const DLL_PROCESS_ATTACH: u32 = 1;
pub const DLL_THREAD_ATTACH: u32 = 2;
pub const DLL_THREAD_DETACH: u32 = 3;
pub const DLL_PROCESS_DETACH: u32 = 0;
pub const EVENTLOG_SEQUENTIAL_READ: u32 = 1;
pub const EVENTLOG_SEEK_READ: u32 = 2;
pub const EVENTLOG_FORWARDS_READ: u32 = 4;
pub const EVENTLOG_BACKWARDS_READ: u32 = 8;
pub const EVENTLOG_SUCCESS: u32 = 0;
pub const EVENTLOG_ERROR_TYPE: u32 = 1;
pub const EVENTLOG_WARNING_TYPE: u32 = 2;
pub const EVENTLOG_INFORMATION_TYPE: u32 = 4;
pub const EVENTLOG_AUDIT_SUCCESS: u32 = 8;
pub const EVENTLOG_AUDIT_FAILURE: u32 = 16;
pub const EVENTLOG_START_PAIRED_EVENT: u32 = 1;
pub const EVENTLOG_END_PAIRED_EVENT: u32 = 2;
pub const EVENTLOG_END_ALL_PAIRED_EVENTS: u32 = 4;
pub const EVENTLOG_PAIRED_EVENT_ACTIVE: u32 = 8;
pub const EVENTLOG_PAIRED_EVENT_INACTIVE: u32 = 16;
pub const MAXLOGICALLOGNAMESIZE: u32 = 256;
pub const KEY_QUERY_VALUE: u32 = 1;
pub const KEY_SET_VALUE: u32 = 2;
pub const KEY_CREATE_SUB_KEY: u32 = 4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 8;
pub const KEY_NOTIFY: u32 = 16;
pub const KEY_CREATE_LINK: u32 = 32;
pub const KEY_WOW64_32KEY: u32 = 512;
pub const KEY_WOW64_64KEY: u32 = 256;
pub const KEY_WOW64_RES: u32 = 768;
pub const KEY_READ: u32 = 131097;
pub const KEY_WRITE: u32 = 131078;
pub const KEY_EXECUTE: u32 = 131097;
pub const KEY_ALL_ACCESS: u32 = 983103;
pub const REG_OPTION_RESERVED: u32 = 0;
pub const REG_OPTION_NON_VOLATILE: u32 = 0;
pub const REG_OPTION_VOLATILE: u32 = 1;
pub const REG_OPTION_CREATE_LINK: u32 = 2;
pub const REG_OPTION_BACKUP_RESTORE: u32 = 4;
pub const REG_OPTION_OPEN_LINK: u32 = 8;
pub const REG_OPTION_DONT_VIRTUALIZE: u32 = 16;
pub const REG_LEGAL_OPTION: u32 = 31;
pub const REG_OPEN_LEGAL_OPTION: u32 = 28;
pub const REG_CREATED_NEW_KEY: u32 = 1;
pub const REG_OPENED_EXISTING_KEY: u32 = 2;
pub const REG_STANDARD_FORMAT: u32 = 1;
pub const REG_LATEST_FORMAT: u32 = 2;
pub const REG_NO_COMPRESSION: u32 = 4;
pub const REG_WHOLE_HIVE_VOLATILE: u32 = 1;
pub const REG_REFRESH_HIVE: u32 = 2;
pub const REG_NO_LAZY_FLUSH: u32 = 4;
pub const REG_FORCE_RESTORE: u32 = 8;
pub const REG_APP_HIVE: u32 = 16;
pub const REG_PROCESS_PRIVATE: u32 = 32;
pub const REG_START_JOURNAL: u32 = 64;
pub const REG_HIVE_EXACT_FILE_GROWTH: u32 = 128;
pub const REG_HIVE_NO_RM: u32 = 256;
pub const REG_HIVE_SINGLE_LOG: u32 = 512;
pub const REG_BOOT_HIVE: u32 = 1024;
pub const REG_LOAD_HIVE_OPEN_HANDLE: u32 = 2048;
pub const REG_FLUSH_HIVE_FILE_GROWTH: u32 = 4096;
pub const REG_OPEN_READ_ONLY: u32 = 8192;
pub const REG_IMMUTABLE: u32 = 16384;
pub const REG_NO_IMPERSONATION_FALLBACK: u32 = 32768;
pub const REG_APP_HIVE_OPEN_READ_ONLY: u32 = 8192;
pub const REG_FORCE_UNLOAD: u32 = 1;
pub const REG_UNLOAD_LEGAL_FLAGS: u32 = 1;
pub const REG_NOTIFY_CHANGE_NAME: u32 = 1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: u32 = 2;
pub const REG_NOTIFY_CHANGE_LAST_SET: u32 = 4;
pub const REG_NOTIFY_CHANGE_SECURITY: u32 = 8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: u32 = 268435456;
pub const REG_LEGAL_CHANGE_FILTER: u32 = 268435471;
pub const REG_NONE: u32 = 0;
pub const REG_SZ: u32 = 1;
pub const REG_EXPAND_SZ: u32 = 2;
pub const REG_BINARY: u32 = 3;
pub const REG_DWORD: u32 = 4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 5;
pub const REG_LINK: u32 = 6;
pub const REG_MULTI_SZ: u32 = 7;
pub const REG_RESOURCE_LIST: u32 = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 10;
pub const REG_QWORD: u32 = 11;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 11;
pub const SERVICE_KERNEL_DRIVER: u32 = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: u32 = 2;
pub const SERVICE_ADAPTER: u32 = 4;
pub const SERVICE_RECOGNIZER_DRIVER: u32 = 8;
pub const SERVICE_DRIVER: u32 = 11;
pub const SERVICE_WIN32_OWN_PROCESS: u32 = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: u32 = 32;
pub const SERVICE_WIN32: u32 = 48;
pub const SERVICE_USER_SERVICE: u32 = 64;
pub const SERVICE_USERSERVICE_INSTANCE: u32 = 128;
pub const SERVICE_USER_SHARE_PROCESS: u32 = 96;
pub const SERVICE_USER_OWN_PROCESS: u32 = 80;
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256;
pub const SERVICE_PKG_SERVICE: u32 = 512;
pub const SERVICE_TYPE_ALL: u32 = 1023;
pub const SERVICE_BOOT_START: u32 = 0;
pub const SERVICE_SYSTEM_START: u32 = 1;
pub const SERVICE_AUTO_START: u32 = 2;
pub const SERVICE_DEMAND_START: u32 = 3;
pub const SERVICE_DISABLED: u32 = 4;
pub const SERVICE_ERROR_IGNORE: u32 = 0;
pub const SERVICE_ERROR_NORMAL: u32 = 1;
pub const SERVICE_ERROR_SEVERE: u32 = 2;
pub const SERVICE_ERROR_CRITICAL: u32 = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128;
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD: u32 = 256;
pub const CM_SERVICE_VALID_PROMOTION_MASK: u32 = 511;
pub const TAPE_ERASE_SHORT: u32 = 0;
pub const TAPE_ERASE_LONG: u32 = 1;
pub const TAPE_LOAD: u32 = 0;
pub const TAPE_UNLOAD: u32 = 1;
pub const TAPE_TENSION: u32 = 2;
pub const TAPE_LOCK: u32 = 3;
pub const TAPE_UNLOCK: u32 = 4;
pub const TAPE_FORMAT: u32 = 5;
pub const TAPE_SETMARKS: u32 = 0;
pub const TAPE_FILEMARKS: u32 = 1;
pub const TAPE_SHORT_FILEMARKS: u32 = 2;
pub const TAPE_LONG_FILEMARKS: u32 = 3;
pub const TAPE_ABSOLUTE_POSITION: u32 = 0;
pub const TAPE_LOGICAL_POSITION: u32 = 1;
pub const TAPE_PSEUDO_LOGICAL_POSITION: u32 = 2;
pub const TAPE_REWIND: u32 = 0;
pub const TAPE_ABSOLUTE_BLOCK: u32 = 1;
pub const TAPE_LOGICAL_BLOCK: u32 = 2;
pub const TAPE_PSEUDO_LOGICAL_BLOCK: u32 = 3;
pub const TAPE_SPACE_END_OF_DATA: u32 = 4;
pub const TAPE_SPACE_RELATIVE_BLOCKS: u32 = 5;
pub const TAPE_SPACE_FILEMARKS: u32 = 6;
pub const TAPE_SPACE_SEQUENTIAL_FMKS: u32 = 7;
pub const TAPE_SPACE_SETMARKS: u32 = 8;
pub const TAPE_SPACE_SEQUENTIAL_SMKS: u32 = 9;
pub const TAPE_DRIVE_FIXED: u32 = 1;
pub const TAPE_DRIVE_SELECT: u32 = 2;
pub const TAPE_DRIVE_INITIATOR: u32 = 4;
pub const TAPE_DRIVE_ERASE_SHORT: u32 = 16;
pub const TAPE_DRIVE_ERASE_LONG: u32 = 32;
pub const TAPE_DRIVE_ERASE_BOP_ONLY: u32 = 64;
pub const TAPE_DRIVE_ERASE_IMMEDIATE: u32 = 128;
pub const TAPE_DRIVE_TAPE_CAPACITY: u32 = 256;
pub const TAPE_DRIVE_TAPE_REMAINING: u32 = 512;
pub const TAPE_DRIVE_FIXED_BLOCK: u32 = 1024;
pub const TAPE_DRIVE_VARIABLE_BLOCK: u32 = 2048;
pub const TAPE_DRIVE_WRITE_PROTECT: u32 = 4096;
pub const TAPE_DRIVE_EOT_WZ_SIZE: u32 = 8192;
pub const TAPE_DRIVE_ECC: u32 = 65536;
pub const TAPE_DRIVE_COMPRESSION: u32 = 131072;
pub const TAPE_DRIVE_PADDING: u32 = 262144;
pub const TAPE_DRIVE_REPORT_SMKS: u32 = 524288;
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK: u32 = 1048576;
pub const TAPE_DRIVE_GET_LOGICAL_BLK: u32 = 2097152;
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE: u32 = 4194304;
pub const TAPE_DRIVE_EJECT_MEDIA: u32 = 16777216;
pub const TAPE_DRIVE_CLEAN_REQUESTS: u32 = 33554432;
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY: u32 = 67108864;
pub const TAPE_DRIVE_RESERVED_BIT: u32 = 2147483648;
pub const TAPE_DRIVE_LOAD_UNLOAD: u32 = 2147483649;
pub const TAPE_DRIVE_TENSION: u32 = 2147483650;
pub const TAPE_DRIVE_LOCK_UNLOCK: u32 = 2147483652;
pub const TAPE_DRIVE_REWIND_IMMEDIATE: u32 = 2147483656;
pub const TAPE_DRIVE_SET_BLOCK_SIZE: u32 = 2147483664;
pub const TAPE_DRIVE_LOAD_UNLD_IMMED: u32 = 2147483680;
pub const TAPE_DRIVE_TENSION_IMMED: u32 = 2147483712;
pub const TAPE_DRIVE_LOCK_UNLK_IMMED: u32 = 2147483776;
pub const TAPE_DRIVE_SET_ECC: u32 = 2147483904;
pub const TAPE_DRIVE_SET_COMPRESSION: u32 = 2147484160;
pub const TAPE_DRIVE_SET_PADDING: u32 = 2147484672;
pub const TAPE_DRIVE_SET_REPORT_SMKS: u32 = 2147485696;
pub const TAPE_DRIVE_ABSOLUTE_BLK: u32 = 2147487744;
pub const TAPE_DRIVE_ABS_BLK_IMMED: u32 = 2147491840;
pub const TAPE_DRIVE_LOGICAL_BLK: u32 = 2147500032;
pub const TAPE_DRIVE_LOG_BLK_IMMED: u32 = 2147516416;
pub const TAPE_DRIVE_END_OF_DATA: u32 = 2147549184;
pub const TAPE_DRIVE_RELATIVE_BLKS: u32 = 2147614720;
pub const TAPE_DRIVE_FILEMARKS: u32 = 2147745792;
pub const TAPE_DRIVE_SEQUENTIAL_FMKS: u32 = 2148007936;
pub const TAPE_DRIVE_SETMARKS: u32 = 2148532224;
pub const TAPE_DRIVE_SEQUENTIAL_SMKS: u32 = 2149580800;
pub const TAPE_DRIVE_REVERSE_POSITION: u32 = 2151677952;
pub const TAPE_DRIVE_SPACE_IMMEDIATE: u32 = 2155872256;
pub const TAPE_DRIVE_WRITE_SETMARKS: u32 = 2164260864;
pub const TAPE_DRIVE_WRITE_FILEMARKS: u32 = 2181038080;
pub const TAPE_DRIVE_WRITE_SHORT_FMKS: u32 = 2214592512;
pub const TAPE_DRIVE_WRITE_LONG_FMKS: u32 = 2281701376;
pub const TAPE_DRIVE_WRITE_MARK_IMMED: u32 = 2415919104;
pub const TAPE_DRIVE_FORMAT: u32 = 2684354560;
pub const TAPE_DRIVE_FORMAT_IMMEDIATE: u32 = 3221225472;
pub const TAPE_DRIVE_HIGH_FEATURES: u32 = 2147483648;
pub const TAPE_FIXED_PARTITIONS: u32 = 0;
pub const TAPE_SELECT_PARTITIONS: u32 = 1;
pub const TAPE_INITIATOR_PARTITIONS: u32 = 2;
pub const TAPE_QUERY_DRIVE_PARAMETERS: u32 = 0;
pub const TAPE_QUERY_MEDIA_CAPACITY: u32 = 1;
pub const TAPE_CHECK_FOR_DRIVE_PROBLEM: u32 = 2;
pub const TAPE_QUERY_IO_ERROR_DATA: u32 = 3;
pub const TAPE_QUERY_DEVICE_ERROR_DATA: u32 = 4;
pub const TRANSACTION_MANAGER_VOLATILE: u32 = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: u32 = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: u32 = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: u32 = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: u32 = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: u32 = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: u32 = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: u32 = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: u32 = 1;
pub const TRANSACTION_MAXIMUM_OPTION: u32 = 1;
pub const RESOURCE_MANAGER_VOLATILE: u32 = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: u32 = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: u32 = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: u32 = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: u32 = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: u32 = 3;
pub const ENLISTMENT_SUPERIOR: u32 = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: u32 = 1;
pub const TRANSACTION_NOTIFY_MASK: u32 = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: u32 = 1;
pub const TRANSACTION_NOTIFY_PREPARE: u32 = 2;
pub const TRANSACTION_NOTIFY_COMMIT: u32 = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: u32 = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: u32 = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: u32 = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: u32 = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: u32 = 128;
pub const TRANSACTION_NOTIFY_RECOVER: u32 = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: u32 = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: u32 = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: u32 = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: u32 = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: u32 = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: u32 = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: u32 = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: u32 = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: u32 = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: u32 = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: u32 = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: u32 = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: u32 = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: u32 = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: u32 = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: u32 = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: u32 = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &[u8; 21usize] = b"\\TransactionManager\\\0";
pub const TRANSACTION_OBJECT_PATH: &[u8; 14usize] = b"\\Transaction\\\0";
pub const ENLISTMENT_OBJECT_PATH: &[u8; 13usize] = b"\\Enlistment\\\0";
pub const RESOURCE_MANAGER_OBJECT_PATH: &[u8; 18usize] = b"\\ResourceManager\\\0";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: u32 = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: u32 = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: u32 = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4;
pub const TRANSACTIONMANAGER_RENAME: u32 = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32;
pub const TRANSACTIONMANAGER_GENERIC_READ: u32 = 131073;
pub const TRANSACTIONMANAGER_GENERIC_WRITE: u32 = 131102;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE: u32 = 131072;
pub const TRANSACTIONMANAGER_ALL_ACCESS: u32 = 983103;
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTION_SET_INFORMATION: u32 = 2;
pub const TRANSACTION_ENLIST: u32 = 4;
pub const TRANSACTION_COMMIT: u32 = 8;
pub const TRANSACTION_ROLLBACK: u32 = 16;
pub const TRANSACTION_PROPAGATE: u32 = 32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64;
pub const TRANSACTION_GENERIC_READ: u32 = 1179649;
pub const TRANSACTION_GENERIC_WRITE: u32 = 1179710;
pub const TRANSACTION_GENERIC_EXECUTE: u32 = 1179672;
pub const TRANSACTION_ALL_ACCESS: u32 = 2031679;
pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS: u32 = 1179703;
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2;
pub const RESOURCEMANAGER_RECOVER: u32 = 4;
pub const RESOURCEMANAGER_ENLIST: u32 = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64;
pub const RESOURCEMANAGER_GENERIC_READ: u32 = 1179649;
pub const RESOURCEMANAGER_GENERIC_WRITE: u32 = 1179774;
pub const RESOURCEMANAGER_GENERIC_EXECUTE: u32 = 1179740;
pub const RESOURCEMANAGER_ALL_ACCESS: u32 = 2031743;
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2;
pub const ENLISTMENT_RECOVER: u32 = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16;
pub const ENLISTMENT_GENERIC_READ: u32 = 131073;
pub const ENLISTMENT_GENERIC_WRITE: u32 = 131102;
pub const ENLISTMENT_GENERIC_EXECUTE: u32 = 131100;
pub const ENLISTMENT_ALL_ACCESS: u32 = 983071;
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: u32 = 1;
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: u32 = 2;
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: u32 = 3;
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: u32 = 4;
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: u32 = 5;
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: u32 = 6;
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: u32 = 7;
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: u32 = 8;
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: u32 = 9;
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS: u32 = 10;
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO: u32 = 11;
pub const ACTIVATION_CONTEXT_SECTION_WINRT_ACTIVATABLE_CLASSES: u32 = 12;
pub const APP_LOCAL_DEVICE_ID_SIZE: u32 = 32;
pub const DM_UPDATE: u32 = 1;
pub const DM_COPY: u32 = 2;
pub const DM_PROMPT: u32 = 4;
pub const DM_MODIFY: u32 = 8;
pub const DM_IN_BUFFER: u32 = 8;
pub const DM_IN_PROMPT: u32 = 4;
pub const DM_OUT_BUFFER: u32 = 2;
pub const DM_OUT_DEFAULT: u32 = 1;
pub const DC_FIELDS: u32 = 1;
pub const DC_PAPERS: u32 = 2;
pub const DC_PAPERSIZE: u32 = 3;
pub const DC_MINEXTENT: u32 = 4;
pub const DC_MAXEXTENT: u32 = 5;
pub const DC_BINS: u32 = 6;
pub const DC_DUPLEX: u32 = 7;
pub const DC_SIZE: u32 = 8;
pub const DC_EXTRA: u32 = 9;
pub const DC_VERSION: u32 = 10;
pub const DC_DRIVER: u32 = 11;
pub const DC_BINNAMES: u32 = 12;
pub const DC_ENUMRESOLUTIONS: u32 = 13;
pub const DC_FILEDEPENDENCIES: u32 = 14;
pub const DC_TRUETYPE: u32 = 15;
pub const DC_PAPERNAMES: u32 = 16;
pub const DC_ORIENTATION: u32 = 17;
pub const DC_COPIES: u32 = 18;
pub const FIND_FIRST_EX_CASE_SENSITIVE: u32 = 1;
pub const FIND_FIRST_EX_LARGE_FETCH: u32 = 2;
pub const FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY: u32 = 4;
pub const LOCKFILE_FAIL_IMMEDIATELY: u32 = 1;
pub const LOCKFILE_EXCLUSIVE_LOCK: u32 = 2;
pub const PROCESS_HEAP_REGION: u32 = 1;
pub const PROCESS_HEAP_UNCOMMITTED_RANGE: u32 = 2;
pub const PROCESS_HEAP_ENTRY_BUSY: u32 = 4;
pub const PROCESS_HEAP_SEG_ALLOC: u32 = 8;
pub const PROCESS_HEAP_ENTRY_MOVEABLE: u32 = 16;
pub const PROCESS_HEAP_ENTRY_DDESHARE: u32 = 32;
pub const EXCEPTION_DEBUG_EVENT: u32 = 1;
pub const CREATE_THREAD_DEBUG_EVENT: u32 = 2;
pub const CREATE_PROCESS_DEBUG_EVENT: u32 = 3;
pub const EXIT_THREAD_DEBUG_EVENT: u32 = 4;
pub const EXIT_PROCESS_DEBUG_EVENT: u32 = 5;
pub const LOAD_DLL_DEBUG_EVENT: u32 = 6;
pub const UNLOAD_DLL_DEBUG_EVENT: u32 = 7;
pub const OUTPUT_DEBUG_STRING_EVENT: u32 = 8;
pub const RIP_EVENT: u32 = 9;
pub const LMEM_FIXED: u32 = 0;
pub const LMEM_MOVEABLE: u32 = 2;
pub const LMEM_NOCOMPACT: u32 = 16;
pub const LMEM_NODISCARD: u32 = 32;
pub const LMEM_ZEROINIT: u32 = 64;
pub const LMEM_MODIFY: u32 = 128;
pub const LMEM_DISCARDABLE: u32 = 3840;
pub const LMEM_VALID_FLAGS: u32 = 3954;
pub const LMEM_INVALID_HANDLE: u32 = 32768;
pub const LHND: u32 = 66;
pub const LPTR: u32 = 64;
pub const NONZEROLHND: u32 = 2;
pub const NONZEROLPTR: u32 = 0;
pub const LMEM_DISCARDED: u32 = 16384;
pub const LMEM_LOCKCOUNT: u32 = 255;
pub const CREATE_NEW: u32 = 1;
pub const CREATE_ALWAYS: u32 = 2;
pub const OPEN_EXISTING: u32 = 3;
pub const OPEN_ALWAYS: u32 = 4;
pub const TRUNCATE_EXISTING: u32 = 5;
pub const INIT_ONCE_CHECK_ONLY: u32 = 1;
pub const INIT_ONCE_ASYNC: u32 = 2;
pub const INIT_ONCE_INIT_FAILED: u32 = 4;
pub const INIT_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const MUTEX_MODIFY_STATE: u32 = 1;
pub const MUTEX_ALL_ACCESS: u32 = 2031617;
pub const CREATE_MUTEX_INITIAL_OWNER: u32 = 1;
pub const CREATE_EVENT_MANUAL_RESET: u32 = 1;
pub const CREATE_EVENT_INITIAL_SET: u32 = 2;
pub const CREATE_WAITABLE_TIMER_MANUAL_RESET: u32 = 1;
pub const CREATE_WAITABLE_TIMER_HIGH_RESOLUTION: u32 = 2;
pub const SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY: u32 = 1;
pub const SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY: u32 = 2;
pub const SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE: u32 = 4;
pub const PROC_THREAD_ATTRIBUTE_REPLACE_VALUE: u32 = 1;
pub const PROCESS_AFFINITY_ENABLE_AUTO_UPDATE: u32 = 1;
pub const THREAD_POWER_THROTTLING_CURRENT_VERSION: u32 = 1;
pub const THREAD_POWER_THROTTLING_EXECUTION_SPEED: u32 = 1;
pub const THREAD_POWER_THROTTLING_VALID_FLAGS: u32 = 1;
pub const PME_CURRENT_VERSION: u32 = 1;
pub const PME_FAILFAST_ON_COMMIT_FAIL_DISABLE: u32 = 0;
pub const PME_FAILFAST_ON_COMMIT_FAIL_ENABLE: u32 = 1;
pub const PROCESS_POWER_THROTTLING_CURRENT_VERSION: u32 = 1;
pub const PROCESS_POWER_THROTTLING_EXECUTION_SPEED: u32 = 1;
pub const PROCESS_POWER_THROTTLING_IGNORE_TIMER_RESOLUTION: u32 = 4;
pub const PROCESS_POWER_THROTTLING_VALID_FLAGS: u32 = 5;
pub const PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND: u32 = 1;
pub const PROCESS_LEAP_SECOND_INFO_VALID_FLAGS: u32 = 1;
pub const USER_CET_ENVIRONMENT_WIN32_PROCESS: u32 = 0;
pub const USER_CET_ENVIRONMENT_SGX2_ENCLAVE: u32 = 2;
pub const USER_CET_ENVIRONMENT_VBS_ENCLAVE: u32 = 16;
pub const USER_CET_ENVIRONMENT_VBS_BASIC_ENCLAVE: u32 = 17;
pub const SCEX2_ALT_NETBIOS_NAME: u32 = 1;
pub const FILE_MAP_WRITE: u32 = 2;
pub const FILE_MAP_READ: u32 = 4;
pub const FILE_MAP_ALL_ACCESS: u32 = 983071;
pub const FILE_MAP_EXECUTE: u32 = 32;
pub const FILE_MAP_COPY: u32 = 1;
pub const FILE_MAP_RESERVE: u32 = 2147483648;
pub const FILE_MAP_TARGETS_INVALID: u32 = 1073741824;
pub const FILE_MAP_LARGE_PAGES: u32 = 536870912;
pub const FILE_CACHE_MAX_HARD_ENABLE: u32 = 1;
pub const FILE_CACHE_MAX_HARD_DISABLE: u32 = 2;
pub const FILE_CACHE_MIN_HARD_ENABLE: u32 = 4;
pub const FILE_CACHE_MIN_HARD_DISABLE: u32 = 8;
pub const MEHC_PATROL_SCRUBBER_PRESENT: u32 = 1;
pub const FIND_RESOURCE_DIRECTORY_TYPES: u32 = 256;
pub const FIND_RESOURCE_DIRECTORY_NAMES: u32 = 512;
pub const FIND_RESOURCE_DIRECTORY_LANGUAGES: u32 = 1024;
pub const RESOURCE_ENUM_LN: u32 = 1;
pub const RESOURCE_ENUM_MUI: u32 = 2;
pub const RESOURCE_ENUM_MUI_SYSTEM: u32 = 4;
pub const RESOURCE_ENUM_VALIDATE: u32 = 8;
pub const RESOURCE_ENUM_MODULE_EXACT: u32 = 16;
pub const SUPPORT_LANG_NUMBER: u32 = 32;
pub const GET_MODULE_HANDLE_EX_FLAG_PIN: u32 = 1;
pub const GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT: u32 = 2;
pub const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: u32 = 4;
pub const CURRENT_IMPORT_REDIRECTION_VERSION: u32 = 1;
pub const DONT_RESOLVE_DLL_REFERENCES: u32 = 1;
pub const LOAD_LIBRARY_AS_DATAFILE: u32 = 2;
pub const LOAD_WITH_ALTERED_SEARCH_PATH: u32 = 8;
pub const LOAD_IGNORE_CODE_AUTHZ_LEVEL: u32 = 16;
pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE: u32 = 32;
pub const LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE: u32 = 64;
pub const LOAD_LIBRARY_REQUIRE_SIGNED_TARGET: u32 = 128;
pub const LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR: u32 = 256;
pub const LOAD_LIBRARY_SEARCH_APPLICATION_DIR: u32 = 512;
pub const LOAD_LIBRARY_SEARCH_USER_DIRS: u32 = 1024;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32: u32 = 2048;
pub const LOAD_LIBRARY_SEARCH_DEFAULT_DIRS: u32 = 4096;
pub const LOAD_LIBRARY_SAFE_CURRENT_DIRS: u32 = 8192;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER: u32 = 16384;
pub const LOAD_LIBRARY_OS_INTEGRITY_CONTINUITY: u32 = 32768;
pub const PRIVATE_NAMESPACE_FLAG_DESTROY: u32 = 1;
pub const FILE_BEGIN: u32 = 0;
pub const FILE_CURRENT: u32 = 1;
pub const FILE_END: u32 = 2;
pub const FILE_FLAG_WRITE_THROUGH: u32 = 2147483648;
pub const FILE_FLAG_OVERLAPPED: u32 = 1073741824;
pub const FILE_FLAG_NO_BUFFERING: u32 = 536870912;
pub const FILE_FLAG_RANDOM_ACCESS: u32 = 268435456;
pub const FILE_FLAG_SEQUENTIAL_SCAN: u32 = 134217728;
pub const FILE_FLAG_DELETE_ON_CLOSE: u32 = 67108864;
pub const FILE_FLAG_BACKUP_SEMANTICS: u32 = 33554432;
pub const FILE_FLAG_POSIX_SEMANTICS: u32 = 16777216;
pub const FILE_FLAG_SESSION_AWARE: u32 = 8388608;
pub const FILE_FLAG_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_FLAG_OPEN_NO_RECALL: u32 = 1048576;
pub const FILE_FLAG_FIRST_PIPE_INSTANCE: u32 = 524288;
pub const FILE_FLAG_OPEN_REQUIRING_OPLOCK: u32 = 262144;
pub const PROGRESS_CONTINUE: u32 = 0;
pub const PROGRESS_CANCEL: u32 = 1;
pub const PROGRESS_STOP: u32 = 2;
pub const PROGRESS_QUIET: u32 = 3;
pub const CALLBACK_CHUNK_FINISHED: u32 = 0;
pub const CALLBACK_STREAM_SWITCH: u32 = 1;
pub const COPY_FILE_FAIL_IF_EXISTS: u32 = 1;
pub const COPY_FILE_RESTARTABLE: u32 = 2;
pub const COPY_FILE_OPEN_SOURCE_FOR_WRITE: u32 = 4;
pub const COPY_FILE_ALLOW_DECRYPTED_DESTINATION: u32 = 8;
pub const COPY_FILE_COPY_SYMLINK: u32 = 2048;
pub const COPY_FILE_NO_BUFFERING: u32 = 4096;
pub const COPY_FILE_REQUEST_SECURITY_PRIVILEGES: u32 = 8192;
pub const COPY_FILE_RESUME_FROM_PAUSE: u32 = 16384;
pub const COPY_FILE_NO_OFFLOAD: u32 = 262144;
pub const COPY_FILE_IGNORE_EDP_BLOCK: u32 = 4194304;
pub const COPY_FILE_IGNORE_SOURCE_ENCRYPTION: u32 = 8388608;
pub const COPY_FILE_DONT_REQUEST_DEST_WRITE_DAC: u32 = 33554432;
pub const COPY_FILE_REQUEST_COMPRESSED_TRAFFIC: u32 = 268435456;
pub const COPY_FILE_OPEN_AND_COPY_REPARSE_POINT: u32 = 2097152;
pub const COPY_FILE_DIRECTORY: u32 = 128;
pub const COPY_FILE_SKIP_ALTERNATE_STREAMS: u32 = 32768;
pub const COPY_FILE_DISABLE_PRE_ALLOCATION: u32 = 67108864;
pub const COPY_FILE_ENABLE_LOW_FREE_SPACE_MODE: u32 = 134217728;
pub const COPY_FILE_ENABLE_SPARSE_COPY: u32 = 536870912;
pub const REPLACEFILE_WRITE_THROUGH: u32 = 1;
pub const REPLACEFILE_IGNORE_MERGE_ERRORS: u32 = 2;
pub const REPLACEFILE_IGNORE_ACL_ERRORS: u32 = 4;
pub const PIPE_ACCESS_INBOUND: u32 = 1;
pub const PIPE_ACCESS_OUTBOUND: u32 = 2;
pub const PIPE_ACCESS_DUPLEX: u32 = 3;
pub const PIPE_CLIENT_END: u32 = 0;
pub const PIPE_SERVER_END: u32 = 1;
pub const PIPE_WAIT: u32 = 0;
pub const PIPE_NOWAIT: u32 = 1;
pub const PIPE_READMODE_BYTE: u32 = 0;
pub const PIPE_READMODE_MESSAGE: u32 = 2;
pub const PIPE_TYPE_BYTE: u32 = 0;
pub const PIPE_TYPE_MESSAGE: u32 = 4;
pub const PIPE_ACCEPT_REMOTE_CLIENTS: u32 = 0;
pub const PIPE_REJECT_REMOTE_CLIENTS: u32 = 8;
pub const PIPE_UNLIMITED_INSTANCES: u32 = 255;
pub const SECURITY_CONTEXT_TRACKING: u32 = 262144;
pub const SECURITY_EFFECTIVE_ONLY: u32 = 524288;
pub const SECURITY_SQOS_PRESENT: u32 = 1048576;
pub const SECURITY_VALID_SQOS_FLAGS: u32 = 2031616;
pub const FAIL_FAST_GENERATE_EXCEPTION_ADDRESS: u32 = 1;
pub const FAIL_FAST_NO_HARD_ERROR_DLG: u32 = 2;
pub const DTR_CONTROL_DISABLE: u32 = 0;
pub const DTR_CONTROL_ENABLE: u32 = 1;
pub const DTR_CONTROL_HANDSHAKE: u32 = 2;
pub const RTS_CONTROL_DISABLE: u32 = 0;
pub const RTS_CONTROL_ENABLE: u32 = 1;
pub const RTS_CONTROL_HANDSHAKE: u32 = 2;
pub const RTS_CONTROL_TOGGLE: u32 = 3;
pub const GMEM_FIXED: u32 = 0;
pub const GMEM_MOVEABLE: u32 = 2;
pub const GMEM_NOCOMPACT: u32 = 16;
pub const GMEM_NODISCARD: u32 = 32;
pub const GMEM_ZEROINIT: u32 = 64;
pub const GMEM_MODIFY: u32 = 128;
pub const GMEM_DISCARDABLE: u32 = 256;
pub const GMEM_NOT_BANKED: u32 = 4096;
pub const GMEM_SHARE: u32 = 8192;
pub const GMEM_DDESHARE: u32 = 8192;
pub const GMEM_NOTIFY: u32 = 16384;
pub const GMEM_LOWER: u32 = 4096;
pub const GMEM_VALID_FLAGS: u32 = 32626;
pub const GMEM_INVALID_HANDLE: u32 = 32768;
pub const GHND: u32 = 66;
pub const GPTR: u32 = 64;
pub const GMEM_DISCARDED: u32 = 16384;
pub const GMEM_LOCKCOUNT: u32 = 255;
pub const DEBUG_PROCESS: u32 = 1;
pub const DEBUG_ONLY_THIS_PROCESS: u32 = 2;
pub const CREATE_SUSPENDED: u32 = 4;
pub const DETACHED_PROCESS: u32 = 8;
pub const CREATE_NEW_CONSOLE: u32 = 16;
pub const NORMAL_PRIORITY_CLASS: u32 = 32;
pub const IDLE_PRIORITY_CLASS: u32 = 64;
pub const HIGH_PRIORITY_CLASS: u32 = 128;
pub const REALTIME_PRIORITY_CLASS: u32 = 256;
pub const CREATE_NEW_PROCESS_GROUP: u32 = 512;
pub const CREATE_UNICODE_ENVIRONMENT: u32 = 1024;
pub const CREATE_SEPARATE_WOW_VDM: u32 = 2048;
pub const CREATE_SHARED_WOW_VDM: u32 = 4096;
pub const CREATE_FORCEDOS: u32 = 8192;
pub const BELOW_NORMAL_PRIORITY_CLASS: u32 = 16384;
pub const ABOVE_NORMAL_PRIORITY_CLASS: u32 = 32768;
pub const INHERIT_PARENT_AFFINITY: u32 = 65536;
pub const INHERIT_CALLER_PRIORITY: u32 = 131072;
pub const CREATE_PROTECTED_PROCESS: u32 = 262144;
pub const EXTENDED_STARTUPINFO_PRESENT: u32 = 524288;
pub const PROCESS_MODE_BACKGROUND_BEGIN: u32 = 1048576;
pub const PROCESS_MODE_BACKGROUND_END: u32 = 2097152;
pub const CREATE_SECURE_PROCESS: u32 = 4194304;
pub const CREATE_BREAKAWAY_FROM_JOB: u32 = 16777216;
pub const CREATE_PRESERVE_CODE_AUTHZ_LEVEL: u32 = 33554432;
pub const CREATE_DEFAULT_ERROR_MODE: u32 = 67108864;
pub const CREATE_NO_WINDOW: u32 = 134217728;
pub const PROFILE_USER: u32 = 268435456;
pub const PROFILE_KERNEL: u32 = 536870912;
pub const PROFILE_SERVER: u32 = 1073741824;
pub const CREATE_IGNORE_SYSTEM_DEFAULT: u32 = 2147483648;
pub const STACK_SIZE_PARAM_IS_A_RESERVATION: u32 = 65536;
pub const THREAD_PRIORITY_LOWEST: i32 = -2;
pub const THREAD_PRIORITY_BELOW_NORMAL: i32 = -1;
pub const THREAD_PRIORITY_NORMAL: u32 = 0;
pub const THREAD_PRIORITY_HIGHEST: u32 = 2;
pub const THREAD_PRIORITY_ABOVE_NORMAL: u32 = 1;
pub const THREAD_PRIORITY_ERROR_RETURN: u32 = 2147483647;
pub const THREAD_PRIORITY_TIME_CRITICAL: u32 = 15;
pub const THREAD_PRIORITY_IDLE: i32 = -15;
pub const THREAD_MODE_BACKGROUND_BEGIN: u32 = 65536;
pub const THREAD_MODE_BACKGROUND_END: u32 = 131072;
pub const VOLUME_NAME_DOS: u32 = 0;
pub const VOLUME_NAME_GUID: u32 = 1;
pub const VOLUME_NAME_NT: u32 = 2;
pub const VOLUME_NAME_NONE: u32 = 4;
pub const FILE_NAME_NORMALIZED: u32 = 0;
pub const FILE_NAME_OPENED: u32 = 8;
pub const DRIVE_UNKNOWN: u32 = 0;
pub const DRIVE_NO_ROOT_DIR: u32 = 1;
pub const DRIVE_REMOVABLE: u32 = 2;
pub const DRIVE_FIXED: u32 = 3;
pub const DRIVE_REMOTE: u32 = 4;
pub const DRIVE_CDROM: u32 = 5;
pub const DRIVE_RAMDISK: u32 = 6;
pub const FILE_TYPE_UNKNOWN: u32 = 0;
pub const FILE_TYPE_DISK: u32 = 1;
pub const FILE_TYPE_CHAR: u32 = 2;
pub const FILE_TYPE_PIPE: u32 = 3;
pub const FILE_TYPE_REMOTE: u32 = 32768;
pub const NOPARITY: u32 = 0;
pub const ODDPARITY: u32 = 1;
pub const EVENPARITY: u32 = 2;
pub const MARKPARITY: u32 = 3;
pub const SPACEPARITY: u32 = 4;
pub const ONESTOPBIT: u32 = 0;
pub const ONE5STOPBITS: u32 = 1;
pub const TWOSTOPBITS: u32 = 2;
pub const IGNORE: u32 = 0;
pub const INFINITE: u32 = 4294967295;
pub const CBR_110: u32 = 110;
pub const CBR_300: u32 = 300;
pub const CBR_600: u32 = 600;
pub const CBR_1200: u32 = 1200;
pub const CBR_2400: u32 = 2400;
pub const CBR_4800: u32 = 4800;
pub const CBR_9600: u32 = 9600;
pub const CBR_14400: u32 = 14400;
pub const CBR_19200: u32 = 19200;
pub const CBR_38400: u32 = 38400;
pub const CBR_56000: u32 = 56000;
pub const CBR_57600: u32 = 57600;
pub const CBR_115200: u32 = 115200;
pub const CBR_128000: u32 = 128000;
pub const CBR_256000: u32 = 256000;
pub const CE_RXOVER: u32 = 1;
pub const CE_OVERRUN: u32 = 2;
pub const CE_RXPARITY: u32 = 4;
pub const CE_FRAME: u32 = 8;
pub const CE_BREAK: u32 = 16;
pub const CE_TXFULL: u32 = 256;
pub const CE_PTO: u32 = 512;
pub const CE_IOE: u32 = 1024;
pub const CE_DNS: u32 = 2048;
pub const CE_OOP: u32 = 4096;
pub const CE_MODE: u32 = 32768;
pub const IE_BADID: i32 = -1;
pub const IE_OPEN: i32 = -2;
pub const IE_NOPEN: i32 = -3;
pub const IE_MEMORY: i32 = -4;
pub const IE_DEFAULT: i32 = -5;
pub const IE_HARDWARE: i32 = -10;
pub const IE_BYTESIZE: i32 = -11;
pub const IE_BAUDRATE: i32 = -12;
pub const EV_RXCHAR: u32 = 1;
pub const EV_RXFLAG: u32 = 2;
pub const EV_TXEMPTY: u32 = 4;
pub const EV_CTS: u32 = 8;
pub const EV_DSR: u32 = 16;
pub const EV_RLSD: u32 = 32;
pub const EV_BREAK: u32 = 64;
pub const EV_ERR: u32 = 128;
pub const EV_RING: u32 = 256;
pub const EV_PERR: u32 = 512;
pub const EV_RX80FULL: u32 = 1024;
pub const EV_EVENT1: u32 = 2048;
pub const EV_EVENT2: u32 = 4096;
pub const SETXOFF: u32 = 1;
pub const SETXON: u32 = 2;
pub const SETRTS: u32 = 3;
pub const CLRRTS: u32 = 4;
pub const SETDTR: u32 = 5;
pub const CLRDTR: u32 = 6;
pub const RESETDEV: u32 = 7;
pub const SETBREAK: u32 = 8;
pub const CLRBREAK: u32 = 9;
pub const PURGE_TXABORT: u32 = 1;
pub const PURGE_RXABORT: u32 = 2;
pub const PURGE_TXCLEAR: u32 = 4;
pub const PURGE_RXCLEAR: u32 = 8;
pub const LPTx: u32 = 128;
pub const S_QUEUEEMPTY: u32 = 0;
pub const S_THRESHOLD: u32 = 1;
pub const S_ALLTHRESHOLD: u32 = 2;
pub const S_NORMAL: u32 = 0;
pub const S_LEGATO: u32 = 1;
pub const S_STACCATO: u32 = 2;
pub const S_PERIOD512: u32 = 0;
pub const S_PERIOD1024: u32 = 1;
pub const S_PERIOD2048: u32 = 2;
pub const S_PERIODVOICE: u32 = 3;
pub const S_WHITE512: u32 = 4;
pub const S_WHITE1024: u32 = 5;
pub const S_WHITE2048: u32 = 6;
pub const S_WHITEVOICE: u32 = 7;
pub const S_SERDVNA: i32 = -1;
pub const S_SEROFM: i32 = -2;
pub const S_SERMACT: i32 = -3;
pub const S_SERQFUL: i32 = -4;
pub const S_SERBDNT: i32 = -5;
pub const S_SERDLN: i32 = -6;
pub const S_SERDCC: i32 = -7;
pub const S_SERDTP: i32 = -8;
pub const S_SERDVL: i32 = -9;
pub const S_SERDMD: i32 = -10;
pub const S_SERDSH: i32 = -11;
pub const S_SERDPT: i32 = -12;
pub const S_SERDFQ: i32 = -13;
pub const S_SERDDR: i32 = -14;
pub const S_SERDSR: i32 = -15;
pub const S_SERDST: i32 = -16;
pub const NMPWAIT_WAIT_FOREVER: u32 = 4294967295;
pub const NMPWAIT_NOWAIT: u32 = 1;
pub const NMPWAIT_USE_DEFAULT_WAIT: u32 = 0;
pub const FS_CASE_IS_PRESERVED: u32 = 2;
pub const FS_CASE_SENSITIVE: u32 = 1;
pub const FS_UNICODE_STORED_ON_DISK: u32 = 4;
pub const FS_PERSISTENT_ACLS: u32 = 8;
pub const FS_VOL_IS_COMPRESSED: u32 = 32768;
pub const FS_FILE_COMPRESSION: u32 = 16;
pub const FS_FILE_ENCRYPTION: u32 = 131072;
pub const OF_READ: u32 = 0;
pub const OF_WRITE: u32 = 1;
pub const OF_READWRITE: u32 = 2;
pub const OF_SHARE_COMPAT: u32 = 0;
pub const OF_SHARE_EXCLUSIVE: u32 = 16;
pub const OF_SHARE_DENY_WRITE: u32 = 32;
pub const OF_SHARE_DENY_READ: u32 = 48;
pub const OF_SHARE_DENY_NONE: u32 = 64;
pub const OF_PARSE: u32 = 256;
pub const OF_DELETE: u32 = 512;
pub const OF_VERIFY: u32 = 1024;
pub const OF_CANCEL: u32 = 2048;
pub const OF_CREATE: u32 = 4096;
pub const OF_PROMPT: u32 = 8192;
pub const OF_EXIST: u32 = 16384;
pub const OF_REOPEN: u32 = 32768;
pub const OFS_MAXPATHNAME: u32 = 128;
pub const MAXINTATOM: u32 = 49152;
pub const SCS_32BIT_BINARY: u32 = 0;
pub const SCS_DOS_BINARY: u32 = 1;
pub const SCS_WOW_BINARY: u32 = 2;
pub const SCS_PIF_BINARY: u32 = 3;
pub const SCS_POSIX_BINARY: u32 = 4;
pub const SCS_OS216_BINARY: u32 = 5;
pub const SCS_64BIT_BINARY: u32 = 6;
pub const SCS_THIS_PLATFORM_BINARY: u32 = 6;
pub const FIBER_FLAG_FLOAT_SWITCH: u32 = 1;
pub const UMS_VERSION: u32 = 256;
pub const PROCESS_DEP_ENABLE: u32 = 1;
pub const PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION: u32 = 2;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS: u32 = 1;
pub const FILE_SKIP_SET_EVENT_ON_HANDLE: u32 = 2;
pub const SEM_FAILCRITICALERRORS: u32 = 1;
pub const SEM_NOGPFAULTERRORBOX: u32 = 2;
pub const SEM_NOALIGNMENTFAULTEXCEPT: u32 = 4;
pub const SEM_NOOPENFILEERRORBOX: u32 = 32768;
pub const CRITICAL_SECTION_NO_DEBUG_INFO: u32 = 16777216;
pub const HANDLE_FLAG_INHERIT: u32 = 1;
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE: u32 = 2;
pub const HINSTANCE_ERROR: u32 = 32;
pub const GET_TAPE_MEDIA_INFORMATION: u32 = 0;
pub const GET_TAPE_DRIVE_INFORMATION: u32 = 1;
pub const SET_TAPE_MEDIA_INFORMATION: u32 = 0;
pub const SET_TAPE_DRIVE_INFORMATION: u32 = 1;
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER: u32 = 256;
pub const FORMAT_MESSAGE_IGNORE_INSERTS: u32 = 512;
pub const FORMAT_MESSAGE_FROM_STRING: u32 = 1024;
pub const FORMAT_MESSAGE_FROM_HMODULE: u32 = 2048;
pub const FORMAT_MESSAGE_FROM_SYSTEM: u32 = 4096;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY: u32 = 8192;
pub const FORMAT_MESSAGE_MAX_WIDTH_MASK: u32 = 255;
pub const FILE_ENCRYPTABLE: u32 = 0;
pub const FILE_IS_ENCRYPTED: u32 = 1;
pub const FILE_SYSTEM_ATTR: u32 = 2;
pub const FILE_ROOT_DIR: u32 = 3;
pub const FILE_SYSTEM_DIR: u32 = 4;
pub const FILE_UNKNOWN: u32 = 5;
pub const FILE_SYSTEM_NOT_SUPPORT: u32 = 6;
pub const FILE_USER_DISALLOWED: u32 = 7;
pub const FILE_READ_ONLY: u32 = 8;
pub const FILE_DIR_DISALLOWED: u32 = 9;
pub const EFS_USE_RECOVERY_KEYS: u32 = 1;
pub const CREATE_FOR_IMPORT: u32 = 1;
pub const CREATE_FOR_DIR: u32 = 2;
pub const OVERWRITE_HIDDEN: u32 = 4;
pub const EFSRPC_SECURE_ONLY: u32 = 8;
pub const EFS_DROP_ALTERNATE_STREAMS: u32 = 16;
pub const BACKUP_INVALID: u32 = 0;
pub const BACKUP_DATA: u32 = 1;
pub const BACKUP_EA_DATA: u32 = 2;
pub const BACKUP_SECURITY_DATA: u32 = 3;
pub const BACKUP_ALTERNATE_DATA: u32 = 4;
pub const BACKUP_LINK: u32 = 5;
pub const BACKUP_PROPERTY_DATA: u32 = 6;
pub const BACKUP_OBJECT_ID: u32 = 7;
pub const BACKUP_REPARSE_DATA: u32 = 8;
pub const BACKUP_SPARSE_BLOCK: u32 = 9;
pub const BACKUP_TXFS_DATA: u32 = 10;
pub const BACKUP_GHOSTED_FILE_EXTENTS: u32 = 11;
pub const STREAM_NORMAL_ATTRIBUTE: u32 = 0;
pub const STREAM_MODIFIED_WHEN_READ: u32 = 1;
pub const STREAM_CONTAINS_SECURITY: u32 = 2;
pub const STREAM_CONTAINS_PROPERTIES: u32 = 4;
pub const STREAM_SPARSE_ATTRIBUTE: u32 = 8;
pub const STREAM_CONTAINS_GHOSTED_FILE_EXTENTS: u32 = 16;
pub const STARTF_USESHOWWINDOW: u32 = 1;
pub const STARTF_USESIZE: u32 = 2;
pub const STARTF_USEPOSITION: u32 = 4;
pub const STARTF_USECOUNTCHARS: u32 = 8;
pub const STARTF_USEFILLATTRIBUTE: u32 = 16;
pub const STARTF_RUNFULLSCREEN: u32 = 32;
pub const STARTF_FORCEONFEEDBACK: u32 = 64;
pub const STARTF_FORCEOFFFEEDBACK: u32 = 128;
pub const STARTF_USESTDHANDLES: u32 = 256;
pub const STARTF_USEHOTKEY: u32 = 512;
pub const STARTF_TITLEISLINKNAME: u32 = 2048;
pub const STARTF_TITLEISAPPID: u32 = 4096;
pub const STARTF_PREVENTPINNING: u32 = 8192;
pub const STARTF_UNTRUSTEDSOURCE: u32 = 32768;
pub const STARTF_HOLOGRAPHIC: u32 = 262144;
pub const SHUTDOWN_NORETRY: u32 = 1;
pub const PROTECTION_LEVEL_WINTCB_LIGHT: u32 = 0;
pub const PROTECTION_LEVEL_WINDOWS: u32 = 1;
pub const PROTECTION_LEVEL_WINDOWS_LIGHT: u32 = 2;
pub const PROTECTION_LEVEL_ANTIMALWARE_LIGHT: u32 = 3;
pub const PROTECTION_LEVEL_LSA_LIGHT: u32 = 4;
pub const PROTECTION_LEVEL_WINTCB: u32 = 5;
pub const PROTECTION_LEVEL_CODEGEN_LIGHT: u32 = 6;
pub const PROTECTION_LEVEL_AUTHENTICODE: u32 = 7;
pub const PROTECTION_LEVEL_PPL_APP: u32 = 8;
pub const PROTECTION_LEVEL_SAME: u32 = 4294967295;
pub const PROTECTION_LEVEL_NONE: u32 = 4294967294;
pub const PROCESS_NAME_NATIVE: u32 = 1;
pub const PROC_THREAD_ATTRIBUTE_NUMBER: u32 = 65535;
pub const PROC_THREAD_ATTRIBUTE_THREAD: u32 = 65536;
pub const PROC_THREAD_ATTRIBUTE_INPUT: u32 = 131072;
pub const PROC_THREAD_ATTRIBUTE_ADDITIVE: u32 = 262144;
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE: u32 = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE: u32 = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE: u32 = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_MASK: u32 = 768;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON: u32 = 256;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF: u32 = 512;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS: u32 = 768;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_MASK: u32 = 12288;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON: u32 = 4096;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_OFF: u32 = 8192;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_RESERVED: u32 = 12288;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_MASK: u32 = 196608;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON: u32 = 65536;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF: u32 = 131072;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_RESERVED: u32 = 196608;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_MASK: u32 = 3145728;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON: u32 = 1048576;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_OFF: u32 = 2097152;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_RESERVED: u32 = 3145728;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_MASK: u32 = 50331648;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON: u32 = 16777216;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_OFF: u32 = 33554432;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_RESERVED: u32 = 50331648;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_MASK: u32 = 805306368;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_DEFER: u32 = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON: u32 = 268435456;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_OFF: u32 = 536870912;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_RESERVED: u32 = 805306368;
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED: u32 = 1;
pub const PROCESS_CREATION_CHILD_PROCESS_OVERRIDE: u32 = 2;
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED_UNLESS_SECURE: u32 = 4;
pub const PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT: u32 = 1;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_ENABLE_PROCESS_TREE: u32 = 1;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_DISABLE_PROCESS_TREE: u32 = 2;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_OVERRIDE: u32 = 4;
pub const ATOM_FLAG_GLOBAL: u32 = 2;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A: &[u8; 25usize] = b"GetSystemWow64DirectoryA\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W: &[u8; 25usize] = b"GetSystemWow64DirectoryA\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A: &[u8; 25usize] = b"GetSystemWow64DirectoryW\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W: &[u8; 25usize] = b"GetSystemWow64DirectoryW\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A: &[u8; 25usize] = b"GetSystemWow64DirectoryA\0";
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W: &[u8; 25usize] = b"GetSystemWow64DirectoryA\0";
pub const BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE: u32 = 1;
pub const BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE: u32 = 65536;
pub const BASE_SEARCH_PATH_PERMANENT: u32 = 32768;
pub const BASE_SEARCH_PATH_INVALID_FLAGS: i32 = -98306;
pub const DDD_RAW_TARGET_PATH: u32 = 1;
pub const DDD_REMOVE_DEFINITION: u32 = 2;
pub const DDD_EXACT_MATCH_ON_REMOVE: u32 = 4;
pub const DDD_NO_BROADCAST_SYSTEM: u32 = 8;
pub const DDD_LUID_BROADCAST_DRIVE: u32 = 16;
pub const COPYFILE2_MESSAGE_COPY_OFFLOAD: u32 = 1;
pub const COPYFILE2_IO_CYCLE_SIZE_MIN: u32 = 4096;
pub const COPYFILE2_IO_CYCLE_SIZE_MAX: u32 = 1073741824;
pub const COPYFILE2_IO_RATE_MIN: u32 = 512;
pub const COPY_FILE2_V2_DONT_COPY_JUNCTIONS: u32 = 1;
pub const COPY_FILE2_V2_VALID_FLAGS: u32 = 1;
pub const MOVEFILE_REPLACE_EXISTING: u32 = 1;
pub const MOVEFILE_COPY_ALLOWED: u32 = 2;
pub const MOVEFILE_DELAY_UNTIL_REBOOT: u32 = 4;
pub const MOVEFILE_WRITE_THROUGH: u32 = 8;
pub const MOVEFILE_CREATE_HARDLINK: u32 = 16;
pub const MOVEFILE_FAIL_IF_NOT_TRACKABLE: u32 = 32;
pub const EVENTLOG_FULL_INFO: u32 = 0;
pub const OPERATION_API_VERSION: u32 = 1;
pub const OPERATION_START_TRACE_CURRENT_THREAD: u32 = 1;
pub const OPERATION_END_DISCARD: u32 = 1;
pub const MAX_COMPUTERNAME_LENGTH: u32 = 15;
pub const LOGON32_LOGON_INTERACTIVE: u32 = 2;
pub const LOGON32_LOGON_NETWORK: u32 = 3;
pub const LOGON32_LOGON_BATCH: u32 = 4;
pub const LOGON32_LOGON_SERVICE: u32 = 5;
pub const LOGON32_LOGON_UNLOCK: u32 = 7;
pub const LOGON32_LOGON_NETWORK_CLEARTEXT: u32 = 8;
pub const LOGON32_LOGON_NEW_CREDENTIALS: u32 = 9;
pub const LOGON32_PROVIDER_DEFAULT: u32 = 0;
pub const LOGON32_PROVIDER_WINNT35: u32 = 1;
pub const LOGON32_PROVIDER_WINNT40: u32 = 2;
pub const LOGON32_PROVIDER_WINNT50: u32 = 3;
pub const LOGON32_PROVIDER_VIRTUAL: u32 = 4;
pub const LOGON_WITH_PROFILE: u32 = 1;
pub const LOGON_NETCREDENTIALS_ONLY: u32 = 2;
pub const LOGON_ZERO_PASSWORD_BUFFER: u32 = 2147483648;
pub const HW_PROFILE_GUIDLEN: u32 = 39;
pub const MAX_PROFILE_LEN: u32 = 80;
pub const DOCKINFO_UNDOCKED: u32 = 1;
pub const DOCKINFO_DOCKED: u32 = 2;
pub const DOCKINFO_USER_SUPPLIED: u32 = 4;
pub const DOCKINFO_USER_UNDOCKED: u32 = 5;
pub const DOCKINFO_USER_DOCKED: u32 = 6;
pub const FACILITY_NULL: u32 = 0;
pub const FACILITY_RPC: u32 = 1;
pub const FACILITY_DISPATCH: u32 = 2;
pub const FACILITY_STORAGE: u32 = 3;
pub const FACILITY_ITF: u32 = 4;
pub const FACILITY_WIN32: u32 = 7;
pub const FACILITY_WINDOWS: u32 = 8;
pub const FACILITY_SSPI: u32 = 9;
pub const FACILITY_SECURITY: u32 = 9;
pub const FACILITY_CONTROL: u32 = 10;
pub const FACILITY_CERT: u32 = 11;
pub const FACILITY_INTERNET: u32 = 12;
pub const FACILITY_MEDIASERVER: u32 = 13;
pub const FACILITY_MSMQ: u32 = 14;
pub const FACILITY_SETUPAPI: u32 = 15;
pub const FACILITY_SCARD: u32 = 16;
pub const FACILITY_COMPLUS: u32 = 17;
pub const FACILITY_AAF: u32 = 18;
pub const FACILITY_URT: u32 = 19;
pub const FACILITY_ACS: u32 = 20;
pub const FACILITY_DPLAY: u32 = 21;
pub const FACILITY_UMI: u32 = 22;
pub const FACILITY_SXS: u32 = 23;
pub const FACILITY_WINDOWS_CE: u32 = 24;
pub const FACILITY_HTTP: u32 = 25;
pub const FACILITY_USERMODE_COMMONLOG: u32 = 26;
pub const FACILITY_WER: u32 = 27;
pub const FACILITY_USERMODE_FILTER_MANAGER: u32 = 31;
pub const FACILITY_BACKGROUNDCOPY: u32 = 32;
pub const FACILITY_CONFIGURATION: u32 = 33;
pub const FACILITY_WIA: u32 = 33;
pub const FACILITY_STATE_MANAGEMENT: u32 = 34;
pub const FACILITY_METADIRECTORY: u32 = 35;
pub const FACILITY_WINDOWSUPDATE: u32 = 36;
pub const FACILITY_DIRECTORYSERVICE: u32 = 37;
pub const FACILITY_GRAPHICS: u32 = 38;
pub const FACILITY_SHELL: u32 = 39;
pub const FACILITY_NAP: u32 = 39;
pub const FACILITY_TPM_SERVICES: u32 = 40;
pub const FACILITY_TPM_SOFTWARE: u32 = 41;
pub const FACILITY_UI: u32 = 42;
pub const FACILITY_XAML: u32 = 43;
pub const FACILITY_ACTION_QUEUE: u32 = 44;
pub const FACILITY_PLA: u32 = 48;
pub const FACILITY_WINDOWS_SETUP: u32 = 48;
pub const FACILITY_FVE: u32 = 49;
pub const FACILITY_FWP: u32 = 50;
pub const FACILITY_WINRM: u32 = 51;
pub const FACILITY_NDIS: u32 = 52;
pub const FACILITY_USERMODE_HYPERVISOR: u32 = 53;
pub const FACILITY_CMI: u32 = 54;
pub const FACILITY_USERMODE_VIRTUALIZATION: u32 = 55;
pub const FACILITY_USERMODE_VOLMGR: u32 = 56;
pub const FACILITY_BCD: u32 = 57;
pub const FACILITY_USERMODE_VHD: u32 = 58;
pub const FACILITY_USERMODE_HNS: u32 = 59;
pub const FACILITY_SDIAG: u32 = 60;
pub const FACILITY_WEBSERVICES: u32 = 61;
pub const FACILITY_WINPE: u32 = 61;
pub const FACILITY_WPN: u32 = 62;
pub const FACILITY_WINDOWS_STORE: u32 = 63;
pub const FACILITY_INPUT: u32 = 64;
pub const FACILITY_QUIC: u32 = 65;
pub const FACILITY_EAP: u32 = 66;
pub const FACILITY_IORING: u32 = 70;
pub const FACILITY_WINDOWS_DEFENDER: u32 = 80;
pub const FACILITY_OPC: u32 = 81;
pub const FACILITY_XPS: u32 = 82;
pub const FACILITY_MBN: u32 = 84;
pub const FACILITY_POWERSHELL: u32 = 84;
pub const FACILITY_RAS: u32 = 83;
pub const FACILITY_P2P_INT: u32 = 98;
pub const FACILITY_P2P: u32 = 99;
pub const FACILITY_DAF: u32 = 100;
pub const FACILITY_BLUETOOTH_ATT: u32 = 101;
pub const FACILITY_AUDIO: u32 = 102;
pub const FACILITY_STATEREPOSITORY: u32 = 103;
pub const FACILITY_VISUALCPP: u32 = 109;
pub const FACILITY_SCRIPT: u32 = 112;
pub const FACILITY_PARSE: u32 = 113;
pub const FACILITY_BLB: u32 = 120;
pub const FACILITY_BLB_CLI: u32 = 121;
pub const FACILITY_WSBAPP: u32 = 122;
pub const FACILITY_BLBUI: u32 = 128;
pub const FACILITY_USN: u32 = 129;
pub const FACILITY_USERMODE_VOLSNAP: u32 = 130;
pub const FACILITY_TIERING: u32 = 131;
pub const FACILITY_WSB_ONLINE: u32 = 133;
pub const FACILITY_ONLINE_ID: u32 = 134;
pub const FACILITY_DEVICE_UPDATE_AGENT: u32 = 135;
pub const FACILITY_DRVSERVICING: u32 = 136;
pub const FACILITY_DLS: u32 = 153;
pub const FACILITY_DELIVERY_OPTIMIZATION: u32 = 208;
pub const FACILITY_USERMODE_SPACES: u32 = 231;
pub const FACILITY_USER_MODE_SECURITY_CORE: u32 = 232;
pub const FACILITY_USERMODE_LICENSING: u32 = 234;
pub const FACILITY_SOS: u32 = 160;
pub const FACILITY_OCP_UPDATE_AGENT: u32 = 173;
pub const FACILITY_DEBUGGERS: u32 = 176;
pub const FACILITY_SPP: u32 = 256;
pub const FACILITY_RESTORE: u32 = 256;
pub const FACILITY_DMSERVER: u32 = 256;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER: u32 = 257;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING: u32 = 258;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT: u32 = 259;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL: u32 = 260;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC: u32 = 261;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE: u32 = 263;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP: u32 = 264;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT: u32 = 272;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING: u32 = 278;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER: u32 = 289;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT: u32 = 290;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER: u32 = 293;
pub const FACILITY_HSP_SERVICES: u32 = 296;
pub const FACILITY_HSP_SOFTWARE: u32 = 297;
pub const FACILITY_LINGUISTIC_SERVICES: u32 = 305;
pub const FACILITY_AUDIOSTREAMING: u32 = 1094;
pub const FACILITY_TTD: u32 = 1490;
pub const FACILITY_ACCELERATOR: u32 = 1536;
pub const FACILITY_WMAAECMA: u32 = 1996;
pub const FACILITY_DIRECTMUSIC: u32 = 2168;
pub const FACILITY_DIRECT3D10: u32 = 2169;
pub const FACILITY_DXGI: u32 = 2170;
pub const FACILITY_DXGI_DDI: u32 = 2171;
pub const FACILITY_DIRECT3D11: u32 = 2172;
pub const FACILITY_DIRECT3D11_DEBUG: u32 = 2173;
pub const FACILITY_DIRECT3D12: u32 = 2174;
pub const FACILITY_DIRECT3D12_DEBUG: u32 = 2175;
pub const FACILITY_DXCORE: u32 = 2176;
pub const FACILITY_PRESENTATION: u32 = 2177;
pub const FACILITY_LEAP: u32 = 2184;
pub const FACILITY_AUDCLNT: u32 = 2185;
pub const FACILITY_WINCODEC_DWRITE_DWM: u32 = 2200;
pub const FACILITY_WINML: u32 = 2192;
pub const FACILITY_DIRECT2D: u32 = 2201;
pub const FACILITY_DEFRAG: u32 = 2304;
pub const FACILITY_USERMODE_SDBUS: u32 = 2305;
pub const FACILITY_JSCRIPT: u32 = 2306;
pub const FACILITY_PIDGENX: u32 = 2561;
pub const FACILITY_EAS: u32 = 85;
pub const FACILITY_WEB: u32 = 885;
pub const FACILITY_WEB_SOCKET: u32 = 886;
pub const FACILITY_MOBILE: u32 = 1793;
pub const FACILITY_SQLITE: u32 = 1967;
pub const FACILITY_SERVICE_FABRIC: u32 = 1968;
pub const FACILITY_UTC: u32 = 1989;
pub const FACILITY_WEP: u32 = 2049;
pub const FACILITY_SYNCENGINE: u32 = 2050;
pub const FACILITY_XBOX: u32 = 2339;
pub const FACILITY_GAME: u32 = 2340;
pub const FACILITY_PIX: u32 = 2748;
pub const ERROR_SUCCESS: u32 = 0;
pub const NO_ERROR: u32 = 0;
pub const ERROR_INVALID_FUNCTION: u32 = 1;
pub const ERROR_FILE_NOT_FOUND: u32 = 2;
pub const ERROR_PATH_NOT_FOUND: u32 = 3;
pub const ERROR_TOO_MANY_OPEN_FILES: u32 = 4;
pub const ERROR_ACCESS_DENIED: u32 = 5;
pub const ERROR_INVALID_HANDLE: u32 = 6;
pub const ERROR_ARENA_TRASHED: u32 = 7;
pub const ERROR_NOT_ENOUGH_MEMORY: u32 = 8;
pub const ERROR_INVALID_BLOCK: u32 = 9;
pub const ERROR_BAD_ENVIRONMENT: u32 = 10;
pub const ERROR_BAD_FORMAT: u32 = 11;
pub const ERROR_INVALID_ACCESS: u32 = 12;
pub const ERROR_INVALID_DATA: u32 = 13;
pub const ERROR_OUTOFMEMORY: u32 = 14;
pub const ERROR_INVALID_DRIVE: u32 = 15;
pub const ERROR_CURRENT_DIRECTORY: u32 = 16;
pub const ERROR_NOT_SAME_DEVICE: u32 = 17;
pub const ERROR_NO_MORE_FILES: u32 = 18;
pub const ERROR_WRITE_PROTECT: u32 = 19;
pub const ERROR_BAD_UNIT: u32 = 20;
pub const ERROR_NOT_READY: u32 = 21;
pub const ERROR_BAD_COMMAND: u32 = 22;
pub const ERROR_CRC: u32 = 23;
pub const ERROR_BAD_LENGTH: u32 = 24;
pub const ERROR_SEEK: u32 = 25;
pub const ERROR_NOT_DOS_DISK: u32 = 26;
pub const ERROR_SECTOR_NOT_FOUND: u32 = 27;
pub const ERROR_OUT_OF_PAPER: u32 = 28;
pub const ERROR_WRITE_FAULT: u32 = 29;
pub const ERROR_READ_FAULT: u32 = 30;
pub const ERROR_GEN_FAILURE: u32 = 31;
pub const ERROR_SHARING_VIOLATION: u32 = 32;
pub const ERROR_LOCK_VIOLATION: u32 = 33;
pub const ERROR_WRONG_DISK: u32 = 34;
pub const ERROR_SHARING_BUFFER_EXCEEDED: u32 = 36;
pub const ERROR_HANDLE_EOF: u32 = 38;
pub const ERROR_HANDLE_DISK_FULL: u32 = 39;
pub const ERROR_NOT_SUPPORTED: u32 = 50;
pub const ERROR_REM_NOT_LIST: u32 = 51;
pub const ERROR_DUP_NAME: u32 = 52;
pub const ERROR_BAD_NETPATH: u32 = 53;
pub const ERROR_NETWORK_BUSY: u32 = 54;
pub const ERROR_DEV_NOT_EXIST: u32 = 55;
pub const ERROR_TOO_MANY_CMDS: u32 = 56;
pub const ERROR_ADAP_HDW_ERR: u32 = 57;
pub const ERROR_BAD_NET_RESP: u32 = 58;
pub const ERROR_UNEXP_NET_ERR: u32 = 59;
pub const ERROR_BAD_REM_ADAP: u32 = 60;
pub const ERROR_PRINTQ_FULL: u32 = 61;
pub const ERROR_NO_SPOOL_SPACE: u32 = 62;
pub const ERROR_PRINT_CANCELLED: u32 = 63;
pub const ERROR_NETNAME_DELETED: u32 = 64;
pub const ERROR_NETWORK_ACCESS_DENIED: u32 = 65;
pub const ERROR_BAD_DEV_TYPE: u32 = 66;
pub const ERROR_BAD_NET_NAME: u32 = 67;
pub const ERROR_TOO_MANY_NAMES: u32 = 68;
pub const ERROR_TOO_MANY_SESS: u32 = 69;
pub const ERROR_SHARING_PAUSED: u32 = 70;
pub const ERROR_REQ_NOT_ACCEP: u32 = 71;
pub const ERROR_REDIR_PAUSED: u32 = 72;
pub const ERROR_FILE_EXISTS: u32 = 80;
pub const ERROR_CANNOT_MAKE: u32 = 82;
pub const ERROR_FAIL_I24: u32 = 83;
pub const ERROR_OUT_OF_STRUCTURES: u32 = 84;
pub const ERROR_ALREADY_ASSIGNED: u32 = 85;
pub const ERROR_INVALID_PASSWORD: u32 = 86;
pub const ERROR_INVALID_PARAMETER: u32 = 87;
pub const ERROR_NET_WRITE_FAULT: u32 = 88;
pub const ERROR_NO_PROC_SLOTS: u32 = 89;
pub const ERROR_TOO_MANY_SEMAPHORES: u32 = 100;
pub const ERROR_EXCL_SEM_ALREADY_OWNED: u32 = 101;
pub const ERROR_SEM_IS_SET: u32 = 102;
pub const ERROR_TOO_MANY_SEM_REQUESTS: u32 = 103;
pub const ERROR_INVALID_AT_INTERRUPT_TIME: u32 = 104;
pub const ERROR_SEM_OWNER_DIED: u32 = 105;
pub const ERROR_SEM_USER_LIMIT: u32 = 106;
pub const ERROR_DISK_CHANGE: u32 = 107;
pub const ERROR_DRIVE_LOCKED: u32 = 108;
pub const ERROR_BROKEN_PIPE: u32 = 109;
pub const ERROR_OPEN_FAILED: u32 = 110;
pub const ERROR_BUFFER_OVERFLOW: u32 = 111;
pub const ERROR_DISK_FULL: u32 = 112;
pub const ERROR_NO_MORE_SEARCH_HANDLES: u32 = 113;
pub const ERROR_INVALID_TARGET_HANDLE: u32 = 114;
pub const ERROR_INVALID_CATEGORY: u32 = 117;
pub const ERROR_INVALID_VERIFY_SWITCH: u32 = 118;
pub const ERROR_BAD_DRIVER_LEVEL: u32 = 119;
pub const ERROR_CALL_NOT_IMPLEMENTED: u32 = 120;
pub const ERROR_SEM_TIMEOUT: u32 = 121;
pub const ERROR_INSUFFICIENT_BUFFER: u32 = 122;
pub const ERROR_INVALID_NAME: u32 = 123;
pub const ERROR_INVALID_LEVEL: u32 = 124;
pub const ERROR_NO_VOLUME_LABEL: u32 = 125;
pub const ERROR_MOD_NOT_FOUND: u32 = 126;
pub const ERROR_PROC_NOT_FOUND: u32 = 127;
pub const ERROR_WAIT_NO_CHILDREN: u32 = 128;
pub const ERROR_CHILD_NOT_COMPLETE: u32 = 129;
pub const ERROR_DIRECT_ACCESS_HANDLE: u32 = 130;
pub const ERROR_NEGATIVE_SEEK: u32 = 131;
pub const ERROR_SEEK_ON_DEVICE: u32 = 132;
pub const ERROR_IS_JOIN_TARGET: u32 = 133;
pub const ERROR_IS_JOINED: u32 = 134;
pub const ERROR_IS_SUBSTED: u32 = 135;
pub const ERROR_NOT_JOINED: u32 = 136;
pub const ERROR_NOT_SUBSTED: u32 = 137;
pub const ERROR_JOIN_TO_JOIN: u32 = 138;
pub const ERROR_SUBST_TO_SUBST: u32 = 139;
pub const ERROR_JOIN_TO_SUBST: u32 = 140;
pub const ERROR_SUBST_TO_JOIN: u32 = 141;
pub const ERROR_BUSY_DRIVE: u32 = 142;
pub const ERROR_SAME_DRIVE: u32 = 143;
pub const ERROR_DIR_NOT_ROOT: u32 = 144;
pub const ERROR_DIR_NOT_EMPTY: u32 = 145;
pub const ERROR_IS_SUBST_PATH: u32 = 146;
pub const ERROR_IS_JOIN_PATH: u32 = 147;
pub const ERROR_PATH_BUSY: u32 = 148;
pub const ERROR_IS_SUBST_TARGET: u32 = 149;
pub const ERROR_SYSTEM_TRACE: u32 = 150;
pub const ERROR_INVALID_EVENT_COUNT: u32 = 151;
pub const ERROR_TOO_MANY_MUXWAITERS: u32 = 152;
pub const ERROR_INVALID_LIST_FORMAT: u32 = 153;
pub const ERROR_LABEL_TOO_LONG: u32 = 154;
pub const ERROR_TOO_MANY_TCBS: u32 = 155;
pub const ERROR_SIGNAL_REFUSED: u32 = 156;
pub const ERROR_DISCARDED: u32 = 157;
pub const ERROR_NOT_LOCKED: u32 = 158;
pub const ERROR_BAD_THREADID_ADDR: u32 = 159;
pub const ERROR_BAD_ARGUMENTS: u32 = 160;
pub const ERROR_BAD_PATHNAME: u32 = 161;
pub const ERROR_SIGNAL_PENDING: u32 = 162;
pub const ERROR_MAX_THRDS_REACHED: u32 = 164;
pub const ERROR_LOCK_FAILED: u32 = 167;
pub const ERROR_BUSY: u32 = 170;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS: u32 = 171;
pub const ERROR_CANCEL_VIOLATION: u32 = 173;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED: u32 = 174;
pub const ERROR_INVALID_SEGMENT_NUMBER: u32 = 180;
pub const ERROR_INVALID_ORDINAL: u32 = 182;
pub const ERROR_ALREADY_EXISTS: u32 = 183;
pub const ERROR_INVALID_FLAG_NUMBER: u32 = 186;
pub const ERROR_SEM_NOT_FOUND: u32 = 187;
pub const ERROR_INVALID_STARTING_CODESEG: u32 = 188;
pub const ERROR_INVALID_STACKSEG: u32 = 189;
pub const ERROR_INVALID_MODULETYPE: u32 = 190;
pub const ERROR_INVALID_EXE_SIGNATURE: u32 = 191;
pub const ERROR_EXE_MARKED_INVALID: u32 = 192;
pub const ERROR_BAD_EXE_FORMAT: u32 = 193;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k: u32 = 194;
pub const ERROR_INVALID_MINALLOCSIZE: u32 = 195;
pub const ERROR_DYNLINK_FROM_INVALID_RING: u32 = 196;
pub const ERROR_IOPL_NOT_ENABLED: u32 = 197;
pub const ERROR_INVALID_SEGDPL: u32 = 198;
pub const ERROR_AUTODATASEG_EXCEEDS_64k: u32 = 199;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE: u32 = 200;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM: u32 = 201;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN: u32 = 202;
pub const ERROR_ENVVAR_NOT_FOUND: u32 = 203;
pub const ERROR_NO_SIGNAL_SENT: u32 = 205;
pub const ERROR_FILENAME_EXCED_RANGE: u32 = 206;
pub const ERROR_RING2_STACK_IN_USE: u32 = 207;
pub const ERROR_META_EXPANSION_TOO_LONG: u32 = 208;
pub const ERROR_INVALID_SIGNAL_NUMBER: u32 = 209;
pub const ERROR_THREAD_1_INACTIVE: u32 = 210;
pub const ERROR_LOCKED: u32 = 212;
pub const ERROR_TOO_MANY_MODULES: u32 = 214;
pub const ERROR_NESTING_NOT_ALLOWED: u32 = 215;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH: u32 = 216;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY: u32 = 217;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY: u32 = 218;
pub const ERROR_FILE_CHECKED_OUT: u32 = 220;
pub const ERROR_CHECKOUT_REQUIRED: u32 = 221;
pub const ERROR_BAD_FILE_TYPE: u32 = 222;
pub const ERROR_FILE_TOO_LARGE: u32 = 223;
pub const ERROR_FORMS_AUTH_REQUIRED: u32 = 224;
pub const ERROR_VIRUS_INFECTED: u32 = 225;
pub const ERROR_VIRUS_DELETED: u32 = 226;
pub const ERROR_PIPE_LOCAL: u32 = 229;
pub const ERROR_BAD_PIPE: u32 = 230;
pub const ERROR_PIPE_BUSY: u32 = 231;
pub const ERROR_NO_DATA: u32 = 232;
pub const ERROR_PIPE_NOT_CONNECTED: u32 = 233;
pub const ERROR_MORE_DATA: u32 = 234;
pub const ERROR_NO_WORK_DONE: u32 = 235;
pub const ERROR_VC_DISCONNECTED: u32 = 240;
pub const ERROR_INVALID_EA_NAME: u32 = 254;
pub const ERROR_EA_LIST_INCONSISTENT: u32 = 255;
pub const WAIT_TIMEOUT: u32 = 258;
pub const ERROR_NO_MORE_ITEMS: u32 = 259;
pub const ERROR_CANNOT_COPY: u32 = 266;
pub const ERROR_DIRECTORY: u32 = 267;
pub const ERROR_EAS_DIDNT_FIT: u32 = 275;
pub const ERROR_EA_FILE_CORRUPT: u32 = 276;
pub const ERROR_EA_TABLE_FULL: u32 = 277;
pub const ERROR_INVALID_EA_HANDLE: u32 = 278;
pub const ERROR_EAS_NOT_SUPPORTED: u32 = 282;
pub const ERROR_NOT_OWNER: u32 = 288;
pub const ERROR_TOO_MANY_POSTS: u32 = 298;
pub const ERROR_PARTIAL_COPY: u32 = 299;
pub const ERROR_OPLOCK_NOT_GRANTED: u32 = 300;
pub const ERROR_INVALID_OPLOCK_PROTOCOL: u32 = 301;
pub const ERROR_DISK_TOO_FRAGMENTED: u32 = 302;
pub const ERROR_DELETE_PENDING: u32 = 303;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING: u32 = 304;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME: u32 = 305;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT: u32 = 306;
pub const ERROR_INVALID_LOCK_RANGE: u32 = 307;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT: u32 = 308;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED: u32 = 309;
pub const ERROR_INVALID_EXCEPTION_HANDLER: u32 = 310;
pub const ERROR_DUPLICATE_PRIVILEGES: u32 = 311;
pub const ERROR_NO_RANGES_PROCESSED: u32 = 312;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE: u32 = 313;
pub const ERROR_DISK_RESOURCES_EXHAUSTED: u32 = 314;
pub const ERROR_INVALID_TOKEN: u32 = 315;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED: u32 = 316;
pub const ERROR_MR_MID_NOT_FOUND: u32 = 317;
pub const ERROR_SCOPE_NOT_FOUND: u32 = 318;
pub const ERROR_UNDEFINED_SCOPE: u32 = 319;
pub const ERROR_INVALID_CAP: u32 = 320;
pub const ERROR_DEVICE_UNREACHABLE: u32 = 321;
pub const ERROR_DEVICE_NO_RESOURCES: u32 = 322;
pub const ERROR_DATA_CHECKSUM_ERROR: u32 = 323;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION: u32 = 324;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED: u32 = 326;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION: u32 = 327;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST: u32 = 328;
pub const ERROR_OPERATION_IN_PROGRESS: u32 = 329;
pub const ERROR_BAD_DEVICE_PATH: u32 = 330;
pub const ERROR_TOO_MANY_DESCRIPTORS: u32 = 331;
pub const ERROR_SCRUB_DATA_DISABLED: u32 = 332;
pub const ERROR_NOT_REDUNDANT_STORAGE: u32 = 333;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED: u32 = 334;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED: u32 = 335;
pub const ERROR_DIRECTORY_NOT_SUPPORTED: u32 = 336;
pub const ERROR_NOT_READ_FROM_COPY: u32 = 337;
pub const ERROR_FT_WRITE_FAILURE: u32 = 338;
pub const ERROR_FT_DI_SCAN_REQUIRED: u32 = 339;
pub const ERROR_INVALID_KERNEL_INFO_VERSION: u32 = 340;
pub const ERROR_INVALID_PEP_INFO_VERSION: u32 = 341;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED: u32 = 342;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN: u32 = 343;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL: u32 = 344;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH: u32 = 345;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS: u32 = 346;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES: u32 = 347;
pub const ERROR_MARKED_TO_DISALLOW_WRITES: u32 = 348;
pub const ERROR_ENCLAVE_FAILURE: u32 = 349;
pub const ERROR_FAIL_NOACTION_REBOOT: u32 = 350;
pub const ERROR_FAIL_SHUTDOWN: u32 = 351;
pub const ERROR_FAIL_RESTART: u32 = 352;
pub const ERROR_MAX_SESSIONS_REACHED: u32 = 353;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP: u32 = 354;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL: u32 = 355;
pub const ERROR_EDP_POLICY_DENIES_OPERATION: u32 = 356;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED: u32 = 357;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT: u32 = 358;
pub const ERROR_DEVICE_IN_MAINTENANCE: u32 = 359;
pub const ERROR_NOT_SUPPORTED_ON_DAX: u32 = 360;
pub const ERROR_DAX_MAPPING_EXISTS: u32 = 361;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING: u32 = 362;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT: u32 = 363;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE: u32 = 364;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE: u32 = 365;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH: u32 = 366;
pub const ERROR_CHILD_PROCESS_BLOCKED: u32 = 367;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE: u32 = 368;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE: u32 = 369;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT: u32 = 370;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY: u32 = 371;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN: u32 = 372;
pub const ERROR_GDI_HANDLE_LEAK: u32 = 373;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS: u32 = 374;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED: u32 = 375;
pub const ERROR_NOT_A_CLOUD_FILE: u32 = 376;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC: u32 = 377;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED: u32 = 378;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED: u32 = 379;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST: u32 = 380;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME: u32 = 381;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY: u32 = 382;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED: u32 = 383;
pub const ERROR_SMB1_NOT_AVAILABLE: u32 = 384;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION: u32 = 385;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED: u32 = 386;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES: u32 = 387;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE: u32 = 388;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL: u32 = 389;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT: u32 = 390;
pub const ERROR_CLOUD_FILE_IN_USE: u32 = 391;
pub const ERROR_CLOUD_FILE_PINNED: u32 = 392;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED: u32 = 393;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT: u32 = 394;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED: u32 = 395;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS: u32 = 396;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT: u32 = 397;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED: u32 = 398;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED: u32 = 399;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND: u32 = 400;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND: u32 = 401;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND: u32 = 402;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND: u32 = 403;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED: u32 = 404;
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT: u32 = 405;
pub const ERROR_FILE_PROTECTED_UNDER_DPL: u32 = 406;
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED: u32 = 407;
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND: u32 = 408;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED: u32 = 409;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED: u32 = 410;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET: u32 = 411;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE: u32 = 412;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER: u32 = 413;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT: u32 = 414;
pub const ERROR_FT_READ_FAILURE: u32 = 415;
pub const ERROR_STORAGE_RESERVE_ID_INVALID: u32 = 416;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST: u32 = 417;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS: u32 = 418;
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY: u32 = 419;
pub const ERROR_NOT_A_DAX_VOLUME: u32 = 420;
pub const ERROR_NOT_DAX_MAPPABLE: u32 = 421;
pub const ERROR_TIME_SENSITIVE_THREAD: u32 = 422;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER: u32 = 423;
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR: u32 = 424;
pub const ERROR_FILE_NOT_SUPPORTED: u32 = 425;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT: u32 = 426;
pub const ERROR_NO_TASK_QUEUE: u32 = 427;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED: u32 = 428;
pub const ERROR_NOT_SUPPORTED_WITH_BTT: u32 = 429;
pub const ERROR_ENCRYPTION_DISABLED: u32 = 430;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED: u32 = 431;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG: u32 = 432;
pub const ERROR_NO_SUCH_DEVICE: u32 = 433;
pub const ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED: u32 = 434;
pub const ERROR_FILE_SNAP_IN_PROGRESS: u32 = 435;
pub const ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED: u32 = 436;
pub const ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED: u32 = 437;
pub const ERROR_FILE_SNAP_IO_NOT_COORDINATED: u32 = 438;
pub const ERROR_FILE_SNAP_UNEXPECTED_ERROR: u32 = 439;
pub const ERROR_FILE_SNAP_INVALID_PARAMETER: u32 = 440;
pub const ERROR_UNSATISFIED_DEPENDENCIES: u32 = 441;
pub const ERROR_CASE_SENSITIVE_PATH: u32 = 442;
pub const ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR: u32 = 443;
pub const ERROR_LINUX_SUBSYSTEM_UPDATE_REQUIRED: u32 = 444;
pub const ERROR_DLP_POLICY_WARNS_AGAINST_OPERATION: u32 = 445;
pub const ERROR_DLP_POLICY_DENIES_OPERATION: u32 = 446;
pub const ERROR_SECURITY_DENIES_OPERATION: u32 = 447;
pub const ERROR_UNTRUSTED_MOUNT_POINT: u32 = 448;
pub const ERROR_DLP_POLICY_SILENTLY_FAIL: u32 = 449;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED: u32 = 450;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE: u32 = 451;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED: u32 = 452;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED: u32 = 453;
pub const ERROR_CAPAUTHZ_NO_POLICY: u32 = 454;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED: u32 = 455;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG: u32 = 456;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY: u32 = 457;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR: u32 = 458;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED: u32 = 459;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH: u32 = 460;
pub const ERROR_CIMFS_IMAGE_CORRUPT: u32 = 470;
pub const ERROR_CIMFS_IMAGE_VERSION_NOT_SUPPORTED: u32 = 471;
pub const ERROR_STORAGE_STACK_ACCESS_DENIED: u32 = 472;
pub const ERROR_INSUFFICIENT_VIRTUAL_ADDR_RESOURCES: u32 = 473;
pub const ERROR_INDEX_OUT_OF_BOUNDS: u32 = 474;
pub const ERROR_CLOUD_FILE_US_MESSAGE_TIMEOUT: u32 = 475;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT: u32 = 480;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT: u32 = 481;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT: u32 = 482;
pub const ERROR_DEVICE_HARDWARE_ERROR: u32 = 483;
pub const ERROR_INVALID_ADDRESS: u32 = 487;
pub const ERROR_HAS_SYSTEM_CRITICAL_FILES: u32 = 488;
pub const ERROR_ENCRYPTED_FILE_NOT_SUPPORTED: u32 = 489;
pub const ERROR_SPARSE_FILE_NOT_SUPPORTED: u32 = 490;
pub const ERROR_PAGEFILE_NOT_SUPPORTED: u32 = 491;
pub const ERROR_VOLUME_NOT_SUPPORTED: u32 = 492;
pub const ERROR_NOT_SUPPORTED_WITH_BYPASSIO: u32 = 493;
pub const ERROR_NO_BYPASSIO_DRIVER_SUPPORT: u32 = 494;
pub const ERROR_NOT_SUPPORTED_WITH_ENCRYPTION: u32 = 495;
pub const ERROR_NOT_SUPPORTED_WITH_COMPRESSION: u32 = 496;
pub const ERROR_NOT_SUPPORTED_WITH_REPLICATION: u32 = 497;
pub const ERROR_NOT_SUPPORTED_WITH_DEDUPLICATION: u32 = 498;
pub const ERROR_NOT_SUPPORTED_WITH_AUDITING: u32 = 499;
pub const ERROR_USER_PROFILE_LOAD: u32 = 500;
pub const ERROR_SESSION_KEY_TOO_SHORT: u32 = 501;
pub const ERROR_ACCESS_DENIED_APPDATA: u32 = 502;
pub const ERROR_NOT_SUPPORTED_WITH_MONITORING: u32 = 503;
pub const ERROR_NOT_SUPPORTED_WITH_SNAPSHOT: u32 = 504;
pub const ERROR_NOT_SUPPORTED_WITH_VIRTUALIZATION: u32 = 505;
pub const ERROR_BYPASSIO_FLT_NOT_SUPPORTED: u32 = 506;
pub const ERROR_DEVICE_RESET_REQUIRED: u32 = 507;
pub const ERROR_VOLUME_WRITE_ACCESS_DENIED: u32 = 508;
pub const ERROR_NOT_SUPPORTED_WITH_CACHED_HANDLE: u32 = 509;
pub const ERROR_FS_METADATA_INCONSISTENT: u32 = 510;
pub const ERROR_BLOCK_WEAK_REFERENCE_INVALID: u32 = 511;
pub const ERROR_BLOCK_SOURCE_WEAK_REFERENCE_INVALID: u32 = 512;
pub const ERROR_BLOCK_TARGET_WEAK_REFERENCE_INVALID: u32 = 513;
pub const ERROR_BLOCK_SHARED: u32 = 514;
pub const ERROR_ARITHMETIC_OVERFLOW: u32 = 534;
pub const ERROR_PIPE_CONNECTED: u32 = 535;
pub const ERROR_PIPE_LISTENING: u32 = 536;
pub const ERROR_VERIFIER_STOP: u32 = 537;
pub const ERROR_ABIOS_ERROR: u32 = 538;
pub const ERROR_WX86_WARNING: u32 = 539;
pub const ERROR_WX86_ERROR: u32 = 540;
pub const ERROR_TIMER_NOT_CANCELED: u32 = 541;
pub const ERROR_UNWIND: u32 = 542;
pub const ERROR_BAD_STACK: u32 = 543;
pub const ERROR_INVALID_UNWIND_TARGET: u32 = 544;
pub const ERROR_INVALID_PORT_ATTRIBUTES: u32 = 545;
pub const ERROR_PORT_MESSAGE_TOO_LONG: u32 = 546;
pub const ERROR_INVALID_QUOTA_LOWER: u32 = 547;
pub const ERROR_DEVICE_ALREADY_ATTACHED: u32 = 548;
pub const ERROR_INSTRUCTION_MISALIGNMENT: u32 = 549;
pub const ERROR_PROFILING_NOT_STARTED: u32 = 550;
pub const ERROR_PROFILING_NOT_STOPPED: u32 = 551;
pub const ERROR_COULD_NOT_INTERPRET: u32 = 552;
pub const ERROR_PROFILING_AT_LIMIT: u32 = 553;
pub const ERROR_CANT_WAIT: u32 = 554;
pub const ERROR_CANT_TERMINATE_SELF: u32 = 555;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR: u32 = 556;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR: u32 = 557;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR: u32 = 558;
pub const ERROR_BAD_FUNCTION_TABLE: u32 = 559;
pub const ERROR_NO_GUID_TRANSLATION: u32 = 560;
pub const ERROR_INVALID_LDT_SIZE: u32 = 561;
pub const ERROR_INVALID_LDT_OFFSET: u32 = 563;
pub const ERROR_INVALID_LDT_DESCRIPTOR: u32 = 564;
pub const ERROR_TOO_MANY_THREADS: u32 = 565;
pub const ERROR_THREAD_NOT_IN_PROCESS: u32 = 566;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED: u32 = 567;
pub const ERROR_LOGON_SERVER_CONFLICT: u32 = 568;
pub const ERROR_SYNCHRONIZATION_REQUIRED: u32 = 569;
pub const ERROR_NET_OPEN_FAILED: u32 = 570;
pub const ERROR_IO_PRIVILEGE_FAILED: u32 = 571;
pub const ERROR_CONTROL_C_EXIT: u32 = 572;
pub const ERROR_MISSING_SYSTEMFILE: u32 = 573;
pub const ERROR_UNHANDLED_EXCEPTION: u32 = 574;
pub const ERROR_APP_INIT_FAILURE: u32 = 575;
pub const ERROR_PAGEFILE_CREATE_FAILED: u32 = 576;
pub const ERROR_INVALID_IMAGE_HASH: u32 = 577;
pub const ERROR_NO_PAGEFILE: u32 = 578;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT: u32 = 579;
pub const ERROR_NO_EVENT_PAIR: u32 = 580;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR: u32 = 581;
pub const ERROR_ILLEGAL_CHARACTER: u32 = 582;
pub const ERROR_UNDEFINED_CHARACTER: u32 = 583;
pub const ERROR_FLOPPY_VOLUME: u32 = 584;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT: u32 = 585;
pub const ERROR_BACKUP_CONTROLLER: u32 = 586;
pub const ERROR_MUTANT_LIMIT_EXCEEDED: u32 = 587;
pub const ERROR_FS_DRIVER_REQUIRED: u32 = 588;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE: u32 = 589;
pub const ERROR_DEBUG_ATTACH_FAILED: u32 = 590;
pub const ERROR_SYSTEM_PROCESS_TERMINATED: u32 = 591;
pub const ERROR_DATA_NOT_ACCEPTED: u32 = 592;
pub const ERROR_VDM_HARD_ERROR: u32 = 593;
pub const ERROR_DRIVER_CANCEL_TIMEOUT: u32 = 594;
pub const ERROR_REPLY_MESSAGE_MISMATCH: u32 = 595;
pub const ERROR_LOST_WRITEBEHIND_DATA: u32 = 596;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID: u32 = 597;
pub const ERROR_NOT_TINY_STREAM: u32 = 598;
pub const ERROR_STACK_OVERFLOW_READ: u32 = 599;
pub const ERROR_CONVERT_TO_LARGE: u32 = 600;
pub const ERROR_FOUND_OUT_OF_SCOPE: u32 = 601;
pub const ERROR_ALLOCATE_BUCKET: u32 = 602;
pub const ERROR_MARSHALL_OVERFLOW: u32 = 603;
pub const ERROR_INVALID_VARIANT: u32 = 604;
pub const ERROR_BAD_COMPRESSION_BUFFER: u32 = 605;
pub const ERROR_AUDIT_FAILED: u32 = 606;
pub const ERROR_TIMER_RESOLUTION_NOT_SET: u32 = 607;
pub const ERROR_INSUFFICIENT_LOGON_INFO: u32 = 608;
pub const ERROR_BAD_DLL_ENTRYPOINT: u32 = 609;
pub const ERROR_BAD_SERVICE_ENTRYPOINT: u32 = 610;
pub const ERROR_IP_ADDRESS_CONFLICT1: u32 = 611;
pub const ERROR_IP_ADDRESS_CONFLICT2: u32 = 612;
pub const ERROR_REGISTRY_QUOTA_LIMIT: u32 = 613;
pub const ERROR_NO_CALLBACK_ACTIVE: u32 = 614;
pub const ERROR_PWD_TOO_SHORT: u32 = 615;
pub const ERROR_PWD_TOO_RECENT: u32 = 616;
pub const ERROR_PWD_HISTORY_CONFLICT: u32 = 617;
pub const ERROR_UNSUPPORTED_COMPRESSION: u32 = 618;
pub const ERROR_INVALID_HW_PROFILE: u32 = 619;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH: u32 = 620;
pub const ERROR_QUOTA_LIST_INCONSISTENT: u32 = 621;
pub const ERROR_EVALUATION_EXPIRATION: u32 = 622;
pub const ERROR_ILLEGAL_DLL_RELOCATION: u32 = 623;
pub const ERROR_DLL_INIT_FAILED_LOGOFF: u32 = 624;
pub const ERROR_VALIDATE_CONTINUE: u32 = 625;
pub const ERROR_NO_MORE_MATCHES: u32 = 626;
pub const ERROR_RANGE_LIST_CONFLICT: u32 = 627;
pub const ERROR_SERVER_SID_MISMATCH: u32 = 628;
pub const ERROR_CANT_ENABLE_DENY_ONLY: u32 = 629;
pub const ERROR_FLOAT_MULTIPLE_FAULTS: u32 = 630;
pub const ERROR_FLOAT_MULTIPLE_TRAPS: u32 = 631;
pub const ERROR_NOINTERFACE: u32 = 632;
pub const ERROR_DRIVER_FAILED_SLEEP: u32 = 633;
pub const ERROR_CORRUPT_SYSTEM_FILE: u32 = 634;
pub const ERROR_COMMITMENT_MINIMUM: u32 = 635;
pub const ERROR_PNP_RESTART_ENUMERATION: u32 = 636;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE: u32 = 637;
pub const ERROR_PNP_REBOOT_REQUIRED: u32 = 638;
pub const ERROR_INSUFFICIENT_POWER: u32 = 639;
pub const ERROR_MULTIPLE_FAULT_VIOLATION: u32 = 640;
pub const ERROR_SYSTEM_SHUTDOWN: u32 = 641;
pub const ERROR_PORT_NOT_SET: u32 = 642;
pub const ERROR_DS_VERSION_CHECK_FAILURE: u32 = 643;
pub const ERROR_RANGE_NOT_FOUND: u32 = 644;
pub const ERROR_NOT_SAFE_MODE_DRIVER: u32 = 646;
pub const ERROR_FAILED_DRIVER_ENTRY: u32 = 647;
pub const ERROR_DEVICE_ENUMERATION_ERROR: u32 = 648;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED: u32 = 649;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER: u32 = 650;
pub const ERROR_MCA_OCCURED: u32 = 651;
pub const ERROR_DRIVER_DATABASE_ERROR: u32 = 652;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE: u32 = 653;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD: u32 = 654;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE: u32 = 655;
pub const ERROR_HIBERNATION_FAILURE: u32 = 656;
pub const ERROR_PWD_TOO_LONG: u32 = 657;
pub const ERROR_FILE_SYSTEM_LIMITATION: u32 = 665;
pub const ERROR_ASSERTION_FAILURE: u32 = 668;
pub const ERROR_ACPI_ERROR: u32 = 669;
pub const ERROR_WOW_ASSERTION: u32 = 670;
pub const ERROR_PNP_BAD_MPS_TABLE: u32 = 671;
pub const ERROR_PNP_TRANSLATION_FAILED: u32 = 672;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED: u32 = 673;
pub const ERROR_PNP_INVALID_ID: u32 = 674;
pub const ERROR_WAKE_SYSTEM_DEBUGGER: u32 = 675;
pub const ERROR_HANDLES_CLOSED: u32 = 676;
pub const ERROR_EXTRANEOUS_INFORMATION: u32 = 677;
pub const ERROR_RXACT_COMMIT_NECESSARY: u32 = 678;
pub const ERROR_MEDIA_CHECK: u32 = 679;
pub const ERROR_GUID_SUBSTITUTION_MADE: u32 = 680;
pub const ERROR_STOPPED_ON_SYMLINK: u32 = 681;
pub const ERROR_LONGJUMP: u32 = 682;
pub const ERROR_PLUGPLAY_QUERY_VETOED: u32 = 683;
pub const ERROR_UNWIND_CONSOLIDATE: u32 = 684;
pub const ERROR_REGISTRY_HIVE_RECOVERED: u32 = 685;
pub const ERROR_DLL_MIGHT_BE_INSECURE: u32 = 686;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE: u32 = 687;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED: u32 = 688;
pub const ERROR_DBG_REPLY_LATER: u32 = 689;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE: u32 = 690;
pub const ERROR_DBG_TERMINATE_THREAD: u32 = 691;
pub const ERROR_DBG_TERMINATE_PROCESS: u32 = 692;
pub const ERROR_DBG_CONTROL_C: u32 = 693;
pub const ERROR_DBG_PRINTEXCEPTION_C: u32 = 694;
pub const ERROR_DBG_RIPEXCEPTION: u32 = 695;
pub const ERROR_DBG_CONTROL_BREAK: u32 = 696;
pub const ERROR_DBG_COMMAND_EXCEPTION: u32 = 697;
pub const ERROR_OBJECT_NAME_EXISTS: u32 = 698;
pub const ERROR_THREAD_WAS_SUSPENDED: u32 = 699;
pub const ERROR_IMAGE_NOT_AT_BASE: u32 = 700;
pub const ERROR_RXACT_STATE_CREATED: u32 = 701;
pub const ERROR_SEGMENT_NOTIFICATION: u32 = 702;
pub const ERROR_BAD_CURRENT_DIRECTORY: u32 = 703;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP: u32 = 704;
pub const ERROR_FT_WRITE_RECOVERY: u32 = 705;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH: u32 = 706;
pub const ERROR_RECEIVE_PARTIAL: u32 = 707;
pub const ERROR_RECEIVE_EXPEDITED: u32 = 708;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED: u32 = 709;
pub const ERROR_EVENT_DONE: u32 = 710;
pub const ERROR_EVENT_PENDING: u32 = 711;
pub const ERROR_CHECKING_FILE_SYSTEM: u32 = 712;
pub const ERROR_FATAL_APP_EXIT: u32 = 713;
pub const ERROR_PREDEFINED_HANDLE: u32 = 714;
pub const ERROR_WAS_UNLOCKED: u32 = 715;
pub const ERROR_SERVICE_NOTIFICATION: u32 = 716;
pub const ERROR_WAS_LOCKED: u32 = 717;
pub const ERROR_LOG_HARD_ERROR: u32 = 718;
pub const ERROR_ALREADY_WIN32: u32 = 719;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE: u32 = 720;
pub const ERROR_NO_YIELD_PERFORMED: u32 = 721;
pub const ERROR_TIMER_RESUME_IGNORED: u32 = 722;
pub const ERROR_ARBITRATION_UNHANDLED: u32 = 723;
pub const ERROR_CARDBUS_NOT_SUPPORTED: u32 = 724;
pub const ERROR_MP_PROCESSOR_MISMATCH: u32 = 725;
pub const ERROR_HIBERNATED: u32 = 726;
pub const ERROR_RESUME_HIBERNATION: u32 = 727;
pub const ERROR_FIRMWARE_UPDATED: u32 = 728;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES: u32 = 729;
pub const ERROR_WAKE_SYSTEM: u32 = 730;
pub const ERROR_WAIT_1: u32 = 731;
pub const ERROR_WAIT_2: u32 = 732;
pub const ERROR_WAIT_3: u32 = 733;
pub const ERROR_WAIT_63: u32 = 734;
pub const ERROR_ABANDONED_WAIT_0: u32 = 735;
pub const ERROR_ABANDONED_WAIT_63: u32 = 736;
pub const ERROR_USER_APC: u32 = 737;
pub const ERROR_KERNEL_APC: u32 = 738;
pub const ERROR_ALERTED: u32 = 739;
pub const ERROR_ELEVATION_REQUIRED: u32 = 740;
pub const ERROR_REPARSE: u32 = 741;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS: u32 = 742;
pub const ERROR_VOLUME_MOUNTED: u32 = 743;
pub const ERROR_RXACT_COMMITTED: u32 = 744;
pub const ERROR_NOTIFY_CLEANUP: u32 = 745;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED: u32 = 746;
pub const ERROR_PAGE_FAULT_TRANSITION: u32 = 747;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO: u32 = 748;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE: u32 = 749;
pub const ERROR_PAGE_FAULT_GUARD_PAGE: u32 = 750;
pub const ERROR_PAGE_FAULT_PAGING_FILE: u32 = 751;
pub const ERROR_CACHE_PAGE_LOCKED: u32 = 752;
pub const ERROR_CRASH_DUMP: u32 = 753;
pub const ERROR_BUFFER_ALL_ZEROS: u32 = 754;
pub const ERROR_REPARSE_OBJECT: u32 = 755;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED: u32 = 756;
pub const ERROR_TRANSLATION_COMPLETE: u32 = 757;
pub const ERROR_NOTHING_TO_TERMINATE: u32 = 758;
pub const ERROR_PROCESS_NOT_IN_JOB: u32 = 759;
pub const ERROR_PROCESS_IN_JOB: u32 = 760;
pub const ERROR_VOLSNAP_HIBERNATE_READY: u32 = 761;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY: u32 = 762;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED: u32 = 763;
pub const ERROR_INTERRUPT_STILL_CONNECTED: u32 = 764;
pub const ERROR_WAIT_FOR_OPLOCK: u32 = 765;
pub const ERROR_DBG_EXCEPTION_HANDLED: u32 = 766;
pub const ERROR_DBG_CONTINUE: u32 = 767;
pub const ERROR_CALLBACK_POP_STACK: u32 = 768;
pub const ERROR_COMPRESSION_DISABLED: u32 = 769;
pub const ERROR_CANTFETCHBACKWARDS: u32 = 770;
pub const ERROR_CANTSCROLLBACKWARDS: u32 = 771;
pub const ERROR_ROWSNOTRELEASED: u32 = 772;
pub const ERROR_BAD_ACCESSOR_FLAGS: u32 = 773;
pub const ERROR_ERRORS_ENCOUNTERED: u32 = 774;
pub const ERROR_NOT_CAPABLE: u32 = 775;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE: u32 = 776;
pub const ERROR_VERSION_PARSE_ERROR: u32 = 777;
pub const ERROR_BADSTARTPOSITION: u32 = 778;
pub const ERROR_MEMORY_HARDWARE: u32 = 779;
pub const ERROR_DISK_REPAIR_DISABLED: u32 = 780;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE: u32 = 781;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION: u32 = 782;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION: u32 = 783;
pub const ERROR_MCA_EXCEPTION: u32 = 784;
pub const ERROR_ACCESS_AUDIT_BY_POLICY: u32 = 785;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY: u32 = 786;
pub const ERROR_ABANDON_HIBERFILE: u32 = 787;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED: u32 = 788;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR: u32 = 789;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR: u32 = 790;
pub const ERROR_BAD_MCFG_TABLE: u32 = 791;
pub const ERROR_DISK_REPAIR_REDIRECTED: u32 = 792;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL: u32 = 793;
pub const ERROR_CORRUPT_LOG_OVERFULL: u32 = 794;
pub const ERROR_CORRUPT_LOG_CORRUPTED: u32 = 795;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE: u32 = 796;
pub const ERROR_CORRUPT_LOG_DELETED_FULL: u32 = 797;
pub const ERROR_CORRUPT_LOG_CLEARED: u32 = 798;
pub const ERROR_ORPHAN_NAME_EXHAUSTED: u32 = 799;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE: u32 = 800;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK: u32 = 801;
pub const ERROR_CANNOT_BREAK_OPLOCK: u32 = 802;
pub const ERROR_OPLOCK_HANDLE_CLOSED: u32 = 803;
pub const ERROR_NO_ACE_CONDITION: u32 = 804;
pub const ERROR_INVALID_ACE_CONDITION: u32 = 805;
pub const ERROR_FILE_HANDLE_REVOKED: u32 = 806;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE: u32 = 807;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE: u32 = 808;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS: u32 = 809;
pub const ERROR_QUOTA_ACTIVITY: u32 = 810;
pub const ERROR_HANDLE_REVOKED: u32 = 811;
pub const ERROR_CALLBACK_INVOKE_INLINE: u32 = 812;
pub const ERROR_CPU_SET_INVALID: u32 = 813;
pub const ERROR_ENCLAVE_NOT_TERMINATED: u32 = 814;
pub const ERROR_ENCLAVE_VIOLATION: u32 = 815;
pub const ERROR_SERVER_TRANSPORT_CONFLICT: u32 = 816;
pub const ERROR_CERTIFICATE_VALIDATION_PREFERENCE_CONFLICT: u32 = 817;
pub const ERROR_FT_READ_FROM_COPY_FAILURE: u32 = 818;
pub const ERROR_SECTION_DIRECT_MAP_ONLY: u32 = 819;
pub const ERROR_EA_ACCESS_DENIED: u32 = 994;
pub const ERROR_OPERATION_ABORTED: u32 = 995;
pub const ERROR_IO_INCOMPLETE: u32 = 996;
pub const ERROR_IO_PENDING: u32 = 997;
pub const ERROR_NOACCESS: u32 = 998;
pub const ERROR_SWAPERROR: u32 = 999;
pub const ERROR_STACK_OVERFLOW: u32 = 1001;
pub const ERROR_INVALID_MESSAGE: u32 = 1002;
pub const ERROR_CAN_NOT_COMPLETE: u32 = 1003;
pub const ERROR_INVALID_FLAGS: u32 = 1004;
pub const ERROR_UNRECOGNIZED_VOLUME: u32 = 1005;
pub const ERROR_FILE_INVALID: u32 = 1006;
pub const ERROR_FULLSCREEN_MODE: u32 = 1007;
pub const ERROR_NO_TOKEN: u32 = 1008;
pub const ERROR_BADDB: u32 = 1009;
pub const ERROR_BADKEY: u32 = 1010;
pub const ERROR_CANTOPEN: u32 = 1011;
pub const ERROR_CANTREAD: u32 = 1012;
pub const ERROR_CANTWRITE: u32 = 1013;
pub const ERROR_REGISTRY_RECOVERED: u32 = 1014;
pub const ERROR_REGISTRY_CORRUPT: u32 = 1015;
pub const ERROR_REGISTRY_IO_FAILED: u32 = 1016;
pub const ERROR_NOT_REGISTRY_FILE: u32 = 1017;
pub const ERROR_KEY_DELETED: u32 = 1018;
pub const ERROR_NO_LOG_SPACE: u32 = 1019;
pub const ERROR_KEY_HAS_CHILDREN: u32 = 1020;
pub const ERROR_CHILD_MUST_BE_VOLATILE: u32 = 1021;
pub const ERROR_NOTIFY_ENUM_DIR: u32 = 1022;
pub const ERROR_DEPENDENT_SERVICES_RUNNING: u32 = 1051;
pub const ERROR_INVALID_SERVICE_CONTROL: u32 = 1052;
pub const ERROR_SERVICE_REQUEST_TIMEOUT: u32 = 1053;
pub const ERROR_SERVICE_NO_THREAD: u32 = 1054;
pub const ERROR_SERVICE_DATABASE_LOCKED: u32 = 1055;
pub const ERROR_SERVICE_ALREADY_RUNNING: u32 = 1056;
pub const ERROR_INVALID_SERVICE_ACCOUNT: u32 = 1057;
pub const ERROR_SERVICE_DISABLED: u32 = 1058;
pub const ERROR_CIRCULAR_DEPENDENCY: u32 = 1059;
pub const ERROR_SERVICE_DOES_NOT_EXIST: u32 = 1060;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL: u32 = 1061;
pub const ERROR_SERVICE_NOT_ACTIVE: u32 = 1062;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: u32 = 1063;
pub const ERROR_EXCEPTION_IN_SERVICE: u32 = 1064;
pub const ERROR_DATABASE_DOES_NOT_EXIST: u32 = 1065;
pub const ERROR_SERVICE_SPECIFIC_ERROR: u32 = 1066;
pub const ERROR_PROCESS_ABORTED: u32 = 1067;
pub const ERROR_SERVICE_DEPENDENCY_FAIL: u32 = 1068;
pub const ERROR_SERVICE_LOGON_FAILED: u32 = 1069;
pub const ERROR_SERVICE_START_HANG: u32 = 1070;
pub const ERROR_INVALID_SERVICE_LOCK: u32 = 1071;
pub const ERROR_SERVICE_MARKED_FOR_DELETE: u32 = 1072;
pub const ERROR_SERVICE_EXISTS: u32 = 1073;
pub const ERROR_ALREADY_RUNNING_LKG: u32 = 1074;
pub const ERROR_SERVICE_DEPENDENCY_DELETED: u32 = 1075;
pub const ERROR_BOOT_ALREADY_ACCEPTED: u32 = 1076;
pub const ERROR_SERVICE_NEVER_STARTED: u32 = 1077;
pub const ERROR_DUPLICATE_SERVICE_NAME: u32 = 1078;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT: u32 = 1079;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE: u32 = 1080;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT: u32 = 1081;
pub const ERROR_NO_RECOVERY_PROGRAM: u32 = 1082;
pub const ERROR_SERVICE_NOT_IN_EXE: u32 = 1083;
pub const ERROR_NOT_SAFEBOOT_SERVICE: u32 = 1084;
pub const ERROR_END_OF_MEDIA: u32 = 1100;
pub const ERROR_FILEMARK_DETECTED: u32 = 1101;
pub const ERROR_BEGINNING_OF_MEDIA: u32 = 1102;
pub const ERROR_SETMARK_DETECTED: u32 = 1103;
pub const ERROR_NO_DATA_DETECTED: u32 = 1104;
pub const ERROR_PARTITION_FAILURE: u32 = 1105;
pub const ERROR_INVALID_BLOCK_LENGTH: u32 = 1106;
pub const ERROR_DEVICE_NOT_PARTITIONED: u32 = 1107;
pub const ERROR_UNABLE_TO_LOCK_MEDIA: u32 = 1108;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA: u32 = 1109;
pub const ERROR_MEDIA_CHANGED: u32 = 1110;
pub const ERROR_BUS_RESET: u32 = 1111;
pub const ERROR_NO_MEDIA_IN_DRIVE: u32 = 1112;
pub const ERROR_NO_UNICODE_TRANSLATION: u32 = 1113;
pub const ERROR_DLL_INIT_FAILED: u32 = 1114;
pub const ERROR_SHUTDOWN_IN_PROGRESS: u32 = 1115;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS: u32 = 1116;
pub const ERROR_IO_DEVICE: u32 = 1117;
pub const ERROR_SERIAL_NO_DEVICE: u32 = 1118;
pub const ERROR_IRQ_BUSY: u32 = 1119;
pub const ERROR_MORE_WRITES: u32 = 1120;
pub const ERROR_COUNTER_TIMEOUT: u32 = 1121;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND: u32 = 1122;
pub const ERROR_FLOPPY_WRONG_CYLINDER: u32 = 1123;
pub const ERROR_FLOPPY_UNKNOWN_ERROR: u32 = 1124;
pub const ERROR_FLOPPY_BAD_REGISTERS: u32 = 1125;
pub const ERROR_DISK_RECALIBRATE_FAILED: u32 = 1126;
pub const ERROR_DISK_OPERATION_FAILED: u32 = 1127;
pub const ERROR_DISK_RESET_FAILED: u32 = 1128;
pub const ERROR_EOM_OVERFLOW: u32 = 1129;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY: u32 = 1130;
pub const ERROR_POSSIBLE_DEADLOCK: u32 = 1131;
pub const ERROR_MAPPED_ALIGNMENT: u32 = 1132;
pub const ERROR_SET_POWER_STATE_VETOED: u32 = 1140;
pub const ERROR_SET_POWER_STATE_FAILED: u32 = 1141;
pub const ERROR_TOO_MANY_LINKS: u32 = 1142;
pub const ERROR_OLD_WIN_VERSION: u32 = 1150;
pub const ERROR_APP_WRONG_OS: u32 = 1151;
pub const ERROR_SINGLE_INSTANCE_APP: u32 = 1152;
pub const ERROR_RMODE_APP: u32 = 1153;
pub const ERROR_INVALID_DLL: u32 = 1154;
pub const ERROR_NO_ASSOCIATION: u32 = 1155;
pub const ERROR_DDE_FAIL: u32 = 1156;
pub const ERROR_DLL_NOT_FOUND: u32 = 1157;
pub const ERROR_NO_MORE_USER_HANDLES: u32 = 1158;
pub const ERROR_MESSAGE_SYNC_ONLY: u32 = 1159;
pub const ERROR_SOURCE_ELEMENT_EMPTY: u32 = 1160;
pub const ERROR_DESTINATION_ELEMENT_FULL: u32 = 1161;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS: u32 = 1162;
pub const ERROR_MAGAZINE_NOT_PRESENT: u32 = 1163;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED: u32 = 1164;
pub const ERROR_DEVICE_REQUIRES_CLEANING: u32 = 1165;
pub const ERROR_DEVICE_DOOR_OPEN: u32 = 1166;
pub const ERROR_DEVICE_NOT_CONNECTED: u32 = 1167;
pub const ERROR_NOT_FOUND: u32 = 1168;
pub const ERROR_NO_MATCH: u32 = 1169;
pub const ERROR_SET_NOT_FOUND: u32 = 1170;
pub const ERROR_POINT_NOT_FOUND: u32 = 1171;
pub const ERROR_NO_TRACKING_SERVICE: u32 = 1172;
pub const ERROR_NO_VOLUME_ID: u32 = 1173;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED: u32 = 1175;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT: u32 = 1176;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2: u32 = 1177;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS: u32 = 1178;
pub const ERROR_JOURNAL_NOT_ACTIVE: u32 = 1179;
pub const ERROR_POTENTIAL_FILE_FOUND: u32 = 1180;
pub const ERROR_JOURNAL_ENTRY_DELETED: u32 = 1181;
pub const ERROR_PARTITION_TERMINATING: u32 = 1184;
pub const ERROR_SHUTDOWN_IS_SCHEDULED: u32 = 1190;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON: u32 = 1191;
pub const ERROR_SHUTDOWN_DISKS_NOT_IN_MAINTENANCE_MODE: u32 = 1192;
pub const ERROR_BAD_DEVICE: u32 = 1200;
pub const ERROR_CONNECTION_UNAVAIL: u32 = 1201;
pub const ERROR_DEVICE_ALREADY_REMEMBERED: u32 = 1202;
pub const ERROR_NO_NET_OR_BAD_PATH: u32 = 1203;
pub const ERROR_BAD_PROVIDER: u32 = 1204;
pub const ERROR_CANNOT_OPEN_PROFILE: u32 = 1205;
pub const ERROR_BAD_PROFILE: u32 = 1206;
pub const ERROR_NOT_CONTAINER: u32 = 1207;
pub const ERROR_EXTENDED_ERROR: u32 = 1208;
pub const ERROR_INVALID_GROUPNAME: u32 = 1209;
pub const ERROR_INVALID_COMPUTERNAME: u32 = 1210;
pub const ERROR_INVALID_EVENTNAME: u32 = 1211;
pub const ERROR_INVALID_DOMAINNAME: u32 = 1212;
pub const ERROR_INVALID_SERVICENAME: u32 = 1213;
pub const ERROR_INVALID_NETNAME: u32 = 1214;
pub const ERROR_INVALID_SHARENAME: u32 = 1215;
pub const ERROR_INVALID_PASSWORDNAME: u32 = 1216;
pub const ERROR_INVALID_MESSAGENAME: u32 = 1217;
pub const ERROR_INVALID_MESSAGEDEST: u32 = 1218;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT: u32 = 1219;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED: u32 = 1220;
pub const ERROR_DUP_DOMAINNAME: u32 = 1221;
pub const ERROR_NO_NETWORK: u32 = 1222;
pub const ERROR_CANCELLED: u32 = 1223;
pub const ERROR_USER_MAPPED_FILE: u32 = 1224;
pub const ERROR_CONNECTION_REFUSED: u32 = 1225;
pub const ERROR_GRACEFUL_DISCONNECT: u32 = 1226;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED: u32 = 1227;
pub const ERROR_ADDRESS_NOT_ASSOCIATED: u32 = 1228;
pub const ERROR_CONNECTION_INVALID: u32 = 1229;
pub const ERROR_CONNECTION_ACTIVE: u32 = 1230;
pub const ERROR_NETWORK_UNREACHABLE: u32 = 1231;
pub const ERROR_HOST_UNREACHABLE: u32 = 1232;
pub const ERROR_PROTOCOL_UNREACHABLE: u32 = 1233;
pub const ERROR_PORT_UNREACHABLE: u32 = 1234;
pub const ERROR_REQUEST_ABORTED: u32 = 1235;
pub const ERROR_CONNECTION_ABORTED: u32 = 1236;
pub const ERROR_RETRY: u32 = 1237;
pub const ERROR_CONNECTION_COUNT_LIMIT: u32 = 1238;
pub const ERROR_LOGIN_TIME_RESTRICTION: u32 = 1239;
pub const ERROR_LOGIN_WKSTA_RESTRICTION: u32 = 1240;
pub const ERROR_INCORRECT_ADDRESS: u32 = 1241;
pub const ERROR_ALREADY_REGISTERED: u32 = 1242;
pub const ERROR_SERVICE_NOT_FOUND: u32 = 1243;
pub const ERROR_NOT_AUTHENTICATED: u32 = 1244;
pub const ERROR_NOT_LOGGED_ON: u32 = 1245;
pub const ERROR_CONTINUE: u32 = 1246;
pub const ERROR_ALREADY_INITIALIZED: u32 = 1247;
pub const ERROR_NO_MORE_DEVICES: u32 = 1248;
pub const ERROR_NO_SUCH_SITE: u32 = 1249;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS: u32 = 1250;
pub const ERROR_ONLY_IF_CONNECTED: u32 = 1251;
pub const ERROR_OVERRIDE_NOCHANGES: u32 = 1252;
pub const ERROR_BAD_USER_PROFILE: u32 = 1253;
pub const ERROR_NOT_SUPPORTED_ON_SBS: u32 = 1254;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS: u32 = 1255;
pub const ERROR_HOST_DOWN: u32 = 1256;
pub const ERROR_NON_ACCOUNT_SID: u32 = 1257;
pub const ERROR_NON_DOMAIN_SID: u32 = 1258;
pub const ERROR_APPHELP_BLOCK: u32 = 1259;
pub const ERROR_ACCESS_DISABLED_BY_POLICY: u32 = 1260;
pub const ERROR_REG_NAT_CONSUMPTION: u32 = 1261;
pub const ERROR_CSCSHARE_OFFLINE: u32 = 1262;
pub const ERROR_PKINIT_FAILURE: u32 = 1263;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE: u32 = 1264;
pub const ERROR_DOWNGRADE_DETECTED: u32 = 1265;
pub const ERROR_MACHINE_LOCKED: u32 = 1271;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED: u32 = 1272;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA: u32 = 1273;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED: u32 = 1274;
pub const ERROR_DRIVER_BLOCKED: u32 = 1275;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL: u32 = 1276;
pub const ERROR_ACCESS_DISABLED_WEBBLADE: u32 = 1277;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER: u32 = 1278;
pub const ERROR_RECOVERY_FAILURE: u32 = 1279;
pub const ERROR_ALREADY_FIBER: u32 = 1280;
pub const ERROR_ALREADY_THREAD: u32 = 1281;
pub const ERROR_STACK_BUFFER_OVERRUN: u32 = 1282;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED: u32 = 1283;
pub const ERROR_DEBUGGER_INACTIVE: u32 = 1284;
pub const ERROR_DELAY_LOAD_FAILED: u32 = 1285;
pub const ERROR_VDM_DISALLOWED: u32 = 1286;
pub const ERROR_UNIDENTIFIED_ERROR: u32 = 1287;
pub const ERROR_INVALID_CRUNTIME_PARAMETER: u32 = 1288;
pub const ERROR_BEYOND_VDL: u32 = 1289;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE: u32 = 1290;
pub const ERROR_DRIVER_PROCESS_TERMINATED: u32 = 1291;
pub const ERROR_IMPLEMENTATION_LIMIT: u32 = 1292;
pub const ERROR_PROCESS_IS_PROTECTED: u32 = 1293;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING: u32 = 1294;
pub const ERROR_DISK_QUOTA_EXCEEDED: u32 = 1295;
pub const ERROR_CONTENT_BLOCKED: u32 = 1296;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE: u32 = 1297;
pub const ERROR_APP_HANG: u32 = 1298;
pub const ERROR_INVALID_LABEL: u32 = 1299;
pub const ERROR_NOT_ALL_ASSIGNED: u32 = 1300;
pub const ERROR_SOME_NOT_MAPPED: u32 = 1301;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT: u32 = 1302;
pub const ERROR_LOCAL_USER_SESSION_KEY: u32 = 1303;
pub const ERROR_NULL_LM_PASSWORD: u32 = 1304;
pub const ERROR_UNKNOWN_REVISION: u32 = 1305;
pub const ERROR_REVISION_MISMATCH: u32 = 1306;
pub const ERROR_INVALID_OWNER: u32 = 1307;
pub const ERROR_INVALID_PRIMARY_GROUP: u32 = 1308;
pub const ERROR_NO_IMPERSONATION_TOKEN: u32 = 1309;
pub const ERROR_CANT_DISABLE_MANDATORY: u32 = 1310;
pub const ERROR_NO_LOGON_SERVERS: u32 = 1311;
pub const ERROR_NO_SUCH_LOGON_SESSION: u32 = 1312;
pub const ERROR_NO_SUCH_PRIVILEGE: u32 = 1313;
pub const ERROR_PRIVILEGE_NOT_HELD: u32 = 1314;
pub const ERROR_INVALID_ACCOUNT_NAME: u32 = 1315;
pub const ERROR_USER_EXISTS: u32 = 1316;
pub const ERROR_NO_SUCH_USER: u32 = 1317;
pub const ERROR_GROUP_EXISTS: u32 = 1318;
pub const ERROR_NO_SUCH_GROUP: u32 = 1319;
pub const ERROR_MEMBER_IN_GROUP: u32 = 1320;
pub const ERROR_MEMBER_NOT_IN_GROUP: u32 = 1321;
pub const ERROR_LAST_ADMIN: u32 = 1322;
pub const ERROR_WRONG_PASSWORD: u32 = 1323;
pub const ERROR_ILL_FORMED_PASSWORD: u32 = 1324;
pub const ERROR_PASSWORD_RESTRICTION: u32 = 1325;
pub const ERROR_LOGON_FAILURE: u32 = 1326;
pub const ERROR_ACCOUNT_RESTRICTION: u32 = 1327;
pub const ERROR_INVALID_LOGON_HOURS: u32 = 1328;
pub const ERROR_INVALID_WORKSTATION: u32 = 1329;
pub const ERROR_PASSWORD_EXPIRED: u32 = 1330;
pub const ERROR_ACCOUNT_DISABLED: u32 = 1331;
pub const ERROR_NONE_MAPPED: u32 = 1332;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED: u32 = 1333;
pub const ERROR_LUIDS_EXHAUSTED: u32 = 1334;
pub const ERROR_INVALID_SUB_AUTHORITY: u32 = 1335;
pub const ERROR_INVALID_ACL: u32 = 1336;
pub const ERROR_INVALID_SID: u32 = 1337;
pub const ERROR_INVALID_SECURITY_DESCR: u32 = 1338;
pub const ERROR_BAD_INHERITANCE_ACL: u32 = 1340;
pub const ERROR_SERVER_DISABLED: u32 = 1341;
pub const ERROR_SERVER_NOT_DISABLED: u32 = 1342;
pub const ERROR_INVALID_ID_AUTHORITY: u32 = 1343;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED: u32 = 1344;
pub const ERROR_INVALID_GROUP_ATTRIBUTES: u32 = 1345;
pub const ERROR_BAD_IMPERSONATION_LEVEL: u32 = 1346;
pub const ERROR_CANT_OPEN_ANONYMOUS: u32 = 1347;
pub const ERROR_BAD_VALIDATION_CLASS: u32 = 1348;
pub const ERROR_BAD_TOKEN_TYPE: u32 = 1349;
pub const ERROR_NO_SECURITY_ON_OBJECT: u32 = 1350;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO: u32 = 1351;
pub const ERROR_INVALID_SERVER_STATE: u32 = 1352;
pub const ERROR_INVALID_DOMAIN_STATE: u32 = 1353;
pub const ERROR_INVALID_DOMAIN_ROLE: u32 = 1354;
pub const ERROR_NO_SUCH_DOMAIN: u32 = 1355;
pub const ERROR_DOMAIN_EXISTS: u32 = 1356;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED: u32 = 1357;
pub const ERROR_INTERNAL_DB_CORRUPTION: u32 = 1358;
pub const ERROR_INTERNAL_ERROR: u32 = 1359;
pub const ERROR_GENERIC_NOT_MAPPED: u32 = 1360;
pub const ERROR_BAD_DESCRIPTOR_FORMAT: u32 = 1361;
pub const ERROR_NOT_LOGON_PROCESS: u32 = 1362;
pub const ERROR_LOGON_SESSION_EXISTS: u32 = 1363;
pub const ERROR_NO_SUCH_PACKAGE: u32 = 1364;
pub const ERROR_BAD_LOGON_SESSION_STATE: u32 = 1365;
pub const ERROR_LOGON_SESSION_COLLISION: u32 = 1366;
pub const ERROR_INVALID_LOGON_TYPE: u32 = 1367;
pub const ERROR_CANNOT_IMPERSONATE: u32 = 1368;
pub const ERROR_RXACT_INVALID_STATE: u32 = 1369;
pub const ERROR_RXACT_COMMIT_FAILURE: u32 = 1370;
pub const ERROR_SPECIAL_ACCOUNT: u32 = 1371;
pub const ERROR_SPECIAL_GROUP: u32 = 1372;
pub const ERROR_SPECIAL_USER: u32 = 1373;
pub const ERROR_MEMBERS_PRIMARY_GROUP: u32 = 1374;
pub const ERROR_TOKEN_ALREADY_IN_USE: u32 = 1375;
pub const ERROR_NO_SUCH_ALIAS: u32 = 1376;
pub const ERROR_MEMBER_NOT_IN_ALIAS: u32 = 1377;
pub const ERROR_MEMBER_IN_ALIAS: u32 = 1378;
pub const ERROR_ALIAS_EXISTS: u32 = 1379;
pub const ERROR_LOGON_NOT_GRANTED: u32 = 1380;
pub const ERROR_TOO_MANY_SECRETS: u32 = 1381;
pub const ERROR_SECRET_TOO_LONG: u32 = 1382;
pub const ERROR_INTERNAL_DB_ERROR: u32 = 1383;
pub const ERROR_TOO_MANY_CONTEXT_IDS: u32 = 1384;
pub const ERROR_LOGON_TYPE_NOT_GRANTED: u32 = 1385;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED: u32 = 1386;
pub const ERROR_NO_SUCH_MEMBER: u32 = 1387;
pub const ERROR_INVALID_MEMBER: u32 = 1388;
pub const ERROR_TOO_MANY_SIDS: u32 = 1389;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED: u32 = 1390;
pub const ERROR_NO_INHERITANCE: u32 = 1391;
pub const ERROR_FILE_CORRUPT: u32 = 1392;
pub const ERROR_DISK_CORRUPT: u32 = 1393;
pub const ERROR_NO_USER_SESSION_KEY: u32 = 1394;
pub const ERROR_LICENSE_QUOTA_EXCEEDED: u32 = 1395;
pub const ERROR_WRONG_TARGET_NAME: u32 = 1396;
pub const ERROR_MUTUAL_AUTH_FAILED: u32 = 1397;
pub const ERROR_TIME_SKEW: u32 = 1398;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED: u32 = 1399;
pub const ERROR_INVALID_WINDOW_HANDLE: u32 = 1400;
pub const ERROR_INVALID_MENU_HANDLE: u32 = 1401;
pub const ERROR_INVALID_CURSOR_HANDLE: u32 = 1402;
pub const ERROR_INVALID_ACCEL_HANDLE: u32 = 1403;
pub const ERROR_INVALID_HOOK_HANDLE: u32 = 1404;
pub const ERROR_INVALID_DWP_HANDLE: u32 = 1405;
pub const ERROR_TLW_WITH_WSCHILD: u32 = 1406;
pub const ERROR_CANNOT_FIND_WND_CLASS: u32 = 1407;
pub const ERROR_WINDOW_OF_OTHER_THREAD: u32 = 1408;
pub const ERROR_HOTKEY_ALREADY_REGISTERED: u32 = 1409;
pub const ERROR_CLASS_ALREADY_EXISTS: u32 = 1410;
pub const ERROR_CLASS_DOES_NOT_EXIST: u32 = 1411;
pub const ERROR_CLASS_HAS_WINDOWS: u32 = 1412;
pub const ERROR_INVALID_INDEX: u32 = 1413;
pub const ERROR_INVALID_ICON_HANDLE: u32 = 1414;
pub const ERROR_PRIVATE_DIALOG_INDEX: u32 = 1415;
pub const ERROR_LISTBOX_ID_NOT_FOUND: u32 = 1416;
pub const ERROR_NO_WILDCARD_CHARACTERS: u32 = 1417;
pub const ERROR_CLIPBOARD_NOT_OPEN: u32 = 1418;
pub const ERROR_HOTKEY_NOT_REGISTERED: u32 = 1419;
pub const ERROR_WINDOW_NOT_DIALOG: u32 = 1420;
pub const ERROR_CONTROL_ID_NOT_FOUND: u32 = 1421;
pub const ERROR_INVALID_COMBOBOX_MESSAGE: u32 = 1422;
pub const ERROR_WINDOW_NOT_COMBOBOX: u32 = 1423;
pub const ERROR_INVALID_EDIT_HEIGHT: u32 = 1424;
pub const ERROR_DC_NOT_FOUND: u32 = 1425;
pub const ERROR_INVALID_HOOK_FILTER: u32 = 1426;
pub const ERROR_INVALID_FILTER_PROC: u32 = 1427;
pub const ERROR_HOOK_NEEDS_HMOD: u32 = 1428;
pub const ERROR_GLOBAL_ONLY_HOOK: u32 = 1429;
pub const ERROR_JOURNAL_HOOK_SET: u32 = 1430;
pub const ERROR_HOOK_NOT_INSTALLED: u32 = 1431;
pub const ERROR_INVALID_LB_MESSAGE: u32 = 1432;
pub const ERROR_SETCOUNT_ON_BAD_LB: u32 = 1433;
pub const ERROR_LB_WITHOUT_TABSTOPS: u32 = 1434;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD: u32 = 1435;
pub const ERROR_CHILD_WINDOW_MENU: u32 = 1436;
pub const ERROR_NO_SYSTEM_MENU: u32 = 1437;
pub const ERROR_INVALID_MSGBOX_STYLE: u32 = 1438;
pub const ERROR_INVALID_SPI_VALUE: u32 = 1439;
pub const ERROR_SCREEN_ALREADY_LOCKED: u32 = 1440;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT: u32 = 1441;
pub const ERROR_NOT_CHILD_WINDOW: u32 = 1442;
pub const ERROR_INVALID_GW_COMMAND: u32 = 1443;
pub const ERROR_INVALID_THREAD_ID: u32 = 1444;
pub const ERROR_NON_MDICHILD_WINDOW: u32 = 1445;
pub const ERROR_POPUP_ALREADY_ACTIVE: u32 = 1446;
pub const ERROR_NO_SCROLLBARS: u32 = 1447;
pub const ERROR_INVALID_SCROLLBAR_RANGE: u32 = 1448;
pub const ERROR_INVALID_SHOWWIN_COMMAND: u32 = 1449;
pub const ERROR_NO_SYSTEM_RESOURCES: u32 = 1450;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES: u32 = 1451;
pub const ERROR_PAGED_SYSTEM_RESOURCES: u32 = 1452;
pub const ERROR_WORKING_SET_QUOTA: u32 = 1453;
pub const ERROR_PAGEFILE_QUOTA: u32 = 1454;
pub const ERROR_COMMITMENT_LIMIT: u32 = 1455;
pub const ERROR_MENU_ITEM_NOT_FOUND: u32 = 1456;
pub const ERROR_INVALID_KEYBOARD_HANDLE: u32 = 1457;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED: u32 = 1458;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION: u32 = 1459;
pub const ERROR_TIMEOUT: u32 = 1460;
pub const ERROR_INVALID_MONITOR_HANDLE: u32 = 1461;
pub const ERROR_INCORRECT_SIZE: u32 = 1462;
pub const ERROR_SYMLINK_CLASS_DISABLED: u32 = 1463;
pub const ERROR_SYMLINK_NOT_SUPPORTED: u32 = 1464;
pub const ERROR_XML_PARSE_ERROR: u32 = 1465;
pub const ERROR_XMLDSIG_ERROR: u32 = 1466;
pub const ERROR_RESTART_APPLICATION: u32 = 1467;
pub const ERROR_WRONG_COMPARTMENT: u32 = 1468;
pub const ERROR_AUTHIP_FAILURE: u32 = 1469;
pub const ERROR_NO_NVRAM_RESOURCES: u32 = 1470;
pub const ERROR_NOT_GUI_PROCESS: u32 = 1471;
pub const ERROR_EVENTLOG_FILE_CORRUPT: u32 = 1500;
pub const ERROR_EVENTLOG_CANT_START: u32 = 1501;
pub const ERROR_LOG_FILE_FULL: u32 = 1502;
pub const ERROR_EVENTLOG_FILE_CHANGED: u32 = 1503;
pub const ERROR_CONTAINER_ASSIGNED: u32 = 1504;
pub const ERROR_JOB_NO_CONTAINER: u32 = 1505;
pub const ERROR_INVALID_TASK_NAME: u32 = 1550;
pub const ERROR_INVALID_TASK_INDEX: u32 = 1551;
pub const ERROR_THREAD_ALREADY_IN_TASK: u32 = 1552;
pub const ERROR_INSTALL_SERVICE_FAILURE: u32 = 1601;
pub const ERROR_INSTALL_USEREXIT: u32 = 1602;
pub const ERROR_INSTALL_FAILURE: u32 = 1603;
pub const ERROR_INSTALL_SUSPEND: u32 = 1604;
pub const ERROR_UNKNOWN_PRODUCT: u32 = 1605;
pub const ERROR_UNKNOWN_FEATURE: u32 = 1606;
pub const ERROR_UNKNOWN_COMPONENT: u32 = 1607;
pub const ERROR_UNKNOWN_PROPERTY: u32 = 1608;
pub const ERROR_INVALID_HANDLE_STATE: u32 = 1609;
pub const ERROR_BAD_CONFIGURATION: u32 = 1610;
pub const ERROR_INDEX_ABSENT: u32 = 1611;
pub const ERROR_INSTALL_SOURCE_ABSENT: u32 = 1612;
pub const ERROR_INSTALL_PACKAGE_VERSION: u32 = 1613;
pub const ERROR_PRODUCT_UNINSTALLED: u32 = 1614;
pub const ERROR_BAD_QUERY_SYNTAX: u32 = 1615;
pub const ERROR_INVALID_FIELD: u32 = 1616;
pub const ERROR_DEVICE_REMOVED: u32 = 1617;
pub const ERROR_INSTALL_ALREADY_RUNNING: u32 = 1618;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED: u32 = 1619;
pub const ERROR_INSTALL_PACKAGE_INVALID: u32 = 1620;
pub const ERROR_INSTALL_UI_FAILURE: u32 = 1621;
pub const ERROR_INSTALL_LOG_FAILURE: u32 = 1622;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED: u32 = 1623;
pub const ERROR_INSTALL_TRANSFORM_FAILURE: u32 = 1624;
pub const ERROR_INSTALL_PACKAGE_REJECTED: u32 = 1625;
pub const ERROR_FUNCTION_NOT_CALLED: u32 = 1626;
pub const ERROR_FUNCTION_FAILED: u32 = 1627;
pub const ERROR_INVALID_TABLE: u32 = 1628;
pub const ERROR_DATATYPE_MISMATCH: u32 = 1629;
pub const ERROR_UNSUPPORTED_TYPE: u32 = 1630;
pub const ERROR_CREATE_FAILED: u32 = 1631;
pub const ERROR_INSTALL_TEMP_UNWRITABLE: u32 = 1632;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED: u32 = 1633;
pub const ERROR_INSTALL_NOTUSED: u32 = 1634;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED: u32 = 1635;
pub const ERROR_PATCH_PACKAGE_INVALID: u32 = 1636;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED: u32 = 1637;
pub const ERROR_PRODUCT_VERSION: u32 = 1638;
pub const ERROR_INVALID_COMMAND_LINE: u32 = 1639;
pub const ERROR_INSTALL_REMOTE_DISALLOWED: u32 = 1640;
pub const ERROR_SUCCESS_REBOOT_INITIATED: u32 = 1641;
pub const ERROR_PATCH_TARGET_NOT_FOUND: u32 = 1642;
pub const ERROR_PATCH_PACKAGE_REJECTED: u32 = 1643;
pub const ERROR_INSTALL_TRANSFORM_REJECTED: u32 = 1644;
pub const ERROR_INSTALL_REMOTE_PROHIBITED: u32 = 1645;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED: u32 = 1646;
pub const ERROR_UNKNOWN_PATCH: u32 = 1647;
pub const ERROR_PATCH_NO_SEQUENCE: u32 = 1648;
pub const ERROR_PATCH_REMOVAL_DISALLOWED: u32 = 1649;
pub const ERROR_INVALID_PATCH_XML: u32 = 1650;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT: u32 = 1651;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT: u32 = 1652;
pub const ERROR_FAIL_FAST_EXCEPTION: u32 = 1653;
pub const ERROR_INSTALL_REJECTED: u32 = 1654;
pub const ERROR_DYNAMIC_CODE_BLOCKED: u32 = 1655;
pub const ERROR_NOT_SAME_OBJECT: u32 = 1656;
pub const ERROR_STRICT_CFG_VIOLATION: u32 = 1657;
pub const ERROR_SET_CONTEXT_DENIED: u32 = 1660;
pub const ERROR_CROSS_PARTITION_VIOLATION: u32 = 1661;
pub const ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT: u32 = 1662;
pub const RPC_S_INVALID_STRING_BINDING: u32 = 1700;
pub const RPC_S_WRONG_KIND_OF_BINDING: u32 = 1701;
pub const RPC_S_INVALID_BINDING: u32 = 1702;
pub const RPC_S_PROTSEQ_NOT_SUPPORTED: u32 = 1703;
pub const RPC_S_INVALID_RPC_PROTSEQ: u32 = 1704;
pub const RPC_S_INVALID_STRING_UUID: u32 = 1705;
pub const RPC_S_INVALID_ENDPOINT_FORMAT: u32 = 1706;
pub const RPC_S_INVALID_NET_ADDR: u32 = 1707;
pub const RPC_S_NO_ENDPOINT_FOUND: u32 = 1708;
pub const RPC_S_INVALID_TIMEOUT: u32 = 1709;
pub const RPC_S_OBJECT_NOT_FOUND: u32 = 1710;
pub const RPC_S_ALREADY_REGISTERED: u32 = 1711;
pub const RPC_S_TYPE_ALREADY_REGISTERED: u32 = 1712;
pub const RPC_S_ALREADY_LISTENING: u32 = 1713;
pub const RPC_S_NO_PROTSEQS_REGISTERED: u32 = 1714;
pub const RPC_S_NOT_LISTENING: u32 = 1715;
pub const RPC_S_UNKNOWN_MGR_TYPE: u32 = 1716;
pub const RPC_S_UNKNOWN_IF: u32 = 1717;
pub const RPC_S_NO_BINDINGS: u32 = 1718;
pub const RPC_S_NO_PROTSEQS: u32 = 1719;
pub const RPC_S_CANT_CREATE_ENDPOINT: u32 = 1720;
pub const RPC_S_OUT_OF_RESOURCES: u32 = 1721;
pub const RPC_S_SERVER_UNAVAILABLE: u32 = 1722;
pub const RPC_S_SERVER_TOO_BUSY: u32 = 1723;
pub const RPC_S_INVALID_NETWORK_OPTIONS: u32 = 1724;
pub const RPC_S_NO_CALL_ACTIVE: u32 = 1725;
pub const RPC_S_CALL_FAILED: u32 = 1726;
pub const RPC_S_CALL_FAILED_DNE: u32 = 1727;
pub const RPC_S_PROTOCOL_ERROR: u32 = 1728;
pub const RPC_S_PROXY_ACCESS_DENIED: u32 = 1729;
pub const RPC_S_UNSUPPORTED_TRANS_SYN: u32 = 1730;
pub const RPC_S_UNSUPPORTED_TYPE: u32 = 1732;
pub const RPC_S_INVALID_TAG: u32 = 1733;
pub const RPC_S_INVALID_BOUND: u32 = 1734;
pub const RPC_S_NO_ENTRY_NAME: u32 = 1735;
pub const RPC_S_INVALID_NAME_SYNTAX: u32 = 1736;
pub const RPC_S_UNSUPPORTED_NAME_SYNTAX: u32 = 1737;
pub const RPC_S_UUID_NO_ADDRESS: u32 = 1739;
pub const RPC_S_DUPLICATE_ENDPOINT: u32 = 1740;
pub const RPC_S_UNKNOWN_AUTHN_TYPE: u32 = 1741;
pub const RPC_S_MAX_CALLS_TOO_SMALL: u32 = 1742;
pub const RPC_S_STRING_TOO_LONG: u32 = 1743;
pub const RPC_S_PROTSEQ_NOT_FOUND: u32 = 1744;
pub const RPC_S_PROCNUM_OUT_OF_RANGE: u32 = 1745;
pub const RPC_S_BINDING_HAS_NO_AUTH: u32 = 1746;
pub const RPC_S_UNKNOWN_AUTHN_SERVICE: u32 = 1747;
pub const RPC_S_UNKNOWN_AUTHN_LEVEL: u32 = 1748;
pub const RPC_S_INVALID_AUTH_IDENTITY: u32 = 1749;
pub const RPC_S_UNKNOWN_AUTHZ_SERVICE: u32 = 1750;
pub const EPT_S_INVALID_ENTRY: u32 = 1751;
pub const EPT_S_CANT_PERFORM_OP: u32 = 1752;
pub const EPT_S_NOT_REGISTERED: u32 = 1753;
pub const RPC_S_NOTHING_TO_EXPORT: u32 = 1754;
pub const RPC_S_INCOMPLETE_NAME: u32 = 1755;
pub const RPC_S_INVALID_VERS_OPTION: u32 = 1756;
pub const RPC_S_NO_MORE_MEMBERS: u32 = 1757;
pub const RPC_S_NOT_ALL_OBJS_UNEXPORTED: u32 = 1758;
pub const RPC_S_INTERFACE_NOT_FOUND: u32 = 1759;
pub const RPC_S_ENTRY_ALREADY_EXISTS: u32 = 1760;
pub const RPC_S_ENTRY_NOT_FOUND: u32 = 1761;
pub const RPC_S_NAME_SERVICE_UNAVAILABLE: u32 = 1762;
pub const RPC_S_INVALID_NAF_ID: u32 = 1763;
pub const RPC_S_CANNOT_SUPPORT: u32 = 1764;
pub const RPC_S_NO_CONTEXT_AVAILABLE: u32 = 1765;
pub const RPC_S_INTERNAL_ERROR: u32 = 1766;
pub const RPC_S_ZERO_DIVIDE: u32 = 1767;
pub const RPC_S_ADDRESS_ERROR: u32 = 1768;
pub const RPC_S_FP_DIV_ZERO: u32 = 1769;
pub const RPC_S_FP_UNDERFLOW: u32 = 1770;
pub const RPC_S_FP_OVERFLOW: u32 = 1771;
pub const RPC_X_NO_MORE_ENTRIES: u32 = 1772;
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL: u32 = 1773;
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE: u32 = 1774;
pub const RPC_X_SS_IN_NULL_CONTEXT: u32 = 1775;
pub const RPC_X_SS_CONTEXT_DAMAGED: u32 = 1777;
pub const RPC_X_SS_HANDLES_MISMATCH: u32 = 1778;
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE: u32 = 1779;
pub const RPC_X_NULL_REF_POINTER: u32 = 1780;
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE: u32 = 1781;
pub const RPC_X_BYTE_COUNT_TOO_SMALL: u32 = 1782;
pub const RPC_X_BAD_STUB_DATA: u32 = 1783;
pub const ERROR_INVALID_USER_BUFFER: u32 = 1784;
pub const ERROR_UNRECOGNIZED_MEDIA: u32 = 1785;
pub const ERROR_NO_TRUST_LSA_SECRET: u32 = 1786;
pub const ERROR_NO_TRUST_SAM_ACCOUNT: u32 = 1787;
pub const ERROR_TRUSTED_DOMAIN_FAILURE: u32 = 1788;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE: u32 = 1789;
pub const ERROR_TRUST_FAILURE: u32 = 1790;
pub const RPC_S_CALL_IN_PROGRESS: u32 = 1791;
pub const ERROR_NETLOGON_NOT_STARTED: u32 = 1792;
pub const ERROR_ACCOUNT_EXPIRED: u32 = 1793;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES: u32 = 1794;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED: u32 = 1795;
pub const ERROR_UNKNOWN_PORT: u32 = 1796;
pub const ERROR_UNKNOWN_PRINTER_DRIVER: u32 = 1797;
pub const ERROR_UNKNOWN_PRINTPROCESSOR: u32 = 1798;
pub const ERROR_INVALID_SEPARATOR_FILE: u32 = 1799;
pub const ERROR_INVALID_PRIORITY: u32 = 1800;
pub const ERROR_INVALID_PRINTER_NAME: u32 = 1801;
pub const ERROR_PRINTER_ALREADY_EXISTS: u32 = 1802;
pub const ERROR_INVALID_PRINTER_COMMAND: u32 = 1803;
pub const ERROR_INVALID_DATATYPE: u32 = 1804;
pub const ERROR_INVALID_ENVIRONMENT: u32 = 1805;
pub const RPC_S_NO_MORE_BINDINGS: u32 = 1806;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: u32 = 1807;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT: u32 = 1808;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT: u32 = 1809;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT: u32 = 1810;
pub const ERROR_SERVER_HAS_OPEN_HANDLES: u32 = 1811;
pub const ERROR_RESOURCE_DATA_NOT_FOUND: u32 = 1812;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND: u32 = 1813;
pub const ERROR_RESOURCE_NAME_NOT_FOUND: u32 = 1814;
pub const ERROR_RESOURCE_LANG_NOT_FOUND: u32 = 1815;
pub const ERROR_NOT_ENOUGH_QUOTA: u32 = 1816;
pub const RPC_S_NO_INTERFACES: u32 = 1817;
pub const RPC_S_CALL_CANCELLED: u32 = 1818;
pub const RPC_S_BINDING_INCOMPLETE: u32 = 1819;
pub const RPC_S_COMM_FAILURE: u32 = 1820;
pub const RPC_S_UNSUPPORTED_AUTHN_LEVEL: u32 = 1821;
pub const RPC_S_NO_PRINC_NAME: u32 = 1822;
pub const RPC_S_NOT_RPC_ERROR: u32 = 1823;
pub const RPC_S_UUID_LOCAL_ONLY: u32 = 1824;
pub const RPC_S_SEC_PKG_ERROR: u32 = 1825;
pub const RPC_S_NOT_CANCELLED: u32 = 1826;
pub const RPC_X_INVALID_ES_ACTION: u32 = 1827;
pub const RPC_X_WRONG_ES_VERSION: u32 = 1828;
pub const RPC_X_WRONG_STUB_VERSION: u32 = 1829;
pub const RPC_X_INVALID_PIPE_OBJECT: u32 = 1830;
pub const RPC_X_WRONG_PIPE_ORDER: u32 = 1831;
pub const RPC_X_WRONG_PIPE_VERSION: u32 = 1832;
pub const RPC_S_COOKIE_AUTH_FAILED: u32 = 1833;
pub const RPC_S_DO_NOT_DISTURB: u32 = 1834;
pub const RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED: u32 = 1835;
pub const RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH: u32 = 1836;
pub const RPC_S_GROUP_MEMBER_NOT_FOUND: u32 = 1898;
pub const EPT_S_CANT_CREATE: u32 = 1899;
pub const RPC_S_INVALID_OBJECT: u32 = 1900;
pub const ERROR_INVALID_TIME: u32 = 1901;
pub const ERROR_INVALID_FORM_NAME: u32 = 1902;
pub const ERROR_INVALID_FORM_SIZE: u32 = 1903;
pub const ERROR_ALREADY_WAITING: u32 = 1904;
pub const ERROR_PRINTER_DELETED: u32 = 1905;
pub const ERROR_INVALID_PRINTER_STATE: u32 = 1906;
pub const ERROR_PASSWORD_MUST_CHANGE: u32 = 1907;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND: u32 = 1908;
pub const ERROR_ACCOUNT_LOCKED_OUT: u32 = 1909;
pub const OR_INVALID_OXID: u32 = 1910;
pub const OR_INVALID_OID: u32 = 1911;
pub const OR_INVALID_SET: u32 = 1912;
pub const RPC_S_SEND_INCOMPLETE: u32 = 1913;
pub const RPC_S_INVALID_ASYNC_HANDLE: u32 = 1914;
pub const RPC_S_INVALID_ASYNC_CALL: u32 = 1915;
pub const RPC_X_PIPE_CLOSED: u32 = 1916;
pub const RPC_X_PIPE_DISCIPLINE_ERROR: u32 = 1917;
pub const RPC_X_PIPE_EMPTY: u32 = 1918;
pub const ERROR_NO_SITENAME: u32 = 1919;
pub const ERROR_CANT_ACCESS_FILE: u32 = 1920;
pub const ERROR_CANT_RESOLVE_FILENAME: u32 = 1921;
pub const RPC_S_ENTRY_TYPE_MISMATCH: u32 = 1922;
pub const RPC_S_NOT_ALL_OBJS_EXPORTED: u32 = 1923;
pub const RPC_S_INTERFACE_NOT_EXPORTED: u32 = 1924;
pub const RPC_S_PROFILE_NOT_ADDED: u32 = 1925;
pub const RPC_S_PRF_ELT_NOT_ADDED: u32 = 1926;
pub const RPC_S_PRF_ELT_NOT_REMOVED: u32 = 1927;
pub const RPC_S_GRP_ELT_NOT_ADDED: u32 = 1928;
pub const RPC_S_GRP_ELT_NOT_REMOVED: u32 = 1929;
pub const ERROR_KM_DRIVER_BLOCKED: u32 = 1930;
pub const ERROR_CONTEXT_EXPIRED: u32 = 1931;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED: u32 = 1932;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED: u32 = 1933;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED: u32 = 1934;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED: u32 = 1935;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED: u32 = 1936;
pub const ERROR_NTLM_BLOCKED: u32 = 1937;
pub const ERROR_PASSWORD_CHANGE_REQUIRED: u32 = 1938;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION: u32 = 1939;
pub const ERROR_INVALID_PIXEL_FORMAT: u32 = 2000;
pub const ERROR_BAD_DRIVER: u32 = 2001;
pub const ERROR_INVALID_WINDOW_STYLE: u32 = 2002;
pub const ERROR_METAFILE_NOT_SUPPORTED: u32 = 2003;
pub const ERROR_TRANSFORM_NOT_SUPPORTED: u32 = 2004;
pub const ERROR_CLIPPING_NOT_SUPPORTED: u32 = 2005;
pub const ERROR_INVALID_CMM: u32 = 2010;
pub const ERROR_INVALID_PROFILE: u32 = 2011;
pub const ERROR_TAG_NOT_FOUND: u32 = 2012;
pub const ERROR_TAG_NOT_PRESENT: u32 = 2013;
pub const ERROR_DUPLICATE_TAG: u32 = 2014;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE: u32 = 2015;
pub const ERROR_PROFILE_NOT_FOUND: u32 = 2016;
pub const ERROR_INVALID_COLORSPACE: u32 = 2017;
pub const ERROR_ICM_NOT_ENABLED: u32 = 2018;
pub const ERROR_DELETING_ICM_XFORM: u32 = 2019;
pub const ERROR_INVALID_TRANSFORM: u32 = 2020;
pub const ERROR_COLORSPACE_MISMATCH: u32 = 2021;
pub const ERROR_INVALID_COLORINDEX: u32 = 2022;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE: u32 = 2023;
pub const ERROR_CONNECTED_OTHER_PASSWORD: u32 = 2108;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 2109;
pub const ERROR_BAD_USERNAME: u32 = 2202;
pub const ERROR_NOT_CONNECTED: u32 = 2250;
pub const ERROR_OPEN_FILES: u32 = 2401;
pub const ERROR_ACTIVE_CONNECTIONS: u32 = 2402;
pub const ERROR_DEVICE_IN_USE: u32 = 2404;
pub const ERROR_UNKNOWN_PRINT_MONITOR: u32 = 3000;
pub const ERROR_PRINTER_DRIVER_IN_USE: u32 = 3001;
pub const ERROR_SPOOL_FILE_NOT_FOUND: u32 = 3002;
pub const ERROR_SPL_NO_STARTDOC: u32 = 3003;
pub const ERROR_SPL_NO_ADDJOB: u32 = 3004;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED: u32 = 3005;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED: u32 = 3006;
pub const ERROR_INVALID_PRINT_MONITOR: u32 = 3007;
pub const ERROR_PRINT_MONITOR_IN_USE: u32 = 3008;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED: u32 = 3009;
pub const ERROR_SUCCESS_REBOOT_REQUIRED: u32 = 3010;
pub const ERROR_SUCCESS_RESTART_REQUIRED: u32 = 3011;
pub const ERROR_PRINTER_NOT_FOUND: u32 = 3012;
pub const ERROR_PRINTER_DRIVER_WARNED: u32 = 3013;
pub const ERROR_PRINTER_DRIVER_BLOCKED: u32 = 3014;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE: u32 = 3015;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND: u32 = 3016;
pub const ERROR_FAIL_REBOOT_REQUIRED: u32 = 3017;
pub const ERROR_FAIL_REBOOT_INITIATED: u32 = 3018;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED: u32 = 3019;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED: u32 = 3020;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST: u32 = 3021;
pub const ERROR_PRINTER_NOT_SHAREABLE: u32 = 3022;
pub const ERROR_SERVER_SERVICE_CALL_REQUIRES_SMB1: u32 = 3023;
pub const ERROR_NETWORK_AUTHENTICATION_PROMPT_CANCELED: u32 = 3024;
pub const ERROR_REQUEST_PAUSED: u32 = 3050;
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED: u32 = 3060;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED: u32 = 3061;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION: u32 = 3062;
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION: u32 = 3063;
pub const ERROR_APPEXEC_INVALID_HOST_STATE: u32 = 3064;
pub const ERROR_APPEXEC_NO_DONOR: u32 = 3065;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH: u32 = 3066;
pub const ERROR_APPEXEC_UNKNOWN_USER: u32 = 3067;
pub const ERROR_APPEXEC_APP_COMPAT_BLOCK: u32 = 3068;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT: u32 = 3069;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT_TERMINATION: u32 = 3070;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT_LICENSING: u32 = 3071;
pub const ERROR_APPEXEC_CALLER_WAIT_TIMEOUT_RESOURCES: u32 = 3072;
pub const ERROR_VRF_VOLATILE_CFG_AND_IO_ENABLED: u32 = 3080;
pub const ERROR_VRF_VOLATILE_NOT_STOPPABLE: u32 = 3081;
pub const ERROR_VRF_VOLATILE_SAFE_MODE: u32 = 3082;
pub const ERROR_VRF_VOLATILE_NOT_RUNNABLE_SYSTEM: u32 = 3083;
pub const ERROR_VRF_VOLATILE_NOT_SUPPORTED_RULECLASS: u32 = 3084;
pub const ERROR_VRF_VOLATILE_PROTECTED_DRIVER: u32 = 3085;
pub const ERROR_VRF_VOLATILE_NMI_REGISTERED: u32 = 3086;
pub const ERROR_VRF_VOLATILE_SETTINGS_CONFLICT: u32 = 3087;
pub const ERROR_DIF_IOCALLBACK_NOT_REPLACED: u32 = 3190;
pub const ERROR_DIF_LIVEDUMP_LIMIT_EXCEEDED: u32 = 3191;
pub const ERROR_DIF_VOLATILE_SECTION_NOT_LOCKED: u32 = 3192;
pub const ERROR_DIF_VOLATILE_DRIVER_HOTPATCHED: u32 = 3193;
pub const ERROR_DIF_VOLATILE_INVALID_INFO: u32 = 3194;
pub const ERROR_DIF_VOLATILE_DRIVER_IS_NOT_RUNNING: u32 = 3195;
pub const ERROR_DIF_VOLATILE_PLUGIN_IS_NOT_RUNNING: u32 = 3196;
pub const ERROR_DIF_VOLATILE_PLUGIN_CHANGE_NOT_ALLOWED: u32 = 3197;
pub const ERROR_DIF_VOLATILE_NOT_ALLOWED: u32 = 3198;
pub const ERROR_DIF_BINDING_API_NOT_FOUND: u32 = 3199;
pub const ERROR_IO_REISSUE_AS_CACHED: u32 = 3950;
pub const ERROR_WINS_INTERNAL: u32 = 4000;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS: u32 = 4001;
pub const ERROR_STATIC_INIT: u32 = 4002;
pub const ERROR_INC_BACKUP: u32 = 4003;
pub const ERROR_FULL_BACKUP: u32 = 4004;
pub const ERROR_REC_NON_EXISTENT: u32 = 4005;
pub const ERROR_RPL_NOT_ALLOWED: u32 = 4006;
pub const PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED: u32 = 4050;
pub const PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO: u32 = 4051;
pub const PEERDIST_ERROR_MISSING_DATA: u32 = 4052;
pub const PEERDIST_ERROR_NO_MORE: u32 = 4053;
pub const PEERDIST_ERROR_NOT_INITIALIZED: u32 = 4054;
pub const PEERDIST_ERROR_ALREADY_INITIALIZED: u32 = 4055;
pub const PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS: u32 = 4056;
pub const PEERDIST_ERROR_INVALIDATED: u32 = 4057;
pub const PEERDIST_ERROR_ALREADY_EXISTS: u32 = 4058;
pub const PEERDIST_ERROR_OPERATION_NOTFOUND: u32 = 4059;
pub const PEERDIST_ERROR_ALREADY_COMPLETED: u32 = 4060;
pub const PEERDIST_ERROR_OUT_OF_BOUNDS: u32 = 4061;
pub const PEERDIST_ERROR_VERSION_UNSUPPORTED: u32 = 4062;
pub const PEERDIST_ERROR_INVALID_CONFIGURATION: u32 = 4063;
pub const PEERDIST_ERROR_NOT_LICENSED: u32 = 4064;
pub const PEERDIST_ERROR_SERVICE_UNAVAILABLE: u32 = 4065;
pub const PEERDIST_ERROR_TRUST_FAILURE: u32 = 4066;
pub const ERROR_DHCP_ADDRESS_CONFLICT: u32 = 4100;
pub const ERROR_WMI_GUID_NOT_FOUND: u32 = 4200;
pub const ERROR_WMI_INSTANCE_NOT_FOUND: u32 = 4201;
pub const ERROR_WMI_ITEMID_NOT_FOUND: u32 = 4202;
pub const ERROR_WMI_TRY_AGAIN: u32 = 4203;
pub const ERROR_WMI_DP_NOT_FOUND: u32 = 4204;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF: u32 = 4205;
pub const ERROR_WMI_ALREADY_ENABLED: u32 = 4206;
pub const ERROR_WMI_GUID_DISCONNECTED: u32 = 4207;
pub const ERROR_WMI_SERVER_UNAVAILABLE: u32 = 4208;
pub const ERROR_WMI_DP_FAILED: u32 = 4209;
pub const ERROR_WMI_INVALID_MOF: u32 = 4210;
pub const ERROR_WMI_INVALID_REGINFO: u32 = 4211;
pub const ERROR_WMI_ALREADY_DISABLED: u32 = 4212;
pub const ERROR_WMI_READ_ONLY: u32 = 4213;
pub const ERROR_WMI_SET_FAILURE: u32 = 4214;
pub const ERROR_NOT_APPCONTAINER: u32 = 4250;
pub const ERROR_APPCONTAINER_REQUIRED: u32 = 4251;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER: u32 = 4252;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH: u32 = 4253;
pub const ERROR_INVALID_MEDIA: u32 = 4300;
pub const ERROR_INVALID_LIBRARY: u32 = 4301;
pub const ERROR_INVALID_MEDIA_POOL: u32 = 4302;
pub const ERROR_DRIVE_MEDIA_MISMATCH: u32 = 4303;
pub const ERROR_MEDIA_OFFLINE: u32 = 4304;
pub const ERROR_LIBRARY_OFFLINE: u32 = 4305;
pub const ERROR_EMPTY: u32 = 4306;
pub const ERROR_NOT_EMPTY: u32 = 4307;
pub const ERROR_MEDIA_UNAVAILABLE: u32 = 4308;
pub const ERROR_RESOURCE_DISABLED: u32 = 4309;
pub const ERROR_INVALID_CLEANER: u32 = 4310;
pub const ERROR_UNABLE_TO_CLEAN: u32 = 4311;
pub const ERROR_OBJECT_NOT_FOUND: u32 = 4312;
pub const ERROR_DATABASE_FAILURE: u32 = 4313;
pub const ERROR_DATABASE_FULL: u32 = 4314;
pub const ERROR_MEDIA_INCOMPATIBLE: u32 = 4315;
pub const ERROR_RESOURCE_NOT_PRESENT: u32 = 4316;
pub const ERROR_INVALID_OPERATION: u32 = 4317;
pub const ERROR_MEDIA_NOT_AVAILABLE: u32 = 4318;
pub const ERROR_DEVICE_NOT_AVAILABLE: u32 = 4319;
pub const ERROR_REQUEST_REFUSED: u32 = 4320;
pub const ERROR_INVALID_DRIVE_OBJECT: u32 = 4321;
pub const ERROR_LIBRARY_FULL: u32 = 4322;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE: u32 = 4323;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM: u32 = 4324;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE: u32 = 4325;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT: u32 = 4326;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT: u32 = 4327;
pub const ERROR_TRANSPORT_FULL: u32 = 4328;
pub const ERROR_CONTROLLING_IEPORT: u32 = 4329;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA: u32 = 4330;
pub const ERROR_CLEANER_SLOT_SET: u32 = 4331;
pub const ERROR_CLEANER_SLOT_NOT_SET: u32 = 4332;
pub const ERROR_CLEANER_CARTRIDGE_SPENT: u32 = 4333;
pub const ERROR_UNEXPECTED_OMID: u32 = 4334;
pub const ERROR_CANT_DELETE_LAST_ITEM: u32 = 4335;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE: u32 = 4336;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES: u32 = 4337;
pub const ERROR_INDIGENOUS_TYPE: u32 = 4338;
pub const ERROR_NO_SUPPORTING_DRIVES: u32 = 4339;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED: u32 = 4340;
pub const ERROR_IEPORT_FULL: u32 = 4341;
pub const ERROR_FILE_OFFLINE: u32 = 4350;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE: u32 = 4351;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR: u32 = 4352;
pub const ERROR_NOT_A_REPARSE_POINT: u32 = 4390;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT: u32 = 4391;
pub const ERROR_INVALID_REPARSE_DATA: u32 = 4392;
pub const ERROR_REPARSE_TAG_INVALID: u32 = 4393;
pub const ERROR_REPARSE_TAG_MISMATCH: u32 = 4394;
pub const ERROR_REPARSE_POINT_ENCOUNTERED: u32 = 4395;
pub const ERROR_APP_DATA_NOT_FOUND: u32 = 4400;
pub const ERROR_APP_DATA_EXPIRED: u32 = 4401;
pub const ERROR_APP_DATA_CORRUPT: u32 = 4402;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED: u32 = 4403;
pub const ERROR_APP_DATA_REBOOT_REQUIRED: u32 = 4404;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED: u32 = 4420;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION: u32 = 4421;
pub const ERROR_SECUREBOOT_INVALID_POLICY: u32 = 4422;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND: u32 = 4423;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED: u32 = 4424;
pub const ERROR_SECUREBOOT_NOT_ENABLED: u32 = 4425;
pub const ERROR_SECUREBOOT_FILE_REPLACED: u32 = 4426;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED: u32 = 4427;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN: u32 = 4428;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION: u32 = 4429;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH: u32 = 4430;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED: u32 = 4431;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH: u32 = 4432;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING: u32 = 4433;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY: u32 = 4434;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY: u32 = 4435;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED: u32 = 4440;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED: u32 = 4441;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED: u32 = 4442;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED: u32 = 4443;
pub const ERROR_ALREADY_HAS_STREAM_ID: u32 = 4444;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED: u32 = 4445;
pub const ERROR_WOF_WIM_HEADER_CORRUPT: u32 = 4446;
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT: u32 = 4447;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT: u32 = 4448;
pub const ERROR_OBJECT_IS_IMMUTABLE: u32 = 4449;
pub const ERROR_VOLUME_NOT_SIS_ENABLED: u32 = 4500;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED: u32 = 4550;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION: u32 = 4551;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY: u32 = 4552;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED: u32 = 4553;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES: u32 = 4554;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED: u32 = 4555;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_MALICIOUS: u32 = 4556;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_PUA: u32 = 4557;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_DANGEROUS_EXT: u32 = 4558;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_OFFLINE: u32 = 4559;
pub const ERROR_VSM_NOT_INITIALIZED: u32 = 4560;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE: u32 = 4561;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED: u32 = 4570;
pub const ERROR_PLATFORM_MANIFEST_INVALID: u32 = 4571;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED: u32 = 4572;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED: u32 = 4573;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND: u32 = 4574;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE: u32 = 4575;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED: u32 = 4576;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_UNFRIENDLY_FILE: u32 = 4580;
pub const ERROR_SYSTEM_INTEGRITY_REPUTATION_UNATTAINABLE: u32 = 4581;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS: u32 = 5001;
pub const ERROR_DEPENDENCY_NOT_FOUND: u32 = 5002;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS: u32 = 5003;
pub const ERROR_RESOURCE_NOT_ONLINE: u32 = 5004;
pub const ERROR_HOST_NODE_NOT_AVAILABLE: u32 = 5005;
pub const ERROR_RESOURCE_NOT_AVAILABLE: u32 = 5006;
pub const ERROR_RESOURCE_NOT_FOUND: u32 = 5007;
pub const ERROR_SHUTDOWN_CLUSTER: u32 = 5008;
pub const ERROR_CANT_EVICT_ACTIVE_NODE: u32 = 5009;
pub const ERROR_OBJECT_ALREADY_EXISTS: u32 = 5010;
pub const ERROR_OBJECT_IN_LIST: u32 = 5011;
pub const ERROR_GROUP_NOT_AVAILABLE: u32 = 5012;
pub const ERROR_GROUP_NOT_FOUND: u32 = 5013;
pub const ERROR_GROUP_NOT_ONLINE: u32 = 5014;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER: u32 = 5015;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER: u32 = 5016;
pub const ERROR_RESMON_CREATE_FAILED: u32 = 5017;
pub const ERROR_RESMON_ONLINE_FAILED: u32 = 5018;
pub const ERROR_RESOURCE_ONLINE: u32 = 5019;
pub const ERROR_QUORUM_RESOURCE: u32 = 5020;
pub const ERROR_NOT_QUORUM_CAPABLE: u32 = 5021;
pub const ERROR_CLUSTER_SHUTTING_DOWN: u32 = 5022;
pub const ERROR_INVALID_STATE: u32 = 5023;
pub const ERROR_RESOURCE_PROPERTIES_STORED: u32 = 5024;
pub const ERROR_NOT_QUORUM_CLASS: u32 = 5025;
pub const ERROR_CORE_RESOURCE: u32 = 5026;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED: u32 = 5027;
pub const ERROR_QUORUMLOG_OPEN_FAILED: u32 = 5028;
pub const ERROR_CLUSTERLOG_CORRUPT: u32 = 5029;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE: u32 = 5030;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE: u32 = 5031;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND: u32 = 5032;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE: u32 = 5033;
pub const ERROR_QUORUM_OWNER_ALIVE: u32 = 5034;
pub const ERROR_NETWORK_NOT_AVAILABLE: u32 = 5035;
pub const ERROR_NODE_NOT_AVAILABLE: u32 = 5036;
pub const ERROR_ALL_NODES_NOT_AVAILABLE: u32 = 5037;
pub const ERROR_RESOURCE_FAILED: u32 = 5038;
pub const ERROR_CLUSTER_INVALID_NODE: u32 = 5039;
pub const ERROR_CLUSTER_NODE_EXISTS: u32 = 5040;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS: u32 = 5041;
pub const ERROR_CLUSTER_NODE_NOT_FOUND: u32 = 5042;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND: u32 = 5043;
pub const ERROR_CLUSTER_NETWORK_EXISTS: u32 = 5044;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND: u32 = 5045;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS: u32 = 5046;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND: u32 = 5047;
pub const ERROR_CLUSTER_INVALID_REQUEST: u32 = 5048;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER: u32 = 5049;
pub const ERROR_CLUSTER_NODE_DOWN: u32 = 5050;
pub const ERROR_CLUSTER_NODE_UNREACHABLE: u32 = 5051;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER: u32 = 5052;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS: u32 = 5053;
pub const ERROR_CLUSTER_INVALID_NETWORK: u32 = 5054;
pub const ERROR_CLUSTER_NODE_UP: u32 = 5056;
pub const ERROR_CLUSTER_IPADDR_IN_USE: u32 = 5057;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED: u32 = 5058;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT: u32 = 5059;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL: u32 = 5060;
pub const ERROR_CLUSTER_NODE_ALREADY_UP: u32 = 5061;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN: u32 = 5062;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE: u32 = 5063;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE: u32 = 5064;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER: u32 = 5065;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK: u32 = 5066;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS: u32 = 5067;
pub const ERROR_INVALID_OPERATION_ON_QUORUM: u32 = 5068;
pub const ERROR_DEPENDENCY_NOT_ALLOWED: u32 = 5069;
pub const ERROR_CLUSTER_NODE_PAUSED: u32 = 5070;
pub const ERROR_NODE_CANT_HOST_RESOURCE: u32 = 5071;
pub const ERROR_CLUSTER_NODE_NOT_READY: u32 = 5072;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN: u32 = 5073;
pub const ERROR_CLUSTER_JOIN_ABORTED: u32 = 5074;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS: u32 = 5075;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED: u32 = 5076;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED: u32 = 5077;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: u32 = 5078;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED: u32 = 5079;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND: u32 = 5080;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED: u32 = 5081;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST: u32 = 5082;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH: u32 = 5083;
pub const ERROR_RESMON_INVALID_STATE: u32 = 5084;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER: u32 = 5085;
pub const ERROR_QUORUM_DISK_NOT_FOUND: u32 = 5086;
pub const ERROR_DATABASE_BACKUP_CORRUPT: u32 = 5087;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT: u32 = 5088;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE: u32 = 5089;
pub const ERROR_NO_ADMIN_ACCESS_POINT: u32 = 5090;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE: u32 = 5890;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND: u32 = 5891;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT: u32 = 5892;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH: u32 = 5893;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP: u32 = 5894;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH: u32 = 5895;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP: u32 = 5896;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH: u32 = 5897;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED: u32 = 5898;
pub const ERROR_CLUSTER_WRONG_OS_VERSION: u32 = 5899;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME: u32 = 5900;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED: u32 = 5901;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED: u32 = 5902;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT: u32 = 5903;
pub const ERROR_CLUSTER_OLD_VERSION: u32 = 5904;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME: u32 = 5905;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS: u32 = 5906;
pub const ERROR_CLUSTER_POISONED: u32 = 5907;
pub const ERROR_CLUSTER_GROUP_MOVING: u32 = 5908;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY: u32 = 5909;
pub const ERROR_RESOURCE_CALL_TIMED_OUT: u32 = 5910;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS: u32 = 5911;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION: u32 = 5912;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS: u32 = 5913;
pub const ERROR_CLUSTER_PARTIAL_SEND: u32 = 5914;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION: u32 = 5915;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION: u32 = 5916;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT: u32 = 5917;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS: u32 = 5918;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS: u32 = 5919;
pub const ERROR_CLUSTER_NULL_DATA: u32 = 5920;
pub const ERROR_CLUSTER_PARTIAL_READ: u32 = 5921;
pub const ERROR_CLUSTER_PARTIAL_WRITE: u32 = 5922;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA: u32 = 5923;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT: u32 = 5924;
pub const ERROR_CLUSTER_NO_QUORUM: u32 = 5925;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK: u32 = 5926;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK: u32 = 5927;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP: u32 = 5928;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX: u32 = 5929;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL: u32 = 5930;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION: u32 = 5931;
pub const ERROR_CLUSTER_NOT_INSTALLED: u32 = 5932;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE: u32 = 5933;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER: u32 = 5934;
pub const ERROR_CLUSTER_TOO_MANY_NODES: u32 = 5935;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED: u32 = 5936;
pub const ERROR_NONCORE_GROUPS_FOUND: u32 = 5937;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT: u32 = 5938;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST: u32 = 5939;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE: u32 = 5940;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE: u32 = 5941;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED: u32 = 5942;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR: u32 = 5943;
pub const ERROR_CLUSTER_GROUP_BUSY: u32 = 5944;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME: u32 = 5945;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR: u32 = 5946;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE: u32 = 5947;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API: u32 = 5948;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS: u32 = 5949;
pub const ERROR_NON_CSV_PATH: u32 = 5950;
pub const ERROR_CSV_VOLUME_NOT_LOCAL: u32 = 5951;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING: u32 = 5952;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES: u32 = 5953;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT: u32 = 5954;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL: u32 = 5955;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING: u32 = 5956;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION: u32 = 5957;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE: u32 = 5958;
pub const ERROR_CLUSTER_GROUP_QUEUED: u32 = 5959;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS: u32 = 5960;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED: u32 = 5961;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS: u32 = 5962;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED: u32 = 5963;
pub const ERROR_DISK_NOT_CSV_CAPABLE: u32 = 5964;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE: u32 = 5965;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED: u32 = 5966;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED: u32 = 5967;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES: u32 = 5968;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES: u32 = 5969;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE: u32 = 5970;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT: u32 = 5971;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE: u32 = 5972;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS: u32 = 5973;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED: u32 = 5974;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED: u32 = 5975;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS: u32 = 5976;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE: u32 = 5977;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD: u32 = 5978;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT: u32 = 5979;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER: u32 = 5980;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED: u32 = 5981;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED: u32 = 5982;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED: u32 = 5983;
pub const ERROR_CLUSTER_NODE_ISOLATED: u32 = 5984;
pub const ERROR_CLUSTER_NODE_QUARANTINED: u32 = 5985;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED: u32 = 5986;
pub const ERROR_CLUSTER_SPACE_DEGRADED: u32 = 5987;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED: u32 = 5988;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE: u32 = 5989;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR: u32 = 5990;
pub const ERROR_GROUPSET_NOT_AVAILABLE: u32 = 5991;
pub const ERROR_GROUPSET_NOT_FOUND: u32 = 5992;
pub const ERROR_GROUPSET_CANT_PROVIDE: u32 = 5993;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND: u32 = 5994;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY: u32 = 5995;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION: u32 = 5996;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS: u32 = 5997;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME: u32 = 5998;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE: u32 = 5999;
pub const ERROR_ENCRYPTION_FAILED: u32 = 6000;
pub const ERROR_DECRYPTION_FAILED: u32 = 6001;
pub const ERROR_FILE_ENCRYPTED: u32 = 6002;
pub const ERROR_NO_RECOVERY_POLICY: u32 = 6003;
pub const ERROR_NO_EFS: u32 = 6004;
pub const ERROR_WRONG_EFS: u32 = 6005;
pub const ERROR_NO_USER_KEYS: u32 = 6006;
pub const ERROR_FILE_NOT_ENCRYPTED: u32 = 6007;
pub const ERROR_NOT_EXPORT_FORMAT: u32 = 6008;
pub const ERROR_FILE_READ_ONLY: u32 = 6009;
pub const ERROR_DIR_EFS_DISALLOWED: u32 = 6010;
pub const ERROR_EFS_SERVER_NOT_TRUSTED: u32 = 6011;
pub const ERROR_BAD_RECOVERY_POLICY: u32 = 6012;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG: u32 = 6013;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS: u32 = 6014;
pub const ERROR_EFS_DISABLED: u32 = 6015;
pub const ERROR_EFS_VERSION_NOT_SUPPORT: u32 = 6016;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE: u32 = 6017;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER: u32 = 6018;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE: u32 = 6019;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE: u32 = 6020;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE: u32 = 6021;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION: u32 = 6022;
pub const ERROR_WIP_ENCRYPTION_FAILED: u32 = 6023;
pub const ERROR_NO_BROWSER_SERVERS_FOUND: u32 = 6118;
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM: u32 = 6200;
pub const ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM: u32 = 6250;
pub const ERROR_LOG_SECTOR_INVALID: u32 = 6600;
pub const ERROR_LOG_SECTOR_PARITY_INVALID: u32 = 6601;
pub const ERROR_LOG_SECTOR_REMAPPED: u32 = 6602;
pub const ERROR_LOG_BLOCK_INCOMPLETE: u32 = 6603;
pub const ERROR_LOG_INVALID_RANGE: u32 = 6604;
pub const ERROR_LOG_BLOCKS_EXHAUSTED: u32 = 6605;
pub const ERROR_LOG_READ_CONTEXT_INVALID: u32 = 6606;
pub const ERROR_LOG_RESTART_INVALID: u32 = 6607;
pub const ERROR_LOG_BLOCK_VERSION: u32 = 6608;
pub const ERROR_LOG_BLOCK_INVALID: u32 = 6609;
pub const ERROR_LOG_READ_MODE_INVALID: u32 = 6610;
pub const ERROR_LOG_NO_RESTART: u32 = 6611;
pub const ERROR_LOG_METADATA_CORRUPT: u32 = 6612;
pub const ERROR_LOG_METADATA_INVALID: u32 = 6613;
pub const ERROR_LOG_METADATA_INCONSISTENT: u32 = 6614;
pub const ERROR_LOG_RESERVATION_INVALID: u32 = 6615;
pub const ERROR_LOG_CANT_DELETE: u32 = 6616;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED: u32 = 6617;
pub const ERROR_LOG_START_OF_LOG: u32 = 6618;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED: u32 = 6619;
pub const ERROR_LOG_POLICY_NOT_INSTALLED: u32 = 6620;
pub const ERROR_LOG_POLICY_INVALID: u32 = 6621;
pub const ERROR_LOG_POLICY_CONFLICT: u32 = 6622;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL: u32 = 6623;
pub const ERROR_LOG_RECORD_NONEXISTENT: u32 = 6624;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID: u32 = 6625;
pub const ERROR_LOG_SPACE_RESERVED_INVALID: u32 = 6626;
pub const ERROR_LOG_TAIL_INVALID: u32 = 6627;
pub const ERROR_LOG_FULL: u32 = 6628;
pub const ERROR_COULD_NOT_RESIZE_LOG: u32 = 6629;
pub const ERROR_LOG_MULTIPLEXED: u32 = 6630;
pub const ERROR_LOG_DEDICATED: u32 = 6631;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS: u32 = 6632;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS: u32 = 6633;
pub const ERROR_LOG_EPHEMERAL: u32 = 6634;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS: u32 = 6635;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED: u32 = 6636;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED: u32 = 6637;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS: u32 = 6638;
pub const ERROR_LOG_CONTAINER_READ_FAILED: u32 = 6639;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED: u32 = 6640;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED: u32 = 6641;
pub const ERROR_LOG_CONTAINER_STATE_INVALID: u32 = 6642;
pub const ERROR_LOG_STATE_INVALID: u32 = 6643;
pub const ERROR_LOG_PINNED: u32 = 6644;
pub const ERROR_LOG_METADATA_FLUSH_FAILED: u32 = 6645;
pub const ERROR_LOG_INCONSISTENT_SECURITY: u32 = 6646;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED: u32 = 6647;
pub const ERROR_LOG_PINNED_RESERVATION: u32 = 6648;
pub const ERROR_INVALID_TRANSACTION: u32 = 6700;
pub const ERROR_TRANSACTION_NOT_ACTIVE: u32 = 6701;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID: u32 = 6702;
pub const ERROR_TRANSACTION_NOT_REQUESTED: u32 = 6703;
pub const ERROR_TRANSACTION_ALREADY_ABORTED: u32 = 6704;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED: u32 = 6705;
pub const ERROR_TM_INITIALIZATION_FAILED: u32 = 6706;
pub const ERROR_RESOURCEMANAGER_READ_ONLY: u32 = 6707;
pub const ERROR_TRANSACTION_NOT_JOINED: u32 = 6708;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS: u32 = 6709;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS: u32 = 6710;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED: u32 = 6711;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND: u32 = 6712;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER: u32 = 6713;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID: u32 = 6714;
pub const ERROR_TRANSACTION_NOT_FOUND: u32 = 6715;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND: u32 = 6716;
pub const ERROR_ENLISTMENT_NOT_FOUND: u32 = 6717;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND: u32 = 6718;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE: u32 = 6719;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION: u32 = 6720;
pub const ERROR_TRANSACTION_NOT_ROOT: u32 = 6721;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED: u32 = 6722;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED: u32 = 6723;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG: u32 = 6724;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED: u32 = 6725;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED: u32 = 6726;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH: u32 = 6727;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT: u32 = 6728;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH: u32 = 6729;
pub const ERROR_TRANSACTION_NO_SUPERIOR: u32 = 6730;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE: u32 = 6731;
pub const ERROR_TRANSACTIONAL_CONFLICT: u32 = 6800;
pub const ERROR_RM_NOT_ACTIVE: u32 = 6801;
pub const ERROR_RM_METADATA_CORRUPT: u32 = 6802;
pub const ERROR_DIRECTORY_NOT_RM: u32 = 6803;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE: u32 = 6805;
pub const ERROR_LOG_RESIZE_INVALID_SIZE: u32 = 6806;
pub const ERROR_OBJECT_NO_LONGER_EXISTS: u32 = 6807;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND: u32 = 6808;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID: u32 = 6809;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION: u32 = 6810;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT: u32 = 6811;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS: u32 = 6812;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH: u32 = 6814;
pub const ERROR_HANDLE_NO_LONGER_VALID: u32 = 6815;
pub const ERROR_NO_TXF_METADATA: u32 = 6816;
pub const ERROR_LOG_CORRUPTION_DETECTED: u32 = 6817;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN: u32 = 6818;
pub const ERROR_RM_DISCONNECTED: u32 = 6819;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR: u32 = 6820;
pub const ERROR_RECOVERY_NOT_NEEDED: u32 = 6821;
pub const ERROR_RM_ALREADY_STARTED: u32 = 6822;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT: u32 = 6823;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY: u32 = 6824;
pub const ERROR_CANT_CROSS_RM_BOUNDARY: u32 = 6825;
pub const ERROR_TXF_DIR_NOT_EMPTY: u32 = 6826;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST: u32 = 6827;
pub const ERROR_TM_VOLATILE: u32 = 6828;
pub const ERROR_ROLLBACK_TIMER_EXPIRED: u32 = 6829;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT: u32 = 6830;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION: u32 = 6831;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED: u32 = 6832;
pub const ERROR_LOG_GROWTH_FAILED: u32 = 6833;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE: u32 = 6834;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT: u32 = 6835;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET: u32 = 6836;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION: u32 = 6837;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION: u32 = 6838;
pub const ERROR_TRANSACTIONS_NOT_FROZEN: u32 = 6839;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS: u32 = 6840;
pub const ERROR_NOT_SNAPSHOT_VOLUME: u32 = 6841;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES: u32 = 6842;
pub const ERROR_DATA_LOST_REPAIR: u32 = 6843;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION: u32 = 6844;
pub const ERROR_TM_IDENTITY_MISMATCH: u32 = 6845;
pub const ERROR_FLOATED_SECTION: u32 = 6846;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK: u32 = 6847;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS: u32 = 6848;
pub const ERROR_BAD_CLUSTERS: u32 = 6849;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION: u32 = 6850;
pub const ERROR_VOLUME_DIRTY: u32 = 6851;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION: u32 = 6852;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION: u32 = 6853;
pub const ERROR_EXPIRED_HANDLE: u32 = 6854;
pub const ERROR_TRANSACTION_NOT_ENLISTED: u32 = 6855;
pub const ERROR_CTX_WINSTATION_NAME_INVALID: u32 = 7001;
pub const ERROR_CTX_INVALID_PD: u32 = 7002;
pub const ERROR_CTX_PD_NOT_FOUND: u32 = 7003;
pub const ERROR_CTX_WD_NOT_FOUND: u32 = 7004;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY: u32 = 7005;
pub const ERROR_CTX_SERVICE_NAME_COLLISION: u32 = 7006;
pub const ERROR_CTX_CLOSE_PENDING: u32 = 7007;
pub const ERROR_CTX_NO_OUTBUF: u32 = 7008;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND: u32 = 7009;
pub const ERROR_CTX_INVALID_MODEMNAME: u32 = 7010;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR: u32 = 7011;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: u32 = 7012;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER: u32 = 7013;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE: u32 = 7014;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY: u32 = 7015;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE: u32 = 7016;
pub const ERROR_CTX_TD_ERROR: u32 = 7017;
pub const ERROR_CTX_WINSTATION_NOT_FOUND: u32 = 7022;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS: u32 = 7023;
pub const ERROR_CTX_WINSTATION_BUSY: u32 = 7024;
pub const ERROR_CTX_BAD_VIDEO_MODE: u32 = 7025;
pub const ERROR_CTX_GRAPHICS_INVALID: u32 = 7035;
pub const ERROR_CTX_LOGON_DISABLED: u32 = 7037;
pub const ERROR_CTX_NOT_CONSOLE: u32 = 7038;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: u32 = 7040;
pub const ERROR_CTX_CONSOLE_DISCONNECT: u32 = 7041;
pub const ERROR_CTX_CONSOLE_CONNECT: u32 = 7042;
pub const ERROR_CTX_SHADOW_DENIED: u32 = 7044;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED: u32 = 7045;
pub const ERROR_CTX_INVALID_WD: u32 = 7049;
pub const ERROR_CTX_SHADOW_INVALID: u32 = 7050;
pub const ERROR_CTX_SHADOW_DISABLED: u32 = 7051;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE: u32 = 7052;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET: u32 = 7053;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE: u32 = 7054;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID: u32 = 7055;
pub const ERROR_CTX_LICENSE_EXPIRED: u32 = 7056;
pub const ERROR_CTX_SHADOW_NOT_RUNNING: u32 = 7057;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE: u32 = 7058;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED: u32 = 7059;
pub const ERROR_CTX_WINSTATIONS_DISABLED: u32 = 7060;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED: u32 = 7061;
pub const ERROR_CTX_SESSION_IN_USE: u32 = 7062;
pub const ERROR_CTX_NO_FORCE_LOGOFF: u32 = 7063;
pub const ERROR_CTX_ACCOUNT_RESTRICTION: u32 = 7064;
pub const ERROR_RDP_PROTOCOL_ERROR: u32 = 7065;
pub const ERROR_CTX_CDM_CONNECT: u32 = 7066;
pub const ERROR_CTX_CDM_DISCONNECT: u32 = 7067;
pub const ERROR_CTX_SECURITY_LAYER_ERROR: u32 = 7068;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS: u32 = 7069;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR: u32 = 7070;
pub const FRS_ERR_INVALID_API_SEQUENCE: u32 = 8001;
pub const FRS_ERR_STARTING_SERVICE: u32 = 8002;
pub const FRS_ERR_STOPPING_SERVICE: u32 = 8003;
pub const FRS_ERR_INTERNAL_API: u32 = 8004;
pub const FRS_ERR_INTERNAL: u32 = 8005;
pub const FRS_ERR_SERVICE_COMM: u32 = 8006;
pub const FRS_ERR_INSUFFICIENT_PRIV: u32 = 8007;
pub const FRS_ERR_AUTHENTICATION: u32 = 8008;
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV: u32 = 8009;
pub const FRS_ERR_PARENT_AUTHENTICATION: u32 = 8010;
pub const FRS_ERR_CHILD_TO_PARENT_COMM: u32 = 8011;
pub const FRS_ERR_PARENT_TO_CHILD_COMM: u32 = 8012;
pub const FRS_ERR_SYSVOL_POPULATE: u32 = 8013;
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: u32 = 8014;
pub const FRS_ERR_SYSVOL_IS_BUSY: u32 = 8015;
pub const FRS_ERR_SYSVOL_DEMOTE: u32 = 8016;
pub const FRS_ERR_INVALID_SERVICE_PARAMETER: u32 = 8017;
pub const DS_S_SUCCESS: u32 = 0;
pub const ERROR_DS_NOT_INSTALLED: u32 = 8200;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY: u32 = 8201;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE: u32 = 8202;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX: u32 = 8203;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED: u32 = 8204;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS: u32 = 8205;
pub const ERROR_DS_BUSY: u32 = 8206;
pub const ERROR_DS_UNAVAILABLE: u32 = 8207;
pub const ERROR_DS_NO_RIDS_ALLOCATED: u32 = 8208;
pub const ERROR_DS_NO_MORE_RIDS: u32 = 8209;
pub const ERROR_DS_INCORRECT_ROLE_OWNER: u32 = 8210;
pub const ERROR_DS_RIDMGR_INIT_ERROR: u32 = 8211;
pub const ERROR_DS_OBJ_CLASS_VIOLATION: u32 = 8212;
pub const ERROR_DS_CANT_ON_NON_LEAF: u32 = 8213;
pub const ERROR_DS_CANT_ON_RDN: u32 = 8214;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS: u32 = 8215;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR: u32 = 8216;
pub const ERROR_DS_GC_NOT_AVAILABLE: u32 = 8217;
pub const ERROR_SHARED_POLICY: u32 = 8218;
pub const ERROR_POLICY_OBJECT_NOT_FOUND: u32 = 8219;
pub const ERROR_POLICY_ONLY_IN_DS: u32 = 8220;
pub const ERROR_PROMOTION_ACTIVE: u32 = 8221;
pub const ERROR_NO_PROMOTION_ACTIVE: u32 = 8222;
pub const ERROR_DS_OPERATIONS_ERROR: u32 = 8224;
pub const ERROR_DS_PROTOCOL_ERROR: u32 = 8225;
pub const ERROR_DS_TIMELIMIT_EXCEEDED: u32 = 8226;
pub const ERROR_DS_SIZELIMIT_EXCEEDED: u32 = 8227;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED: u32 = 8228;
pub const ERROR_DS_COMPARE_FALSE: u32 = 8229;
pub const ERROR_DS_COMPARE_TRUE: u32 = 8230;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED: u32 = 8231;
pub const ERROR_DS_STRONG_AUTH_REQUIRED: u32 = 8232;
pub const ERROR_DS_INAPPROPRIATE_AUTH: u32 = 8233;
pub const ERROR_DS_AUTH_UNKNOWN: u32 = 8234;
pub const ERROR_DS_REFERRAL: u32 = 8235;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION: u32 = 8236;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED: u32 = 8237;
pub const ERROR_DS_INAPPROPRIATE_MATCHING: u32 = 8238;
pub const ERROR_DS_CONSTRAINT_VIOLATION: u32 = 8239;
pub const ERROR_DS_NO_SUCH_OBJECT: u32 = 8240;
pub const ERROR_DS_ALIAS_PROBLEM: u32 = 8241;
pub const ERROR_DS_INVALID_DN_SYNTAX: u32 = 8242;
pub const ERROR_DS_IS_LEAF: u32 = 8243;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM: u32 = 8244;
pub const ERROR_DS_UNWILLING_TO_PERFORM: u32 = 8245;
pub const ERROR_DS_LOOP_DETECT: u32 = 8246;
pub const ERROR_DS_NAMING_VIOLATION: u32 = 8247;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE: u32 = 8248;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS: u32 = 8249;
pub const ERROR_DS_SERVER_DOWN: u32 = 8250;
pub const ERROR_DS_LOCAL_ERROR: u32 = 8251;
pub const ERROR_DS_ENCODING_ERROR: u32 = 8252;
pub const ERROR_DS_DECODING_ERROR: u32 = 8253;
pub const ERROR_DS_FILTER_UNKNOWN: u32 = 8254;
pub const ERROR_DS_PARAM_ERROR: u32 = 8255;
pub const ERROR_DS_NOT_SUPPORTED: u32 = 8256;
pub const ERROR_DS_NO_RESULTS_RETURNED: u32 = 8257;
pub const ERROR_DS_CONTROL_NOT_FOUND: u32 = 8258;
pub const ERROR_DS_CLIENT_LOOP: u32 = 8259;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED: u32 = 8260;
pub const ERROR_DS_SORT_CONTROL_MISSING: u32 = 8261;
pub const ERROR_DS_OFFSET_RANGE_ERROR: u32 = 8262;
pub const ERROR_DS_RIDMGR_DISABLED: u32 = 8263;
pub const ERROR_DS_ROOT_MUST_BE_NC: u32 = 8301;
pub const ERROR_DS_ADD_REPLICA_INHIBITED: u32 = 8302;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA: u32 = 8303;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED: u32 = 8304;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS: u32 = 8305;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA: u32 = 8306;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA: u32 = 8307;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND: u32 = 8308;
pub const ERROR_DS_USER_BUFFER_TO_SMALL: u32 = 8309;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ: u32 = 8310;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION: u32 = 8311;
pub const ERROR_DS_OBJ_TOO_LARGE: u32 = 8312;
pub const ERROR_DS_BAD_INSTANCE_TYPE: u32 = 8313;
pub const ERROR_DS_MASTERDSA_REQUIRED: u32 = 8314;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED: u32 = 8315;
pub const ERROR_DS_MISSING_REQUIRED_ATT: u32 = 8316;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS: u32 = 8317;
pub const ERROR_DS_ATT_ALREADY_EXISTS: u32 = 8318;
pub const ERROR_DS_CANT_ADD_ATT_VALUES: u32 = 8320;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT: u32 = 8321;
pub const ERROR_DS_RANGE_CONSTRAINT: u32 = 8322;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS: u32 = 8323;
pub const ERROR_DS_CANT_REM_MISSING_ATT: u32 = 8324;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL: u32 = 8325;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF: u32 = 8326;
pub const ERROR_DS_NO_CHAINING: u32 = 8327;
pub const ERROR_DS_NO_CHAINED_EVAL: u32 = 8328;
pub const ERROR_DS_NO_PARENT_OBJECT: u32 = 8329;
pub const ERROR_DS_PARENT_IS_AN_ALIAS: u32 = 8330;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS: u32 = 8331;
pub const ERROR_DS_CHILDREN_EXIST: u32 = 8332;
pub const ERROR_DS_OBJ_NOT_FOUND: u32 = 8333;
pub const ERROR_DS_ALIASED_OBJ_MISSING: u32 = 8334;
pub const ERROR_DS_BAD_NAME_SYNTAX: u32 = 8335;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS: u32 = 8336;
pub const ERROR_DS_CANT_DEREF_ALIAS: u32 = 8337;
pub const ERROR_DS_OUT_OF_SCOPE: u32 = 8338;
pub const ERROR_DS_OBJECT_BEING_REMOVED: u32 = 8339;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ: u32 = 8340;
pub const ERROR_DS_GENERIC_ERROR: u32 = 8341;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER: u32 = 8342;
pub const ERROR_DS_CLASS_NOT_DSA: u32 = 8343;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS: u32 = 8344;
pub const ERROR_DS_ILLEGAL_SUPERIOR: u32 = 8345;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM: u32 = 8346;
pub const ERROR_DS_NAME_TOO_MANY_PARTS: u32 = 8347;
pub const ERROR_DS_NAME_TOO_LONG: u32 = 8348;
pub const ERROR_DS_NAME_VALUE_TOO_LONG: u32 = 8349;
pub const ERROR_DS_NAME_UNPARSEABLE: u32 = 8350;
pub const ERROR_DS_NAME_TYPE_UNKNOWN: u32 = 8351;
pub const ERROR_DS_NOT_AN_OBJECT: u32 = 8352;
pub const ERROR_DS_SEC_DESC_TOO_SHORT: u32 = 8353;
pub const ERROR_DS_SEC_DESC_INVALID: u32 = 8354;
pub const ERROR_DS_NO_DELETED_NAME: u32 = 8355;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT: u32 = 8356;
pub const ERROR_DS_NCNAME_MUST_BE_NC: u32 = 8357;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY: u32 = 8358;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE: u32 = 8359;
pub const ERROR_DS_INVALID_DMD: u32 = 8360;
pub const ERROR_DS_OBJ_GUID_EXISTS: u32 = 8361;
pub const ERROR_DS_NOT_ON_BACKLINK: u32 = 8362;
pub const ERROR_DS_NO_CROSSREF_FOR_NC: u32 = 8363;
pub const ERROR_DS_SHUTTING_DOWN: u32 = 8364;
pub const ERROR_DS_UNKNOWN_OPERATION: u32 = 8365;
pub const ERROR_DS_INVALID_ROLE_OWNER: u32 = 8366;
pub const ERROR_DS_COULDNT_CONTACT_FSMO: u32 = 8367;
pub const ERROR_DS_CROSS_NC_DN_RENAME: u32 = 8368;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY: u32 = 8369;
pub const ERROR_DS_REPLICATOR_ONLY: u32 = 8370;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED: u32 = 8371;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS: u32 = 8372;
pub const ERROR_DS_NAME_REFERENCE_INVALID: u32 = 8373;
pub const ERROR_DS_CROSS_REF_EXISTS: u32 = 8374;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF: u32 = 8375;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD: u32 = 8376;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX: u32 = 8377;
pub const ERROR_DS_DUP_RDN: u32 = 8378;
pub const ERROR_DS_DUP_OID: u32 = 8379;
pub const ERROR_DS_DUP_MAPI_ID: u32 = 8380;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID: u32 = 8381;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME: u32 = 8382;
pub const ERROR_DS_SEMANTIC_ATT_TEST: u32 = 8383;
pub const ERROR_DS_SYNTAX_MISMATCH: u32 = 8384;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE: u32 = 8385;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE: u32 = 8386;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE: u32 = 8387;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE: u32 = 8388;
pub const ERROR_DS_AUX_CLS_TEST_FAIL: u32 = 8389;
pub const ERROR_DS_NONEXISTENT_POSS_SUP: u32 = 8390;
pub const ERROR_DS_SUB_CLS_TEST_FAIL: u32 = 8391;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX: u32 = 8392;
pub const ERROR_DS_EXISTS_IN_AUX_CLS: u32 = 8393;
pub const ERROR_DS_EXISTS_IN_SUB_CLS: u32 = 8394;
pub const ERROR_DS_EXISTS_IN_POSS_SUP: u32 = 8395;
pub const ERROR_DS_RECALCSCHEMA_FAILED: u32 = 8396;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED: u32 = 8397;
pub const ERROR_DS_CANT_DELETE: u32 = 8398;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID: u32 = 8399;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX: u32 = 8400;
pub const ERROR_DS_CANT_CACHE_ATT: u32 = 8401;
pub const ERROR_DS_CANT_CACHE_CLASS: u32 = 8402;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE: u32 = 8403;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE: u32 = 8404;
pub const ERROR_DS_CANT_RETRIEVE_DN: u32 = 8405;
pub const ERROR_DS_MISSING_SUPREF: u32 = 8406;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE: u32 = 8407;
pub const ERROR_DS_CODE_INCONSISTENCY: u32 = 8408;
pub const ERROR_DS_DATABASE_ERROR: u32 = 8409;
pub const ERROR_DS_GOVERNSID_MISSING: u32 = 8410;
pub const ERROR_DS_MISSING_EXPECTED_ATT: u32 = 8411;
pub const ERROR_DS_NCNAME_MISSING_CR_REF: u32 = 8412;
pub const ERROR_DS_SECURITY_CHECKING_ERROR: u32 = 8413;
pub const ERROR_DS_SCHEMA_NOT_LOADED: u32 = 8414;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED: u32 = 8415;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX: u32 = 8416;
pub const ERROR_DS_GCVERIFY_ERROR: u32 = 8417;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH: u32 = 8418;
pub const ERROR_DS_CANT_FIND_DSA_OBJ: u32 = 8419;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC: u32 = 8420;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE: u32 = 8421;
pub const ERROR_DS_CANT_RETRIEVE_CHILD: u32 = 8422;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY: u32 = 8423;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC: u32 = 8424;
pub const ERROR_DS_BAD_HIERARCHY_FILE: u32 = 8425;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED: u32 = 8426;
pub const ERROR_DS_CONFIG_PARAM_MISSING: u32 = 8427;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED: u32 = 8428;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED: u32 = 8429;
pub const ERROR_DS_INTERNAL_FAILURE: u32 = 8430;
pub const ERROR_DS_UNKNOWN_ERROR: u32 = 8431;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP: u32 = 8432;
pub const ERROR_DS_REFUSING_FSMO_ROLES: u32 = 8433;
pub const ERROR_DS_MISSING_FSMO_SETTINGS: u32 = 8434;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES: u32 = 8435;
pub const ERROR_DS_DRA_GENERIC: u32 = 8436;
pub const ERROR_DS_DRA_INVALID_PARAMETER: u32 = 8437;
pub const ERROR_DS_DRA_BUSY: u32 = 8438;
pub const ERROR_DS_DRA_BAD_DN: u32 = 8439;
pub const ERROR_DS_DRA_BAD_NC: u32 = 8440;
pub const ERROR_DS_DRA_DN_EXISTS: u32 = 8441;
pub const ERROR_DS_DRA_INTERNAL_ERROR: u32 = 8442;
pub const ERROR_DS_DRA_INCONSISTENT_DIT: u32 = 8443;
pub const ERROR_DS_DRA_CONNECTION_FAILED: u32 = 8444;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE: u32 = 8445;
pub const ERROR_DS_DRA_OUT_OF_MEM: u32 = 8446;
pub const ERROR_DS_DRA_MAIL_PROBLEM: u32 = 8447;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS: u32 = 8448;
pub const ERROR_DS_DRA_REF_NOT_FOUND: u32 = 8449;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE: u32 = 8450;
pub const ERROR_DS_DRA_DB_ERROR: u32 = 8451;
pub const ERROR_DS_DRA_NO_REPLICA: u32 = 8452;
pub const ERROR_DS_DRA_ACCESS_DENIED: u32 = 8453;
pub const ERROR_DS_DRA_NOT_SUPPORTED: u32 = 8454;
pub const ERROR_DS_DRA_RPC_CANCELLED: u32 = 8455;
pub const ERROR_DS_DRA_SOURCE_DISABLED: u32 = 8456;
pub const ERROR_DS_DRA_SINK_DISABLED: u32 = 8457;
pub const ERROR_DS_DRA_NAME_COLLISION: u32 = 8458;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED: u32 = 8459;
pub const ERROR_DS_DRA_MISSING_PARENT: u32 = 8460;
pub const ERROR_DS_DRA_PREEMPTED: u32 = 8461;
pub const ERROR_DS_DRA_ABANDON_SYNC: u32 = 8462;
pub const ERROR_DS_DRA_SHUTDOWN: u32 = 8463;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET: u32 = 8464;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA: u32 = 8465;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED: u32 = 8466;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH: u32 = 8467;
pub const ERROR_DS_DUP_LINK_ID: u32 = 8468;
pub const ERROR_DS_NAME_ERROR_RESOLVING: u32 = 8469;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND: u32 = 8470;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE: u32 = 8471;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING: u32 = 8472;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY: u32 = 8473;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING: u32 = 8474;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD: u32 = 8475;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS: u32 = 8476;
pub const ERROR_DS_DRA_REPL_PENDING: u32 = 8477;
pub const ERROR_DS_DS_REQUIRED: u32 = 8478;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME: u32 = 8479;
pub const ERROR_DS_NON_BASE_SEARCH: u32 = 8480;
pub const ERROR_DS_CANT_RETRIEVE_ATTS: u32 = 8481;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK: u32 = 8482;
pub const ERROR_DS_EPOCH_MISMATCH: u32 = 8483;
pub const ERROR_DS_SRC_NAME_MISMATCH: u32 = 8484;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL: u32 = 8485;
pub const ERROR_DS_DST_NC_MISMATCH: u32 = 8486;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC: u32 = 8487;
pub const ERROR_DS_SRC_GUID_MISMATCH: u32 = 8488;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT: u32 = 8489;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS: u32 = 8490;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD: u32 = 8491;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION: u32 = 8492;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS: u32 = 8493;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT: u32 = 8494;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE: u32 = 8495;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE: u32 = 8496;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER: u32 = 8497;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP: u32 = 8498;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP: u32 = 8499;
pub const ERROR_DS_INVALID_SEARCH_FLAG: u32 = 8500;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC: u32 = 8501;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE: u32 = 8502;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE: u32 = 8503;
pub const ERROR_DS_SAM_INIT_FAILURE: u32 = 8504;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION: u32 = 8505;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID: u32 = 8506;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD: u32 = 8507;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE: u32 = 8508;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED: u32 = 8509;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA: u32 = 8510;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION: u32 = 8511;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE: u32 = 8512;
pub const ERROR_DS_INVALID_GROUP_TYPE: u32 = 8513;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: u32 = 8514;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: u32 = 8515;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8516;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8517;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8518;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: u32 = 8519;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: u32 = 8520;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS: u32 = 8521;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED: u32 = 8522;
pub const ERROR_DS_NAMING_MASTER_GC: u32 = 8523;
pub const ERROR_DS_DNS_LOOKUP_FAILURE: u32 = 8524;
pub const ERROR_DS_COULDNT_UPDATE_SPNS: u32 = 8525;
pub const ERROR_DS_CANT_RETRIEVE_SD: u32 = 8526;
pub const ERROR_DS_KEY_NOT_UNIQUE: u32 = 8527;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX: u32 = 8528;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD: u32 = 8529;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY: u32 = 8530;
pub const ERROR_DS_CANT_START: u32 = 8531;
pub const ERROR_DS_INIT_FAILURE: u32 = 8532;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION: u32 = 8533;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST: u32 = 8534;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST: u32 = 8535;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED: u32 = 8536;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN: u32 = 8537;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER: u32 = 8538;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST: u32 = 8539;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH: u32 = 8540;
pub const ERROR_SAM_INIT_FAILURE: u32 = 8541;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP: u32 = 8542;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT: u32 = 8543;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT: u32 = 8544;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH: u32 = 8545;
pub const ERROR_DS_NC_STILL_HAS_DSAS: u32 = 8546;
pub const ERROR_DS_GC_REQUIRED: u32 = 8547;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: u32 = 8548;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS: u32 = 8549;
pub const ERROR_DS_CANT_ADD_TO_GC: u32 = 8550;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC: u32 = 8551;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED: u32 = 8552;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC: u32 = 8553;
pub const ERROR_DS_INVALID_NAME_FOR_SPN: u32 = 8554;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: u32 = 8555;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES: u32 = 8556;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: u32 = 8557;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC: u32 = 8558;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER: u32 = 8559;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ: u32 = 8560;
pub const ERROR_DS_INIT_FAILURE_CONSOLE: u32 = 8561;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE: u32 = 8562;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH: u32 = 8563;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH: u32 = 8564;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW: u32 = 8565;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW: u32 = 8566;
pub const ERROR_DS_INCOMPATIBLE_VERSION: u32 = 8567;
pub const ERROR_DS_LOW_DSA_VERSION: u32 = 8568;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN: u32 = 8569;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER: u32 = 8570;
pub const ERROR_DS_NAME_NOT_UNIQUE: u32 = 8571;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4: u32 = 8572;
pub const ERROR_DS_OUT_OF_VERSION_STORE: u32 = 8573;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED: u32 = 8574;
pub const ERROR_DS_NO_REF_DOMAIN: u32 = 8575;
pub const ERROR_DS_RESERVED_LINK_ID: u32 = 8576;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE: u32 = 8577;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8578;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE: u32 = 8579;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC: u32 = 8580;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG: u32 = 8581;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT: u32 = 8582;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL: u32 = 8583;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER: u32 = 8584;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD: u32 = 8585;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2: u32 = 8586;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED: u32 = 8587;
pub const ERROR_DS_NOT_CLOSEST: u32 = 8588;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF: u32 = 8589;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED: u32 = 8590;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR: u32 = 8591;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR: u32 = 8592;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS: u32 = 8593;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED: u32 = 8594;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR: u32 = 8595;
pub const ERROR_DS_NO_MSDS_INTID: u32 = 8596;
pub const ERROR_DS_DUP_MSDS_INTID: u32 = 8597;
pub const ERROR_DS_EXISTS_IN_RDNATTID: u32 = 8598;
pub const ERROR_DS_AUTHORIZATION_FAILED: u32 = 8599;
pub const ERROR_DS_INVALID_SCRIPT: u32 = 8600;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED: u32 = 8601;
pub const ERROR_DS_CROSS_REF_BUSY: u32 = 8602;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN: u32 = 8603;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC: u32 = 8604;
pub const ERROR_DS_DUPLICATE_ID_FOUND: u32 = 8605;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT: u32 = 8606;
pub const ERROR_DS_GROUP_CONVERSION_ERROR: u32 = 8607;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP: u32 = 8608;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP: u32 = 8609;
pub const ERROR_DS_ROLE_NOT_VERIFIED: u32 = 8610;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL: u32 = 8611;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS: u32 = 8612;
pub const ERROR_DS_EXISTING_AD_CHILD_NC: u32 = 8613;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED: u32 = 8614;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER: u32 = 8615;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL: u32 = 8616;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW: u32 = 8617;
pub const ERROR_DS_POLICY_NOT_KNOWN: u32 = 8618;
pub const ERROR_NO_SITE_SETTINGS_OBJECT: u32 = 8619;
pub const ERROR_NO_SECRETS: u32 = 8620;
pub const ERROR_NO_WRITABLE_DC_FOUND: u32 = 8621;
pub const ERROR_DS_NO_SERVER_OBJECT: u32 = 8622;
pub const ERROR_DS_NO_NTDSA_OBJECT: u32 = 8623;
pub const ERROR_DS_NON_ASQ_SEARCH: u32 = 8624;
pub const ERROR_DS_AUDIT_FAILURE: u32 = 8625;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE: u32 = 8626;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE: u32 = 8627;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP: u32 = 8628;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR: u32 = 8629;
pub const ERROR_DS_DRA_SECRETS_DENIED: u32 = 8630;
pub const ERROR_DS_RESERVED_MAPI_ID: u32 = 8631;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE: u32 = 8632;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET: u32 = 8633;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST: u32 = 8634;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST: u32 = 8635;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME: u32 = 8636;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS: u32 = 8637;
pub const ERROR_DS_OID_NOT_FOUND: u32 = 8638;
pub const ERROR_DS_DRA_RECYCLED_TARGET: u32 = 8639;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT: u32 = 8640;
pub const ERROR_DS_HIGH_ADLDS_FFL: u32 = 8641;
pub const ERROR_DS_HIGH_DSA_VERSION: u32 = 8642;
pub const ERROR_DS_LOW_ADLDS_FFL: u32 = 8643;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION: u32 = 8644;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED: u32 = 8645;
pub const ERROR_INCORRECT_ACCOUNT_TYPE: u32 = 8646;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 8647;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST: u32 = 8648;
pub const ERROR_DS_MISSING_FOREST_TRUST: u32 = 8649;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE: u32 = 8650;
pub const ERROR_WEAK_WHFBKEY_BLOCKED: u32 = 8651;
pub const ERROR_DS_PER_ATTRIBUTE_AUTHZ_FAILED_DURING_ADD: u32 = 8652;
pub const ERROR_LOCAL_POLICY_MODIFICATION_NOT_SUPPORTED: u32 = 8653;
pub const DNS_ERROR_RESPONSE_CODES_BASE: u32 = 9000;
pub const DNS_ERROR_RCODE_NO_ERROR: u32 = 0;
pub const DNS_ERROR_MASK: u32 = 9000;
pub const DNS_ERROR_RCODE_FORMAT_ERROR: u32 = 9001;
pub const DNS_ERROR_RCODE_SERVER_FAILURE: u32 = 9002;
pub const DNS_ERROR_RCODE_NAME_ERROR: u32 = 9003;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED: u32 = 9004;
pub const DNS_ERROR_RCODE_REFUSED: u32 = 9005;
pub const DNS_ERROR_RCODE_YXDOMAIN: u32 = 9006;
pub const DNS_ERROR_RCODE_YXRRSET: u32 = 9007;
pub const DNS_ERROR_RCODE_NXRRSET: u32 = 9008;
pub const DNS_ERROR_RCODE_NOTAUTH: u32 = 9009;
pub const DNS_ERROR_RCODE_NOTZONE: u32 = 9010;
pub const DNS_ERROR_RCODE_BADSIG: u32 = 9016;
pub const DNS_ERROR_RCODE_BADKEY: u32 = 9017;
pub const DNS_ERROR_RCODE_BADTIME: u32 = 9018;
pub const DNS_ERROR_RCODE_LAST: u32 = 9018;
pub const DNS_ERROR_DNSSEC_BASE: u32 = 9100;
pub const DNS_ERROR_KEYMASTER_REQUIRED: u32 = 9101;
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE: u32 = 9102;
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1: u32 = 9103;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS: u32 = 9104;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM: u32 = 9105;
pub const DNS_ERROR_INVALID_KEY_SIZE: u32 = 9106;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE: u32 = 9107;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION: u32 = 9108;
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR: u32 = 9109;
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR: u32 = 9110;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION: u32 = 9111;
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE: u32 = 9112;
pub const DNS_ERROR_TOO_MANY_SKDS: u32 = 9113;
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD: u32 = 9114;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET: u32 = 9115;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS: u32 = 9116;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT: u32 = 9117;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK: u32 = 9118;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD: u32 = 9119;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED: u32 = 9120;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE: u32 = 9121;
pub const DNS_ERROR_BAD_KEYMASTER: u32 = 9122;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD: u32 = 9123;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT: u32 = 9124;
pub const DNS_ERROR_DNSSEC_IS_DISABLED: u32 = 9125;
pub const DNS_ERROR_INVALID_XML: u32 = 9126;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS: u32 = 9127;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE: u32 = 9128;
pub const DNS_ERROR_NSEC3_NAME_COLLISION: u32 = 9129;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1: u32 = 9130;
pub const DNS_ERROR_PACKET_FMT_BASE: u32 = 9500;
pub const DNS_INFO_NO_RECORDS: u32 = 9501;
pub const DNS_ERROR_BAD_PACKET: u32 = 9502;
pub const DNS_ERROR_NO_PACKET: u32 = 9503;
pub const DNS_ERROR_RCODE: u32 = 9504;
pub const DNS_ERROR_UNSECURE_PACKET: u32 = 9505;
pub const DNS_STATUS_PACKET_UNSECURE: u32 = 9505;
pub const DNS_REQUEST_PENDING: u32 = 9506;
pub const DNS_ERROR_NO_MEMORY: u32 = 14;
pub const DNS_ERROR_INVALID_NAME: u32 = 123;
pub const DNS_ERROR_INVALID_DATA: u32 = 13;
pub const DNS_ERROR_GENERAL_API_BASE: u32 = 9550;
pub const DNS_ERROR_INVALID_TYPE: u32 = 9551;
pub const DNS_ERROR_INVALID_IP_ADDRESS: u32 = 9552;
pub const DNS_ERROR_INVALID_PROPERTY: u32 = 9553;
pub const DNS_ERROR_TRY_AGAIN_LATER: u32 = 9554;
pub const DNS_ERROR_NOT_UNIQUE: u32 = 9555;
pub const DNS_ERROR_NON_RFC_NAME: u32 = 9556;
pub const DNS_STATUS_FQDN: u32 = 9557;
pub const DNS_STATUS_DOTTED_NAME: u32 = 9558;
pub const DNS_STATUS_SINGLE_PART_NAME: u32 = 9559;
pub const DNS_ERROR_INVALID_NAME_CHAR: u32 = 9560;
pub const DNS_ERROR_NUMERIC_NAME: u32 = 9561;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER: u32 = 9562;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION: u32 = 9563;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS: u32 = 9564;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS: u32 = 9565;
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL: u32 = 9566;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE: u32 = 9567;
pub const DNS_ERROR_BACKGROUND_LOADING: u32 = 9568;
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC: u32 = 9569;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME: u32 = 9570;
pub const DNS_ERROR_DELEGATION_REQUIRED: u32 = 9571;
pub const DNS_ERROR_INVALID_POLICY_TABLE: u32 = 9572;
pub const DNS_ERROR_ADDRESS_REQUIRED: u32 = 9573;
pub const DNS_ERROR_ZONE_BASE: u32 = 9600;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST: u32 = 9601;
pub const DNS_ERROR_NO_ZONE_INFO: u32 = 9602;
pub const DNS_ERROR_INVALID_ZONE_OPERATION: u32 = 9603;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR: u32 = 9604;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD: u32 = 9605;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS: u32 = 9606;
pub const DNS_ERROR_ZONE_LOCKED: u32 = 9607;
pub const DNS_ERROR_ZONE_CREATION_FAILED: u32 = 9608;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS: u32 = 9609;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS: u32 = 9610;
pub const DNS_ERROR_INVALID_ZONE_TYPE: u32 = 9611;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP: u32 = 9612;
pub const DNS_ERROR_ZONE_NOT_SECONDARY: u32 = 9613;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES: u32 = 9614;
pub const DNS_ERROR_WINS_INIT_FAILED: u32 = 9615;
pub const DNS_ERROR_NEED_WINS_SERVERS: u32 = 9616;
pub const DNS_ERROR_NBSTAT_INIT_FAILED: u32 = 9617;
pub const DNS_ERROR_SOA_DELETE_INVALID: u32 = 9618;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS: u32 = 9619;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP: u32 = 9620;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN: u32 = 9621;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING: u32 = 9622;
pub const DNS_ERROR_DATAFILE_BASE: u32 = 9650;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE: u32 = 9651;
pub const DNS_ERROR_INVALID_DATAFILE_NAME: u32 = 9652;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE: u32 = 9653;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED: u32 = 9654;
pub const DNS_ERROR_DATAFILE_PARSING: u32 = 9655;
pub const DNS_ERROR_DATABASE_BASE: u32 = 9700;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST: u32 = 9701;
pub const DNS_ERROR_RECORD_FORMAT: u32 = 9702;
pub const DNS_ERROR_NODE_CREATION_FAILED: u32 = 9703;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE: u32 = 9704;
pub const DNS_ERROR_RECORD_TIMED_OUT: u32 = 9705;
pub const DNS_ERROR_NAME_NOT_IN_ZONE: u32 = 9706;
pub const DNS_ERROR_CNAME_LOOP: u32 = 9707;
pub const DNS_ERROR_NODE_IS_CNAME: u32 = 9708;
pub const DNS_ERROR_CNAME_COLLISION: u32 = 9709;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT: u32 = 9710;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS: u32 = 9711;
pub const DNS_ERROR_SECONDARY_DATA: u32 = 9712;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA: u32 = 9713;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST: u32 = 9714;
pub const DNS_WARNING_PTR_CREATE_FAILED: u32 = 9715;
pub const DNS_WARNING_DOMAIN_UNDELETED: u32 = 9716;
pub const DNS_ERROR_DS_UNAVAILABLE: u32 = 9717;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS: u32 = 9718;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE: u32 = 9719;
pub const DNS_ERROR_NODE_IS_DNAME: u32 = 9720;
pub const DNS_ERROR_DNAME_COLLISION: u32 = 9721;
pub const DNS_ERROR_ALIAS_LOOP: u32 = 9722;
pub const DNS_ERROR_OPERATION_BASE: u32 = 9750;
pub const DNS_INFO_AXFR_COMPLETE: u32 = 9751;
pub const DNS_ERROR_AXFR: u32 = 9752;
pub const DNS_INFO_ADDED_LOCAL_WINS: u32 = 9753;
pub const DNS_ERROR_SECURE_BASE: u32 = 9800;
pub const DNS_STATUS_CONTINUE_NEEDED: u32 = 9801;
pub const DNS_ERROR_SETUP_BASE: u32 = 9850;
pub const DNS_ERROR_NO_TCPIP: u32 = 9851;
pub const DNS_ERROR_NO_DNS_SERVERS: u32 = 9852;
pub const DNS_ERROR_DP_BASE: u32 = 9900;
pub const DNS_ERROR_DP_DOES_NOT_EXIST: u32 = 9901;
pub const DNS_ERROR_DP_ALREADY_EXISTS: u32 = 9902;
pub const DNS_ERROR_DP_NOT_ENLISTED: u32 = 9903;
pub const DNS_ERROR_DP_ALREADY_ENLISTED: u32 = 9904;
pub const DNS_ERROR_DP_NOT_AVAILABLE: u32 = 9905;
pub const DNS_ERROR_DP_FSMO_ERROR: u32 = 9906;
pub const DNS_ERROR_RRL_NOT_ENABLED: u32 = 9911;
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE: u32 = 9912;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX: u32 = 9913;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX: u32 = 9914;
pub const DNS_ERROR_RRL_INVALID_TC_RATE: u32 = 9915;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE: u32 = 9916;
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE: u32 = 9917;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS: u32 = 9921;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST: u32 = 9922;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED: u32 = 9923;
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME: u32 = 9924;
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE: u32 = 9925;
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS: u32 = 9951;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST: u32 = 9952;
pub const DNS_ERROR_DEFAULT_ZONESCOPE: u32 = 9953;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME: u32 = 9954;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES: u32 = 9955;
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED: u32 = 9956;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED: u32 = 9957;
pub const DNS_ERROR_INVALID_SCOPE_NAME: u32 = 9958;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST: u32 = 9959;
pub const DNS_ERROR_DEFAULT_SCOPE: u32 = 9960;
pub const DNS_ERROR_INVALID_SCOPE_OPERATION: u32 = 9961;
pub const DNS_ERROR_SCOPE_LOCKED: u32 = 9962;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS: u32 = 9963;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS: u32 = 9971;
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST: u32 = 9972;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA: u32 = 9973;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS: u32 = 9974;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED: u32 = 9975;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST: u32 = 9976;
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS: u32 = 9977;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST: u32 = 9978;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS: u32 = 9979;
pub const DNS_ERROR_POLICY_LOCKED: u32 = 9980;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT: u32 = 9981;
pub const DNS_ERROR_POLICY_INVALID_NAME: u32 = 9982;
pub const DNS_ERROR_POLICY_MISSING_CRITERIA: u32 = 9983;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME: u32 = 9984;
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID: u32 = 9985;
pub const DNS_ERROR_POLICY_SCOPE_MISSING: u32 = 9986;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED: u32 = 9987;
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED: u32 = 9988;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED: u32 = 9989;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET: u32 = 9990;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL: u32 = 9991;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL: u32 = 9992;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE: u32 = 9993;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN: u32 = 9994;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE: u32 = 9995;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY: u32 = 9996;
pub const WSABASEERR: u32 = 10000;
pub const WSAEINTR: u32 = 10004;
pub const WSAEBADF: u32 = 10009;
pub const WSAEACCES: u32 = 10013;
pub const WSAEFAULT: u32 = 10014;
pub const WSAEINVAL: u32 = 10022;
pub const WSAEMFILE: u32 = 10024;
pub const WSAEWOULDBLOCK: u32 = 10035;
pub const WSAEINPROGRESS: u32 = 10036;
pub const WSAEALREADY: u32 = 10037;
pub const WSAENOTSOCK: u32 = 10038;
pub const WSAEDESTADDRREQ: u32 = 10039;
pub const WSAEMSGSIZE: u32 = 10040;
pub const WSAEPROTOTYPE: u32 = 10041;
pub const WSAENOPROTOOPT: u32 = 10042;
pub const WSAEPROTONOSUPPORT: u32 = 10043;
pub const WSAESOCKTNOSUPPORT: u32 = 10044;
pub const WSAEOPNOTSUPP: u32 = 10045;
pub const WSAEPFNOSUPPORT: u32 = 10046;
pub const WSAEAFNOSUPPORT: u32 = 10047;
pub const WSAEADDRINUSE: u32 = 10048;
pub const WSAEADDRNOTAVAIL: u32 = 10049;
pub const WSAENETDOWN: u32 = 10050;
pub const WSAENETUNREACH: u32 = 10051;
pub const WSAENETRESET: u32 = 10052;
pub const WSAECONNABORTED: u32 = 10053;
pub const WSAECONNRESET: u32 = 10054;
pub const WSAENOBUFS: u32 = 10055;
pub const WSAEISCONN: u32 = 10056;
pub const WSAENOTCONN: u32 = 10057;
pub const WSAESHUTDOWN: u32 = 10058;
pub const WSAETOOMANYREFS: u32 = 10059;
pub const WSAETIMEDOUT: u32 = 10060;
pub const WSAECONNREFUSED: u32 = 10061;
pub const WSAELOOP: u32 = 10062;
pub const WSAENAMETOOLONG: u32 = 10063;
pub const WSAEHOSTDOWN: u32 = 10064;
pub const WSAEHOSTUNREACH: u32 = 10065;
pub const WSAENOTEMPTY: u32 = 10066;
pub const WSAEPROCLIM: u32 = 10067;
pub const WSAEUSERS: u32 = 10068;
pub const WSAEDQUOT: u32 = 10069;
pub const WSAESTALE: u32 = 10070;
pub const WSAEREMOTE: u32 = 10071;
pub const WSASYSNOTREADY: u32 = 10091;
pub const WSAVERNOTSUPPORTED: u32 = 10092;
pub const WSANOTINITIALISED: u32 = 10093;
pub const WSAEDISCON: u32 = 10101;
pub const WSAENOMORE: u32 = 10102;
pub const WSAECANCELLED: u32 = 10103;
pub const WSAEINVALIDPROCTABLE: u32 = 10104;
pub const WSAEINVALIDPROVIDER: u32 = 10105;
pub const WSAEPROVIDERFAILEDINIT: u32 = 10106;
pub const WSASYSCALLFAILURE: u32 = 10107;
pub const WSASERVICE_NOT_FOUND: u32 = 10108;
pub const WSATYPE_NOT_FOUND: u32 = 10109;
pub const WSA_E_NO_MORE: u32 = 10110;
pub const WSA_E_CANCELLED: u32 = 10111;
pub const WSAEREFUSED: u32 = 10112;
pub const WSAHOST_NOT_FOUND: u32 = 11001;
pub const WSATRY_AGAIN: u32 = 11002;
pub const WSANO_RECOVERY: u32 = 11003;
pub const WSANO_DATA: u32 = 11004;
pub const WSA_QOS_RECEIVERS: u32 = 11005;
pub const WSA_QOS_SENDERS: u32 = 11006;
pub const WSA_QOS_NO_SENDERS: u32 = 11007;
pub const WSA_QOS_NO_RECEIVERS: u32 = 11008;
pub const WSA_QOS_REQUEST_CONFIRMED: u32 = 11009;
pub const WSA_QOS_ADMISSION_FAILURE: u32 = 11010;
pub const WSA_QOS_POLICY_FAILURE: u32 = 11011;
pub const WSA_QOS_BAD_STYLE: u32 = 11012;
pub const WSA_QOS_BAD_OBJECT: u32 = 11013;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR: u32 = 11014;
pub const WSA_QOS_GENERIC_ERROR: u32 = 11015;
pub const WSA_QOS_ESERVICETYPE: u32 = 11016;
pub const WSA_QOS_EFLOWSPEC: u32 = 11017;
pub const WSA_QOS_EPROVSPECBUF: u32 = 11018;
pub const WSA_QOS_EFILTERSTYLE: u32 = 11019;
pub const WSA_QOS_EFILTERTYPE: u32 = 11020;
pub const WSA_QOS_EFILTERCOUNT: u32 = 11021;
pub const WSA_QOS_EOBJLENGTH: u32 = 11022;
pub const WSA_QOS_EFLOWCOUNT: u32 = 11023;
pub const WSA_QOS_EUNKOWNPSOBJ: u32 = 11024;
pub const WSA_QOS_EPOLICYOBJ: u32 = 11025;
pub const WSA_QOS_EFLOWDESC: u32 = 11026;
pub const WSA_QOS_EPSFLOWSPEC: u32 = 11027;
pub const WSA_QOS_EPSFILTERSPEC: u32 = 11028;
pub const WSA_QOS_ESDMODEOBJ: u32 = 11029;
pub const WSA_QOS_ESHAPERATEOBJ: u32 = 11030;
pub const WSA_QOS_RESERVED_PETYPE: u32 = 11031;
pub const WSA_SECURE_HOST_NOT_FOUND: u32 = 11032;
pub const WSA_IPSEC_NAME_POLICY_ERROR: u32 = 11033;
pub const ERROR_IPSEC_QM_POLICY_EXISTS: u32 = 13000;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND: u32 = 13001;
pub const ERROR_IPSEC_QM_POLICY_IN_USE: u32 = 13002;
pub const ERROR_IPSEC_MM_POLICY_EXISTS: u32 = 13003;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND: u32 = 13004;
pub const ERROR_IPSEC_MM_POLICY_IN_USE: u32 = 13005;
pub const ERROR_IPSEC_MM_FILTER_EXISTS: u32 = 13006;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND: u32 = 13007;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS: u32 = 13008;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND: u32 = 13009;
pub const ERROR_IPSEC_MM_AUTH_EXISTS: u32 = 13010;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND: u32 = 13011;
pub const ERROR_IPSEC_MM_AUTH_IN_USE: u32 = 13012;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND: u32 = 13013;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND: u32 = 13014;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND: u32 = 13015;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS: u32 = 13016;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND: u32 = 13017;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION: u32 = 13018;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION: u32 = 13019;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION: u32 = 13020;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION: u32 = 13021;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION: u32 = 13022;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION: u32 = 13023;
pub const WARNING_IPSEC_MM_POLICY_PRUNED: u32 = 13024;
pub const WARNING_IPSEC_QM_POLICY_PRUNED: u32 = 13025;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN: u32 = 13800;
pub const ERROR_IPSEC_IKE_AUTH_FAIL: u32 = 13801;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL: u32 = 13802;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING: u32 = 13803;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR: u32 = 13804;
pub const ERROR_IPSEC_IKE_TIMED_OUT: u32 = 13805;
pub const ERROR_IPSEC_IKE_NO_CERT: u32 = 13806;
pub const ERROR_IPSEC_IKE_SA_DELETED: u32 = 13807;
pub const ERROR_IPSEC_IKE_SA_REAPED: u32 = 13808;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP: u32 = 13809;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP: u32 = 13810;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM: u32 = 13811;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM: u32 = 13812;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE: u32 = 13813;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP: u32 = 13814;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP: u32 = 13815;
pub const ERROR_IPSEC_IKE_ERROR: u32 = 13816;
pub const ERROR_IPSEC_IKE_CRL_FAILED: u32 = 13817;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE: u32 = 13818;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE: u32 = 13819;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY: u32 = 13820;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY: u32 = 13821;
pub const ERROR_IPSEC_IKE_DH_FAIL: u32 = 13822;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED: u32 = 13823;
pub const ERROR_IPSEC_IKE_INVALID_HEADER: u32 = 13824;
pub const ERROR_IPSEC_IKE_NO_POLICY: u32 = 13825;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE: u32 = 13826;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR: u32 = 13827;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY: u32 = 13828;
pub const ERROR_IPSEC_IKE_PROCESS_ERR: u32 = 13829;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA: u32 = 13830;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP: u32 = 13831;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS: u32 = 13832;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE: u32 = 13833;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID: u32 = 13834;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT: u32 = 13835;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ: u32 = 13836;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH: u32 = 13837;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG: u32 = 13838;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE: u32 = 13839;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY: u32 = 13840;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE: u32 = 13841;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR: u32 = 13842;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD: u32 = 13843;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA: u32 = 13844;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN: u32 = 13845;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE: u32 = 13846;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT: u32 = 13847;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED: u32 = 13848;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE: u32 = 13849;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY: u32 = 13850;
pub const ERROR_IPSEC_IKE_NOTCBPRIV: u32 = 13851;
pub const ERROR_IPSEC_IKE_SECLOADFAIL: u32 = 13852;
pub const ERROR_IPSEC_IKE_FAILSSPINIT: u32 = 13853;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP: u32 = 13854;
pub const ERROR_IPSEC_IKE_SRVACQFAIL: u32 = 13855;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED: u32 = 13856;
pub const ERROR_IPSEC_IKE_GETSPIFAIL: u32 = 13857;
pub const ERROR_IPSEC_IKE_INVALID_FILTER: u32 = 13858;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY: u32 = 13859;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED: u32 = 13860;
pub const ERROR_IPSEC_IKE_INVALID_POLICY: u32 = 13861;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI: u32 = 13862;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION: u32 = 13863;
pub const ERROR_IPSEC_IKE_DH_FAILURE: u32 = 13864;
pub const ERROR_IPSEC_IKE_INVALID_GROUP: u32 = 13865;
pub const ERROR_IPSEC_IKE_ENCRYPT: u32 = 13866;
pub const ERROR_IPSEC_IKE_DECRYPT: u32 = 13867;
pub const ERROR_IPSEC_IKE_POLICY_MATCH: u32 = 13868;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID: u32 = 13869;
pub const ERROR_IPSEC_IKE_INVALID_HASH: u32 = 13870;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG: u32 = 13871;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE: u32 = 13872;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG: u32 = 13873;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG: u32 = 13874;
pub const ERROR_IPSEC_IKE_INVALID_SIG: u32 = 13875;
pub const ERROR_IPSEC_IKE_LOAD_FAILED: u32 = 13876;
pub const ERROR_IPSEC_IKE_RPC_DELETE: u32 = 13877;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT: u32 = 13878;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY: u32 = 13879;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION: u32 = 13880;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN: u32 = 13881;
pub const ERROR_IPSEC_IKE_MM_LIMIT: u32 = 13882;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED: u32 = 13883;
pub const ERROR_IPSEC_IKE_QM_LIMIT: u32 = 13884;
pub const ERROR_IPSEC_IKE_MM_EXPIRED: u32 = 13885;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID: u32 = 13886;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH: u32 = 13887;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID: u32 = 13888;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD: u32 = 13889;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT: u32 = 13890;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN: u32 = 13891;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED: u32 = 13892;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA: u32 = 13893;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM: u32 = 13894;
pub const ERROR_IPSEC_IKE_QM_EXPIRED: u32 = 13895;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS: u32 = 13896;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END: u32 = 13897;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL: u32 = 13898;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE: u32 = 13899;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING: u32 = 13900;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING: u32 = 13901;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS: u32 = 13902;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP: u32 = 13903;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE: u32 = 13904;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE: u32 = 13905;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE: u32 = 13906;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY: u32 = 13907;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE: u32 = 13908;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END: u32 = 13909;
pub const ERROR_IPSEC_BAD_SPI: u32 = 13910;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED: u32 = 13911;
pub const ERROR_IPSEC_WRONG_SA: u32 = 13912;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED: u32 = 13913;
pub const ERROR_IPSEC_INVALID_PACKET: u32 = 13914;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED: u32 = 13915;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP: u32 = 13916;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP: u32 = 13917;
pub const ERROR_IPSEC_THROTTLE_DROP: u32 = 13918;
pub const ERROR_IPSEC_DOSP_BLOCK: u32 = 13925;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST: u32 = 13926;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET: u32 = 13927;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED: u32 = 13928;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES: u32 = 13929;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED: u32 = 13930;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED: u32 = 13931;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES: u32 = 13932;
pub const ERROR_SXS_SECTION_NOT_FOUND: u32 = 14000;
pub const ERROR_SXS_CANT_GEN_ACTCTX: u32 = 14001;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT: u32 = 14002;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND: u32 = 14003;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR: u32 = 14004;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR: u32 = 14005;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED: u32 = 14006;
pub const ERROR_SXS_KEY_NOT_FOUND: u32 = 14007;
pub const ERROR_SXS_VERSION_CONFLICT: u32 = 14008;
pub const ERROR_SXS_WRONG_SECTION_TYPE: u32 = 14009;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED: u32 = 14010;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET: u32 = 14011;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP: u32 = 14012;
pub const ERROR_SXS_UNKNOWN_ENCODING: u32 = 14013;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI: u32 = 14014;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14015;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14016;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14017;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE: u32 = 14018;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE: u32 = 14019;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT: u32 = 14020;
pub const ERROR_SXS_DUPLICATE_DLL_NAME: u32 = 14021;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME: u32 = 14022;
pub const ERROR_SXS_DUPLICATE_CLSID: u32 = 14023;
pub const ERROR_SXS_DUPLICATE_IID: u32 = 14024;
pub const ERROR_SXS_DUPLICATE_TLBID: u32 = 14025;
pub const ERROR_SXS_DUPLICATE_PROGID: u32 = 14026;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME: u32 = 14027;
pub const ERROR_SXS_FILE_HASH_MISMATCH: u32 = 14028;
pub const ERROR_SXS_POLICY_PARSE_ERROR: u32 = 14029;
pub const ERROR_SXS_XML_E_MISSINGQUOTE: u32 = 14030;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX: u32 = 14031;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR: u32 = 14032;
pub const ERROR_SXS_XML_E_BADNAMECHAR: u32 = 14033;
pub const ERROR_SXS_XML_E_BADCHARINSTRING: u32 = 14034;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX: u32 = 14035;
pub const ERROR_SXS_XML_E_BADCHARDATA: u32 = 14036;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE: u32 = 14037;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND: u32 = 14038;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON: u32 = 14039;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN: u32 = 14040;
pub const ERROR_SXS_XML_E_INTERNALERROR: u32 = 14041;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE: u32 = 14042;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING: u32 = 14043;
pub const ERROR_SXS_XML_E_MISSING_PAREN: u32 = 14044;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE: u32 = 14045;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS: u32 = 14046;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL: u32 = 14047;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL: u32 = 14048;
pub const ERROR_SXS_XML_E_INVALID_UNICODE: u32 = 14049;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK: u32 = 14050;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG: u32 = 14051;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG: u32 = 14052;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE: u32 = 14053;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS: u32 = 14054;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL: u32 = 14055;
pub const ERROR_SXS_XML_E_BADXMLDECL: u32 = 14056;
pub const ERROR_SXS_XML_E_MISSINGROOT: u32 = 14057;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF: u32 = 14058;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET: u32 = 14059;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG: u32 = 14060;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG: u32 = 14061;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING: u32 = 14062;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT: u32 = 14063;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL: u32 = 14064;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA: u32 = 14065;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE: u32 = 14066;
pub const ERROR_SXS_XML_E_INVALIDENCODING: u32 = 14067;
pub const ERROR_SXS_XML_E_INVALIDSWITCH: u32 = 14068;
pub const ERROR_SXS_XML_E_BADXMLCASE: u32 = 14069;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE: u32 = 14070;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE: u32 = 14071;
pub const ERROR_SXS_XML_E_INVALID_VERSION: u32 = 14072;
pub const ERROR_SXS_XML_E_MISSINGEQUALS: u32 = 14073;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED: u32 = 14074;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT: u32 = 14075;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID: u32 = 14076;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT: u32 = 14077;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING: u32 = 14078;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14079;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME: u32 = 14080;
pub const ERROR_SXS_ASSEMBLY_MISSING: u32 = 14081;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK: u32 = 14082;
pub const ERROR_SXS_CORRUPTION: u32 = 14083;
pub const ERROR_SXS_EARLY_DEACTIVATION: u32 = 14084;
pub const ERROR_SXS_INVALID_DEACTIVATION: u32 = 14085;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION: u32 = 14086;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED: u32 = 14087;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT: u32 = 14088;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY: u32 = 14089;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE: u32 = 14090;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME: u32 = 14091;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE: u32 = 14092;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR: u32 = 14093;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING: u32 = 14094;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN: u32 = 14095;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING: u32 = 14096;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED: u32 = 14097;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT: u32 = 14098;
pub const ERROR_ADVANCED_INSTALLER_FAILED: u32 = 14099;
pub const ERROR_XML_ENCODING_MISMATCH: u32 = 14100;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT: u32 = 14101;
pub const ERROR_SXS_IDENTITIES_DIFFERENT: u32 = 14102;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT: u32 = 14103;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY: u32 = 14104;
pub const ERROR_SXS_MANIFEST_TOO_BIG: u32 = 14105;
pub const ERROR_SXS_SETTING_NOT_REGISTERED: u32 = 14106;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE: u32 = 14107;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED: u32 = 14108;
pub const ERROR_GENERIC_COMMAND_FAILED: u32 = 14109;
pub const ERROR_SXS_FILE_HASH_MISSING: u32 = 14110;
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS: u32 = 14111;
pub const ERROR_EVT_INVALID_CHANNEL_PATH: u32 = 15000;
pub const ERROR_EVT_INVALID_QUERY: u32 = 15001;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND: u32 = 15002;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND: u32 = 15003;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME: u32 = 15004;
pub const ERROR_EVT_INVALID_EVENT_DATA: u32 = 15005;
pub const ERROR_EVT_CHANNEL_NOT_FOUND: u32 = 15007;
pub const ERROR_EVT_MALFORMED_XML_TEXT: u32 = 15008;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL: u32 = 15009;
pub const ERROR_EVT_CONFIGURATION_ERROR: u32 = 15010;
pub const ERROR_EVT_QUERY_RESULT_STALE: u32 = 15011;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION: u32 = 15012;
pub const ERROR_EVT_NON_VALIDATING_MSXML: u32 = 15013;
pub const ERROR_EVT_FILTER_ALREADYSCOPED: u32 = 15014;
pub const ERROR_EVT_FILTER_NOTELTSET: u32 = 15015;
pub const ERROR_EVT_FILTER_INVARG: u32 = 15016;
pub const ERROR_EVT_FILTER_INVTEST: u32 = 15017;
pub const ERROR_EVT_FILTER_INVTYPE: u32 = 15018;
pub const ERROR_EVT_FILTER_PARSEERR: u32 = 15019;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP: u32 = 15020;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN: u32 = 15021;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL: u32 = 15022;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE: u32 = 15023;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE: u32 = 15024;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE: u32 = 15025;
pub const ERROR_EVT_FILTER_TOO_COMPLEX: u32 = 15026;
pub const ERROR_EVT_MESSAGE_NOT_FOUND: u32 = 15027;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND: u32 = 15028;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT: u32 = 15029;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT: u32 = 15030;
pub const ERROR_EVT_MAX_INSERTS_REACHED: u32 = 15031;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND: u32 = 15032;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND: u32 = 15033;
pub const ERROR_EVT_VERSION_TOO_OLD: u32 = 15034;
pub const ERROR_EVT_VERSION_TOO_NEW: u32 = 15035;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY: u32 = 15036;
pub const ERROR_EVT_PUBLISHER_DISABLED: u32 = 15037;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE: u32 = 15038;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE: u32 = 15080;
pub const ERROR_EC_LOG_DISABLED: u32 = 15081;
pub const ERROR_EC_CIRCULAR_FORWARDING: u32 = 15082;
pub const ERROR_EC_CREDSTORE_FULL: u32 = 15083;
pub const ERROR_EC_CRED_NOT_FOUND: u32 = 15084;
pub const ERROR_EC_NO_ACTIVE_CHANNEL: u32 = 15085;
pub const ERROR_MUI_FILE_NOT_FOUND: u32 = 15100;
pub const ERROR_MUI_INVALID_FILE: u32 = 15101;
pub const ERROR_MUI_INVALID_RC_CONFIG: u32 = 15102;
pub const ERROR_MUI_INVALID_LOCALE_NAME: u32 = 15103;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME: u32 = 15104;
pub const ERROR_MUI_FILE_NOT_LOADED: u32 = 15105;
pub const ERROR_RESOURCE_ENUM_USER_STOP: u32 = 15106;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED: u32 = 15107;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME: u32 = 15108;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE: u32 = 15110;
pub const ERROR_MRM_INVALID_PRICONFIG: u32 = 15111;
pub const ERROR_MRM_INVALID_FILE_TYPE: u32 = 15112;
pub const ERROR_MRM_UNKNOWN_QUALIFIER: u32 = 15113;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE: u32 = 15114;
pub const ERROR_MRM_NO_CANDIDATE: u32 = 15115;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE: u32 = 15116;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH: u32 = 15117;
pub const ERROR_MRM_DUPLICATE_MAP_NAME: u32 = 15118;
pub const ERROR_MRM_DUPLICATE_ENTRY: u32 = 15119;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER: u32 = 15120;
pub const ERROR_MRM_FILEPATH_TOO_LONG: u32 = 15121;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE: u32 = 15122;
pub const ERROR_MRM_INVALID_PRI_FILE: u32 = 15126;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND: u32 = 15127;
pub const ERROR_MRM_MAP_NOT_FOUND: u32 = 15135;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE: u32 = 15136;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR: u32 = 15137;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE: u32 = 15138;
pub const ERROR_MRM_AUTOMERGE_ENABLED: u32 = 15139;
pub const ERROR_MRM_TOO_MANY_RESOURCES: u32 = 15140;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE: u32 = 15141;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE: u32 = 15142;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD: u32 = 15143;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST: u32 = 15144;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT: u32 = 15145;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE: u32 = 15146;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH: u32 = 15147;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH: u32 = 15148;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA: u32 = 15149;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED: u32 = 15150;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED: u32 = 15151;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED: u32 = 15152;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED: u32 = 15153;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED: u32 = 15154;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED: u32 = 15155;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED: u32 = 15156;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED: u32 = 15157;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME: u32 = 15158;
pub const ERROR_MRM_PACKAGE_NOT_FOUND: u32 = 15159;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE: u32 = 15160;
pub const ERROR_MRM_SCOPE_ITEM_CONFLICT: u32 = 15161;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING: u32 = 15200;
pub const ERROR_MCA_INVALID_VCP_VERSION: u32 = 15201;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION: u32 = 15202;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH: u32 = 15203;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION: u32 = 15204;
pub const ERROR_MCA_INTERNAL_ERROR: u32 = 15205;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED: u32 = 15206;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE: u32 = 15207;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE: u32 = 15250;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND: u32 = 15299;
pub const ERROR_HASH_NOT_SUPPORTED: u32 = 15300;
pub const ERROR_HASH_NOT_PRESENT: u32 = 15301;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED: u32 = 15321;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID: u32 = 15322;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED: u32 = 15323;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET: u32 = 15324;
pub const ERROR_GPIO_OPERATION_DENIED: u32 = 15325;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE: u32 = 15326;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED: u32 = 15327;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL: u32 = 15400;
pub const ERROR_INVALID_RUNLEVEL_SETTING: u32 = 15401;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT: u32 = 15402;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT: u32 = 15403;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS: u32 = 15404;
pub const ERROR_SERVICES_FAILED_AUTOSTART: u32 = 15405;
pub const ERROR_COM_TASK_STOP_PENDING: u32 = 15501;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED: u32 = 15600;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND: u32 = 15601;
pub const ERROR_INSTALL_INVALID_PACKAGE: u32 = 15602;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED: u32 = 15603;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE: u32 = 15604;
pub const ERROR_INSTALL_NETWORK_FAILURE: u32 = 15605;
pub const ERROR_INSTALL_REGISTRATION_FAILURE: u32 = 15606;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE: u32 = 15607;
pub const ERROR_INSTALL_CANCEL: u32 = 15608;
pub const ERROR_INSTALL_FAILED: u32 = 15609;
pub const ERROR_REMOVE_FAILED: u32 = 15610;
pub const ERROR_PACKAGE_ALREADY_EXISTS: u32 = 15611;
pub const ERROR_NEEDS_REMEDIATION: u32 = 15612;
pub const ERROR_INSTALL_PREREQUISITE_FAILED: u32 = 15613;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED: u32 = 15614;
pub const ERROR_INSTALL_POLICY_FAILURE: u32 = 15615;
pub const ERROR_PACKAGE_UPDATING: u32 = 15616;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY: u32 = 15617;
pub const ERROR_PACKAGES_IN_USE: u32 = 15618;
pub const ERROR_RECOVERY_FILE_CORRUPT: u32 = 15619;
pub const ERROR_INVALID_STAGED_SIGNATURE: u32 = 15620;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED: u32 = 15621;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE: u32 = 15622;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION: u32 = 15623;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN: u32 = 15624;
pub const ERROR_RESILIENCY_FILE_CORRUPT: u32 = 15625;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING: u32 = 15626;
pub const ERROR_PACKAGE_MOVE_FAILED: u32 = 15627;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY: u32 = 15628;
pub const ERROR_INSTALL_VOLUME_OFFLINE: u32 = 15629;
pub const ERROR_INSTALL_VOLUME_CORRUPT: u32 = 15630;
pub const ERROR_NEEDS_REGISTRATION: u32 = 15631;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE: u32 = 15632;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED: u32 = 15633;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE: u32 = 15634;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM: u32 = 15635;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING: u32 = 15636;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE: u32 = 15637;
pub const ERROR_PACKAGE_STAGING_ONHOLD: u32 = 15638;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE: u32 = 15639;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY: u32 = 15640;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF: u32 = 15641;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED: u32 = 15642;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED: u32 = 15643;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT: u32 = 15644;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED: u32 = 15645;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED: u32 = 15646;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED: u32 = 15647;
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED: u32 = 15648;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE: u32 = 15649;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE: u32 = 15650;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY: u32 = 15651;
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY: u32 = 15652;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER: u32 = 15653;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED: u32 = 15654;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE: u32 = 15655;
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES: u32 = 15656;
pub const ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED: u32 = 15657;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST: u32 = 15658;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT: u32 = 15659;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE: u32 = 15660;
pub const ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE: u32 = 15661;
pub const ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED: u32 = 15662;
pub const ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY: u32 =
    15663;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_FOR_MANDATORY_STARTUPTASKS: u32 = 15664;
pub const ERROR_INSTALL_RESOLVE_HOSTRUNTIME_DEPENDENCY_FAILED: u32 = 15665;
pub const ERROR_MACHINE_SCOPE_NOT_ALLOWED: u32 = 15666;
pub const ERROR_CLASSIC_COMPAT_MODE_NOT_ALLOWED: u32 = 15667;
pub const ERROR_STAGEFROMUPDATEAGENT_PACKAGE_NOT_APPLICABLE: u32 = 15668;
pub const ERROR_PACKAGE_NOT_REGISTERED_FOR_USER: u32 = 15669;
pub const ERROR_PACKAGE_NAME_MISMATCH: u32 = 15670;
pub const ERROR_APPINSTALLER_URI_IN_USE: u32 = 15671;
pub const ERROR_APPINSTALLER_IS_MANAGED_BY_SYSTEM: u32 = 15672;
pub const APPMODEL_ERROR_NO_PACKAGE: u32 = 15700;
pub const APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT: u32 = 15701;
pub const APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT: u32 = 15702;
pub const APPMODEL_ERROR_NO_APPLICATION: u32 = 15703;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED: u32 = 15704;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID: u32 = 15705;
pub const APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE: u32 = 15706;
pub const APPMODEL_ERROR_NO_MUTABLE_DIRECTORY: u32 = 15707;
pub const ERROR_STATE_LOAD_STORE_FAILED: u32 = 15800;
pub const ERROR_STATE_GET_VERSION_FAILED: u32 = 15801;
pub const ERROR_STATE_SET_VERSION_FAILED: u32 = 15802;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED: u32 = 15803;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED: u32 = 15804;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED: u32 = 15805;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED: u32 = 15806;
pub const ERROR_STATE_READ_SETTING_FAILED: u32 = 15807;
pub const ERROR_STATE_WRITE_SETTING_FAILED: u32 = 15808;
pub const ERROR_STATE_DELETE_SETTING_FAILED: u32 = 15809;
pub const ERROR_STATE_QUERY_SETTING_FAILED: u32 = 15810;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED: u32 = 15811;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED: u32 = 15812;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED: u32 = 15813;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED: u32 = 15814;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 15815;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: u32 = 15816;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED: u32 = 15817;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED: u32 = 15818;
pub const ERROR_API_UNAVAILABLE: u32 = 15841;
pub const STORE_ERROR_UNLICENSED: u32 = 15861;
pub const STORE_ERROR_UNLICENSED_USER: u32 = 15862;
pub const STORE_ERROR_PENDING_COM_TRANSACTION: u32 = 15863;
pub const STORE_ERROR_LICENSE_REVOKED: u32 = 15864;
pub const SEVERITY_SUCCESS: u32 = 0;
pub const SEVERITY_ERROR: u32 = 1;
pub const FACILITY_NT_BIT: u32 = 268435456;
pub const NOERROR: u32 = 0;
pub const DRAGDROP_E_FIRST: u32 = 2147746048;
pub const DRAGDROP_E_LAST: u32 = 2147746063;
pub const DRAGDROP_S_FIRST: u32 = 262400;
pub const DRAGDROP_S_LAST: u32 = 262415;
pub const CLASSFACTORY_E_FIRST: u32 = 2147746064;
pub const CLASSFACTORY_E_LAST: u32 = 2147746079;
pub const CLASSFACTORY_S_FIRST: u32 = 262416;
pub const CLASSFACTORY_S_LAST: u32 = 262431;
pub const MARSHAL_E_FIRST: u32 = 2147746080;
pub const MARSHAL_E_LAST: u32 = 2147746095;
pub const MARSHAL_S_FIRST: u32 = 262432;
pub const MARSHAL_S_LAST: u32 = 262447;
pub const DATA_E_FIRST: u32 = 2147746096;
pub const DATA_E_LAST: u32 = 2147746111;
pub const DATA_S_FIRST: u32 = 262448;
pub const DATA_S_LAST: u32 = 262463;
pub const VIEW_E_FIRST: u32 = 2147746112;
pub const VIEW_E_LAST: u32 = 2147746127;
pub const VIEW_S_FIRST: u32 = 262464;
pub const VIEW_S_LAST: u32 = 262479;
pub const REGDB_E_FIRST: u32 = 2147746128;
pub const REGDB_E_LAST: u32 = 2147746143;
pub const REGDB_S_FIRST: u32 = 262480;
pub const REGDB_S_LAST: u32 = 262495;
pub const CAT_E_FIRST: u32 = 2147746144;
pub const CAT_E_LAST: u32 = 2147746145;
pub const CS_E_FIRST: u32 = 2147746148;
pub const CS_E_LAST: u32 = 2147746159;
pub const CACHE_E_FIRST: u32 = 2147746160;
pub const CACHE_E_LAST: u32 = 2147746175;
pub const CACHE_S_FIRST: u32 = 262512;
pub const CACHE_S_LAST: u32 = 262527;
pub const OLEOBJ_E_FIRST: u32 = 2147746176;
pub const OLEOBJ_E_LAST: u32 = 2147746191;
pub const OLEOBJ_S_FIRST: u32 = 262528;
pub const OLEOBJ_S_LAST: u32 = 262543;
pub const CLIENTSITE_E_FIRST: u32 = 2147746192;
pub const CLIENTSITE_E_LAST: u32 = 2147746207;
pub const CLIENTSITE_S_FIRST: u32 = 262544;
pub const CLIENTSITE_S_LAST: u32 = 262559;
pub const INPLACE_E_FIRST: u32 = 2147746208;
pub const INPLACE_E_LAST: u32 = 2147746223;
pub const INPLACE_S_FIRST: u32 = 262560;
pub const INPLACE_S_LAST: u32 = 262575;
pub const ENUM_E_FIRST: u32 = 2147746224;
pub const ENUM_E_LAST: u32 = 2147746239;
pub const ENUM_S_FIRST: u32 = 262576;
pub const ENUM_S_LAST: u32 = 262591;
pub const CONVERT10_E_FIRST: u32 = 2147746240;
pub const CONVERT10_E_LAST: u32 = 2147746255;
pub const CONVERT10_S_FIRST: u32 = 262592;
pub const CONVERT10_S_LAST: u32 = 262607;
pub const CLIPBRD_E_FIRST: u32 = 2147746256;
pub const CLIPBRD_E_LAST: u32 = 2147746271;
pub const CLIPBRD_S_FIRST: u32 = 262608;
pub const CLIPBRD_S_LAST: u32 = 262623;
pub const MK_E_FIRST: u32 = 2147746272;
pub const MK_E_LAST: u32 = 2147746287;
pub const MK_S_FIRST: u32 = 262624;
pub const MK_S_LAST: u32 = 262639;
pub const CO_E_FIRST: u32 = 2147746288;
pub const CO_E_LAST: u32 = 2147746303;
pub const CO_S_FIRST: u32 = 262640;
pub const CO_S_LAST: u32 = 262655;
pub const EVENT_E_FIRST: u32 = 2147746304;
pub const EVENT_E_LAST: u32 = 2147746335;
pub const EVENT_S_FIRST: u32 = 262656;
pub const EVENT_S_LAST: u32 = 262687;
pub const XACT_E_FIRST: u32 = 2147799040;
pub const XACT_E_LAST: u32 = 2147799083;
pub const XACT_S_FIRST: u32 = 315392;
pub const XACT_S_LAST: u32 = 315408;
pub const CONTEXT_E_FIRST: u32 = 2147803136;
pub const CONTEXT_E_LAST: u32 = 2147803183;
pub const CONTEXT_S_FIRST: u32 = 319488;
pub const CONTEXT_S_LAST: u32 = 319535;
pub const NTE_OP_OK: u32 = 0;
pub const SCARD_S_SUCCESS: u32 = 0;
pub const TC_NORMAL: u32 = 0;
pub const TC_HARDERR: u32 = 1;
pub const TC_GP_TRAP: u32 = 2;
pub const TC_SIGNAL: u32 = 3;
pub const AC_LINE_OFFLINE: u32 = 0;
pub const AC_LINE_ONLINE: u32 = 1;
pub const AC_LINE_BACKUP_POWER: u32 = 2;
pub const AC_LINE_UNKNOWN: u32 = 255;
pub const BATTERY_FLAG_HIGH: u32 = 1;
pub const BATTERY_FLAG_LOW: u32 = 2;
pub const BATTERY_FLAG_CRITICAL: u32 = 4;
pub const BATTERY_FLAG_CHARGING: u32 = 8;
pub const BATTERY_FLAG_NO_BATTERY: u32 = 128;
pub const BATTERY_FLAG_UNKNOWN: u32 = 255;
pub const BATTERY_PERCENTAGE_UNKNOWN: u32 = 255;
pub const SYSTEM_STATUS_FLAG_POWER_SAVING_ON: u32 = 1;
pub const BATTERY_LIFE_UNKNOWN: u32 = 4294967295;
pub const ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID: u32 = 1;
pub const ACTCTX_FLAG_LANGID_VALID: u32 = 2;
pub const ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID: u32 = 4;
pub const ACTCTX_FLAG_RESOURCE_NAME_VALID: u32 = 8;
pub const ACTCTX_FLAG_SET_PROCESS_DEFAULT: u32 = 16;
pub const ACTCTX_FLAG_APPLICATION_NAME_VALID: u32 = 32;
pub const ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF: u32 = 64;
pub const ACTCTX_FLAG_HMODULE_VALID: u32 = 128;
pub const DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION: u32 = 1;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX: u32 = 1;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS: u32 = 2;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA: u32 = 4;
pub const ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED: u32 = 1;
pub const QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX: u32 = 4;
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE: u32 = 8;
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS: u32 = 16;
pub const QUERY_ACTCTX_FLAG_NO_ADDREF: u32 = 2147483648;
pub const RESTART_MAX_CMD_LINE: u32 = 1024;
pub const RESTART_NO_CRASH: u32 = 1;
pub const RESTART_NO_HANG: u32 = 2;
pub const RESTART_NO_PATCH: u32 = 4;
pub const RESTART_NO_REBOOT: u32 = 8;
pub const RECOVERY_DEFAULT_PING_INTERVAL: u32 = 5000;
pub const RECOVERY_MAX_PING_INTERVAL: u32 = 300000;
pub const FILE_RENAME_FLAG_REPLACE_IF_EXISTS: u32 = 1;
pub const FILE_RENAME_FLAG_POSIX_SEMANTICS: u32 = 2;
pub const FILE_RENAME_FLAG_SUPPRESS_PIN_STATE_INHERITANCE: u32 = 4;
pub const FILE_DISPOSITION_FLAG_DO_NOT_DELETE: u32 = 0;
pub const FILE_DISPOSITION_FLAG_DELETE: u32 = 1;
pub const FILE_DISPOSITION_FLAG_POSIX_SEMANTICS: u32 = 2;
pub const FILE_DISPOSITION_FLAG_FORCE_IMAGE_SECTION_CHECK: u32 = 4;
pub const FILE_DISPOSITION_FLAG_ON_CLOSE: u32 = 8;
pub const FILE_DISPOSITION_FLAG_IGNORE_READONLY_ATTRIBUTE: u32 = 16;
pub const STORAGE_INFO_FLAGS_ALIGNED_DEVICE: u32 = 1;
pub const STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: u32 = 2;
pub const STORAGE_INFO_OFFSET_UNKNOWN: u32 = 4294967295;
pub const REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK: u32 = 1;
pub const REMOTE_PROTOCOL_INFO_FLAG_OFFLINE: u32 = 2;
pub const REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE: u32 = 4;
pub const RPI_FLAG_SMB2_SHARECAP_TIMEWARP: u32 = 2;
pub const RPI_FLAG_SMB2_SHARECAP_DFS: u32 = 8;
pub const RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY: u32 = 16;
pub const RPI_FLAG_SMB2_SHARECAP_SCALEOUT: u32 = 32;
pub const RPI_FLAG_SMB2_SHARECAP_CLUSTER: u32 = 64;
pub const RPI_SMB2_SHAREFLAG_ENCRYPT_DATA: u32 = 1;
pub const RPI_SMB2_SHAREFLAG_COMPRESS_DATA: u32 = 2;
pub const RPI_SMB2_FLAG_SERVERCAP_DFS: u32 = 1;
pub const RPI_SMB2_FLAG_SERVERCAP_LEASING: u32 = 2;
pub const RPI_SMB2_FLAG_SERVERCAP_LARGEMTU: u32 = 4;
pub const RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL: u32 = 8;
pub const RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES: u32 = 16;
pub const RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING: u32 = 32;
pub const SYMBOLIC_LINK_FLAG_DIRECTORY: u32 = 1;
pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE: u32 = 2;
pub const MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS: u32 = 1;
pub const MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS: u32 = 0;
pub const R2_BLACK: u32 = 1;
pub const R2_NOTMERGEPEN: u32 = 2;
pub const R2_MASKNOTPEN: u32 = 3;
pub const R2_NOTCOPYPEN: u32 = 4;
pub const R2_MASKPENNOT: u32 = 5;
pub const R2_NOT: u32 = 6;
pub const R2_XORPEN: u32 = 7;
pub const R2_NOTMASKPEN: u32 = 8;
pub const R2_MASKPEN: u32 = 9;
pub const R2_NOTXORPEN: u32 = 10;
pub const R2_NOP: u32 = 11;
pub const R2_MERGENOTPEN: u32 = 12;
pub const R2_COPYPEN: u32 = 13;
pub const R2_MERGEPENNOT: u32 = 14;
pub const R2_MERGEPEN: u32 = 15;
pub const R2_WHITE: u32 = 16;
pub const R2_LAST: u32 = 16;
pub const GDI_ERROR: u32 = 4294967295;
pub const ERROR: u32 = 0;
pub const NULLREGION: u32 = 1;
pub const SIMPLEREGION: u32 = 2;
pub const COMPLEXREGION: u32 = 3;
pub const RGN_ERROR: u32 = 0;
pub const RGN_AND: u32 = 1;
pub const RGN_OR: u32 = 2;
pub const RGN_XOR: u32 = 3;
pub const RGN_DIFF: u32 = 4;
pub const RGN_COPY: u32 = 5;
pub const RGN_MIN: u32 = 1;
pub const RGN_MAX: u32 = 5;
pub const BLACKONWHITE: u32 = 1;
pub const WHITEONBLACK: u32 = 2;
pub const COLORONCOLOR: u32 = 3;
pub const HALFTONE: u32 = 4;
pub const MAXSTRETCHBLTMODE: u32 = 4;
pub const STRETCH_ANDSCANS: u32 = 1;
pub const STRETCH_ORSCANS: u32 = 2;
pub const STRETCH_DELETESCANS: u32 = 3;
pub const STRETCH_HALFTONE: u32 = 4;
pub const ALTERNATE: u32 = 1;
pub const WINDING: u32 = 2;
pub const POLYFILL_LAST: u32 = 2;
pub const LAYOUT_RTL: u32 = 1;
pub const LAYOUT_BTT: u32 = 2;
pub const LAYOUT_VBH: u32 = 4;
pub const LAYOUT_ORIENTATIONMASK: u32 = 7;
pub const LAYOUT_BITMAPORIENTATIONPRESERVED: u32 = 8;
pub const TA_NOUPDATECP: u32 = 0;
pub const TA_UPDATECP: u32 = 1;
pub const TA_LEFT: u32 = 0;
pub const TA_RIGHT: u32 = 2;
pub const TA_CENTER: u32 = 6;
pub const TA_TOP: u32 = 0;
pub const TA_BOTTOM: u32 = 8;
pub const TA_BASELINE: u32 = 24;
pub const TA_RTLREADING: u32 = 256;
pub const TA_MASK: u32 = 287;
pub const VTA_BASELINE: u32 = 24;
pub const VTA_LEFT: u32 = 8;
pub const VTA_RIGHT: u32 = 0;
pub const VTA_CENTER: u32 = 6;
pub const VTA_BOTTOM: u32 = 2;
pub const VTA_TOP: u32 = 0;
pub const ETO_OPAQUE: u32 = 2;
pub const ETO_CLIPPED: u32 = 4;
pub const ETO_GLYPH_INDEX: u32 = 16;
pub const ETO_RTLREADING: u32 = 128;
pub const ETO_NUMERICSLOCAL: u32 = 1024;
pub const ETO_NUMERICSLATIN: u32 = 2048;
pub const ETO_IGNORELANGUAGE: u32 = 4096;
pub const ETO_PDY: u32 = 8192;
pub const ETO_REVERSE_INDEX_MAP: u32 = 65536;
pub const ASPECT_FILTERING: u32 = 1;
pub const DCB_RESET: u32 = 1;
pub const DCB_ACCUMULATE: u32 = 2;
pub const DCB_DIRTY: u32 = 2;
pub const DCB_SET: u32 = 3;
pub const DCB_ENABLE: u32 = 4;
pub const DCB_DISABLE: u32 = 8;
pub const META_SETBKCOLOR: u32 = 513;
pub const META_SETBKMODE: u32 = 258;
pub const META_SETMAPMODE: u32 = 259;
pub const META_SETROP2: u32 = 260;
pub const META_SETRELABS: u32 = 261;
pub const META_SETPOLYFILLMODE: u32 = 262;
pub const META_SETSTRETCHBLTMODE: u32 = 263;
pub const META_SETTEXTCHAREXTRA: u32 = 264;
pub const META_SETTEXTCOLOR: u32 = 521;
pub const META_SETTEXTJUSTIFICATION: u32 = 522;
pub const META_SETWINDOWORG: u32 = 523;
pub const META_SETWINDOWEXT: u32 = 524;
pub const META_SETVIEWPORTORG: u32 = 525;
pub const META_SETVIEWPORTEXT: u32 = 526;
pub const META_OFFSETWINDOWORG: u32 = 527;
pub const META_SCALEWINDOWEXT: u32 = 1040;
pub const META_OFFSETVIEWPORTORG: u32 = 529;
pub const META_SCALEVIEWPORTEXT: u32 = 1042;
pub const META_LINETO: u32 = 531;
pub const META_MOVETO: u32 = 532;
pub const META_EXCLUDECLIPRECT: u32 = 1045;
pub const META_INTERSECTCLIPRECT: u32 = 1046;
pub const META_ARC: u32 = 2071;
pub const META_ELLIPSE: u32 = 1048;
pub const META_FLOODFILL: u32 = 1049;
pub const META_PIE: u32 = 2074;
pub const META_RECTANGLE: u32 = 1051;
pub const META_ROUNDRECT: u32 = 1564;
pub const META_PATBLT: u32 = 1565;
pub const META_SAVEDC: u32 = 30;
pub const META_SETPIXEL: u32 = 1055;
pub const META_OFFSETCLIPRGN: u32 = 544;
pub const META_TEXTOUT: u32 = 1313;
pub const META_BITBLT: u32 = 2338;
pub const META_STRETCHBLT: u32 = 2851;
pub const META_POLYGON: u32 = 804;
pub const META_POLYLINE: u32 = 805;
pub const META_ESCAPE: u32 = 1574;
pub const META_RESTOREDC: u32 = 295;
pub const META_FILLREGION: u32 = 552;
pub const META_FRAMEREGION: u32 = 1065;
pub const META_INVERTREGION: u32 = 298;
pub const META_PAINTREGION: u32 = 299;
pub const META_SELECTCLIPREGION: u32 = 300;
pub const META_SELECTOBJECT: u32 = 301;
pub const META_SETTEXTALIGN: u32 = 302;
pub const META_CHORD: u32 = 2096;
pub const META_SETMAPPERFLAGS: u32 = 561;
pub const META_EXTTEXTOUT: u32 = 2610;
pub const META_SETDIBTODEV: u32 = 3379;
pub const META_SELECTPALETTE: u32 = 564;
pub const META_REALIZEPALETTE: u32 = 53;
pub const META_ANIMATEPALETTE: u32 = 1078;
pub const META_SETPALENTRIES: u32 = 55;
pub const META_POLYPOLYGON: u32 = 1336;
pub const META_RESIZEPALETTE: u32 = 313;
pub const META_DIBBITBLT: u32 = 2368;
pub const META_DIBSTRETCHBLT: u32 = 2881;
pub const META_DIBCREATEPATTERNBRUSH: u32 = 322;
pub const META_STRETCHDIB: u32 = 3907;
pub const META_EXTFLOODFILL: u32 = 1352;
pub const META_SETLAYOUT: u32 = 329;
pub const META_DELETEOBJECT: u32 = 496;
pub const META_CREATEPALETTE: u32 = 247;
pub const META_CREATEPATTERNBRUSH: u32 = 505;
pub const META_CREATEPENINDIRECT: u32 = 762;
pub const META_CREATEFONTINDIRECT: u32 = 763;
pub const META_CREATEBRUSHINDIRECT: u32 = 764;
pub const META_CREATEREGION: u32 = 1791;
pub const NEWFRAME: u32 = 1;
pub const ABORTDOC: u32 = 2;
pub const NEXTBAND: u32 = 3;
pub const SETCOLORTABLE: u32 = 4;
pub const GETCOLORTABLE: u32 = 5;
pub const FLUSHOUTPUT: u32 = 6;
pub const DRAFTMODE: u32 = 7;
pub const QUERYESCSUPPORT: u32 = 8;
pub const SETABORTPROC: u32 = 9;
pub const STARTDOC: u32 = 10;
pub const ENDDOC: u32 = 11;
pub const GETPHYSPAGESIZE: u32 = 12;
pub const GETPRINTINGOFFSET: u32 = 13;
pub const GETSCALINGFACTOR: u32 = 14;
pub const MFCOMMENT: u32 = 15;
pub const GETPENWIDTH: u32 = 16;
pub const SETCOPYCOUNT: u32 = 17;
pub const SELECTPAPERSOURCE: u32 = 18;
pub const DEVICEDATA: u32 = 19;
pub const PASSTHROUGH: u32 = 19;
pub const GETTECHNOLGY: u32 = 20;
pub const GETTECHNOLOGY: u32 = 20;
pub const SETLINECAP: u32 = 21;
pub const SETLINEJOIN: u32 = 22;
pub const SETMITERLIMIT: u32 = 23;
pub const BANDINFO: u32 = 24;
pub const DRAWPATTERNRECT: u32 = 25;
pub const GETVECTORPENSIZE: u32 = 26;
pub const GETVECTORBRUSHSIZE: u32 = 27;
pub const ENABLEDUPLEX: u32 = 28;
pub const GETSETPAPERBINS: u32 = 29;
pub const GETSETPRINTORIENT: u32 = 30;
pub const ENUMPAPERBINS: u32 = 31;
pub const SETDIBSCALING: u32 = 32;
pub const EPSPRINTING: u32 = 33;
pub const ENUMPAPERMETRICS: u32 = 34;
pub const GETSETPAPERMETRICS: u32 = 35;
pub const POSTSCRIPT_DATA: u32 = 37;
pub const POSTSCRIPT_IGNORE: u32 = 38;
pub const MOUSETRAILS: u32 = 39;
pub const GETDEVICEUNITS: u32 = 42;
pub const GETEXTENDEDTEXTMETRICS: u32 = 256;
pub const GETEXTENTTABLE: u32 = 257;
pub const GETPAIRKERNTABLE: u32 = 258;
pub const GETTRACKKERNTABLE: u32 = 259;
pub const EXTTEXTOUT: u32 = 512;
pub const GETFACENAME: u32 = 513;
pub const DOWNLOADFACE: u32 = 514;
pub const ENABLERELATIVEWIDTHS: u32 = 768;
pub const ENABLEPAIRKERNING: u32 = 769;
pub const SETKERNTRACK: u32 = 770;
pub const SETALLJUSTVALUES: u32 = 771;
pub const SETCHARSET: u32 = 772;
pub const STRETCHBLT: u32 = 2048;
pub const METAFILE_DRIVER: u32 = 2049;
pub const GETSETSCREENPARAMS: u32 = 3072;
pub const QUERYDIBSUPPORT: u32 = 3073;
pub const BEGIN_PATH: u32 = 4096;
pub const CLIP_TO_PATH: u32 = 4097;
pub const END_PATH: u32 = 4098;
pub const EXT_DEVICE_CAPS: u32 = 4099;
pub const RESTORE_CTM: u32 = 4100;
pub const SAVE_CTM: u32 = 4101;
pub const SET_ARC_DIRECTION: u32 = 4102;
pub const SET_BACKGROUND_COLOR: u32 = 4103;
pub const SET_POLY_MODE: u32 = 4104;
pub const SET_SCREEN_ANGLE: u32 = 4105;
pub const SET_SPREAD: u32 = 4106;
pub const TRANSFORM_CTM: u32 = 4107;
pub const SET_CLIP_BOX: u32 = 4108;
pub const SET_BOUNDS: u32 = 4109;
pub const SET_MIRROR_MODE: u32 = 4110;
pub const OPENCHANNEL: u32 = 4110;
pub const DOWNLOADHEADER: u32 = 4111;
pub const CLOSECHANNEL: u32 = 4112;
pub const POSTSCRIPT_PASSTHROUGH: u32 = 4115;
pub const ENCAPSULATED_POSTSCRIPT: u32 = 4116;
pub const POSTSCRIPT_IDENTIFY: u32 = 4117;
pub const POSTSCRIPT_INJECTION: u32 = 4118;
pub const CHECKJPEGFORMAT: u32 = 4119;
pub const CHECKPNGFORMAT: u32 = 4120;
pub const GET_PS_FEATURESETTING: u32 = 4121;
pub const GDIPLUS_TS_QUERYVER: u32 = 4122;
pub const GDIPLUS_TS_RECORD: u32 = 4123;
pub const MILCORE_TS_QUERYVER_RESULT_FALSE: u32 = 0;
pub const MILCORE_TS_QUERYVER_RESULT_TRUE: u32 = 2147483647;
pub const SPCLPASSTHROUGH2: u32 = 4568;
pub const PSIDENT_GDICENTRIC: u32 = 0;
pub const PSIDENT_PSCENTRIC: u32 = 1;
pub const PSINJECT_BEGINSTREAM: u32 = 1;
pub const PSINJECT_PSADOBE: u32 = 2;
pub const PSINJECT_PAGESATEND: u32 = 3;
pub const PSINJECT_PAGES: u32 = 4;
pub const PSINJECT_DOCNEEDEDRES: u32 = 5;
pub const PSINJECT_DOCSUPPLIEDRES: u32 = 6;
pub const PSINJECT_PAGEORDER: u32 = 7;
pub const PSINJECT_ORIENTATION: u32 = 8;
pub const PSINJECT_BOUNDINGBOX: u32 = 9;
pub const PSINJECT_DOCUMENTPROCESSCOLORS: u32 = 10;
pub const PSINJECT_COMMENTS: u32 = 11;
pub const PSINJECT_BEGINDEFAULTS: u32 = 12;
pub const PSINJECT_ENDDEFAULTS: u32 = 13;
pub const PSINJECT_BEGINPROLOG: u32 = 14;
pub const PSINJECT_ENDPROLOG: u32 = 15;
pub const PSINJECT_BEGINSETUP: u32 = 16;
pub const PSINJECT_ENDSETUP: u32 = 17;
pub const PSINJECT_TRAILER: u32 = 18;
pub const PSINJECT_EOF: u32 = 19;
pub const PSINJECT_ENDSTREAM: u32 = 20;
pub const PSINJECT_DOCUMENTPROCESSCOLORSATEND: u32 = 21;
pub const PSINJECT_PAGENUMBER: u32 = 100;
pub const PSINJECT_BEGINPAGESETUP: u32 = 101;
pub const PSINJECT_ENDPAGESETUP: u32 = 102;
pub const PSINJECT_PAGETRAILER: u32 = 103;
pub const PSINJECT_PLATECOLOR: u32 = 104;
pub const PSINJECT_SHOWPAGE: u32 = 105;
pub const PSINJECT_PAGEBBOX: u32 = 106;
pub const PSINJECT_ENDPAGECOMMENTS: u32 = 107;
pub const PSINJECT_VMSAVE: u32 = 200;
pub const PSINJECT_VMRESTORE: u32 = 201;
pub const PSINJECT_DLFONT: u32 = 3722304989;
pub const FEATURESETTING_NUP: u32 = 0;
pub const FEATURESETTING_OUTPUT: u32 = 1;
pub const FEATURESETTING_PSLEVEL: u32 = 2;
pub const FEATURESETTING_CUSTPAPER: u32 = 3;
pub const FEATURESETTING_MIRROR: u32 = 4;
pub const FEATURESETTING_NEGATIVE: u32 = 5;
pub const FEATURESETTING_PROTOCOL: u32 = 6;
pub const FEATURESETTING_PRIVATE_BEGIN: u32 = 4096;
pub const FEATURESETTING_PRIVATE_END: u32 = 8191;
pub const PSPROTOCOL_ASCII: u32 = 0;
pub const PSPROTOCOL_BCP: u32 = 1;
pub const PSPROTOCOL_TBCP: u32 = 2;
pub const PSPROTOCOL_BINARY: u32 = 3;
pub const QDI_SETDIBITS: u32 = 1;
pub const QDI_GETDIBITS: u32 = 2;
pub const QDI_DIBTOSCREEN: u32 = 4;
pub const QDI_STRETCHDIB: u32 = 8;
pub const SP_NOTREPORTED: u32 = 16384;
pub const SP_ERROR: i32 = -1;
pub const SP_APPABORT: i32 = -2;
pub const SP_USERABORT: i32 = -3;
pub const SP_OUTOFDISK: i32 = -4;
pub const SP_OUTOFMEMORY: i32 = -5;
pub const PR_JOBSTATUS: u32 = 0;
pub const OBJ_PEN: u32 = 1;
pub const OBJ_BRUSH: u32 = 2;
pub const OBJ_DC: u32 = 3;
pub const OBJ_METADC: u32 = 4;
pub const OBJ_PAL: u32 = 5;
pub const OBJ_FONT: u32 = 6;
pub const OBJ_BITMAP: u32 = 7;
pub const OBJ_REGION: u32 = 8;
pub const OBJ_METAFILE: u32 = 9;
pub const OBJ_MEMDC: u32 = 10;
pub const OBJ_EXTPEN: u32 = 11;
pub const OBJ_ENHMETADC: u32 = 12;
pub const OBJ_ENHMETAFILE: u32 = 13;
pub const OBJ_COLORSPACE: u32 = 14;
pub const GDI_OBJ_LAST: u32 = 14;
pub const GDI_MIN_OBJ_TYPE: u32 = 1;
pub const GDI_MAX_OBJ_TYPE: u32 = 14;
pub const MWT_IDENTITY: u32 = 1;
pub const MWT_LEFTMULTIPLY: u32 = 2;
pub const MWT_RIGHTMULTIPLY: u32 = 3;
pub const MWT_MIN: u32 = 1;
pub const MWT_MAX: u32 = 3;
pub const CS_ENABLE: u32 = 1;
pub const CS_DISABLE: u32 = 2;
pub const CS_DELETE_TRANSFORM: u32 = 3;
pub const LCS_CALIBRATED_RGB: u32 = 0;
pub const LCS_GM_BUSINESS: u32 = 1;
pub const LCS_GM_GRAPHICS: u32 = 2;
pub const LCS_GM_IMAGES: u32 = 4;
pub const LCS_GM_ABS_COLORIMETRIC: u32 = 8;
pub const CM_OUT_OF_GAMUT: u32 = 255;
pub const CM_IN_GAMUT: u32 = 0;
pub const ICM_ADDPROFILE: u32 = 1;
pub const ICM_DELETEPROFILE: u32 = 2;
pub const ICM_QUERYPROFILE: u32 = 3;
pub const ICM_SETDEFAULTPROFILE: u32 = 4;
pub const ICM_REGISTERICMATCHER: u32 = 5;
pub const ICM_UNREGISTERICMATCHER: u32 = 6;
pub const ICM_QUERYMATCH: u32 = 7;
pub const BI_RGB: u32 = 0;
pub const BI_RLE8: u32 = 1;
pub const BI_RLE4: u32 = 2;
pub const BI_BITFIELDS: u32 = 3;
pub const BI_JPEG: u32 = 4;
pub const BI_PNG: u32 = 5;
pub const TCI_SRCCHARSET: u32 = 1;
pub const TCI_SRCCODEPAGE: u32 = 2;
pub const TCI_SRCFONTSIG: u32 = 3;
pub const TCI_SRCLOCALE: u32 = 4096;
pub const TMPF_FIXED_PITCH: u32 = 1;
pub const TMPF_VECTOR: u32 = 2;
pub const TMPF_DEVICE: u32 = 8;
pub const TMPF_TRUETYPE: u32 = 4;
pub const NTM_REGULAR: u32 = 64;
pub const NTM_BOLD: u32 = 32;
pub const NTM_ITALIC: u32 = 1;
pub const NTM_NONNEGATIVE_AC: u32 = 65536;
pub const NTM_PS_OPENTYPE: u32 = 131072;
pub const NTM_TT_OPENTYPE: u32 = 262144;
pub const NTM_MULTIPLEMASTER: u32 = 524288;
pub const NTM_TYPE1: u32 = 1048576;
pub const NTM_DSIG: u32 = 2097152;
pub const LF_FACESIZE: u32 = 32;
pub const LF_FULLFACESIZE: u32 = 64;
pub const OUT_DEFAULT_PRECIS: u32 = 0;
pub const OUT_STRING_PRECIS: u32 = 1;
pub const OUT_CHARACTER_PRECIS: u32 = 2;
pub const OUT_STROKE_PRECIS: u32 = 3;
pub const OUT_TT_PRECIS: u32 = 4;
pub const OUT_DEVICE_PRECIS: u32 = 5;
pub const OUT_RASTER_PRECIS: u32 = 6;
pub const OUT_TT_ONLY_PRECIS: u32 = 7;
pub const OUT_OUTLINE_PRECIS: u32 = 8;
pub const OUT_SCREEN_OUTLINE_PRECIS: u32 = 9;
pub const OUT_PS_ONLY_PRECIS: u32 = 10;
pub const CLIP_DEFAULT_PRECIS: u32 = 0;
pub const CLIP_CHARACTER_PRECIS: u32 = 1;
pub const CLIP_STROKE_PRECIS: u32 = 2;
pub const CLIP_MASK: u32 = 15;
pub const CLIP_LH_ANGLES: u32 = 16;
pub const CLIP_TT_ALWAYS: u32 = 32;
pub const CLIP_DFA_DISABLE: u32 = 64;
pub const CLIP_EMBEDDED: u32 = 128;
pub const DEFAULT_QUALITY: u32 = 0;
pub const DRAFT_QUALITY: u32 = 1;
pub const PROOF_QUALITY: u32 = 2;
pub const NONANTIALIASED_QUALITY: u32 = 3;
pub const ANTIALIASED_QUALITY: u32 = 4;
pub const CLEARTYPE_QUALITY: u32 = 5;
pub const CLEARTYPE_NATURAL_QUALITY: u32 = 6;
pub const DEFAULT_PITCH: u32 = 0;
pub const FIXED_PITCH: u32 = 1;
pub const VARIABLE_PITCH: u32 = 2;
pub const MONO_FONT: u32 = 8;
pub const ANSI_CHARSET: u32 = 0;
pub const DEFAULT_CHARSET: u32 = 1;
pub const SYMBOL_CHARSET: u32 = 2;
pub const SHIFTJIS_CHARSET: u32 = 128;
pub const HANGEUL_CHARSET: u32 = 129;
pub const HANGUL_CHARSET: u32 = 129;
pub const GB2312_CHARSET: u32 = 134;
pub const CHINESEBIG5_CHARSET: u32 = 136;
pub const OEM_CHARSET: u32 = 255;
pub const JOHAB_CHARSET: u32 = 130;
pub const HEBREW_CHARSET: u32 = 177;
pub const ARABIC_CHARSET: u32 = 178;
pub const GREEK_CHARSET: u32 = 161;
pub const TURKISH_CHARSET: u32 = 162;
pub const VIETNAMESE_CHARSET: u32 = 163;
pub const THAI_CHARSET: u32 = 222;
pub const EASTEUROPE_CHARSET: u32 = 238;
pub const RUSSIAN_CHARSET: u32 = 204;
pub const MAC_CHARSET: u32 = 77;
pub const BALTIC_CHARSET: u32 = 186;
pub const FS_LATIN1: u32 = 1;
pub const FS_LATIN2: u32 = 2;
pub const FS_CYRILLIC: u32 = 4;
pub const FS_GREEK: u32 = 8;
pub const FS_TURKISH: u32 = 16;
pub const FS_HEBREW: u32 = 32;
pub const FS_ARABIC: u32 = 64;
pub const FS_BALTIC: u32 = 128;
pub const FS_VIETNAMESE: u32 = 256;
pub const FS_THAI: u32 = 65536;
pub const FS_JISJAPAN: u32 = 131072;
pub const FS_CHINESESIMP: u32 = 262144;
pub const FS_WANSUNG: u32 = 524288;
pub const FS_CHINESETRAD: u32 = 1048576;
pub const FS_JOHAB: u32 = 2097152;
pub const FS_SYMBOL: u32 = 2147483648;
pub const FF_DONTCARE: u32 = 0;
pub const FF_ROMAN: u32 = 16;
pub const FF_SWISS: u32 = 32;
pub const FF_MODERN: u32 = 48;
pub const FF_SCRIPT: u32 = 64;
pub const FF_DECORATIVE: u32 = 80;
pub const FW_DONTCARE: u32 = 0;
pub const FW_THIN: u32 = 100;
pub const FW_EXTRALIGHT: u32 = 200;
pub const FW_LIGHT: u32 = 300;
pub const FW_NORMAL: u32 = 400;
pub const FW_MEDIUM: u32 = 500;
pub const FW_SEMIBOLD: u32 = 600;
pub const FW_BOLD: u32 = 700;
pub const FW_EXTRABOLD: u32 = 800;
pub const FW_HEAVY: u32 = 900;
pub const FW_ULTRALIGHT: u32 = 200;
pub const FW_REGULAR: u32 = 400;
pub const FW_DEMIBOLD: u32 = 600;
pub const FW_ULTRABOLD: u32 = 800;
pub const FW_BLACK: u32 = 900;
pub const PANOSE_COUNT: u32 = 10;
pub const PAN_FAMILYTYPE_INDEX: u32 = 0;
pub const PAN_SERIFSTYLE_INDEX: u32 = 1;
pub const PAN_WEIGHT_INDEX: u32 = 2;
pub const PAN_PROPORTION_INDEX: u32 = 3;
pub const PAN_CONTRAST_INDEX: u32 = 4;
pub const PAN_STROKEVARIATION_INDEX: u32 = 5;
pub const PAN_ARMSTYLE_INDEX: u32 = 6;
pub const PAN_LETTERFORM_INDEX: u32 = 7;
pub const PAN_MIDLINE_INDEX: u32 = 8;
pub const PAN_XHEIGHT_INDEX: u32 = 9;
pub const PAN_CULTURE_LATIN: u32 = 0;
pub const PAN_ANY: u32 = 0;
pub const PAN_NO_FIT: u32 = 1;
pub const PAN_FAMILY_TEXT_DISPLAY: u32 = 2;
pub const PAN_FAMILY_SCRIPT: u32 = 3;
pub const PAN_FAMILY_DECORATIVE: u32 = 4;
pub const PAN_FAMILY_PICTORIAL: u32 = 5;
pub const PAN_SERIF_COVE: u32 = 2;
pub const PAN_SERIF_OBTUSE_COVE: u32 = 3;
pub const PAN_SERIF_SQUARE_COVE: u32 = 4;
pub const PAN_SERIF_OBTUSE_SQUARE_COVE: u32 = 5;
pub const PAN_SERIF_SQUARE: u32 = 6;
pub const PAN_SERIF_THIN: u32 = 7;
pub const PAN_SERIF_BONE: u32 = 8;
pub const PAN_SERIF_EXAGGERATED: u32 = 9;
pub const PAN_SERIF_TRIANGLE: u32 = 10;
pub const PAN_SERIF_NORMAL_SANS: u32 = 11;
pub const PAN_SERIF_OBTUSE_SANS: u32 = 12;
pub const PAN_SERIF_PERP_SANS: u32 = 13;
pub const PAN_SERIF_FLARED: u32 = 14;
pub const PAN_SERIF_ROUNDED: u32 = 15;
pub const PAN_WEIGHT_VERY_LIGHT: u32 = 2;
pub const PAN_WEIGHT_LIGHT: u32 = 3;
pub const PAN_WEIGHT_THIN: u32 = 4;
pub const PAN_WEIGHT_BOOK: u32 = 5;
pub const PAN_WEIGHT_MEDIUM: u32 = 6;
pub const PAN_WEIGHT_DEMI: u32 = 7;
pub const PAN_WEIGHT_BOLD: u32 = 8;
pub const PAN_WEIGHT_HEAVY: u32 = 9;
pub const PAN_WEIGHT_BLACK: u32 = 10;
pub const PAN_WEIGHT_NORD: u32 = 11;
pub const PAN_PROP_OLD_STYLE: u32 = 2;
pub const PAN_PROP_MODERN: u32 = 3;
pub const PAN_PROP_EVEN_WIDTH: u32 = 4;
pub const PAN_PROP_EXPANDED: u32 = 5;
pub const PAN_PROP_CONDENSED: u32 = 6;
pub const PAN_PROP_VERY_EXPANDED: u32 = 7;
pub const PAN_PROP_VERY_CONDENSED: u32 = 8;
pub const PAN_PROP_MONOSPACED: u32 = 9;
pub const PAN_CONTRAST_NONE: u32 = 2;
pub const PAN_CONTRAST_VERY_LOW: u32 = 3;
pub const PAN_CONTRAST_LOW: u32 = 4;
pub const PAN_CONTRAST_MEDIUM_LOW: u32 = 5;
pub const PAN_CONTRAST_MEDIUM: u32 = 6;
pub const PAN_CONTRAST_MEDIUM_HIGH: u32 = 7;
pub const PAN_CONTRAST_HIGH: u32 = 8;
pub const PAN_CONTRAST_VERY_HIGH: u32 = 9;
pub const PAN_STROKE_GRADUAL_DIAG: u32 = 2;
pub const PAN_STROKE_GRADUAL_TRAN: u32 = 3;
pub const PAN_STROKE_GRADUAL_VERT: u32 = 4;
pub const PAN_STROKE_GRADUAL_HORZ: u32 = 5;
pub const PAN_STROKE_RAPID_VERT: u32 = 6;
pub const PAN_STROKE_RAPID_HORZ: u32 = 7;
pub const PAN_STROKE_INSTANT_VERT: u32 = 8;
pub const PAN_STRAIGHT_ARMS_HORZ: u32 = 2;
pub const PAN_STRAIGHT_ARMS_WEDGE: u32 = 3;
pub const PAN_STRAIGHT_ARMS_VERT: u32 = 4;
pub const PAN_STRAIGHT_ARMS_SINGLE_SERIF: u32 = 5;
pub const PAN_STRAIGHT_ARMS_DOUBLE_SERIF: u32 = 6;
pub const PAN_BENT_ARMS_HORZ: u32 = 7;
pub const PAN_BENT_ARMS_WEDGE: u32 = 8;
pub const PAN_BENT_ARMS_VERT: u32 = 9;
pub const PAN_BENT_ARMS_SINGLE_SERIF: u32 = 10;
pub const PAN_BENT_ARMS_DOUBLE_SERIF: u32 = 11;
pub const PAN_LETT_NORMAL_CONTACT: u32 = 2;
pub const PAN_LETT_NORMAL_WEIGHTED: u32 = 3;
pub const PAN_LETT_NORMAL_BOXED: u32 = 4;
pub const PAN_LETT_NORMAL_FLATTENED: u32 = 5;
pub const PAN_LETT_NORMAL_ROUNDED: u32 = 6;
pub const PAN_LETT_NORMAL_OFF_CENTER: u32 = 7;
pub const PAN_LETT_NORMAL_SQUARE: u32 = 8;
pub const PAN_LETT_OBLIQUE_CONTACT: u32 = 9;
pub const PAN_LETT_OBLIQUE_WEIGHTED: u32 = 10;
pub const PAN_LETT_OBLIQUE_BOXED: u32 = 11;
pub const PAN_LETT_OBLIQUE_FLATTENED: u32 = 12;
pub const PAN_LETT_OBLIQUE_ROUNDED: u32 = 13;
pub const PAN_LETT_OBLIQUE_OFF_CENTER: u32 = 14;
pub const PAN_LETT_OBLIQUE_SQUARE: u32 = 15;
pub const PAN_MIDLINE_STANDARD_TRIMMED: u32 = 2;
pub const PAN_MIDLINE_STANDARD_POINTED: u32 = 3;
pub const PAN_MIDLINE_STANDARD_SERIFED: u32 = 4;
pub const PAN_MIDLINE_HIGH_TRIMMED: u32 = 5;
pub const PAN_MIDLINE_HIGH_POINTED: u32 = 6;
pub const PAN_MIDLINE_HIGH_SERIFED: u32 = 7;
pub const PAN_MIDLINE_CONSTANT_TRIMMED: u32 = 8;
pub const PAN_MIDLINE_CONSTANT_POINTED: u32 = 9;
pub const PAN_MIDLINE_CONSTANT_SERIFED: u32 = 10;
pub const PAN_MIDLINE_LOW_TRIMMED: u32 = 11;
pub const PAN_MIDLINE_LOW_POINTED: u32 = 12;
pub const PAN_MIDLINE_LOW_SERIFED: u32 = 13;
pub const PAN_XHEIGHT_CONSTANT_SMALL: u32 = 2;
pub const PAN_XHEIGHT_CONSTANT_STD: u32 = 3;
pub const PAN_XHEIGHT_CONSTANT_LARGE: u32 = 4;
pub const PAN_XHEIGHT_DUCKING_SMALL: u32 = 5;
pub const PAN_XHEIGHT_DUCKING_STD: u32 = 6;
pub const PAN_XHEIGHT_DUCKING_LARGE: u32 = 7;
pub const ELF_VENDOR_SIZE: u32 = 4;
pub const ELF_VERSION: u32 = 0;
pub const ELF_CULTURE_LATIN: u32 = 0;
pub const RASTER_FONTTYPE: u32 = 1;
pub const DEVICE_FONTTYPE: u32 = 2;
pub const TRUETYPE_FONTTYPE: u32 = 4;
pub const PC_RESERVED: u32 = 1;
pub const PC_EXPLICIT: u32 = 2;
pub const PC_NOCOLLAPSE: u32 = 4;
pub const TRANSPARENT: u32 = 1;
pub const OPAQUE: u32 = 2;
pub const BKMODE_LAST: u32 = 2;
pub const GM_COMPATIBLE: u32 = 1;
pub const GM_ADVANCED: u32 = 2;
pub const GM_LAST: u32 = 2;
pub const PT_CLOSEFIGURE: u32 = 1;
pub const PT_LINETO: u32 = 2;
pub const PT_BEZIERTO: u32 = 4;
pub const PT_MOVETO: u32 = 6;
pub const MM_TEXT: u32 = 1;
pub const MM_LOMETRIC: u32 = 2;
pub const MM_HIMETRIC: u32 = 3;
pub const MM_LOENGLISH: u32 = 4;
pub const MM_HIENGLISH: u32 = 5;
pub const MM_TWIPS: u32 = 6;
pub const MM_ISOTROPIC: u32 = 7;
pub const MM_ANISOTROPIC: u32 = 8;
pub const MM_MIN: u32 = 1;
pub const MM_MAX: u32 = 8;
pub const MM_MAX_FIXEDSCALE: u32 = 6;
pub const ABSOLUTE: u32 = 1;
pub const RELATIVE: u32 = 2;
pub const WHITE_BRUSH: u32 = 0;
pub const LTGRAY_BRUSH: u32 = 1;
pub const GRAY_BRUSH: u32 = 2;
pub const DKGRAY_BRUSH: u32 = 3;
pub const BLACK_BRUSH: u32 = 4;
pub const NULL_BRUSH: u32 = 5;
pub const HOLLOW_BRUSH: u32 = 5;
pub const WHITE_PEN: u32 = 6;
pub const BLACK_PEN: u32 = 7;
pub const NULL_PEN: u32 = 8;
pub const OEM_FIXED_FONT: u32 = 10;
pub const ANSI_FIXED_FONT: u32 = 11;
pub const ANSI_VAR_FONT: u32 = 12;
pub const SYSTEM_FONT: u32 = 13;
pub const DEVICE_DEFAULT_FONT: u32 = 14;
pub const DEFAULT_PALETTE: u32 = 15;
pub const SYSTEM_FIXED_FONT: u32 = 16;
pub const DEFAULT_GUI_FONT: u32 = 17;
pub const DC_BRUSH: u32 = 18;
pub const DC_PEN: u32 = 19;
pub const STOCK_LAST: u32 = 19;
pub const CLR_INVALID: u32 = 4294967295;
pub const BS_SOLID: u32 = 0;
pub const BS_NULL: u32 = 1;
pub const BS_HOLLOW: u32 = 1;
pub const BS_HATCHED: u32 = 2;
pub const BS_PATTERN: u32 = 3;
pub const BS_INDEXED: u32 = 4;
pub const BS_DIBPATTERN: u32 = 5;
pub const BS_DIBPATTERNPT: u32 = 6;
pub const BS_PATTERN8X8: u32 = 7;
pub const BS_DIBPATTERN8X8: u32 = 8;
pub const BS_MONOPATTERN: u32 = 9;
pub const HS_HORIZONTAL: u32 = 0;
pub const HS_VERTICAL: u32 = 1;
pub const HS_FDIAGONAL: u32 = 2;
pub const HS_BDIAGONAL: u32 = 3;
pub const HS_CROSS: u32 = 4;
pub const HS_DIAGCROSS: u32 = 5;
pub const HS_API_MAX: u32 = 12;
pub const PS_SOLID: u32 = 0;
pub const PS_DASH: u32 = 1;
pub const PS_DOT: u32 = 2;
pub const PS_DASHDOT: u32 = 3;
pub const PS_DASHDOTDOT: u32 = 4;
pub const PS_NULL: u32 = 5;
pub const PS_INSIDEFRAME: u32 = 6;
pub const PS_USERSTYLE: u32 = 7;
pub const PS_ALTERNATE: u32 = 8;
pub const PS_STYLE_MASK: u32 = 15;
pub const PS_ENDCAP_ROUND: u32 = 0;
pub const PS_ENDCAP_SQUARE: u32 = 256;
pub const PS_ENDCAP_FLAT: u32 = 512;
pub const PS_ENDCAP_MASK: u32 = 3840;
pub const PS_JOIN_ROUND: u32 = 0;
pub const PS_JOIN_BEVEL: u32 = 4096;
pub const PS_JOIN_MITER: u32 = 8192;
pub const PS_JOIN_MASK: u32 = 61440;
pub const PS_COSMETIC: u32 = 0;
pub const PS_GEOMETRIC: u32 = 65536;
pub const PS_TYPE_MASK: u32 = 983040;
pub const AD_COUNTERCLOCKWISE: u32 = 1;
pub const AD_CLOCKWISE: u32 = 2;
pub const DRIVERVERSION: u32 = 0;
pub const TECHNOLOGY: u32 = 2;
pub const HORZSIZE: u32 = 4;
pub const VERTSIZE: u32 = 6;
pub const HORZRES: u32 = 8;
pub const VERTRES: u32 = 10;
pub const BITSPIXEL: u32 = 12;
pub const PLANES: u32 = 14;
pub const NUMBRUSHES: u32 = 16;
pub const NUMPENS: u32 = 18;
pub const NUMMARKERS: u32 = 20;
pub const NUMFONTS: u32 = 22;
pub const NUMCOLORS: u32 = 24;
pub const PDEVICESIZE: u32 = 26;
pub const CURVECAPS: u32 = 28;
pub const LINECAPS: u32 = 30;
pub const POLYGONALCAPS: u32 = 32;
pub const TEXTCAPS: u32 = 34;
pub const CLIPCAPS: u32 = 36;
pub const RASTERCAPS: u32 = 38;
pub const ASPECTX: u32 = 40;
pub const ASPECTY: u32 = 42;
pub const ASPECTXY: u32 = 44;
pub const LOGPIXELSX: u32 = 88;
pub const LOGPIXELSY: u32 = 90;
pub const SIZEPALETTE: u32 = 104;
pub const NUMRESERVED: u32 = 106;
pub const COLORRES: u32 = 108;
pub const PHYSICALWIDTH: u32 = 110;
pub const PHYSICALHEIGHT: u32 = 111;
pub const PHYSICALOFFSETX: u32 = 112;
pub const PHYSICALOFFSETY: u32 = 113;
pub const SCALINGFACTORX: u32 = 114;
pub const SCALINGFACTORY: u32 = 115;
pub const VREFRESH: u32 = 116;
pub const DESKTOPVERTRES: u32 = 117;
pub const DESKTOPHORZRES: u32 = 118;
pub const BLTALIGNMENT: u32 = 119;
pub const SHADEBLENDCAPS: u32 = 120;
pub const COLORMGMTCAPS: u32 = 121;
pub const DT_PLOTTER: u32 = 0;
pub const DT_RASDISPLAY: u32 = 1;
pub const DT_RASPRINTER: u32 = 2;
pub const DT_RASCAMERA: u32 = 3;
pub const DT_CHARSTREAM: u32 = 4;
pub const DT_METAFILE: u32 = 5;
pub const DT_DISPFILE: u32 = 6;
pub const CC_NONE: u32 = 0;
pub const CC_CIRCLES: u32 = 1;
pub const CC_PIE: u32 = 2;
pub const CC_CHORD: u32 = 4;
pub const CC_ELLIPSES: u32 = 8;
pub const CC_WIDE: u32 = 16;
pub const CC_STYLED: u32 = 32;
pub const CC_WIDESTYLED: u32 = 64;
pub const CC_INTERIORS: u32 = 128;
pub const CC_ROUNDRECT: u32 = 256;
pub const LC_NONE: u32 = 0;
pub const LC_POLYLINE: u32 = 2;
pub const LC_MARKER: u32 = 4;
pub const LC_POLYMARKER: u32 = 8;
pub const LC_WIDE: u32 = 16;
pub const LC_STYLED: u32 = 32;
pub const LC_WIDESTYLED: u32 = 64;
pub const LC_INTERIORS: u32 = 128;
pub const PC_NONE: u32 = 0;
pub const PC_POLYGON: u32 = 1;
pub const PC_RECTANGLE: u32 = 2;
pub const PC_WINDPOLYGON: u32 = 4;
pub const PC_TRAPEZOID: u32 = 4;
pub const PC_SCANLINE: u32 = 8;
pub const PC_WIDE: u32 = 16;
pub const PC_STYLED: u32 = 32;
pub const PC_WIDESTYLED: u32 = 64;
pub const PC_INTERIORS: u32 = 128;
pub const PC_POLYPOLYGON: u32 = 256;
pub const PC_PATHS: u32 = 512;
pub const CP_NONE: u32 = 0;
pub const CP_RECTANGLE: u32 = 1;
pub const CP_REGION: u32 = 2;
pub const TC_OP_CHARACTER: u32 = 1;
pub const TC_OP_STROKE: u32 = 2;
pub const TC_CP_STROKE: u32 = 4;
pub const TC_CR_90: u32 = 8;
pub const TC_CR_ANY: u32 = 16;
pub const TC_SF_X_YINDEP: u32 = 32;
pub const TC_SA_DOUBLE: u32 = 64;
pub const TC_SA_INTEGER: u32 = 128;
pub const TC_SA_CONTIN: u32 = 256;
pub const TC_EA_DOUBLE: u32 = 512;
pub const TC_IA_ABLE: u32 = 1024;
pub const TC_UA_ABLE: u32 = 2048;
pub const TC_SO_ABLE: u32 = 4096;
pub const TC_RA_ABLE: u32 = 8192;
pub const TC_VA_ABLE: u32 = 16384;
pub const TC_RESERVED: u32 = 32768;
pub const TC_SCROLLBLT: u32 = 65536;
pub const RC_BITBLT: u32 = 1;
pub const RC_BANDING: u32 = 2;
pub const RC_SCALING: u32 = 4;
pub const RC_BITMAP64: u32 = 8;
pub const RC_GDI20_OUTPUT: u32 = 16;
pub const RC_GDI20_STATE: u32 = 32;
pub const RC_SAVEBITMAP: u32 = 64;
pub const RC_DI_BITMAP: u32 = 128;
pub const RC_PALETTE: u32 = 256;
pub const RC_DIBTODEV: u32 = 512;
pub const RC_BIGFONT: u32 = 1024;
pub const RC_STRETCHBLT: u32 = 2048;
pub const RC_FLOODFILL: u32 = 4096;
pub const RC_STRETCHDIB: u32 = 8192;
pub const RC_OP_DX_OUTPUT: u32 = 16384;
pub const RC_DEVBITS: u32 = 32768;
pub const SB_NONE: u32 = 0;
pub const SB_CONST_ALPHA: u32 = 1;
pub const SB_PIXEL_ALPHA: u32 = 2;
pub const SB_PREMULT_ALPHA: u32 = 4;
pub const SB_GRAD_RECT: u32 = 16;
pub const SB_GRAD_TRI: u32 = 32;
pub const CM_NONE: u32 = 0;
pub const CM_DEVICE_ICM: u32 = 1;
pub const CM_GAMMA_RAMP: u32 = 2;
pub const CM_CMYK_COLOR: u32 = 4;
pub const DIB_RGB_COLORS: u32 = 0;
pub const DIB_PAL_COLORS: u32 = 1;
pub const SYSPAL_ERROR: u32 = 0;
pub const SYSPAL_STATIC: u32 = 1;
pub const SYSPAL_NOSTATIC: u32 = 2;
pub const SYSPAL_NOSTATIC256: u32 = 3;
pub const CBM_INIT: u32 = 4;
pub const FLOODFILLBORDER: u32 = 0;
pub const FLOODFILLSURFACE: u32 = 1;
pub const CCHDEVICENAME: u32 = 32;
pub const CCHFORMNAME: u32 = 32;
pub const DM_SPECVERSION: u32 = 1025;
pub const DM_ORIENTATION: u32 = 1;
pub const DM_PAPERSIZE: u32 = 2;
pub const DM_PAPERLENGTH: u32 = 4;
pub const DM_PAPERWIDTH: u32 = 8;
pub const DM_SCALE: u32 = 16;
pub const DM_POSITION: u32 = 32;
pub const DM_NUP: u32 = 64;
pub const DM_DISPLAYORIENTATION: u32 = 128;
pub const DM_COPIES: u32 = 256;
pub const DM_DEFAULTSOURCE: u32 = 512;
pub const DM_PRINTQUALITY: u32 = 1024;
pub const DM_COLOR: u32 = 2048;
pub const DM_DUPLEX: u32 = 4096;
pub const DM_YRESOLUTION: u32 = 8192;
pub const DM_TTOPTION: u32 = 16384;
pub const DM_COLLATE: u32 = 32768;
pub const DM_FORMNAME: u32 = 65536;
pub const DM_LOGPIXELS: u32 = 131072;
pub const DM_BITSPERPEL: u32 = 262144;
pub const DM_PELSWIDTH: u32 = 524288;
pub const DM_PELSHEIGHT: u32 = 1048576;
pub const DM_DISPLAYFLAGS: u32 = 2097152;
pub const DM_DISPLAYFREQUENCY: u32 = 4194304;
pub const DM_ICMMETHOD: u32 = 8388608;
pub const DM_ICMINTENT: u32 = 16777216;
pub const DM_MEDIATYPE: u32 = 33554432;
pub const DM_DITHERTYPE: u32 = 67108864;
pub const DM_PANNINGWIDTH: u32 = 134217728;
pub const DM_PANNINGHEIGHT: u32 = 268435456;
pub const DM_DISPLAYFIXEDOUTPUT: u32 = 536870912;
pub const DMORIENT_PORTRAIT: u32 = 1;
pub const DMORIENT_LANDSCAPE: u32 = 2;
pub const DMPAPER_LETTER: u32 = 1;
pub const DMPAPER_LETTERSMALL: u32 = 2;
pub const DMPAPER_TABLOID: u32 = 3;
pub const DMPAPER_LEDGER: u32 = 4;
pub const DMPAPER_LEGAL: u32 = 5;
pub const DMPAPER_STATEMENT: u32 = 6;
pub const DMPAPER_EXECUTIVE: u32 = 7;
pub const DMPAPER_A3: u32 = 8;
pub const DMPAPER_A4: u32 = 9;
pub const DMPAPER_A4SMALL: u32 = 10;
pub const DMPAPER_A5: u32 = 11;
pub const DMPAPER_B4: u32 = 12;
pub const DMPAPER_B5: u32 = 13;
pub const DMPAPER_FOLIO: u32 = 14;
pub const DMPAPER_QUARTO: u32 = 15;
pub const DMPAPER_10X14: u32 = 16;
pub const DMPAPER_11X17: u32 = 17;
pub const DMPAPER_NOTE: u32 = 18;
pub const DMPAPER_ENV_9: u32 = 19;
pub const DMPAPER_ENV_10: u32 = 20;
pub const DMPAPER_ENV_11: u32 = 21;
pub const DMPAPER_ENV_12: u32 = 22;
pub const DMPAPER_ENV_14: u32 = 23;
pub const DMPAPER_CSHEET: u32 = 24;
pub const DMPAPER_DSHEET: u32 = 25;
pub const DMPAPER_ESHEET: u32 = 26;
pub const DMPAPER_ENV_DL: u32 = 27;
pub const DMPAPER_ENV_C5: u32 = 28;
pub const DMPAPER_ENV_C3: u32 = 29;
pub const DMPAPER_ENV_C4: u32 = 30;
pub const DMPAPER_ENV_C6: u32 = 31;
pub const DMPAPER_ENV_C65: u32 = 32;
pub const DMPAPER_ENV_B4: u32 = 33;
pub const DMPAPER_ENV_B5: u32 = 34;
pub const DMPAPER_ENV_B6: u32 = 35;
pub const DMPAPER_ENV_ITALY: u32 = 36;
pub const DMPAPER_ENV_MONARCH: u32 = 37;
pub const DMPAPER_ENV_PERSONAL: u32 = 38;
pub const DMPAPER_FANFOLD_US: u32 = 39;
pub const DMPAPER_FANFOLD_STD_GERMAN: u32 = 40;
pub const DMPAPER_FANFOLD_LGL_GERMAN: u32 = 41;
pub const DMPAPER_ISO_B4: u32 = 42;
pub const DMPAPER_JAPANESE_POSTCARD: u32 = 43;
pub const DMPAPER_9X11: u32 = 44;
pub const DMPAPER_10X11: u32 = 45;
pub const DMPAPER_15X11: u32 = 46;
pub const DMPAPER_ENV_INVITE: u32 = 47;
pub const DMPAPER_RESERVED_48: u32 = 48;
pub const DMPAPER_RESERVED_49: u32 = 49;
pub const DMPAPER_LETTER_EXTRA: u32 = 50;
pub const DMPAPER_LEGAL_EXTRA: u32 = 51;
pub const DMPAPER_TABLOID_EXTRA: u32 = 52;
pub const DMPAPER_A4_EXTRA: u32 = 53;
pub const DMPAPER_LETTER_TRANSVERSE: u32 = 54;
pub const DMPAPER_A4_TRANSVERSE: u32 = 55;
pub const DMPAPER_LETTER_EXTRA_TRANSVERSE: u32 = 56;
pub const DMPAPER_A_PLUS: u32 = 57;
pub const DMPAPER_B_PLUS: u32 = 58;
pub const DMPAPER_LETTER_PLUS: u32 = 59;
pub const DMPAPER_A4_PLUS: u32 = 60;
pub const DMPAPER_A5_TRANSVERSE: u32 = 61;
pub const DMPAPER_B5_TRANSVERSE: u32 = 62;
pub const DMPAPER_A3_EXTRA: u32 = 63;
pub const DMPAPER_A5_EXTRA: u32 = 64;
pub const DMPAPER_B5_EXTRA: u32 = 65;
pub const DMPAPER_A2: u32 = 66;
pub const DMPAPER_A3_TRANSVERSE: u32 = 67;
pub const DMPAPER_A3_EXTRA_TRANSVERSE: u32 = 68;
pub const DMPAPER_DBL_JAPANESE_POSTCARD: u32 = 69;
pub const DMPAPER_A6: u32 = 70;
pub const DMPAPER_JENV_KAKU2: u32 = 71;
pub const DMPAPER_JENV_KAKU3: u32 = 72;
pub const DMPAPER_JENV_CHOU3: u32 = 73;
pub const DMPAPER_JENV_CHOU4: u32 = 74;
pub const DMPAPER_LETTER_ROTATED: u32 = 75;
pub const DMPAPER_A3_ROTATED: u32 = 76;
pub const DMPAPER_A4_ROTATED: u32 = 77;
pub const DMPAPER_A5_ROTATED: u32 = 78;
pub const DMPAPER_B4_JIS_ROTATED: u32 = 79;
pub const DMPAPER_B5_JIS_ROTATED: u32 = 80;
pub const DMPAPER_JAPANESE_POSTCARD_ROTATED: u32 = 81;
pub const DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED: u32 = 82;
pub const DMPAPER_A6_ROTATED: u32 = 83;
pub const DMPAPER_JENV_KAKU2_ROTATED: u32 = 84;
pub const DMPAPER_JENV_KAKU3_ROTATED: u32 = 85;
pub const DMPAPER_JENV_CHOU3_ROTATED: u32 = 86;
pub const DMPAPER_JENV_CHOU4_ROTATED: u32 = 87;
pub const DMPAPER_B6_JIS: u32 = 88;
pub const DMPAPER_B6_JIS_ROTATED: u32 = 89;
pub const DMPAPER_12X11: u32 = 90;
pub const DMPAPER_JENV_YOU4: u32 = 91;
pub const DMPAPER_JENV_YOU4_ROTATED: u32 = 92;
pub const DMPAPER_P16K: u32 = 93;
pub const DMPAPER_P32K: u32 = 94;
pub const DMPAPER_P32KBIG: u32 = 95;
pub const DMPAPER_PENV_1: u32 = 96;
pub const DMPAPER_PENV_2: u32 = 97;
pub const DMPAPER_PENV_3: u32 = 98;
pub const DMPAPER_PENV_4: u32 = 99;
pub const DMPAPER_PENV_5: u32 = 100;
pub const DMPAPER_PENV_6: u32 = 101;
pub const DMPAPER_PENV_7: u32 = 102;
pub const DMPAPER_PENV_8: u32 = 103;
pub const DMPAPER_PENV_9: u32 = 104;
pub const DMPAPER_PENV_10: u32 = 105;
pub const DMPAPER_P16K_ROTATED: u32 = 106;
pub const DMPAPER_P32K_ROTATED: u32 = 107;
pub const DMPAPER_P32KBIG_ROTATED: u32 = 108;
pub const DMPAPER_PENV_1_ROTATED: u32 = 109;
pub const DMPAPER_PENV_2_ROTATED: u32 = 110;
pub const DMPAPER_PENV_3_ROTATED: u32 = 111;
pub const DMPAPER_PENV_4_ROTATED: u32 = 112;
pub const DMPAPER_PENV_5_ROTATED: u32 = 113;
pub const DMPAPER_PENV_6_ROTATED: u32 = 114;
pub const DMPAPER_PENV_7_ROTATED: u32 = 115;
pub const DMPAPER_PENV_8_ROTATED: u32 = 116;
pub const DMPAPER_PENV_9_ROTATED: u32 = 117;
pub const DMPAPER_PENV_10_ROTATED: u32 = 118;
pub const DMPAPER_LAST: u32 = 118;
pub const DMPAPER_USER: u32 = 256;
pub const DMBIN_UPPER: u32 = 1;
pub const DMBIN_ONLYONE: u32 = 1;
pub const DMBIN_LOWER: u32 = 2;
pub const DMBIN_MIDDLE: u32 = 3;
pub const DMBIN_MANUAL: u32 = 4;
pub const DMBIN_ENVELOPE: u32 = 5;
pub const DMBIN_ENVMANUAL: u32 = 6;
pub const DMBIN_AUTO: u32 = 7;
pub const DMBIN_TRACTOR: u32 = 8;
pub const DMBIN_SMALLFMT: u32 = 9;
pub const DMBIN_LARGEFMT: u32 = 10;
pub const DMBIN_LARGECAPACITY: u32 = 11;
pub const DMBIN_CASSETTE: u32 = 14;
pub const DMBIN_FORMSOURCE: u32 = 15;
pub const DMBIN_LAST: u32 = 15;
pub const DMBIN_USER: u32 = 256;
pub const DMRES_DRAFT: i32 = -1;
pub const DMRES_LOW: i32 = -2;
pub const DMRES_MEDIUM: i32 = -3;
pub const DMRES_HIGH: i32 = -4;
pub const DMCOLOR_MONOCHROME: u32 = 1;
pub const DMCOLOR_COLOR: u32 = 2;
pub const DMDUP_SIMPLEX: u32 = 1;
pub const DMDUP_VERTICAL: u32 = 2;
pub const DMDUP_HORIZONTAL: u32 = 3;
pub const DMTT_BITMAP: u32 = 1;
pub const DMTT_DOWNLOAD: u32 = 2;
pub const DMTT_SUBDEV: u32 = 3;
pub const DMTT_DOWNLOAD_OUTLINE: u32 = 4;
pub const DMCOLLATE_FALSE: u32 = 0;
pub const DMCOLLATE_TRUE: u32 = 1;
pub const DMDO_DEFAULT: u32 = 0;
pub const DMDO_90: u32 = 1;
pub const DMDO_180: u32 = 2;
pub const DMDO_270: u32 = 3;
pub const DMDFO_DEFAULT: u32 = 0;
pub const DMDFO_STRETCH: u32 = 1;
pub const DMDFO_CENTER: u32 = 2;
pub const DM_INTERLACED: u32 = 2;
pub const DMDISPLAYFLAGS_TEXTMODE: u32 = 4;
pub const DMNUP_SYSTEM: u32 = 1;
pub const DMNUP_ONEUP: u32 = 2;
pub const DMICMMETHOD_NONE: u32 = 1;
pub const DMICMMETHOD_SYSTEM: u32 = 2;
pub const DMICMMETHOD_DRIVER: u32 = 3;
pub const DMICMMETHOD_DEVICE: u32 = 4;
pub const DMICMMETHOD_USER: u32 = 256;
pub const DMICM_SATURATE: u32 = 1;
pub const DMICM_CONTRAST: u32 = 2;
pub const DMICM_COLORIMETRIC: u32 = 3;
pub const DMICM_ABS_COLORIMETRIC: u32 = 4;
pub const DMICM_USER: u32 = 256;
pub const DMMEDIA_STANDARD: u32 = 1;
pub const DMMEDIA_TRANSPARENCY: u32 = 2;
pub const DMMEDIA_GLOSSY: u32 = 3;
pub const DMMEDIA_USER: u32 = 256;
pub const DMDITHER_NONE: u32 = 1;
pub const DMDITHER_COARSE: u32 = 2;
pub const DMDITHER_FINE: u32 = 3;
pub const DMDITHER_LINEART: u32 = 4;
pub const DMDITHER_ERRORDIFFUSION: u32 = 5;
pub const DMDITHER_RESERVED6: u32 = 6;
pub const DMDITHER_RESERVED7: u32 = 7;
pub const DMDITHER_RESERVED8: u32 = 8;
pub const DMDITHER_RESERVED9: u32 = 9;
pub const DMDITHER_GRAYSCALE: u32 = 10;
pub const DMDITHER_USER: u32 = 256;
pub const DISPLAY_DEVICE_ATTACHED_TO_DESKTOP: u32 = 1;
pub const DISPLAY_DEVICE_MULTI_DRIVER: u32 = 2;
pub const DISPLAY_DEVICE_PRIMARY_DEVICE: u32 = 4;
pub const DISPLAY_DEVICE_MIRRORING_DRIVER: u32 = 8;
pub const DISPLAY_DEVICE_VGA_COMPATIBLE: u32 = 16;
pub const DISPLAY_DEVICE_REMOVABLE: u32 = 32;
pub const DISPLAY_DEVICE_ACC_DRIVER: u32 = 64;
pub const DISPLAY_DEVICE_MODESPRUNED: u32 = 134217728;
pub const DISPLAY_DEVICE_RDPUDD: u32 = 16777216;
pub const DISPLAY_DEVICE_REMOTE: u32 = 67108864;
pub const DISPLAY_DEVICE_DISCONNECT: u32 = 33554432;
pub const DISPLAY_DEVICE_TS_COMPATIBLE: u32 = 2097152;
pub const DISPLAY_DEVICE_UNSAFE_MODES_ON: u32 = 524288;
pub const DISPLAY_DEVICE_ACTIVE: u32 = 1;
pub const DISPLAY_DEVICE_ATTACHED: u32 = 2;
pub const DISPLAYCONFIG_MAXPATH: u32 = 1024;
pub const DISPLAYCONFIG_PATH_MODE_IDX_INVALID: u32 = 4294967295;
pub const DISPLAYCONFIG_PATH_TARGET_MODE_IDX_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_PATH_DESKTOP_IMAGE_IDX_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_PATH_SOURCE_MODE_IDX_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_PATH_CLONE_GROUP_INVALID: u32 = 65535;
pub const DISPLAYCONFIG_SOURCE_IN_USE: u32 = 1;
pub const DISPLAYCONFIG_TARGET_IN_USE: u32 = 1;
pub const DISPLAYCONFIG_TARGET_FORCIBLE: u32 = 2;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_BOOT: u32 = 4;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_PATH: u32 = 8;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_SYSTEM: u32 = 16;
pub const DISPLAYCONFIG_TARGET_IS_HMD: u32 = 32;
pub const DISPLAYCONFIG_PATH_ACTIVE: u32 = 1;
pub const DISPLAYCONFIG_PATH_PREFERRED_UNSCALED: u32 = 4;
pub const DISPLAYCONFIG_PATH_SUPPORT_VIRTUAL_MODE: u32 = 8;
pub const DISPLAYCONFIG_PATH_VALID_FLAGS: u32 = 29;
pub const QDC_ALL_PATHS: u32 = 1;
pub const QDC_ONLY_ACTIVE_PATHS: u32 = 2;
pub const QDC_DATABASE_CURRENT: u32 = 4;
pub const QDC_VIRTUAL_MODE_AWARE: u32 = 16;
pub const QDC_INCLUDE_HMD: u32 = 32;
pub const QDC_VIRTUAL_REFRESH_RATE_AWARE: u32 = 64;
pub const SDC_TOPOLOGY_INTERNAL: u32 = 1;
pub const SDC_TOPOLOGY_CLONE: u32 = 2;
pub const SDC_TOPOLOGY_EXTEND: u32 = 4;
pub const SDC_TOPOLOGY_EXTERNAL: u32 = 8;
pub const SDC_TOPOLOGY_SUPPLIED: u32 = 16;
pub const SDC_USE_DATABASE_CURRENT: u32 = 15;
pub const SDC_USE_SUPPLIED_DISPLAY_CONFIG: u32 = 32;
pub const SDC_VALIDATE: u32 = 64;
pub const SDC_APPLY: u32 = 128;
pub const SDC_NO_OPTIMIZATION: u32 = 256;
pub const SDC_SAVE_TO_DATABASE: u32 = 512;
pub const SDC_ALLOW_CHANGES: u32 = 1024;
pub const SDC_PATH_PERSIST_IF_REQUIRED: u32 = 2048;
pub const SDC_FORCE_MODE_ENUMERATION: u32 = 4096;
pub const SDC_ALLOW_PATH_ORDER_CHANGES: u32 = 8192;
pub const SDC_VIRTUAL_MODE_AWARE: u32 = 32768;
pub const SDC_VIRTUAL_REFRESH_RATE_AWARE: u32 = 131072;
pub const RDH_RECTANGLES: u32 = 1;
pub const SYSRGN: u32 = 4;
pub const GGO_METRICS: u32 = 0;
pub const GGO_BITMAP: u32 = 1;
pub const GGO_NATIVE: u32 = 2;
pub const GGO_BEZIER: u32 = 3;
pub const GGO_GRAY2_BITMAP: u32 = 4;
pub const GGO_GRAY4_BITMAP: u32 = 5;
pub const GGO_GRAY8_BITMAP: u32 = 6;
pub const GGO_GLYPH_INDEX: u32 = 128;
pub const GGO_UNHINTED: u32 = 256;
pub const TT_POLYGON_TYPE: u32 = 24;
pub const TT_PRIM_LINE: u32 = 1;
pub const TT_PRIM_QSPLINE: u32 = 2;
pub const TT_PRIM_CSPLINE: u32 = 3;
pub const GCP_DBCS: u32 = 1;
pub const GCP_REORDER: u32 = 2;
pub const GCP_USEKERNING: u32 = 8;
pub const GCP_GLYPHSHAPE: u32 = 16;
pub const GCP_LIGATE: u32 = 32;
pub const GCP_DIACRITIC: u32 = 256;
pub const GCP_KASHIDA: u32 = 1024;
pub const GCP_ERROR: u32 = 32768;
pub const FLI_MASK: u32 = 4155;
pub const GCP_JUSTIFY: u32 = 65536;
pub const FLI_GLYPHS: u32 = 262144;
pub const GCP_CLASSIN: u32 = 524288;
pub const GCP_MAXEXTENT: u32 = 1048576;
pub const GCP_JUSTIFYIN: u32 = 2097152;
pub const GCP_DISPLAYZWG: u32 = 4194304;
pub const GCP_SYMSWAPOFF: u32 = 8388608;
pub const GCP_NUMERICOVERRIDE: u32 = 16777216;
pub const GCP_NEUTRALOVERRIDE: u32 = 33554432;
pub const GCP_NUMERICSLATIN: u32 = 67108864;
pub const GCP_NUMERICSLOCAL: u32 = 134217728;
pub const GCPCLASS_LATIN: u32 = 1;
pub const GCPCLASS_HEBREW: u32 = 2;
pub const GCPCLASS_ARABIC: u32 = 2;
pub const GCPCLASS_NEUTRAL: u32 = 3;
pub const GCPCLASS_LOCALNUMBER: u32 = 4;
pub const GCPCLASS_LATINNUMBER: u32 = 5;
pub const GCPCLASS_LATINNUMERICTERMINATOR: u32 = 6;
pub const GCPCLASS_LATINNUMERICSEPARATOR: u32 = 7;
pub const GCPCLASS_NUMERICSEPARATOR: u32 = 8;
pub const GCPCLASS_PREBOUNDLTR: u32 = 128;
pub const GCPCLASS_PREBOUNDRTL: u32 = 64;
pub const GCPCLASS_POSTBOUNDLTR: u32 = 32;
pub const GCPCLASS_POSTBOUNDRTL: u32 = 16;
pub const GCPGLYPH_LINKBEFORE: u32 = 32768;
pub const GCPGLYPH_LINKAFTER: u32 = 16384;
pub const TT_AVAILABLE: u32 = 1;
pub const TT_ENABLED: u32 = 2;
pub const PFD_TYPE_RGBA: u32 = 0;
pub const PFD_TYPE_COLORINDEX: u32 = 1;
pub const PFD_MAIN_PLANE: u32 = 0;
pub const PFD_OVERLAY_PLANE: u32 = 1;
pub const PFD_UNDERLAY_PLANE: i32 = -1;
pub const PFD_DOUBLEBUFFER: u32 = 1;
pub const PFD_STEREO: u32 = 2;
pub const PFD_DRAW_TO_WINDOW: u32 = 4;
pub const PFD_DRAW_TO_BITMAP: u32 = 8;
pub const PFD_SUPPORT_GDI: u32 = 16;
pub const PFD_SUPPORT_OPENGL: u32 = 32;
pub const PFD_GENERIC_FORMAT: u32 = 64;
pub const PFD_NEED_PALETTE: u32 = 128;
pub const PFD_NEED_SYSTEM_PALETTE: u32 = 256;
pub const PFD_SWAP_EXCHANGE: u32 = 512;
pub const PFD_SWAP_COPY: u32 = 1024;
pub const PFD_SWAP_LAYER_BUFFERS: u32 = 2048;
pub const PFD_GENERIC_ACCELERATED: u32 = 4096;
pub const PFD_SUPPORT_DIRECTDRAW: u32 = 8192;
pub const PFD_DIRECT3D_ACCELERATED: u32 = 16384;
pub const PFD_SUPPORT_COMPOSITION: u32 = 32768;
pub const PFD_DEPTH_DONTCARE: u32 = 536870912;
pub const PFD_DOUBLEBUFFER_DONTCARE: u32 = 1073741824;
pub const PFD_STEREO_DONTCARE: u32 = 2147483648;
pub const DC_BINADJUST: u32 = 19;
pub const DC_EMF_COMPLIANT: u32 = 20;
pub const DC_DATATYPE_PRODUCED: u32 = 21;
pub const DC_COLLATE: u32 = 22;
pub const DC_MANUFACTURER: u32 = 23;
pub const DC_MODEL: u32 = 24;
pub const DC_PERSONALITY: u32 = 25;
pub const DC_PRINTRATE: u32 = 26;
pub const DC_PRINTRATEUNIT: u32 = 27;
pub const PRINTRATEUNIT_PPM: u32 = 1;
pub const PRINTRATEUNIT_CPS: u32 = 2;
pub const PRINTRATEUNIT_LPM: u32 = 3;
pub const PRINTRATEUNIT_IPM: u32 = 4;
pub const DC_PRINTERMEM: u32 = 28;
pub const DC_MEDIAREADY: u32 = 29;
pub const DC_STAPLE: u32 = 30;
pub const DC_PRINTRATEPPM: u32 = 31;
pub const DC_COLORDEVICE: u32 = 32;
pub const DC_NUP: u32 = 33;
pub const DC_MEDIATYPENAMES: u32 = 34;
pub const DC_MEDIATYPES: u32 = 35;
pub const DCTT_BITMAP: u32 = 1;
pub const DCTT_DOWNLOAD: u32 = 2;
pub const DCTT_SUBDEV: u32 = 4;
pub const DCTT_DOWNLOAD_OUTLINE: u32 = 8;
pub const DCBA_FACEUPNONE: u32 = 0;
pub const DCBA_FACEUPCENTER: u32 = 1;
pub const DCBA_FACEUPLEFT: u32 = 2;
pub const DCBA_FACEUPRIGHT: u32 = 3;
pub const DCBA_FACEDOWNNONE: u32 = 256;
pub const DCBA_FACEDOWNCENTER: u32 = 257;
pub const DCBA_FACEDOWNLEFT: u32 = 258;
pub const DCBA_FACEDOWNRIGHT: u32 = 259;
pub const GS_8BIT_INDICES: u32 = 1;
pub const GGI_MARK_NONEXISTING_GLYPHS: u32 = 1;
pub const MM_MAX_NUMAXES: u32 = 16;
pub const FR_PRIVATE: u32 = 16;
pub const FR_NOT_ENUM: u32 = 32;
pub const MM_MAX_AXES_NAMELEN: u32 = 16;
pub const AC_SRC_OVER: u32 = 0;
pub const AC_SRC_ALPHA: u32 = 1;
pub const GRADIENT_FILL_RECT_H: u32 = 0;
pub const GRADIENT_FILL_RECT_V: u32 = 1;
pub const GRADIENT_FILL_TRIANGLE: u32 = 2;
pub const GRADIENT_FILL_OP_FLAG: u32 = 255;
pub const CA_NEGATIVE: u32 = 1;
pub const CA_LOG_FILTER: u32 = 2;
pub const ILLUMINANT_DEVICE_DEFAULT: u32 = 0;
pub const ILLUMINANT_A: u32 = 1;
pub const ILLUMINANT_B: u32 = 2;
pub const ILLUMINANT_C: u32 = 3;
pub const ILLUMINANT_D50: u32 = 4;
pub const ILLUMINANT_D55: u32 = 5;
pub const ILLUMINANT_D65: u32 = 6;
pub const ILLUMINANT_D75: u32 = 7;
pub const ILLUMINANT_F2: u32 = 8;
pub const ILLUMINANT_MAX_INDEX: u32 = 8;
pub const ILLUMINANT_TUNGSTEN: u32 = 1;
pub const ILLUMINANT_DAYLIGHT: u32 = 3;
pub const ILLUMINANT_FLUORESCENT: u32 = 8;
pub const ILLUMINANT_NTSC: u32 = 3;
pub const DI_APPBANDING: u32 = 1;
pub const DI_ROPS_READ_DESTINATION: u32 = 2;
pub const FONTMAPPER_MAX: u32 = 10;
pub const ICM_OFF: u32 = 1;
pub const ICM_ON: u32 = 2;
pub const ICM_QUERY: u32 = 3;
pub const ICM_DONE_OUTSIDEDC: u32 = 4;
pub const ENHMETA_SIGNATURE: u32 = 1179469088;
pub const ENHMETA_STOCK_OBJECT: u32 = 2147483648;
pub const EMR_HEADER: u32 = 1;
pub const EMR_POLYBEZIER: u32 = 2;
pub const EMR_POLYGON: u32 = 3;
pub const EMR_POLYLINE: u32 = 4;
pub const EMR_POLYBEZIERTO: u32 = 5;
pub const EMR_POLYLINETO: u32 = 6;
pub const EMR_POLYPOLYLINE: u32 = 7;
pub const EMR_POLYPOLYGON: u32 = 8;
pub const EMR_SETWINDOWEXTEX: u32 = 9;
pub const EMR_SETWINDOWORGEX: u32 = 10;
pub const EMR_SETVIEWPORTEXTEX: u32 = 11;
pub const EMR_SETVIEWPORTORGEX: u32 = 12;
pub const EMR_SETBRUSHORGEX: u32 = 13;
pub const EMR_EOF: u32 = 14;
pub const EMR_SETPIXELV: u32 = 15;
pub const EMR_SETMAPPERFLAGS: u32 = 16;
pub const EMR_SETMAPMODE: u32 = 17;
pub const EMR_SETBKMODE: u32 = 18;
pub const EMR_SETPOLYFILLMODE: u32 = 19;
pub const EMR_SETROP2: u32 = 20;
pub const EMR_SETSTRETCHBLTMODE: u32 = 21;
pub const EMR_SETTEXTALIGN: u32 = 22;
pub const EMR_SETCOLORADJUSTMENT: u32 = 23;
pub const EMR_SETTEXTCOLOR: u32 = 24;
pub const EMR_SETBKCOLOR: u32 = 25;
pub const EMR_OFFSETCLIPRGN: u32 = 26;
pub const EMR_MOVETOEX: u32 = 27;
pub const EMR_SETMETARGN: u32 = 28;
pub const EMR_EXCLUDECLIPRECT: u32 = 29;
pub const EMR_INTERSECTCLIPRECT: u32 = 30;
pub const EMR_SCALEVIEWPORTEXTEX: u32 = 31;
pub const EMR_SCALEWINDOWEXTEX: u32 = 32;
pub const EMR_SAVEDC: u32 = 33;
pub const EMR_RESTOREDC: u32 = 34;
pub const EMR_SETWORLDTRANSFORM: u32 = 35;
pub const EMR_MODIFYWORLDTRANSFORM: u32 = 36;
pub const EMR_SELECTOBJECT: u32 = 37;
pub const EMR_CREATEPEN: u32 = 38;
pub const EMR_CREATEBRUSHINDIRECT: u32 = 39;
pub const EMR_DELETEOBJECT: u32 = 40;
pub const EMR_ANGLEARC: u32 = 41;
pub const EMR_ELLIPSE: u32 = 42;
pub const EMR_RECTANGLE: u32 = 43;
pub const EMR_ROUNDRECT: u32 = 44;
pub const EMR_ARC: u32 = 45;
pub const EMR_CHORD: u32 = 46;
pub const EMR_PIE: u32 = 47;
pub const EMR_SELECTPALETTE: u32 = 48;
pub const EMR_CREATEPALETTE: u32 = 49;
pub const EMR_SETPALETTEENTRIES: u32 = 50;
pub const EMR_RESIZEPALETTE: u32 = 51;
pub const EMR_REALIZEPALETTE: u32 = 52;
pub const EMR_EXTFLOODFILL: u32 = 53;
pub const EMR_LINETO: u32 = 54;
pub const EMR_ARCTO: u32 = 55;
pub const EMR_POLYDRAW: u32 = 56;
pub const EMR_SETARCDIRECTION: u32 = 57;
pub const EMR_SETMITERLIMIT: u32 = 58;
pub const EMR_BEGINPATH: u32 = 59;
pub const EMR_ENDPATH: u32 = 60;
pub const EMR_CLOSEFIGURE: u32 = 61;
pub const EMR_FILLPATH: u32 = 62;
pub const EMR_STROKEANDFILLPATH: u32 = 63;
pub const EMR_STROKEPATH: u32 = 64;
pub const EMR_FLATTENPATH: u32 = 65;
pub const EMR_WIDENPATH: u32 = 66;
pub const EMR_SELECTCLIPPATH: u32 = 67;
pub const EMR_ABORTPATH: u32 = 68;
pub const EMR_GDICOMMENT: u32 = 70;
pub const EMR_FILLRGN: u32 = 71;
pub const EMR_FRAMERGN: u32 = 72;
pub const EMR_INVERTRGN: u32 = 73;
pub const EMR_PAINTRGN: u32 = 74;
pub const EMR_EXTSELECTCLIPRGN: u32 = 75;
pub const EMR_BITBLT: u32 = 76;
pub const EMR_STRETCHBLT: u32 = 77;
pub const EMR_MASKBLT: u32 = 78;
pub const EMR_PLGBLT: u32 = 79;
pub const EMR_SETDIBITSTODEVICE: u32 = 80;
pub const EMR_STRETCHDIBITS: u32 = 81;
pub const EMR_EXTCREATEFONTINDIRECTW: u32 = 82;
pub const EMR_EXTTEXTOUTA: u32 = 83;
pub const EMR_EXTTEXTOUTW: u32 = 84;
pub const EMR_POLYBEZIER16: u32 = 85;
pub const EMR_POLYGON16: u32 = 86;
pub const EMR_POLYLINE16: u32 = 87;
pub const EMR_POLYBEZIERTO16: u32 = 88;
pub const EMR_POLYLINETO16: u32 = 89;
pub const EMR_POLYPOLYLINE16: u32 = 90;
pub const EMR_POLYPOLYGON16: u32 = 91;
pub const EMR_POLYDRAW16: u32 = 92;
pub const EMR_CREATEMONOBRUSH: u32 = 93;
pub const EMR_CREATEDIBPATTERNBRUSHPT: u32 = 94;
pub const EMR_EXTCREATEPEN: u32 = 95;
pub const EMR_POLYTEXTOUTA: u32 = 96;
pub const EMR_POLYTEXTOUTW: u32 = 97;
pub const EMR_SETICMMODE: u32 = 98;
pub const EMR_CREATECOLORSPACE: u32 = 99;
pub const EMR_SETCOLORSPACE: u32 = 100;
pub const EMR_DELETECOLORSPACE: u32 = 101;
pub const EMR_GLSRECORD: u32 = 102;
pub const EMR_GLSBOUNDEDRECORD: u32 = 103;
pub const EMR_PIXELFORMAT: u32 = 104;
pub const EMR_RESERVED_105: u32 = 105;
pub const EMR_RESERVED_106: u32 = 106;
pub const EMR_RESERVED_107: u32 = 107;
pub const EMR_RESERVED_108: u32 = 108;
pub const EMR_RESERVED_109: u32 = 109;
pub const EMR_RESERVED_110: u32 = 110;
pub const EMR_COLORCORRECTPALETTE: u32 = 111;
pub const EMR_SETICMPROFILEA: u32 = 112;
pub const EMR_SETICMPROFILEW: u32 = 113;
pub const EMR_ALPHABLEND: u32 = 114;
pub const EMR_SETLAYOUT: u32 = 115;
pub const EMR_TRANSPARENTBLT: u32 = 116;
pub const EMR_RESERVED_117: u32 = 117;
pub const EMR_GRADIENTFILL: u32 = 118;
pub const EMR_RESERVED_119: u32 = 119;
pub const EMR_RESERVED_120: u32 = 120;
pub const EMR_COLORMATCHTOTARGETW: u32 = 121;
pub const EMR_CREATECOLORSPACEW: u32 = 122;
pub const EMR_MIN: u32 = 1;
pub const EMR_MAX: u32 = 122;
pub const SETICMPROFILE_EMBEDED: u32 = 1;
pub const CREATECOLORSPACE_EMBEDED: u32 = 1;
pub const COLORMATCHTOTARGET_EMBEDED: u32 = 1;
pub const GDICOMMENT_IDENTIFIER: u32 = 1128875079;
pub const GDICOMMENT_WINDOWS_METAFILE: u32 = 2147483649;
pub const GDICOMMENT_BEGINGROUP: u32 = 2;
pub const GDICOMMENT_ENDGROUP: u32 = 3;
pub const GDICOMMENT_MULTIFORMATS: u32 = 1073741828;
pub const EPS_SIGNATURE: u32 = 1179865157;
pub const GDICOMMENT_UNICODE_STRING: u32 = 64;
pub const GDICOMMENT_UNICODE_END: u32 = 128;
pub const WGL_FONT_LINES: u32 = 0;
pub const WGL_FONT_POLYGONS: u32 = 1;
pub const LPD_DOUBLEBUFFER: u32 = 1;
pub const LPD_STEREO: u32 = 2;
pub const LPD_SUPPORT_GDI: u32 = 16;
pub const LPD_SUPPORT_OPENGL: u32 = 32;
pub const LPD_SHARE_DEPTH: u32 = 64;
pub const LPD_SHARE_STENCIL: u32 = 128;
pub const LPD_SHARE_ACCUM: u32 = 256;
pub const LPD_SWAP_EXCHANGE: u32 = 512;
pub const LPD_SWAP_COPY: u32 = 1024;
pub const LPD_TRANSPARENT: u32 = 4096;
pub const LPD_TYPE_RGBA: u32 = 0;
pub const LPD_TYPE_COLORINDEX: u32 = 1;
pub const WGL_SWAP_MAIN_PLANE: u32 = 1;
pub const WGL_SWAP_OVERLAY1: u32 = 2;
pub const WGL_SWAP_OVERLAY2: u32 = 4;
pub const WGL_SWAP_OVERLAY3: u32 = 8;
pub const WGL_SWAP_OVERLAY4: u32 = 16;
pub const WGL_SWAP_OVERLAY5: u32 = 32;
pub const WGL_SWAP_OVERLAY6: u32 = 64;
pub const WGL_SWAP_OVERLAY7: u32 = 128;
pub const WGL_SWAP_OVERLAY8: u32 = 256;
pub const WGL_SWAP_OVERLAY9: u32 = 512;
pub const WGL_SWAP_OVERLAY10: u32 = 1024;
pub const WGL_SWAP_OVERLAY11: u32 = 2048;
pub const WGL_SWAP_OVERLAY12: u32 = 4096;
pub const WGL_SWAP_OVERLAY13: u32 = 8192;
pub const WGL_SWAP_OVERLAY14: u32 = 16384;
pub const WGL_SWAP_OVERLAY15: u32 = 32768;
pub const WGL_SWAP_UNDERLAY1: u32 = 65536;
pub const WGL_SWAP_UNDERLAY2: u32 = 131072;
pub const WGL_SWAP_UNDERLAY3: u32 = 262144;
pub const WGL_SWAP_UNDERLAY4: u32 = 524288;
pub const WGL_SWAP_UNDERLAY5: u32 = 1048576;
pub const WGL_SWAP_UNDERLAY6: u32 = 2097152;
pub const WGL_SWAP_UNDERLAY7: u32 = 4194304;
pub const WGL_SWAP_UNDERLAY8: u32 = 8388608;
pub const WGL_SWAP_UNDERLAY9: u32 = 16777216;
pub const WGL_SWAP_UNDERLAY10: u32 = 33554432;
pub const WGL_SWAP_UNDERLAY11: u32 = 67108864;
pub const WGL_SWAP_UNDERLAY12: u32 = 134217728;
pub const WGL_SWAP_UNDERLAY13: u32 = 268435456;
pub const WGL_SWAP_UNDERLAY14: u32 = 536870912;
pub const WGL_SWAP_UNDERLAY15: u32 = 1073741824;
pub const WGL_SWAPMULTIPLE_MAX: u32 = 16;
pub const DIFFERENCE: u32 = 11;
pub const SB_HORZ: u32 = 0;
pub const SB_VERT: u32 = 1;
pub const SB_CTL: u32 = 2;
pub const SB_BOTH: u32 = 3;
pub const SB_LINEUP: u32 = 0;
pub const SB_LINELEFT: u32 = 0;
pub const SB_LINEDOWN: u32 = 1;
pub const SB_LINERIGHT: u32 = 1;
pub const SB_PAGEUP: u32 = 2;
pub const SB_PAGELEFT: u32 = 2;
pub const SB_PAGEDOWN: u32 = 3;
pub const SB_PAGERIGHT: u32 = 3;
pub const SB_THUMBPOSITION: u32 = 4;
pub const SB_THUMBTRACK: u32 = 5;
pub const SB_TOP: u32 = 6;
pub const SB_LEFT: u32 = 6;
pub const SB_BOTTOM: u32 = 7;
pub const SB_RIGHT: u32 = 7;
pub const SB_ENDSCROLL: u32 = 8;
pub const SW_HIDE: u32 = 0;
pub const SW_SHOWNORMAL: u32 = 1;
pub const SW_NORMAL: u32 = 1;
pub const SW_SHOWMINIMIZED: u32 = 2;
pub const SW_SHOWMAXIMIZED: u32 = 3;
pub const SW_MAXIMIZE: u32 = 3;
pub const SW_SHOWNOACTIVATE: u32 = 4;
pub const SW_SHOW: u32 = 5;
pub const SW_MINIMIZE: u32 = 6;
pub const SW_SHOWMINNOACTIVE: u32 = 7;
pub const SW_SHOWNA: u32 = 8;
pub const SW_RESTORE: u32 = 9;
pub const SW_SHOWDEFAULT: u32 = 10;
pub const SW_FORCEMINIMIZE: u32 = 11;
pub const SW_MAX: u32 = 11;
pub const HIDE_WINDOW: u32 = 0;
pub const SHOW_OPENWINDOW: u32 = 1;
pub const SHOW_ICONWINDOW: u32 = 2;
pub const SHOW_FULLSCREEN: u32 = 3;
pub const SHOW_OPENNOACTIVATE: u32 = 4;
pub const SW_PARENTCLOSING: u32 = 1;
pub const SW_OTHERZOOM: u32 = 2;
pub const SW_PARENTOPENING: u32 = 3;
pub const SW_OTHERUNZOOM: u32 = 4;
pub const AW_HOR_POSITIVE: u32 = 1;
pub const AW_HOR_NEGATIVE: u32 = 2;
pub const AW_VER_POSITIVE: u32 = 4;
pub const AW_VER_NEGATIVE: u32 = 8;
pub const AW_CENTER: u32 = 16;
pub const AW_HIDE: u32 = 65536;
pub const AW_ACTIVATE: u32 = 131072;
pub const AW_SLIDE: u32 = 262144;
pub const AW_BLEND: u32 = 524288;
pub const KF_EXTENDED: u32 = 256;
pub const KF_DLGMODE: u32 = 2048;
pub const KF_MENUMODE: u32 = 4096;
pub const KF_ALTDOWN: u32 = 8192;
pub const KF_REPEAT: u32 = 16384;
pub const KF_UP: u32 = 32768;
pub const VK_LBUTTON: u32 = 1;
pub const VK_RBUTTON: u32 = 2;
pub const VK_CANCEL: u32 = 3;
pub const VK_MBUTTON: u32 = 4;
pub const VK_XBUTTON1: u32 = 5;
pub const VK_XBUTTON2: u32 = 6;
pub const VK_BACK: u32 = 8;
pub const VK_TAB: u32 = 9;
pub const VK_CLEAR: u32 = 12;
pub const VK_RETURN: u32 = 13;
pub const VK_SHIFT: u32 = 16;
pub const VK_CONTROL: u32 = 17;
pub const VK_MENU: u32 = 18;
pub const VK_PAUSE: u32 = 19;
pub const VK_CAPITAL: u32 = 20;
pub const VK_KANA: u32 = 21;
pub const VK_HANGEUL: u32 = 21;
pub const VK_HANGUL: u32 = 21;
pub const VK_IME_ON: u32 = 22;
pub const VK_JUNJA: u32 = 23;
pub const VK_FINAL: u32 = 24;
pub const VK_HANJA: u32 = 25;
pub const VK_KANJI: u32 = 25;
pub const VK_IME_OFF: u32 = 26;
pub const VK_ESCAPE: u32 = 27;
pub const VK_CONVERT: u32 = 28;
pub const VK_NONCONVERT: u32 = 29;
pub const VK_ACCEPT: u32 = 30;
pub const VK_MODECHANGE: u32 = 31;
pub const VK_SPACE: u32 = 32;
pub const VK_PRIOR: u32 = 33;
pub const VK_NEXT: u32 = 34;
pub const VK_END: u32 = 35;
pub const VK_HOME: u32 = 36;
pub const VK_LEFT: u32 = 37;
pub const VK_UP: u32 = 38;
pub const VK_RIGHT: u32 = 39;
pub const VK_DOWN: u32 = 40;
pub const VK_SELECT: u32 = 41;
pub const VK_PRINT: u32 = 42;
pub const VK_EXECUTE: u32 = 43;
pub const VK_SNAPSHOT: u32 = 44;
pub const VK_INSERT: u32 = 45;
pub const VK_DELETE: u32 = 46;
pub const VK_HELP: u32 = 47;
pub const VK_LWIN: u32 = 91;
pub const VK_RWIN: u32 = 92;
pub const VK_APPS: u32 = 93;
pub const VK_SLEEP: u32 = 95;
pub const VK_NUMPAD0: u32 = 96;
pub const VK_NUMPAD1: u32 = 97;
pub const VK_NUMPAD2: u32 = 98;
pub const VK_NUMPAD3: u32 = 99;
pub const VK_NUMPAD4: u32 = 100;
pub const VK_NUMPAD5: u32 = 101;
pub const VK_NUMPAD6: u32 = 102;
pub const VK_NUMPAD7: u32 = 103;
pub const VK_NUMPAD8: u32 = 104;
pub const VK_NUMPAD9: u32 = 105;
pub const VK_MULTIPLY: u32 = 106;
pub const VK_ADD: u32 = 107;
pub const VK_SEPARATOR: u32 = 108;
pub const VK_SUBTRACT: u32 = 109;
pub const VK_DECIMAL: u32 = 110;
pub const VK_DIVIDE: u32 = 111;
pub const VK_F1: u32 = 112;
pub const VK_F2: u32 = 113;
pub const VK_F3: u32 = 114;
pub const VK_F4: u32 = 115;
pub const VK_F5: u32 = 116;
pub const VK_F6: u32 = 117;
pub const VK_F7: u32 = 118;
pub const VK_F8: u32 = 119;
pub const VK_F9: u32 = 120;
pub const VK_F10: u32 = 121;
pub const VK_F11: u32 = 122;
pub const VK_F12: u32 = 123;
pub const VK_F13: u32 = 124;
pub const VK_F14: u32 = 125;
pub const VK_F15: u32 = 126;
pub const VK_F16: u32 = 127;
pub const VK_F17: u32 = 128;
pub const VK_F18: u32 = 129;
pub const VK_F19: u32 = 130;
pub const VK_F20: u32 = 131;
pub const VK_F21: u32 = 132;
pub const VK_F22: u32 = 133;
pub const VK_F23: u32 = 134;
pub const VK_F24: u32 = 135;
pub const VK_NAVIGATION_VIEW: u32 = 136;
pub const VK_NAVIGATION_MENU: u32 = 137;
pub const VK_NAVIGATION_UP: u32 = 138;
pub const VK_NAVIGATION_DOWN: u32 = 139;
pub const VK_NAVIGATION_LEFT: u32 = 140;
pub const VK_NAVIGATION_RIGHT: u32 = 141;
pub const VK_NAVIGATION_ACCEPT: u32 = 142;
pub const VK_NAVIGATION_CANCEL: u32 = 143;
pub const VK_NUMLOCK: u32 = 144;
pub const VK_SCROLL: u32 = 145;
pub const VK_OEM_NEC_EQUAL: u32 = 146;
pub const VK_OEM_FJ_JISHO: u32 = 146;
pub const VK_OEM_FJ_MASSHOU: u32 = 147;
pub const VK_OEM_FJ_TOUROKU: u32 = 148;
pub const VK_OEM_FJ_LOYA: u32 = 149;
pub const VK_OEM_FJ_ROYA: u32 = 150;
pub const VK_LSHIFT: u32 = 160;
pub const VK_RSHIFT: u32 = 161;
pub const VK_LCONTROL: u32 = 162;
pub const VK_RCONTROL: u32 = 163;
pub const VK_LMENU: u32 = 164;
pub const VK_RMENU: u32 = 165;
pub const VK_BROWSER_BACK: u32 = 166;
pub const VK_BROWSER_FORWARD: u32 = 167;
pub const VK_BROWSER_REFRESH: u32 = 168;
pub const VK_BROWSER_STOP: u32 = 169;
pub const VK_BROWSER_SEARCH: u32 = 170;
pub const VK_BROWSER_FAVORITES: u32 = 171;
pub const VK_BROWSER_HOME: u32 = 172;
pub const VK_VOLUME_MUTE: u32 = 173;
pub const VK_VOLUME_DOWN: u32 = 174;
pub const VK_VOLUME_UP: u32 = 175;
pub const VK_MEDIA_NEXT_TRACK: u32 = 176;
pub const VK_MEDIA_PREV_TRACK: u32 = 177;
pub const VK_MEDIA_STOP: u32 = 178;
pub const VK_MEDIA_PLAY_PAUSE: u32 = 179;
pub const VK_LAUNCH_MAIL: u32 = 180;
pub const VK_LAUNCH_MEDIA_SELECT: u32 = 181;
pub const VK_LAUNCH_APP1: u32 = 182;
pub const VK_LAUNCH_APP2: u32 = 183;
pub const VK_OEM_1: u32 = 186;
pub const VK_OEM_PLUS: u32 = 187;
pub const VK_OEM_COMMA: u32 = 188;
pub const VK_OEM_MINUS: u32 = 189;
pub const VK_OEM_PERIOD: u32 = 190;
pub const VK_OEM_2: u32 = 191;
pub const VK_OEM_3: u32 = 192;
pub const VK_GAMEPAD_A: u32 = 195;
pub const VK_GAMEPAD_B: u32 = 196;
pub const VK_GAMEPAD_X: u32 = 197;
pub const VK_GAMEPAD_Y: u32 = 198;
pub const VK_GAMEPAD_RIGHT_SHOULDER: u32 = 199;
pub const VK_GAMEPAD_LEFT_SHOULDER: u32 = 200;
pub const VK_GAMEPAD_LEFT_TRIGGER: u32 = 201;
pub const VK_GAMEPAD_RIGHT_TRIGGER: u32 = 202;
pub const VK_GAMEPAD_DPAD_UP: u32 = 203;
pub const VK_GAMEPAD_DPAD_DOWN: u32 = 204;
pub const VK_GAMEPAD_DPAD_LEFT: u32 = 205;
pub const VK_GAMEPAD_DPAD_RIGHT: u32 = 206;
pub const VK_GAMEPAD_MENU: u32 = 207;
pub const VK_GAMEPAD_VIEW: u32 = 208;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON: u32 = 209;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON: u32 = 210;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_UP: u32 = 211;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_DOWN: u32 = 212;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT: u32 = 213;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_LEFT: u32 = 214;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_UP: u32 = 215;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN: u32 = 216;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT: u32 = 217;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT: u32 = 218;
pub const VK_OEM_4: u32 = 219;
pub const VK_OEM_5: u32 = 220;
pub const VK_OEM_6: u32 = 221;
pub const VK_OEM_7: u32 = 222;
pub const VK_OEM_8: u32 = 223;
pub const VK_OEM_AX: u32 = 225;
pub const VK_OEM_102: u32 = 226;
pub const VK_ICO_HELP: u32 = 227;
pub const VK_ICO_00: u32 = 228;
pub const VK_PROCESSKEY: u32 = 229;
pub const VK_ICO_CLEAR: u32 = 230;
pub const VK_PACKET: u32 = 231;
pub const VK_OEM_RESET: u32 = 233;
pub const VK_OEM_JUMP: u32 = 234;
pub const VK_OEM_PA1: u32 = 235;
pub const VK_OEM_PA2: u32 = 236;
pub const VK_OEM_PA3: u32 = 237;
pub const VK_OEM_WSCTRL: u32 = 238;
pub const VK_OEM_CUSEL: u32 = 239;
pub const VK_OEM_ATTN: u32 = 240;
pub const VK_OEM_FINISH: u32 = 241;
pub const VK_OEM_COPY: u32 = 242;
pub const VK_OEM_AUTO: u32 = 243;
pub const VK_OEM_ENLW: u32 = 244;
pub const VK_OEM_BACKTAB: u32 = 245;
pub const VK_ATTN: u32 = 246;
pub const VK_CRSEL: u32 = 247;
pub const VK_EXSEL: u32 = 248;
pub const VK_EREOF: u32 = 249;
pub const VK_PLAY: u32 = 250;
pub const VK_ZOOM: u32 = 251;
pub const VK_NONAME: u32 = 252;
pub const VK_PA1: u32 = 253;
pub const VK_OEM_CLEAR: u32 = 254;
pub const WH_MIN: i32 = -1;
pub const WH_MSGFILTER: i32 = -1;
pub const WH_JOURNALRECORD: u32 = 0;
pub const WH_JOURNALPLAYBACK: u32 = 1;
pub const WH_KEYBOARD: u32 = 2;
pub const WH_GETMESSAGE: u32 = 3;
pub const WH_CALLWNDPROC: u32 = 4;
pub const WH_CBT: u32 = 5;
pub const WH_SYSMSGFILTER: u32 = 6;
pub const WH_MOUSE: u32 = 7;
pub const WH_DEBUG: u32 = 9;
pub const WH_SHELL: u32 = 10;
pub const WH_FOREGROUNDIDLE: u32 = 11;
pub const WH_CALLWNDPROCRET: u32 = 12;
pub const WH_KEYBOARD_LL: u32 = 13;
pub const WH_MOUSE_LL: u32 = 14;
pub const WH_MAX: u32 = 14;
pub const WH_MINHOOK: i32 = -1;
pub const WH_MAXHOOK: u32 = 14;
pub const HC_ACTION: u32 = 0;
pub const HC_GETNEXT: u32 = 1;
pub const HC_SKIP: u32 = 2;
pub const HC_NOREMOVE: u32 = 3;
pub const HC_NOREM: u32 = 3;
pub const HC_SYSMODALON: u32 = 4;
pub const HC_SYSMODALOFF: u32 = 5;
pub const HCBT_MOVESIZE: u32 = 0;
pub const HCBT_MINMAX: u32 = 1;
pub const HCBT_QS: u32 = 2;
pub const HCBT_CREATEWND: u32 = 3;
pub const HCBT_DESTROYWND: u32 = 4;
pub const HCBT_ACTIVATE: u32 = 5;
pub const HCBT_CLICKSKIPPED: u32 = 6;
pub const HCBT_KEYSKIPPED: u32 = 7;
pub const HCBT_SYSCOMMAND: u32 = 8;
pub const HCBT_SETFOCUS: u32 = 9;
pub const WTS_CONSOLE_CONNECT: u32 = 1;
pub const WTS_CONSOLE_DISCONNECT: u32 = 2;
pub const WTS_REMOTE_CONNECT: u32 = 3;
pub const WTS_REMOTE_DISCONNECT: u32 = 4;
pub const WTS_SESSION_LOGON: u32 = 5;
pub const WTS_SESSION_LOGOFF: u32 = 6;
pub const WTS_SESSION_LOCK: u32 = 7;
pub const WTS_SESSION_UNLOCK: u32 = 8;
pub const WTS_SESSION_REMOTE_CONTROL: u32 = 9;
pub const WTS_SESSION_CREATE: u32 = 10;
pub const WTS_SESSION_TERMINATE: u32 = 11;
pub const MSGF_DIALOGBOX: u32 = 0;
pub const MSGF_MESSAGEBOX: u32 = 1;
pub const MSGF_MENU: u32 = 2;
pub const MSGF_SCROLLBAR: u32 = 5;
pub const MSGF_NEXTWINDOW: u32 = 6;
pub const MSGF_MAX: u32 = 8;
pub const MSGF_USER: u32 = 4096;
pub const HSHELL_WINDOWCREATED: u32 = 1;
pub const HSHELL_WINDOWDESTROYED: u32 = 2;
pub const HSHELL_ACTIVATESHELLWINDOW: u32 = 3;
pub const HSHELL_WINDOWACTIVATED: u32 = 4;
pub const HSHELL_GETMINRECT: u32 = 5;
pub const HSHELL_REDRAW: u32 = 6;
pub const HSHELL_TASKMAN: u32 = 7;
pub const HSHELL_LANGUAGE: u32 = 8;
pub const HSHELL_SYSMENU: u32 = 9;
pub const HSHELL_ENDTASK: u32 = 10;
pub const HSHELL_ACCESSIBILITYSTATE: u32 = 11;
pub const HSHELL_APPCOMMAND: u32 = 12;
pub const HSHELL_WINDOWREPLACED: u32 = 13;
pub const HSHELL_WINDOWREPLACING: u32 = 14;
pub const HSHELL_MONITORCHANGED: u32 = 16;
pub const HSHELL_HIGHBIT: u32 = 32768;
pub const HSHELL_FLASH: u32 = 32774;
pub const HSHELL_RUDEAPPACTIVATED: u32 = 32772;
pub const APPCOMMAND_BROWSER_BACKWARD: u32 = 1;
pub const APPCOMMAND_BROWSER_FORWARD: u32 = 2;
pub const APPCOMMAND_BROWSER_REFRESH: u32 = 3;
pub const APPCOMMAND_BROWSER_STOP: u32 = 4;
pub const APPCOMMAND_BROWSER_SEARCH: u32 = 5;
pub const APPCOMMAND_BROWSER_FAVORITES: u32 = 6;
pub const APPCOMMAND_BROWSER_HOME: u32 = 7;
pub const APPCOMMAND_VOLUME_MUTE: u32 = 8;
pub const APPCOMMAND_VOLUME_DOWN: u32 = 9;
pub const APPCOMMAND_VOLUME_UP: u32 = 10;
pub const APPCOMMAND_MEDIA_NEXTTRACK: u32 = 11;
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK: u32 = 12;
pub const APPCOMMAND_MEDIA_STOP: u32 = 13;
pub const APPCOMMAND_MEDIA_PLAY_PAUSE: u32 = 14;
pub const APPCOMMAND_LAUNCH_MAIL: u32 = 15;
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT: u32 = 16;
pub const APPCOMMAND_LAUNCH_APP1: u32 = 17;
pub const APPCOMMAND_LAUNCH_APP2: u32 = 18;
pub const APPCOMMAND_BASS_DOWN: u32 = 19;
pub const APPCOMMAND_BASS_BOOST: u32 = 20;
pub const APPCOMMAND_BASS_UP: u32 = 21;
pub const APPCOMMAND_TREBLE_DOWN: u32 = 22;
pub const APPCOMMAND_TREBLE_UP: u32 = 23;
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE: u32 = 24;
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN: u32 = 25;
pub const APPCOMMAND_MICROPHONE_VOLUME_UP: u32 = 26;
pub const APPCOMMAND_HELP: u32 = 27;
pub const APPCOMMAND_FIND: u32 = 28;
pub const APPCOMMAND_NEW: u32 = 29;
pub const APPCOMMAND_OPEN: u32 = 30;
pub const APPCOMMAND_CLOSE: u32 = 31;
pub const APPCOMMAND_SAVE: u32 = 32;
pub const APPCOMMAND_PRINT: u32 = 33;
pub const APPCOMMAND_UNDO: u32 = 34;
pub const APPCOMMAND_REDO: u32 = 35;
pub const APPCOMMAND_COPY: u32 = 36;
pub const APPCOMMAND_CUT: u32 = 37;
pub const APPCOMMAND_PASTE: u32 = 38;
pub const APPCOMMAND_REPLY_TO_MAIL: u32 = 39;
pub const APPCOMMAND_FORWARD_MAIL: u32 = 40;
pub const APPCOMMAND_SEND_MAIL: u32 = 41;
pub const APPCOMMAND_SPELL_CHECK: u32 = 42;
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE: u32 = 43;
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE: u32 = 44;
pub const APPCOMMAND_CORRECTION_LIST: u32 = 45;
pub const APPCOMMAND_MEDIA_PLAY: u32 = 46;
pub const APPCOMMAND_MEDIA_PAUSE: u32 = 47;
pub const APPCOMMAND_MEDIA_RECORD: u32 = 48;
pub const APPCOMMAND_MEDIA_FAST_FORWARD: u32 = 49;
pub const APPCOMMAND_MEDIA_REWIND: u32 = 50;
pub const APPCOMMAND_MEDIA_CHANNEL_UP: u32 = 51;
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN: u32 = 52;
pub const APPCOMMAND_DELETE: u32 = 53;
pub const APPCOMMAND_DWM_FLIP3D: u32 = 54;
pub const FAPPCOMMAND_MOUSE: u32 = 32768;
pub const FAPPCOMMAND_KEY: u32 = 0;
pub const FAPPCOMMAND_OEM: u32 = 4096;
pub const FAPPCOMMAND_MASK: u32 = 61440;
pub const LLKHF_EXTENDED: u32 = 1;
pub const LLKHF_INJECTED: u32 = 16;
pub const LLKHF_ALTDOWN: u32 = 32;
pub const LLKHF_UP: u32 = 128;
pub const LLKHF_LOWER_IL_INJECTED: u32 = 2;
pub const LLMHF_INJECTED: u32 = 1;
pub const LLMHF_LOWER_IL_INJECTED: u32 = 2;
pub const HKL_PREV: u32 = 0;
pub const HKL_NEXT: u32 = 1;
pub const KLF_ACTIVATE: u32 = 1;
pub const KLF_SUBSTITUTE_OK: u32 = 2;
pub const KLF_REORDER: u32 = 8;
pub const KLF_REPLACELANG: u32 = 16;
pub const KLF_NOTELLSHELL: u32 = 128;
pub const KLF_SETFORPROCESS: u32 = 256;
pub const KLF_SHIFTLOCK: u32 = 65536;
pub const KLF_RESET: u32 = 1073741824;
pub const INPUTLANGCHANGE_SYSCHARSET: u32 = 1;
pub const INPUTLANGCHANGE_FORWARD: u32 = 2;
pub const INPUTLANGCHANGE_BACKWARD: u32 = 4;
pub const KL_NAMELENGTH: u32 = 9;
pub const GMMP_USE_DISPLAY_POINTS: u32 = 1;
pub const GMMP_USE_HIGH_RESOLUTION_POINTS: u32 = 2;
pub const DESKTOP_READOBJECTS: u32 = 1;
pub const DESKTOP_CREATEWINDOW: u32 = 2;
pub const DESKTOP_CREATEMENU: u32 = 4;
pub const DESKTOP_HOOKCONTROL: u32 = 8;
pub const DESKTOP_JOURNALRECORD: u32 = 16;
pub const DESKTOP_JOURNALPLAYBACK: u32 = 32;
pub const DESKTOP_ENUMERATE: u32 = 64;
pub const DESKTOP_WRITEOBJECTS: u32 = 128;
pub const DESKTOP_SWITCHDESKTOP: u32 = 256;
pub const DF_ALLOWOTHERACCOUNTHOOK: u32 = 1;
pub const WINSTA_ENUMDESKTOPS: u32 = 1;
pub const WINSTA_READATTRIBUTES: u32 = 2;
pub const WINSTA_ACCESSCLIPBOARD: u32 = 4;
pub const WINSTA_CREATEDESKTOP: u32 = 8;
pub const WINSTA_WRITEATTRIBUTES: u32 = 16;
pub const WINSTA_ACCESSGLOBALATOMS: u32 = 32;
pub const WINSTA_EXITWINDOWS: u32 = 64;
pub const WINSTA_ENUMERATE: u32 = 256;
pub const WINSTA_READSCREEN: u32 = 512;
pub const WINSTA_ALL_ACCESS: u32 = 895;
pub const CWF_CREATE_ONLY: u32 = 1;
pub const WSF_VISIBLE: u32 = 1;
pub const UOI_FLAGS: u32 = 1;
pub const UOI_NAME: u32 = 2;
pub const UOI_TYPE: u32 = 3;
pub const UOI_USER_SID: u32 = 4;
pub const UOI_HEAPSIZE: u32 = 5;
pub const UOI_IO: u32 = 6;
pub const UOI_TIMERPROC_EXCEPTION_SUPPRESSION: u32 = 7;
pub const GWL_WNDPROC: i32 = -4;
pub const GWL_HINSTANCE: i32 = -6;
pub const GWL_HWNDPARENT: i32 = -8;
pub const GWL_STYLE: i32 = -16;
pub const GWL_EXSTYLE: i32 = -20;
pub const GWL_USERDATA: i32 = -21;
pub const GWL_ID: i32 = -12;
pub const GWLP_WNDPROC: i32 = -4;
pub const GWLP_HINSTANCE: i32 = -6;
pub const GWLP_HWNDPARENT: i32 = -8;
pub const GWLP_USERDATA: i32 = -21;
pub const GWLP_ID: i32 = -12;
pub const GCL_MENUNAME: i32 = -8;
pub const GCL_HBRBACKGROUND: i32 = -10;
pub const GCL_HCURSOR: i32 = -12;
pub const GCL_HICON: i32 = -14;
pub const GCL_HMODULE: i32 = -16;
pub const GCL_CBWNDEXTRA: i32 = -18;
pub const GCL_CBCLSEXTRA: i32 = -20;
pub const GCL_WNDPROC: i32 = -24;
pub const GCL_STYLE: i32 = -26;
pub const GCW_ATOM: i32 = -32;
pub const GCL_HICONSM: i32 = -34;
pub const GCLP_MENUNAME: i32 = -8;
pub const GCLP_HBRBACKGROUND: i32 = -10;
pub const GCLP_HCURSOR: i32 = -12;
pub const GCLP_HICON: i32 = -14;
pub const GCLP_HMODULE: i32 = -16;
pub const GCLP_WNDPROC: i32 = -24;
pub const GCLP_HICONSM: i32 = -34;
pub const WM_NULL: u32 = 0;
pub const WM_CREATE: u32 = 1;
pub const WM_DESTROY: u32 = 2;
pub const WM_MOVE: u32 = 3;
pub const WM_SIZE: u32 = 5;
pub const WM_ACTIVATE: u32 = 6;
pub const WA_INACTIVE: u32 = 0;
pub const WA_ACTIVE: u32 = 1;
pub const WA_CLICKACTIVE: u32 = 2;
pub const WM_SETFOCUS: u32 = 7;
pub const WM_KILLFOCUS: u32 = 8;
pub const WM_ENABLE: u32 = 10;
pub const WM_SETREDRAW: u32 = 11;
pub const WM_SETTEXT: u32 = 12;
pub const WM_GETTEXT: u32 = 13;
pub const WM_GETTEXTLENGTH: u32 = 14;
pub const WM_PAINT: u32 = 15;
pub const WM_CLOSE: u32 = 16;
pub const WM_QUERYENDSESSION: u32 = 17;
pub const WM_QUERYOPEN: u32 = 19;
pub const WM_ENDSESSION: u32 = 22;
pub const WM_QUIT: u32 = 18;
pub const WM_ERASEBKGND: u32 = 20;
pub const WM_SYSCOLORCHANGE: u32 = 21;
pub const WM_SHOWWINDOW: u32 = 24;
pub const WM_WININICHANGE: u32 = 26;
pub const WM_SETTINGCHANGE: u32 = 26;
pub const WM_DEVMODECHANGE: u32 = 27;
pub const WM_ACTIVATEAPP: u32 = 28;
pub const WM_FONTCHANGE: u32 = 29;
pub const WM_TIMECHANGE: u32 = 30;
pub const WM_CANCELMODE: u32 = 31;
pub const WM_SETCURSOR: u32 = 32;
pub const WM_MOUSEACTIVATE: u32 = 33;
pub const WM_CHILDACTIVATE: u32 = 34;
pub const WM_QUEUESYNC: u32 = 35;
pub const WM_GETMINMAXINFO: u32 = 36;
pub const WM_PAINTICON: u32 = 38;
pub const WM_ICONERASEBKGND: u32 = 39;
pub const WM_NEXTDLGCTL: u32 = 40;
pub const WM_SPOOLERSTATUS: u32 = 42;
pub const WM_DRAWITEM: u32 = 43;
pub const WM_MEASUREITEM: u32 = 44;
pub const WM_DELETEITEM: u32 = 45;
pub const WM_VKEYTOITEM: u32 = 46;
pub const WM_CHARTOITEM: u32 = 47;
pub const WM_SETFONT: u32 = 48;
pub const WM_GETFONT: u32 = 49;
pub const WM_SETHOTKEY: u32 = 50;
pub const WM_GETHOTKEY: u32 = 51;
pub const WM_QUERYDRAGICON: u32 = 55;
pub const WM_COMPAREITEM: u32 = 57;
pub const WM_GETOBJECT: u32 = 61;
pub const WM_COMPACTING: u32 = 65;
pub const WM_COMMNOTIFY: u32 = 68;
pub const WM_WINDOWPOSCHANGING: u32 = 70;
pub const WM_WINDOWPOSCHANGED: u32 = 71;
pub const WM_POWER: u32 = 72;
pub const PWR_OK: u32 = 1;
pub const PWR_FAIL: i32 = -1;
pub const PWR_SUSPENDREQUEST: u32 = 1;
pub const PWR_SUSPENDRESUME: u32 = 2;
pub const PWR_CRITICALRESUME: u32 = 3;
pub const WM_COPYDATA: u32 = 74;
pub const WM_CANCELJOURNAL: u32 = 75;
pub const WM_NOTIFY: u32 = 78;
pub const WM_INPUTLANGCHANGEREQUEST: u32 = 80;
pub const WM_INPUTLANGCHANGE: u32 = 81;
pub const WM_TCARD: u32 = 82;
pub const WM_HELP: u32 = 83;
pub const WM_USERCHANGED: u32 = 84;
pub const WM_NOTIFYFORMAT: u32 = 85;
pub const NFR_ANSI: u32 = 1;
pub const NFR_UNICODE: u32 = 2;
pub const NF_QUERY: u32 = 3;
pub const NF_REQUERY: u32 = 4;
pub const WM_CONTEXTMENU: u32 = 123;
pub const WM_STYLECHANGING: u32 = 124;
pub const WM_STYLECHANGED: u32 = 125;
pub const WM_DISPLAYCHANGE: u32 = 126;
pub const WM_GETICON: u32 = 127;
pub const WM_SETICON: u32 = 128;
pub const WM_NCCREATE: u32 = 129;
pub const WM_NCDESTROY: u32 = 130;
pub const WM_NCCALCSIZE: u32 = 131;
pub const WM_NCHITTEST: u32 = 132;
pub const WM_NCPAINT: u32 = 133;
pub const WM_NCACTIVATE: u32 = 134;
pub const WM_GETDLGCODE: u32 = 135;
pub const WM_SYNCPAINT: u32 = 136;
pub const WM_NCMOUSEMOVE: u32 = 160;
pub const WM_NCLBUTTONDOWN: u32 = 161;
pub const WM_NCLBUTTONUP: u32 = 162;
pub const WM_NCLBUTTONDBLCLK: u32 = 163;
pub const WM_NCRBUTTONDOWN: u32 = 164;
pub const WM_NCRBUTTONUP: u32 = 165;
pub const WM_NCRBUTTONDBLCLK: u32 = 166;
pub const WM_NCMBUTTONDOWN: u32 = 167;
pub const WM_NCMBUTTONUP: u32 = 168;
pub const WM_NCMBUTTONDBLCLK: u32 = 169;
pub const WM_NCXBUTTONDOWN: u32 = 171;
pub const WM_NCXBUTTONUP: u32 = 172;
pub const WM_NCXBUTTONDBLCLK: u32 = 173;
pub const WM_INPUT_DEVICE_CHANGE: u32 = 254;
pub const WM_INPUT: u32 = 255;
pub const WM_KEYFIRST: u32 = 256;
pub const WM_KEYDOWN: u32 = 256;
pub const WM_KEYUP: u32 = 257;
pub const WM_CHAR: u32 = 258;
pub const WM_DEADCHAR: u32 = 259;
pub const WM_SYSKEYDOWN: u32 = 260;
pub const WM_SYSKEYUP: u32 = 261;
pub const WM_SYSCHAR: u32 = 262;
pub const WM_SYSDEADCHAR: u32 = 263;
pub const WM_UNICHAR: u32 = 265;
pub const WM_KEYLAST: u32 = 265;
pub const UNICODE_NOCHAR: u32 = 65535;
pub const WM_IME_STARTCOMPOSITION: u32 = 269;
pub const WM_IME_ENDCOMPOSITION: u32 = 270;
pub const WM_IME_COMPOSITION: u32 = 271;
pub const WM_IME_KEYLAST: u32 = 271;
pub const WM_INITDIALOG: u32 = 272;
pub const WM_COMMAND: u32 = 273;
pub const WM_SYSCOMMAND: u32 = 274;
pub const WM_TIMER: u32 = 275;
pub const WM_HSCROLL: u32 = 276;
pub const WM_VSCROLL: u32 = 277;
pub const WM_INITMENU: u32 = 278;
pub const WM_INITMENUPOPUP: u32 = 279;
pub const WM_GESTURE: u32 = 281;
pub const WM_GESTURENOTIFY: u32 = 282;
pub const WM_MENUSELECT: u32 = 287;
pub const WM_MENUCHAR: u32 = 288;
pub const WM_ENTERIDLE: u32 = 289;
pub const WM_MENURBUTTONUP: u32 = 290;
pub const WM_MENUDRAG: u32 = 291;
pub const WM_MENUGETOBJECT: u32 = 292;
pub const WM_UNINITMENUPOPUP: u32 = 293;
pub const WM_MENUCOMMAND: u32 = 294;
pub const WM_CHANGEUISTATE: u32 = 295;
pub const WM_UPDATEUISTATE: u32 = 296;
pub const WM_QUERYUISTATE: u32 = 297;
pub const UIS_SET: u32 = 1;
pub const UIS_CLEAR: u32 = 2;
pub const UIS_INITIALIZE: u32 = 3;
pub const UISF_HIDEFOCUS: u32 = 1;
pub const UISF_HIDEACCEL: u32 = 2;
pub const UISF_ACTIVE: u32 = 4;
pub const WM_CTLCOLORMSGBOX: u32 = 306;
pub const WM_CTLCOLOREDIT: u32 = 307;
pub const WM_CTLCOLORLISTBOX: u32 = 308;
pub const WM_CTLCOLORBTN: u32 = 309;
pub const WM_CTLCOLORDLG: u32 = 310;
pub const WM_CTLCOLORSCROLLBAR: u32 = 311;
pub const WM_CTLCOLORSTATIC: u32 = 312;
pub const MN_GETHMENU: u32 = 481;
pub const WM_MOUSEFIRST: u32 = 512;
pub const WM_MOUSEMOVE: u32 = 512;
pub const WM_LBUTTONDOWN: u32 = 513;
pub const WM_LBUTTONUP: u32 = 514;
pub const WM_LBUTTONDBLCLK: u32 = 515;
pub const WM_RBUTTONDOWN: u32 = 516;
pub const WM_RBUTTONUP: u32 = 517;
pub const WM_RBUTTONDBLCLK: u32 = 518;
pub const WM_MBUTTONDOWN: u32 = 519;
pub const WM_MBUTTONUP: u32 = 520;
pub const WM_MBUTTONDBLCLK: u32 = 521;
pub const WM_MOUSEWHEEL: u32 = 522;
pub const WM_XBUTTONDOWN: u32 = 523;
pub const WM_XBUTTONUP: u32 = 524;
pub const WM_XBUTTONDBLCLK: u32 = 525;
pub const WM_MOUSEHWHEEL: u32 = 526;
pub const WM_MOUSELAST: u32 = 526;
pub const WHEEL_DELTA: u32 = 120;
pub const XBUTTON1: u32 = 1;
pub const XBUTTON2: u32 = 2;
pub const WM_PARENTNOTIFY: u32 = 528;
pub const WM_ENTERMENULOOP: u32 = 529;
pub const WM_EXITMENULOOP: u32 = 530;
pub const WM_NEXTMENU: u32 = 531;
pub const WM_SIZING: u32 = 532;
pub const WM_CAPTURECHANGED: u32 = 533;
pub const WM_MOVING: u32 = 534;
pub const WM_POWERBROADCAST: u32 = 536;
pub const PBT_APMQUERYSUSPEND: u32 = 0;
pub const PBT_APMQUERYSTANDBY: u32 = 1;
pub const PBT_APMQUERYSUSPENDFAILED: u32 = 2;
pub const PBT_APMQUERYSTANDBYFAILED: u32 = 3;
pub const PBT_APMSUSPEND: u32 = 4;
pub const PBT_APMSTANDBY: u32 = 5;
pub const PBT_APMRESUMECRITICAL: u32 = 6;
pub const PBT_APMRESUMESUSPEND: u32 = 7;
pub const PBT_APMRESUMESTANDBY: u32 = 8;
pub const PBTF_APMRESUMEFROMFAILURE: u32 = 1;
pub const PBT_APMBATTERYLOW: u32 = 9;
pub const PBT_APMPOWERSTATUSCHANGE: u32 = 10;
pub const PBT_APMOEMEVENT: u32 = 11;
pub const PBT_APMRESUMEAUTOMATIC: u32 = 18;
pub const PBT_POWERSETTINGCHANGE: u32 = 32787;
pub const WM_DEVICECHANGE: u32 = 537;
pub const WM_MDICREATE: u32 = 544;
pub const WM_MDIDESTROY: u32 = 545;
pub const WM_MDIACTIVATE: u32 = 546;
pub const WM_MDIRESTORE: u32 = 547;
pub const WM_MDINEXT: u32 = 548;
pub const WM_MDIMAXIMIZE: u32 = 549;
pub const WM_MDITILE: u32 = 550;
pub const WM_MDICASCADE: u32 = 551;
pub const WM_MDIICONARRANGE: u32 = 552;
pub const WM_MDIGETACTIVE: u32 = 553;
pub const WM_MDISETMENU: u32 = 560;
pub const WM_ENTERSIZEMOVE: u32 = 561;
pub const WM_EXITSIZEMOVE: u32 = 562;
pub const WM_DROPFILES: u32 = 563;
pub const WM_MDIREFRESHMENU: u32 = 564;
pub const WM_POINTERDEVICECHANGE: u32 = 568;
pub const WM_POINTERDEVICEINRANGE: u32 = 569;
pub const WM_POINTERDEVICEOUTOFRANGE: u32 = 570;
pub const WM_TOUCH: u32 = 576;
pub const WM_NCPOINTERUPDATE: u32 = 577;
pub const WM_NCPOINTERDOWN: u32 = 578;
pub const WM_NCPOINTERUP: u32 = 579;
pub const WM_POINTERUPDATE: u32 = 581;
pub const WM_POINTERDOWN: u32 = 582;
pub const WM_POINTERUP: u32 = 583;
pub const WM_POINTERENTER: u32 = 585;
pub const WM_POINTERLEAVE: u32 = 586;
pub const WM_POINTERACTIVATE: u32 = 587;
pub const WM_POINTERCAPTURECHANGED: u32 = 588;
pub const WM_TOUCHHITTESTING: u32 = 589;
pub const WM_POINTERWHEEL: u32 = 590;
pub const WM_POINTERHWHEEL: u32 = 591;
pub const DM_POINTERHITTEST: u32 = 592;
pub const WM_POINTERROUTEDTO: u32 = 593;
pub const WM_POINTERROUTEDAWAY: u32 = 594;
pub const WM_POINTERROUTEDRELEASED: u32 = 595;
pub const WM_IME_SETCONTEXT: u32 = 641;
pub const WM_IME_NOTIFY: u32 = 642;
pub const WM_IME_CONTROL: u32 = 643;
pub const WM_IME_COMPOSITIONFULL: u32 = 644;
pub const WM_IME_SELECT: u32 = 645;
pub const WM_IME_CHAR: u32 = 646;
pub const WM_IME_REQUEST: u32 = 648;
pub const WM_IME_KEYDOWN: u32 = 656;
pub const WM_IME_KEYUP: u32 = 657;
pub const WM_MOUSEHOVER: u32 = 673;
pub const WM_MOUSELEAVE: u32 = 675;
pub const WM_NCMOUSEHOVER: u32 = 672;
pub const WM_NCMOUSELEAVE: u32 = 674;
pub const WM_WTSSESSION_CHANGE: u32 = 689;
pub const WM_TABLET_FIRST: u32 = 704;
pub const WM_TABLET_LAST: u32 = 735;
pub const WM_DPICHANGED: u32 = 736;
pub const WM_DPICHANGED_BEFOREPARENT: u32 = 738;
pub const WM_DPICHANGED_AFTERPARENT: u32 = 739;
pub const WM_GETDPISCALEDSIZE: u32 = 740;
pub const WM_CUT: u32 = 768;
pub const WM_COPY: u32 = 769;
pub const WM_PASTE: u32 = 770;
pub const WM_CLEAR: u32 = 771;
pub const WM_UNDO: u32 = 772;
pub const WM_RENDERFORMAT: u32 = 773;
pub const WM_RENDERALLFORMATS: u32 = 774;
pub const WM_DESTROYCLIPBOARD: u32 = 775;
pub const WM_DRAWCLIPBOARD: u32 = 776;
pub const WM_PAINTCLIPBOARD: u32 = 777;
pub const WM_VSCROLLCLIPBOARD: u32 = 778;
pub const WM_SIZECLIPBOARD: u32 = 779;
pub const WM_ASKCBFORMATNAME: u32 = 780;
pub const WM_CHANGECBCHAIN: u32 = 781;
pub const WM_HSCROLLCLIPBOARD: u32 = 782;
pub const WM_QUERYNEWPALETTE: u32 = 783;
pub const WM_PALETTEISCHANGING: u32 = 784;
pub const WM_PALETTECHANGED: u32 = 785;
pub const WM_HOTKEY: u32 = 786;
pub const WM_PRINT: u32 = 791;
pub const WM_PRINTCLIENT: u32 = 792;
pub const WM_APPCOMMAND: u32 = 793;
pub const WM_THEMECHANGED: u32 = 794;
pub const WM_CLIPBOARDUPDATE: u32 = 797;
pub const WM_DWMCOMPOSITIONCHANGED: u32 = 798;
pub const WM_DWMNCRENDERINGCHANGED: u32 = 799;
pub const WM_DWMCOLORIZATIONCOLORCHANGED: u32 = 800;
pub const WM_DWMWINDOWMAXIMIZEDCHANGE: u32 = 801;
pub const WM_DWMSENDICONICTHUMBNAIL: u32 = 803;
pub const WM_DWMSENDICONICLIVEPREVIEWBITMAP: u32 = 806;
pub const WM_GETTITLEBARINFOEX: u32 = 831;
pub const WM_HANDHELDFIRST: u32 = 856;
pub const WM_HANDHELDLAST: u32 = 863;
pub const WM_AFXFIRST: u32 = 864;
pub const WM_AFXLAST: u32 = 895;
pub const WM_PENWINFIRST: u32 = 896;
pub const WM_PENWINLAST: u32 = 911;
pub const WM_APP: u32 = 32768;
pub const WM_USER: u32 = 1024;
pub const WMSZ_LEFT: u32 = 1;
pub const WMSZ_RIGHT: u32 = 2;
pub const WMSZ_TOP: u32 = 3;
pub const WMSZ_TOPLEFT: u32 = 4;
pub const WMSZ_TOPRIGHT: u32 = 5;
pub const WMSZ_BOTTOM: u32 = 6;
pub const WMSZ_BOTTOMLEFT: u32 = 7;
pub const WMSZ_BOTTOMRIGHT: u32 = 8;
pub const HTERROR: i32 = -2;
pub const HTTRANSPARENT: i32 = -1;
pub const HTNOWHERE: u32 = 0;
pub const HTCLIENT: u32 = 1;
pub const HTCAPTION: u32 = 2;
pub const HTSYSMENU: u32 = 3;
pub const HTGROWBOX: u32 = 4;
pub const HTSIZE: u32 = 4;
pub const HTMENU: u32 = 5;
pub const HTHSCROLL: u32 = 6;
pub const HTVSCROLL: u32 = 7;
pub const HTMINBUTTON: u32 = 8;
pub const HTMAXBUTTON: u32 = 9;
pub const HTLEFT: u32 = 10;
pub const HTRIGHT: u32 = 11;
pub const HTTOP: u32 = 12;
pub const HTTOPLEFT: u32 = 13;
pub const HTTOPRIGHT: u32 = 14;
pub const HTBOTTOM: u32 = 15;
pub const HTBOTTOMLEFT: u32 = 16;
pub const HTBOTTOMRIGHT: u32 = 17;
pub const HTBORDER: u32 = 18;
pub const HTREDUCE: u32 = 8;
pub const HTZOOM: u32 = 9;
pub const HTSIZEFIRST: u32 = 10;
pub const HTSIZELAST: u32 = 17;
pub const HTOBJECT: u32 = 19;
pub const HTCLOSE: u32 = 20;
pub const HTHELP: u32 = 21;
pub const SMTO_NORMAL: u32 = 0;
pub const SMTO_BLOCK: u32 = 1;
pub const SMTO_ABORTIFHUNG: u32 = 2;
pub const SMTO_NOTIMEOUTIFNOTHUNG: u32 = 8;
pub const SMTO_ERRORONEXIT: u32 = 32;
pub const MA_ACTIVATE: u32 = 1;
pub const MA_ACTIVATEANDEAT: u32 = 2;
pub const MA_NOACTIVATE: u32 = 3;
pub const MA_NOACTIVATEANDEAT: u32 = 4;
pub const ICON_SMALL: u32 = 0;
pub const ICON_BIG: u32 = 1;
pub const ICON_SMALL2: u32 = 2;
pub const SIZE_RESTORED: u32 = 0;
pub const SIZE_MINIMIZED: u32 = 1;
pub const SIZE_MAXIMIZED: u32 = 2;
pub const SIZE_MAXSHOW: u32 = 3;
pub const SIZE_MAXHIDE: u32 = 4;
pub const SIZENORMAL: u32 = 0;
pub const SIZEICONIC: u32 = 1;
pub const SIZEFULLSCREEN: u32 = 2;
pub const SIZEZOOMSHOW: u32 = 3;
pub const SIZEZOOMHIDE: u32 = 4;
pub const WVR_ALIGNTOP: u32 = 16;
pub const WVR_ALIGNLEFT: u32 = 32;
pub const WVR_ALIGNBOTTOM: u32 = 64;
pub const WVR_ALIGNRIGHT: u32 = 128;
pub const WVR_HREDRAW: u32 = 256;
pub const WVR_VREDRAW: u32 = 512;
pub const WVR_REDRAW: u32 = 768;
pub const WVR_VALIDRECTS: u32 = 1024;
pub const MK_LBUTTON: u32 = 1;
pub const MK_RBUTTON: u32 = 2;
pub const MK_SHIFT: u32 = 4;
pub const MK_CONTROL: u32 = 8;
pub const MK_MBUTTON: u32 = 16;
pub const MK_XBUTTON1: u32 = 32;
pub const MK_XBUTTON2: u32 = 64;
pub const TME_HOVER: u32 = 1;
pub const TME_LEAVE: u32 = 2;
pub const TME_NONCLIENT: u32 = 16;
pub const TME_QUERY: u32 = 1073741824;
pub const TME_CANCEL: u32 = 2147483648;
pub const HOVER_DEFAULT: u32 = 4294967295;
pub const WS_OVERLAPPED: u32 = 0;
pub const WS_POPUP: u32 = 2147483648;
pub const WS_CHILD: u32 = 1073741824;
pub const WS_MINIMIZE: u32 = 536870912;
pub const WS_VISIBLE: u32 = 268435456;
pub const WS_DISABLED: u32 = 134217728;
pub const WS_CLIPSIBLINGS: u32 = 67108864;
pub const WS_CLIPCHILDREN: u32 = 33554432;
pub const WS_MAXIMIZE: u32 = 16777216;
pub const WS_CAPTION: u32 = 12582912;
pub const WS_BORDER: u32 = 8388608;
pub const WS_DLGFRAME: u32 = 4194304;
pub const WS_VSCROLL: u32 = 2097152;
pub const WS_HSCROLL: u32 = 1048576;
pub const WS_SYSMENU: u32 = 524288;
pub const WS_THICKFRAME: u32 = 262144;
pub const WS_GROUP: u32 = 131072;
pub const WS_TABSTOP: u32 = 65536;
pub const WS_MINIMIZEBOX: u32 = 131072;
pub const WS_MAXIMIZEBOX: u32 = 65536;
pub const WS_TILED: u32 = 0;
pub const WS_ICONIC: u32 = 536870912;
pub const WS_SIZEBOX: u32 = 262144;
pub const WS_OVERLAPPEDWINDOW: u32 = 13565952;
pub const WS_POPUPWINDOW: u32 = 2156396544;
pub const WS_CHILDWINDOW: u32 = 1073741824;
pub const WS_EX_DLGMODALFRAME: u32 = 1;
pub const WS_EX_NOPARENTNOTIFY: u32 = 4;
pub const WS_EX_TOPMOST: u32 = 8;
pub const WS_EX_ACCEPTFILES: u32 = 16;
pub const WS_EX_TRANSPARENT: u32 = 32;
pub const WS_EX_MDICHILD: u32 = 64;
pub const WS_EX_TOOLWINDOW: u32 = 128;
pub const WS_EX_WINDOWEDGE: u32 = 256;
pub const WS_EX_CLIENTEDGE: u32 = 512;
pub const WS_EX_CONTEXTHELP: u32 = 1024;
pub const WS_EX_RIGHT: u32 = 4096;
pub const WS_EX_LEFT: u32 = 0;
pub const WS_EX_RTLREADING: u32 = 8192;
pub const WS_EX_LTRREADING: u32 = 0;
pub const WS_EX_LEFTSCROLLBAR: u32 = 16384;
pub const WS_EX_RIGHTSCROLLBAR: u32 = 0;
pub const WS_EX_CONTROLPARENT: u32 = 65536;
pub const WS_EX_STATICEDGE: u32 = 131072;
pub const WS_EX_APPWINDOW: u32 = 262144;
pub const WS_EX_OVERLAPPEDWINDOW: u32 = 768;
pub const WS_EX_PALETTEWINDOW: u32 = 392;
pub const WS_EX_LAYERED: u32 = 524288;
pub const WS_EX_NOINHERITLAYOUT: u32 = 1048576;
pub const WS_EX_NOREDIRECTIONBITMAP: u32 = 2097152;
pub const WS_EX_LAYOUTRTL: u32 = 4194304;
pub const WS_EX_COMPOSITED: u32 = 33554432;
pub const WS_EX_NOACTIVATE: u32 = 134217728;
pub const CS_VREDRAW: u32 = 1;
pub const CS_HREDRAW: u32 = 2;
pub const CS_DBLCLKS: u32 = 8;
pub const CS_OWNDC: u32 = 32;
pub const CS_CLASSDC: u32 = 64;
pub const CS_PARENTDC: u32 = 128;
pub const CS_NOCLOSE: u32 = 512;
pub const CS_SAVEBITS: u32 = 2048;
pub const CS_BYTEALIGNCLIENT: u32 = 4096;
pub const CS_BYTEALIGNWINDOW: u32 = 8192;
pub const CS_GLOBALCLASS: u32 = 16384;
pub const CS_IME: u32 = 65536;
pub const CS_DROPSHADOW: u32 = 131072;
pub const PRF_CHECKVISIBLE: u32 = 1;
pub const PRF_NONCLIENT: u32 = 2;
pub const PRF_CLIENT: u32 = 4;
pub const PRF_ERASEBKGND: u32 = 8;
pub const PRF_CHILDREN: u32 = 16;
pub const PRF_OWNED: u32 = 32;
pub const BDR_RAISEDOUTER: u32 = 1;
pub const BDR_SUNKENOUTER: u32 = 2;
pub const BDR_RAISEDINNER: u32 = 4;
pub const BDR_SUNKENINNER: u32 = 8;
pub const BDR_OUTER: u32 = 3;
pub const BDR_INNER: u32 = 12;
pub const BDR_RAISED: u32 = 5;
pub const BDR_SUNKEN: u32 = 10;
pub const EDGE_RAISED: u32 = 5;
pub const EDGE_SUNKEN: u32 = 10;
pub const EDGE_ETCHED: u32 = 6;
pub const EDGE_BUMP: u32 = 9;
pub const BF_LEFT: u32 = 1;
pub const BF_TOP: u32 = 2;
pub const BF_RIGHT: u32 = 4;
pub const BF_BOTTOM: u32 = 8;
pub const BF_TOPLEFT: u32 = 3;
pub const BF_TOPRIGHT: u32 = 6;
pub const BF_BOTTOMLEFT: u32 = 9;
pub const BF_BOTTOMRIGHT: u32 = 12;
pub const BF_RECT: u32 = 15;
pub const BF_DIAGONAL: u32 = 16;
pub const BF_DIAGONAL_ENDTOPRIGHT: u32 = 22;
pub const BF_DIAGONAL_ENDTOPLEFT: u32 = 19;
pub const BF_DIAGONAL_ENDBOTTOMLEFT: u32 = 25;
pub const BF_DIAGONAL_ENDBOTTOMRIGHT: u32 = 28;
pub const BF_MIDDLE: u32 = 2048;
pub const BF_SOFT: u32 = 4096;
pub const BF_ADJUST: u32 = 8192;
pub const BF_FLAT: u32 = 16384;
pub const BF_MONO: u32 = 32768;
pub const DFC_CAPTION: u32 = 1;
pub const DFC_MENU: u32 = 2;
pub const DFC_SCROLL: u32 = 3;
pub const DFC_BUTTON: u32 = 4;
pub const DFC_POPUPMENU: u32 = 5;
pub const DFCS_CAPTIONCLOSE: u32 = 0;
pub const DFCS_CAPTIONMIN: u32 = 1;
pub const DFCS_CAPTIONMAX: u32 = 2;
pub const DFCS_CAPTIONRESTORE: u32 = 3;
pub const DFCS_CAPTIONHELP: u32 = 4;
pub const DFCS_MENUARROW: u32 = 0;
pub const DFCS_MENUCHECK: u32 = 1;
pub const DFCS_MENUBULLET: u32 = 2;
pub const DFCS_MENUARROWRIGHT: u32 = 4;
pub const DFCS_SCROLLUP: u32 = 0;
pub const DFCS_SCROLLDOWN: u32 = 1;
pub const DFCS_SCROLLLEFT: u32 = 2;
pub const DFCS_SCROLLRIGHT: u32 = 3;
pub const DFCS_SCROLLCOMBOBOX: u32 = 5;
pub const DFCS_SCROLLSIZEGRIP: u32 = 8;
pub const DFCS_SCROLLSIZEGRIPRIGHT: u32 = 16;
pub const DFCS_BUTTONCHECK: u32 = 0;
pub const DFCS_BUTTONRADIOIMAGE: u32 = 1;
pub const DFCS_BUTTONRADIOMASK: u32 = 2;
pub const DFCS_BUTTONRADIO: u32 = 4;
pub const DFCS_BUTTON3STATE: u32 = 8;
pub const DFCS_BUTTONPUSH: u32 = 16;
pub const DFCS_INACTIVE: u32 = 256;
pub const DFCS_PUSHED: u32 = 512;
pub const DFCS_CHECKED: u32 = 1024;
pub const DFCS_TRANSPARENT: u32 = 2048;
pub const DFCS_HOT: u32 = 4096;
pub const DFCS_ADJUSTRECT: u32 = 8192;
pub const DFCS_FLAT: u32 = 16384;
pub const DFCS_MONO: u32 = 32768;
pub const DC_ACTIVE: u32 = 1;
pub const DC_SMALLCAP: u32 = 2;
pub const DC_ICON: u32 = 4;
pub const DC_TEXT: u32 = 8;
pub const DC_INBUTTON: u32 = 16;
pub const DC_GRADIENT: u32 = 32;
pub const DC_BUTTONS: u32 = 4096;
pub const IDANI_OPEN: u32 = 1;
pub const IDANI_CAPTION: u32 = 3;
pub const CF_TEXT: u32 = 1;
pub const CF_BITMAP: u32 = 2;
pub const CF_METAFILEPICT: u32 = 3;
pub const CF_SYLK: u32 = 4;
pub const CF_DIF: u32 = 5;
pub const CF_TIFF: u32 = 6;
pub const CF_OEMTEXT: u32 = 7;
pub const CF_DIB: u32 = 8;
pub const CF_PALETTE: u32 = 9;
pub const CF_PENDATA: u32 = 10;
pub const CF_RIFF: u32 = 11;
pub const CF_WAVE: u32 = 12;
pub const CF_UNICODETEXT: u32 = 13;
pub const CF_ENHMETAFILE: u32 = 14;
pub const CF_HDROP: u32 = 15;
pub const CF_LOCALE: u32 = 16;
pub const CF_DIBV5: u32 = 17;
pub const CF_MAX: u32 = 18;
pub const CF_OWNERDISPLAY: u32 = 128;
pub const CF_DSPTEXT: u32 = 129;
pub const CF_DSPBITMAP: u32 = 130;
pub const CF_DSPMETAFILEPICT: u32 = 131;
pub const CF_DSPENHMETAFILE: u32 = 142;
pub const CF_PRIVATEFIRST: u32 = 512;
pub const CF_PRIVATELAST: u32 = 767;
pub const CF_GDIOBJFIRST: u32 = 768;
pub const CF_GDIOBJLAST: u32 = 1023;
pub const FVIRTKEY: u32 = 1;
pub const FNOINVERT: u32 = 2;
pub const FSHIFT: u32 = 4;
pub const FCONTROL: u32 = 8;
pub const FALT: u32 = 16;
pub const WPF_SETMINPOSITION: u32 = 1;
pub const WPF_RESTORETOMAXIMIZED: u32 = 2;
pub const WPF_ASYNCWINDOWPLACEMENT: u32 = 4;
pub const ODT_MENU: u32 = 1;
pub const ODT_LISTBOX: u32 = 2;
pub const ODT_COMBOBOX: u32 = 3;
pub const ODT_BUTTON: u32 = 4;
pub const ODT_STATIC: u32 = 5;
pub const ODA_DRAWENTIRE: u32 = 1;
pub const ODA_SELECT: u32 = 2;
pub const ODA_FOCUS: u32 = 4;
pub const ODS_SELECTED: u32 = 1;
pub const ODS_GRAYED: u32 = 2;
pub const ODS_DISABLED: u32 = 4;
pub const ODS_CHECKED: u32 = 8;
pub const ODS_FOCUS: u32 = 16;
pub const ODS_DEFAULT: u32 = 32;
pub const ODS_COMBOBOXEDIT: u32 = 4096;
pub const ODS_HOTLIGHT: u32 = 64;
pub const ODS_INACTIVE: u32 = 128;
pub const ODS_NOACCEL: u32 = 256;
pub const ODS_NOFOCUSRECT: u32 = 512;
pub const PM_NOREMOVE: u32 = 0;
pub const PM_REMOVE: u32 = 1;
pub const PM_NOYIELD: u32 = 2;
pub const MOD_ALT: u32 = 1;
pub const MOD_CONTROL: u32 = 2;
pub const MOD_SHIFT: u32 = 4;
pub const MOD_WIN: u32 = 8;
pub const MOD_NOREPEAT: u32 = 16384;
pub const IDHOT_SNAPWINDOW: i32 = -1;
pub const IDHOT_SNAPDESKTOP: i32 = -2;
pub const ENDSESSION_CLOSEAPP: u32 = 1;
pub const ENDSESSION_CRITICAL: u32 = 1073741824;
pub const ENDSESSION_LOGOFF: u32 = 2147483648;
pub const EWX_LOGOFF: u32 = 0;
pub const EWX_SHUTDOWN: u32 = 1;
pub const EWX_REBOOT: u32 = 2;
pub const EWX_FORCE: u32 = 4;
pub const EWX_POWEROFF: u32 = 8;
pub const EWX_FORCEIFHUNG: u32 = 16;
pub const EWX_QUICKRESOLVE: u32 = 32;
pub const EWX_RESTARTAPPS: u32 = 64;
pub const EWX_HYBRID_SHUTDOWN: u32 = 4194304;
pub const EWX_BOOTOPTIONS: u32 = 16777216;
pub const EWX_ARSO: u32 = 67108864;
pub const EWX_CHECK_SAFE_FOR_SERVER: u32 = 134217728;
pub const EWX_SYSTEM_INITIATED: u32 = 268435456;
pub const BSM_ALLCOMPONENTS: u32 = 0;
pub const BSM_VXDS: u32 = 1;
pub const BSM_NETDRIVER: u32 = 2;
pub const BSM_INSTALLABLEDRIVERS: u32 = 4;
pub const BSM_APPLICATIONS: u32 = 8;
pub const BSM_ALLDESKTOPS: u32 = 16;
pub const BSF_QUERY: u32 = 1;
pub const BSF_IGNORECURRENTTASK: u32 = 2;
pub const BSF_FLUSHDISK: u32 = 4;
pub const BSF_NOHANG: u32 = 8;
pub const BSF_POSTMESSAGE: u32 = 16;
pub const BSF_FORCEIFHUNG: u32 = 32;
pub const BSF_NOTIMEOUTIFNOTHUNG: u32 = 64;
pub const BSF_ALLOWSFW: u32 = 128;
pub const BSF_SENDNOTIFYMESSAGE: u32 = 256;
pub const BSF_RETURNHDESK: u32 = 512;
pub const BSF_LUID: u32 = 1024;
pub const BROADCAST_QUERY_DENY: u32 = 1112363332;
pub const DEVICE_NOTIFY_WINDOW_HANDLE: u32 = 0;
pub const DEVICE_NOTIFY_SERVICE_HANDLE: u32 = 1;
pub const DEVICE_NOTIFY_ALL_INTERFACE_CLASSES: u32 = 4;
pub const ISMEX_NOSEND: u32 = 0;
pub const ISMEX_SEND: u32 = 1;
pub const ISMEX_NOTIFY: u32 = 2;
pub const ISMEX_CALLBACK: u32 = 4;
pub const ISMEX_REPLIED: u32 = 8;
pub const PW_CLIENTONLY: u32 = 1;
pub const PW_RENDERFULLCONTENT: u32 = 2;
pub const LWA_COLORKEY: u32 = 1;
pub const LWA_ALPHA: u32 = 2;
pub const ULW_COLORKEY: u32 = 1;
pub const ULW_ALPHA: u32 = 2;
pub const ULW_OPAQUE: u32 = 4;
pub const ULW_EX_NORESIZE: u32 = 8;
pub const FLASHW_STOP: u32 = 0;
pub const FLASHW_CAPTION: u32 = 1;
pub const FLASHW_TRAY: u32 = 2;
pub const FLASHW_ALL: u32 = 3;
pub const FLASHW_TIMER: u32 = 4;
pub const FLASHW_TIMERNOFG: u32 = 12;
pub const WDA_NONE: u32 = 0;
pub const WDA_MONITOR: u32 = 1;
pub const WDA_EXCLUDEFROMCAPTURE: u32 = 17;
pub const SWP_NOSIZE: u32 = 1;
pub const SWP_NOMOVE: u32 = 2;
pub const SWP_NOZORDER: u32 = 4;
pub const SWP_NOREDRAW: u32 = 8;
pub const SWP_NOACTIVATE: u32 = 16;
pub const SWP_FRAMECHANGED: u32 = 32;
pub const SWP_SHOWWINDOW: u32 = 64;
pub const SWP_HIDEWINDOW: u32 = 128;
pub const SWP_NOCOPYBITS: u32 = 256;
pub const SWP_NOOWNERZORDER: u32 = 512;
pub const SWP_NOSENDCHANGING: u32 = 1024;
pub const SWP_DRAWFRAME: u32 = 32;
pub const SWP_NOREPOSITION: u32 = 512;
pub const SWP_DEFERERASE: u32 = 8192;
pub const SWP_ASYNCWINDOWPOS: u32 = 16384;
pub const DLGWINDOWEXTRA: u32 = 30;
pub const KEYEVENTF_EXTENDEDKEY: u32 = 1;
pub const KEYEVENTF_KEYUP: u32 = 2;
pub const KEYEVENTF_UNICODE: u32 = 4;
pub const KEYEVENTF_SCANCODE: u32 = 8;
pub const MOUSEEVENTF_MOVE: u32 = 1;
pub const MOUSEEVENTF_LEFTDOWN: u32 = 2;
pub const MOUSEEVENTF_LEFTUP: u32 = 4;
pub const MOUSEEVENTF_RIGHTDOWN: u32 = 8;
pub const MOUSEEVENTF_RIGHTUP: u32 = 16;
pub const MOUSEEVENTF_MIDDLEDOWN: u32 = 32;
pub const MOUSEEVENTF_MIDDLEUP: u32 = 64;
pub const MOUSEEVENTF_XDOWN: u32 = 128;
pub const MOUSEEVENTF_XUP: u32 = 256;
pub const MOUSEEVENTF_WHEEL: u32 = 2048;
pub const MOUSEEVENTF_HWHEEL: u32 = 4096;
pub const MOUSEEVENTF_MOVE_NOCOALESCE: u32 = 8192;
pub const MOUSEEVENTF_VIRTUALDESK: u32 = 16384;
pub const MOUSEEVENTF_ABSOLUTE: u32 = 32768;
pub const INPUT_MOUSE: u32 = 0;
pub const INPUT_KEYBOARD: u32 = 1;
pub const INPUT_HARDWARE: u32 = 2;
pub const TOUCHEVENTF_MOVE: u32 = 1;
pub const TOUCHEVENTF_DOWN: u32 = 2;
pub const TOUCHEVENTF_UP: u32 = 4;
pub const TOUCHEVENTF_INRANGE: u32 = 8;
pub const TOUCHEVENTF_PRIMARY: u32 = 16;
pub const TOUCHEVENTF_NOCOALESCE: u32 = 32;
pub const TOUCHEVENTF_PEN: u32 = 64;
pub const TOUCHEVENTF_PALM: u32 = 128;
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM: u32 = 1;
pub const TOUCHINPUTMASKF_EXTRAINFO: u32 = 2;
pub const TOUCHINPUTMASKF_CONTACTAREA: u32 = 4;
pub const TWF_FINETOUCH: u32 = 1;
pub const TWF_WANTPALM: u32 = 2;
pub const POINTER_FLAG_NONE: u32 = 0;
pub const POINTER_FLAG_NEW: u32 = 1;
pub const POINTER_FLAG_INRANGE: u32 = 2;
pub const POINTER_FLAG_INCONTACT: u32 = 4;
pub const POINTER_FLAG_FIRSTBUTTON: u32 = 16;
pub const POINTER_FLAG_SECONDBUTTON: u32 = 32;
pub const POINTER_FLAG_THIRDBUTTON: u32 = 64;
pub const POINTER_FLAG_FOURTHBUTTON: u32 = 128;
pub const POINTER_FLAG_FIFTHBUTTON: u32 = 256;
pub const POINTER_FLAG_PRIMARY: u32 = 8192;
pub const POINTER_FLAG_CONFIDENCE: u32 = 16384;
pub const POINTER_FLAG_CANCELED: u32 = 32768;
pub const POINTER_FLAG_DOWN: u32 = 65536;
pub const POINTER_FLAG_UPDATE: u32 = 131072;
pub const POINTER_FLAG_UP: u32 = 262144;
pub const POINTER_FLAG_WHEEL: u32 = 524288;
pub const POINTER_FLAG_HWHEEL: u32 = 1048576;
pub const POINTER_FLAG_CAPTURECHANGED: u32 = 2097152;
pub const POINTER_FLAG_HASTRANSFORM: u32 = 4194304;
pub const POINTER_MOD_SHIFT: u32 = 4;
pub const POINTER_MOD_CTRL: u32 = 8;
pub const TOUCH_FLAG_NONE: u32 = 0;
pub const TOUCH_MASK_NONE: u32 = 0;
pub const TOUCH_MASK_CONTACTAREA: u32 = 1;
pub const TOUCH_MASK_ORIENTATION: u32 = 2;
pub const TOUCH_MASK_PRESSURE: u32 = 4;
pub const PEN_FLAG_NONE: u32 = 0;
pub const PEN_FLAG_BARREL: u32 = 1;
pub const PEN_FLAG_INVERTED: u32 = 2;
pub const PEN_FLAG_ERASER: u32 = 4;
pub const PEN_MASK_NONE: u32 = 0;
pub const PEN_MASK_PRESSURE: u32 = 1;
pub const PEN_MASK_ROTATION: u32 = 2;
pub const PEN_MASK_TILT_X: u32 = 4;
pub const PEN_MASK_TILT_Y: u32 = 8;
pub const POINTER_MESSAGE_FLAG_NEW: u32 = 1;
pub const POINTER_MESSAGE_FLAG_INRANGE: u32 = 2;
pub const POINTER_MESSAGE_FLAG_INCONTACT: u32 = 4;
pub const POINTER_MESSAGE_FLAG_FIRSTBUTTON: u32 = 16;
pub const POINTER_MESSAGE_FLAG_SECONDBUTTON: u32 = 32;
pub const POINTER_MESSAGE_FLAG_THIRDBUTTON: u32 = 64;
pub const POINTER_MESSAGE_FLAG_FOURTHBUTTON: u32 = 128;
pub const POINTER_MESSAGE_FLAG_FIFTHBUTTON: u32 = 256;
pub const POINTER_MESSAGE_FLAG_PRIMARY: u32 = 8192;
pub const POINTER_MESSAGE_FLAG_CONFIDENCE: u32 = 16384;
pub const POINTER_MESSAGE_FLAG_CANCELED: u32 = 32768;
pub const PA_ACTIVATE: u32 = 1;
pub const PA_NOACTIVATE: u32 = 3;
pub const MAX_TOUCH_COUNT: u32 = 256;
pub const TOUCH_FEEDBACK_DEFAULT: u32 = 1;
pub const TOUCH_FEEDBACK_INDIRECT: u32 = 2;
pub const TOUCH_FEEDBACK_NONE: u32 = 3;
pub const TOUCH_HIT_TESTING_DEFAULT: u32 = 0;
pub const TOUCH_HIT_TESTING_CLIENT: u32 = 1;
pub const TOUCH_HIT_TESTING_NONE: u32 = 2;
pub const TOUCH_HIT_TESTING_PROXIMITY_CLOSEST: u32 = 0;
pub const TOUCH_HIT_TESTING_PROXIMITY_FARTHEST: u32 = 4095;
pub const GWFS_INCLUDE_ANCESTORS: u32 = 1;
pub const MAPVK_VK_TO_VSC: u32 = 0;
pub const MAPVK_VSC_TO_VK: u32 = 1;
pub const MAPVK_VK_TO_CHAR: u32 = 2;
pub const MAPVK_VSC_TO_VK_EX: u32 = 3;
pub const MAPVK_VK_TO_VSC_EX: u32 = 4;
pub const MWMO_WAITALL: u32 = 1;
pub const MWMO_ALERTABLE: u32 = 2;
pub const MWMO_INPUTAVAILABLE: u32 = 4;
pub const QS_KEY: u32 = 1;
pub const QS_MOUSEMOVE: u32 = 2;
pub const QS_MOUSEBUTTON: u32 = 4;
pub const QS_POSTMESSAGE: u32 = 8;
pub const QS_TIMER: u32 = 16;
pub const QS_PAINT: u32 = 32;
pub const QS_SENDMESSAGE: u32 = 64;
pub const QS_HOTKEY: u32 = 128;
pub const QS_ALLPOSTMESSAGE: u32 = 256;
pub const QS_RAWINPUT: u32 = 1024;
pub const QS_TOUCH: u32 = 2048;
pub const QS_POINTER: u32 = 4096;
pub const QS_MOUSE: u32 = 6;
pub const QS_INPUT: u32 = 7175;
pub const QS_ALLEVENTS: u32 = 7359;
pub const QS_ALLINPUT: u32 = 7423;
pub const USER_TIMER_MAXIMUM: u32 = 2147483647;
pub const USER_TIMER_MINIMUM: u32 = 10;
pub const TIMERV_DEFAULT_COALESCING: u32 = 0;
pub const TIMERV_NO_COALESCING: u32 = 4294967295;
pub const TIMERV_COALESCING_MIN: u32 = 1;
pub const TIMERV_COALESCING_MAX: u32 = 2147483637;
pub const SM_CXSCREEN: u32 = 0;
pub const SM_CYSCREEN: u32 = 1;
pub const SM_CXVSCROLL: u32 = 2;
pub const SM_CYHSCROLL: u32 = 3;
pub const SM_CYCAPTION: u32 = 4;
pub const SM_CXBORDER: u32 = 5;
pub const SM_CYBORDER: u32 = 6;
pub const SM_CXDLGFRAME: u32 = 7;
pub const SM_CYDLGFRAME: u32 = 8;
pub const SM_CYVTHUMB: u32 = 9;
pub const SM_CXHTHUMB: u32 = 10;
pub const SM_CXICON: u32 = 11;
pub const SM_CYICON: u32 = 12;
pub const SM_CXCURSOR: u32 = 13;
pub const SM_CYCURSOR: u32 = 14;
pub const SM_CYMENU: u32 = 15;
pub const SM_CXFULLSCREEN: u32 = 16;
pub const SM_CYFULLSCREEN: u32 = 17;
pub const SM_CYKANJIWINDOW: u32 = 18;
pub const SM_MOUSEPRESENT: u32 = 19;
pub const SM_CYVSCROLL: u32 = 20;
pub const SM_CXHSCROLL: u32 = 21;
pub const SM_DEBUG: u32 = 22;
pub const SM_SWAPBUTTON: u32 = 23;
pub const SM_RESERVED1: u32 = 24;
pub const SM_RESERVED2: u32 = 25;
pub const SM_RESERVED3: u32 = 26;
pub const SM_RESERVED4: u32 = 27;
pub const SM_CXMIN: u32 = 28;
pub const SM_CYMIN: u32 = 29;
pub const SM_CXSIZE: u32 = 30;
pub const SM_CYSIZE: u32 = 31;
pub const SM_CXFRAME: u32 = 32;
pub const SM_CYFRAME: u32 = 33;
pub const SM_CXMINTRACK: u32 = 34;
pub const SM_CYMINTRACK: u32 = 35;
pub const SM_CXDOUBLECLK: u32 = 36;
pub const SM_CYDOUBLECLK: u32 = 37;
pub const SM_CXICONSPACING: u32 = 38;
pub const SM_CYICONSPACING: u32 = 39;
pub const SM_MENUDROPALIGNMENT: u32 = 40;
pub const SM_PENWINDOWS: u32 = 41;
pub const SM_DBCSENABLED: u32 = 42;
pub const SM_CMOUSEBUTTONS: u32 = 43;
pub const SM_CXFIXEDFRAME: u32 = 7;
pub const SM_CYFIXEDFRAME: u32 = 8;
pub const SM_CXSIZEFRAME: u32 = 32;
pub const SM_CYSIZEFRAME: u32 = 33;
pub const SM_SECURE: u32 = 44;
pub const SM_CXEDGE: u32 = 45;
pub const SM_CYEDGE: u32 = 46;
pub const SM_CXMINSPACING: u32 = 47;
pub const SM_CYMINSPACING: u32 = 48;
pub const SM_CXSMICON: u32 = 49;
pub const SM_CYSMICON: u32 = 50;
pub const SM_CYSMCAPTION: u32 = 51;
pub const SM_CXSMSIZE: u32 = 52;
pub const SM_CYSMSIZE: u32 = 53;
pub const SM_CXMENUSIZE: u32 = 54;
pub const SM_CYMENUSIZE: u32 = 55;
pub const SM_ARRANGE: u32 = 56;
pub const SM_CXMINIMIZED: u32 = 57;
pub const SM_CYMINIMIZED: u32 = 58;
pub const SM_CXMAXTRACK: u32 = 59;
pub const SM_CYMAXTRACK: u32 = 60;
pub const SM_CXMAXIMIZED: u32 = 61;
pub const SM_CYMAXIMIZED: u32 = 62;
pub const SM_NETWORK: u32 = 63;
pub const SM_CLEANBOOT: u32 = 67;
pub const SM_CXDRAG: u32 = 68;
pub const SM_CYDRAG: u32 = 69;
pub const SM_SHOWSOUNDS: u32 = 70;
pub const SM_CXMENUCHECK: u32 = 71;
pub const SM_CYMENUCHECK: u32 = 72;
pub const SM_SLOWMACHINE: u32 = 73;
pub const SM_MIDEASTENABLED: u32 = 74;
pub const SM_MOUSEWHEELPRESENT: u32 = 75;
pub const SM_XVIRTUALSCREEN: u32 = 76;
pub const SM_YVIRTUALSCREEN: u32 = 77;
pub const SM_CXVIRTUALSCREEN: u32 = 78;
pub const SM_CYVIRTUALSCREEN: u32 = 79;
pub const SM_CMONITORS: u32 = 80;
pub const SM_SAMEDISPLAYFORMAT: u32 = 81;
pub const SM_IMMENABLED: u32 = 82;
pub const SM_CXFOCUSBORDER: u32 = 83;
pub const SM_CYFOCUSBORDER: u32 = 84;
pub const SM_TABLETPC: u32 = 86;
pub const SM_MEDIACENTER: u32 = 87;
pub const SM_STARTER: u32 = 88;
pub const SM_SERVERR2: u32 = 89;
pub const SM_MOUSEHORIZONTALWHEELPRESENT: u32 = 91;
pub const SM_CXPADDEDBORDER: u32 = 92;
pub const SM_DIGITIZER: u32 = 94;
pub const SM_MAXIMUMTOUCHES: u32 = 95;
pub const SM_CMETRICS: u32 = 97;
pub const SM_REMOTESESSION: u32 = 4096;
pub const SM_SHUTTINGDOWN: u32 = 8192;
pub const SM_REMOTECONTROL: u32 = 8193;
pub const SM_CARETBLINKINGENABLED: u32 = 8194;
pub const SM_CONVERTIBLESLATEMODE: u32 = 8195;
pub const SM_SYSTEMDOCKED: u32 = 8196;
pub const PMB_ACTIVE: u32 = 1;
pub const MNC_IGNORE: u32 = 0;
pub const MNC_CLOSE: u32 = 1;
pub const MNC_EXECUTE: u32 = 2;
pub const MNC_SELECT: u32 = 3;
pub const MNS_NOCHECK: u32 = 2147483648;
pub const MNS_MODELESS: u32 = 1073741824;
pub const MNS_DRAGDROP: u32 = 536870912;
pub const MNS_AUTODISMISS: u32 = 268435456;
pub const MNS_NOTIFYBYPOS: u32 = 134217728;
pub const MNS_CHECKORBMP: u32 = 67108864;
pub const MIM_MAXHEIGHT: u32 = 1;
pub const MIM_BACKGROUND: u32 = 2;
pub const MIM_HELPID: u32 = 4;
pub const MIM_MENUDATA: u32 = 8;
pub const MIM_STYLE: u32 = 16;
pub const MIM_APPLYTOSUBMENUS: u32 = 2147483648;
pub const MND_CONTINUE: u32 = 0;
pub const MND_ENDMENU: u32 = 1;
pub const MNGOF_TOPGAP: u32 = 1;
pub const MNGOF_BOTTOMGAP: u32 = 2;
pub const MNGO_NOINTERFACE: u32 = 0;
pub const MNGO_NOERROR: u32 = 1;
pub const MIIM_STATE: u32 = 1;
pub const MIIM_ID: u32 = 2;
pub const MIIM_SUBMENU: u32 = 4;
pub const MIIM_CHECKMARKS: u32 = 8;
pub const MIIM_TYPE: u32 = 16;
pub const MIIM_DATA: u32 = 32;
pub const MIIM_STRING: u32 = 64;
pub const MIIM_BITMAP: u32 = 128;
pub const MIIM_FTYPE: u32 = 256;
pub const GMDI_USEDISABLED: u32 = 1;
pub const GMDI_GOINTOPOPUPS: u32 = 2;
pub const TPM_LEFTBUTTON: u32 = 0;
pub const TPM_RIGHTBUTTON: u32 = 2;
pub const TPM_LEFTALIGN: u32 = 0;
pub const TPM_CENTERALIGN: u32 = 4;
pub const TPM_RIGHTALIGN: u32 = 8;
pub const TPM_TOPALIGN: u32 = 0;
pub const TPM_VCENTERALIGN: u32 = 16;
pub const TPM_BOTTOMALIGN: u32 = 32;
pub const TPM_HORIZONTAL: u32 = 0;
pub const TPM_VERTICAL: u32 = 64;
pub const TPM_NONOTIFY: u32 = 128;
pub const TPM_RETURNCMD: u32 = 256;
pub const TPM_RECURSE: u32 = 1;
pub const TPM_HORPOSANIMATION: u32 = 1024;
pub const TPM_HORNEGANIMATION: u32 = 2048;
pub const TPM_VERPOSANIMATION: u32 = 4096;
pub const TPM_VERNEGANIMATION: u32 = 8192;
pub const TPM_NOANIMATION: u32 = 16384;
pub const TPM_LAYOUTRTL: u32 = 32768;
pub const TPM_WORKAREA: u32 = 65536;
pub const DOF_EXECUTABLE: u32 = 32769;
pub const DOF_DOCUMENT: u32 = 32770;
pub const DOF_DIRECTORY: u32 = 32771;
pub const DOF_MULTIPLE: u32 = 32772;
pub const DOF_PROGMAN: u32 = 1;
pub const DOF_SHELLDATA: u32 = 2;
pub const DO_DROPFILE: u32 = 1162627398;
pub const DO_PRINTFILE: u32 = 1414419024;
pub const DT_TOP: u32 = 0;
pub const DT_LEFT: u32 = 0;
pub const DT_CENTER: u32 = 1;
pub const DT_RIGHT: u32 = 2;
pub const DT_VCENTER: u32 = 4;
pub const DT_BOTTOM: u32 = 8;
pub const DT_WORDBREAK: u32 = 16;
pub const DT_SINGLELINE: u32 = 32;
pub const DT_EXPANDTABS: u32 = 64;
pub const DT_TABSTOP: u32 = 128;
pub const DT_NOCLIP: u32 = 256;
pub const DT_EXTERNALLEADING: u32 = 512;
pub const DT_CALCRECT: u32 = 1024;
pub const DT_NOPREFIX: u32 = 2048;
pub const DT_INTERNAL: u32 = 4096;
pub const DT_EDITCONTROL: u32 = 8192;
pub const DT_PATH_ELLIPSIS: u32 = 16384;
pub const DT_END_ELLIPSIS: u32 = 32768;
pub const DT_MODIFYSTRING: u32 = 65536;
pub const DT_RTLREADING: u32 = 131072;
pub const DT_WORD_ELLIPSIS: u32 = 262144;
pub const DT_NOFULLWIDTHCHARBREAK: u32 = 524288;
pub const DT_HIDEPREFIX: u32 = 1048576;
pub const DT_PREFIXONLY: u32 = 2097152;
pub const DST_COMPLEX: u32 = 0;
pub const DST_TEXT: u32 = 1;
pub const DST_PREFIXTEXT: u32 = 2;
pub const DST_ICON: u32 = 3;
pub const DST_BITMAP: u32 = 4;
pub const DSS_NORMAL: u32 = 0;
pub const DSS_UNION: u32 = 16;
pub const DSS_DISABLED: u32 = 32;
pub const DSS_MONO: u32 = 128;
pub const DSS_HIDEPREFIX: u32 = 512;
pub const DSS_PREFIXONLY: u32 = 1024;
pub const DSS_RIGHT: u32 = 32768;
pub const LSFW_LOCK: u32 = 1;
pub const LSFW_UNLOCK: u32 = 2;
pub const DCX_WINDOW: u32 = 1;
pub const DCX_CACHE: u32 = 2;
pub const DCX_NORESETATTRS: u32 = 4;
pub const DCX_CLIPCHILDREN: u32 = 8;
pub const DCX_CLIPSIBLINGS: u32 = 16;
pub const DCX_PARENTCLIP: u32 = 32;
pub const DCX_EXCLUDERGN: u32 = 64;
pub const DCX_INTERSECTRGN: u32 = 128;
pub const DCX_EXCLUDEUPDATE: u32 = 256;
pub const DCX_INTERSECTUPDATE: u32 = 512;
pub const DCX_LOCKWINDOWUPDATE: u32 = 1024;
pub const DCX_VALIDATE: u32 = 2097152;
pub const RDW_INVALIDATE: u32 = 1;
pub const RDW_INTERNALPAINT: u32 = 2;
pub const RDW_ERASE: u32 = 4;
pub const RDW_VALIDATE: u32 = 8;
pub const RDW_NOINTERNALPAINT: u32 = 16;
pub const RDW_NOERASE: u32 = 32;
pub const RDW_NOCHILDREN: u32 = 64;
pub const RDW_ALLCHILDREN: u32 = 128;
pub const RDW_UPDATENOW: u32 = 256;
pub const RDW_ERASENOW: u32 = 512;
pub const RDW_FRAME: u32 = 1024;
pub const RDW_NOFRAME: u32 = 2048;
pub const SW_SCROLLCHILDREN: u32 = 1;
pub const SW_INVALIDATE: u32 = 2;
pub const SW_ERASE: u32 = 4;
pub const SW_SMOOTHSCROLL: u32 = 16;
pub const ESB_ENABLE_BOTH: u32 = 0;
pub const ESB_DISABLE_BOTH: u32 = 3;
pub const ESB_DISABLE_LEFT: u32 = 1;
pub const ESB_DISABLE_RIGHT: u32 = 2;
pub const ESB_DISABLE_UP: u32 = 1;
pub const ESB_DISABLE_DOWN: u32 = 2;
pub const ESB_DISABLE_LTUP: u32 = 1;
pub const ESB_DISABLE_RTDN: u32 = 2;
pub const HELPINFO_WINDOW: u32 = 1;
pub const HELPINFO_MENUITEM: u32 = 2;
pub const MB_OK: u32 = 0;
pub const MB_OKCANCEL: u32 = 1;
pub const MB_ABORTRETRYIGNORE: u32 = 2;
pub const MB_YESNOCANCEL: u32 = 3;
pub const MB_YESNO: u32 = 4;
pub const MB_RETRYCANCEL: u32 = 5;
pub const MB_CANCELTRYCONTINUE: u32 = 6;
pub const MB_ICONHAND: u32 = 16;
pub const MB_ICONQUESTION: u32 = 32;
pub const MB_ICONEXCLAMATION: u32 = 48;
pub const MB_ICONASTERISK: u32 = 64;
pub const MB_USERICON: u32 = 128;
pub const MB_ICONWARNING: u32 = 48;
pub const MB_ICONERROR: u32 = 16;
pub const MB_ICONINFORMATION: u32 = 64;
pub const MB_ICONSTOP: u32 = 16;
pub const MB_DEFBUTTON1: u32 = 0;
pub const MB_DEFBUTTON2: u32 = 256;
pub const MB_DEFBUTTON3: u32 = 512;
pub const MB_DEFBUTTON4: u32 = 768;
pub const MB_APPLMODAL: u32 = 0;
pub const MB_SYSTEMMODAL: u32 = 4096;
pub const MB_TASKMODAL: u32 = 8192;
pub const MB_HELP: u32 = 16384;
pub const MB_NOFOCUS: u32 = 32768;
pub const MB_SETFOREGROUND: u32 = 65536;
pub const MB_DEFAULT_DESKTOP_ONLY: u32 = 131072;
pub const MB_TOPMOST: u32 = 262144;
pub const MB_RIGHT: u32 = 524288;
pub const MB_RTLREADING: u32 = 1048576;
pub const MB_SERVICE_NOTIFICATION: u32 = 2097152;
pub const MB_SERVICE_NOTIFICATION_NT3X: u32 = 262144;
pub const MB_TYPEMASK: u32 = 15;
pub const MB_ICONMASK: u32 = 240;
pub const MB_DEFMASK: u32 = 3840;
pub const MB_MODEMASK: u32 = 12288;
pub const MB_MISCMASK: u32 = 49152;
pub const CWP_ALL: u32 = 0;
pub const CWP_SKIPINVISIBLE: u32 = 1;
pub const CWP_SKIPDISABLED: u32 = 2;
pub const CWP_SKIPTRANSPARENT: u32 = 4;
pub const CTLCOLOR_MSGBOX: u32 = 0;
pub const CTLCOLOR_EDIT: u32 = 1;
pub const CTLCOLOR_LISTBOX: u32 = 2;
pub const CTLCOLOR_BTN: u32 = 3;
pub const CTLCOLOR_DLG: u32 = 4;
pub const CTLCOLOR_SCROLLBAR: u32 = 5;
pub const CTLCOLOR_STATIC: u32 = 6;
pub const CTLCOLOR_MAX: u32 = 7;
pub const COLOR_SCROLLBAR: u32 = 0;
pub const COLOR_BACKGROUND: u32 = 1;
pub const COLOR_ACTIVECAPTION: u32 = 2;
pub const COLOR_INACTIVECAPTION: u32 = 3;
pub const COLOR_MENU: u32 = 4;
pub const COLOR_WINDOW: u32 = 5;
pub const COLOR_WINDOWFRAME: u32 = 6;
pub const COLOR_MENUTEXT: u32 = 7;
pub const COLOR_WINDOWTEXT: u32 = 8;
pub const COLOR_CAPTIONTEXT: u32 = 9;
pub const COLOR_ACTIVEBORDER: u32 = 10;
pub const COLOR_INACTIVEBORDER: u32 = 11;
pub const COLOR_APPWORKSPACE: u32 = 12;
pub const COLOR_HIGHLIGHT: u32 = 13;
pub const COLOR_HIGHLIGHTTEXT: u32 = 14;
pub const COLOR_BTNFACE: u32 = 15;
pub const COLOR_BTNSHADOW: u32 = 16;
pub const COLOR_GRAYTEXT: u32 = 17;
pub const COLOR_BTNTEXT: u32 = 18;
pub const COLOR_INACTIVECAPTIONTEXT: u32 = 19;
pub const COLOR_BTNHIGHLIGHT: u32 = 20;
pub const COLOR_3DDKSHADOW: u32 = 21;
pub const COLOR_3DLIGHT: u32 = 22;
pub const COLOR_INFOTEXT: u32 = 23;
pub const COLOR_INFOBK: u32 = 24;
pub const COLOR_HOTLIGHT: u32 = 26;
pub const COLOR_GRADIENTACTIVECAPTION: u32 = 27;
pub const COLOR_GRADIENTINACTIVECAPTION: u32 = 28;
pub const COLOR_MENUHILIGHT: u32 = 29;
pub const COLOR_MENUBAR: u32 = 30;
pub const COLOR_DESKTOP: u32 = 1;
pub const COLOR_3DFACE: u32 = 15;
pub const COLOR_3DSHADOW: u32 = 16;
pub const COLOR_3DHIGHLIGHT: u32 = 20;
pub const COLOR_3DHILIGHT: u32 = 20;
pub const COLOR_BTNHILIGHT: u32 = 20;
pub const GW_HWNDFIRST: u32 = 0;
pub const GW_HWNDLAST: u32 = 1;
pub const GW_HWNDNEXT: u32 = 2;
pub const GW_HWNDPREV: u32 = 3;
pub const GW_OWNER: u32 = 4;
pub const GW_CHILD: u32 = 5;
pub const GW_ENABLEDPOPUP: u32 = 6;
pub const GW_MAX: u32 = 6;
pub const MF_INSERT: u32 = 0;
pub const MF_CHANGE: u32 = 128;
pub const MF_APPEND: u32 = 256;
pub const MF_DELETE: u32 = 512;
pub const MF_REMOVE: u32 = 4096;
pub const MF_BYCOMMAND: u32 = 0;
pub const MF_BYPOSITION: u32 = 1024;
pub const MF_SEPARATOR: u32 = 2048;
pub const MF_ENABLED: u32 = 0;
pub const MF_GRAYED: u32 = 1;
pub const MF_DISABLED: u32 = 2;
pub const MF_UNCHECKED: u32 = 0;
pub const MF_CHECKED: u32 = 8;
pub const MF_USECHECKBITMAPS: u32 = 512;
pub const MF_STRING: u32 = 0;
pub const MF_BITMAP: u32 = 4;
pub const MF_OWNERDRAW: u32 = 256;
pub const MF_POPUP: u32 = 16;
pub const MF_MENUBARBREAK: u32 = 32;
pub const MF_MENUBREAK: u32 = 64;
pub const MF_UNHILITE: u32 = 0;
pub const MF_HILITE: u32 = 128;
pub const MF_DEFAULT: u32 = 4096;
pub const MF_SYSMENU: u32 = 8192;
pub const MF_HELP: u32 = 16384;
pub const MF_RIGHTJUSTIFY: u32 = 16384;
pub const MF_MOUSESELECT: u32 = 32768;
pub const MF_END: u32 = 128;
pub const MFT_STRING: u32 = 0;
pub const MFT_BITMAP: u32 = 4;
pub const MFT_MENUBARBREAK: u32 = 32;
pub const MFT_MENUBREAK: u32 = 64;
pub const MFT_OWNERDRAW: u32 = 256;
pub const MFT_RADIOCHECK: u32 = 512;
pub const MFT_SEPARATOR: u32 = 2048;
pub const MFT_RIGHTORDER: u32 = 8192;
pub const MFT_RIGHTJUSTIFY: u32 = 16384;
pub const MFS_GRAYED: u32 = 3;
pub const MFS_DISABLED: u32 = 3;
pub const MFS_CHECKED: u32 = 8;
pub const MFS_HILITE: u32 = 128;
pub const MFS_ENABLED: u32 = 0;
pub const MFS_UNCHECKED: u32 = 0;
pub const MFS_UNHILITE: u32 = 0;
pub const MFS_DEFAULT: u32 = 4096;
pub const SC_SIZE: u32 = 61440;
pub const SC_MOVE: u32 = 61456;
pub const SC_MINIMIZE: u32 = 61472;
pub const SC_MAXIMIZE: u32 = 61488;
pub const SC_NEXTWINDOW: u32 = 61504;
pub const SC_PREVWINDOW: u32 = 61520;
pub const SC_CLOSE: u32 = 61536;
pub const SC_VSCROLL: u32 = 61552;
pub const SC_HSCROLL: u32 = 61568;
pub const SC_MOUSEMENU: u32 = 61584;
pub const SC_KEYMENU: u32 = 61696;
pub const SC_ARRANGE: u32 = 61712;
pub const SC_RESTORE: u32 = 61728;
pub const SC_TASKLIST: u32 = 61744;
pub const SC_SCREENSAVE: u32 = 61760;
pub const SC_HOTKEY: u32 = 61776;
pub const SC_DEFAULT: u32 = 61792;
pub const SC_MONITORPOWER: u32 = 61808;
pub const SC_CONTEXTHELP: u32 = 61824;
pub const SC_SEPARATOR: u32 = 61455;
pub const SCF_ISSECURE: u32 = 1;
pub const SC_ICON: u32 = 61472;
pub const SC_ZOOM: u32 = 61488;
pub const CURSOR_CREATION_SCALING_NONE: u32 = 1;
pub const CURSOR_CREATION_SCALING_DEFAULT: u32 = 2;
pub const IMAGE_BITMAP: u32 = 0;
pub const IMAGE_ICON: u32 = 1;
pub const IMAGE_CURSOR: u32 = 2;
pub const IMAGE_ENHMETAFILE: u32 = 3;
pub const LR_DEFAULTCOLOR: u32 = 0;
pub const LR_MONOCHROME: u32 = 1;
pub const LR_COLOR: u32 = 2;
pub const LR_COPYRETURNORG: u32 = 4;
pub const LR_COPYDELETEORG: u32 = 8;
pub const LR_LOADFROMFILE: u32 = 16;
pub const LR_LOADTRANSPARENT: u32 = 32;
pub const LR_DEFAULTSIZE: u32 = 64;
pub const LR_VGACOLOR: u32 = 128;
pub const LR_LOADMAP3DCOLORS: u32 = 4096;
pub const LR_CREATEDIBSECTION: u32 = 8192;
pub const LR_COPYFROMRESOURCE: u32 = 16384;
pub const LR_SHARED: u32 = 32768;
pub const DI_MASK: u32 = 1;
pub const DI_IMAGE: u32 = 2;
pub const DI_NORMAL: u32 = 3;
pub const DI_COMPAT: u32 = 4;
pub const DI_DEFAULTSIZE: u32 = 8;
pub const DI_NOMIRROR: u32 = 16;
pub const RES_ICON: u32 = 1;
pub const RES_CURSOR: u32 = 2;
pub const ORD_LANGDRIVER: u32 = 1;
pub const IDOK: u32 = 1;
pub const IDCANCEL: u32 = 2;
pub const IDABORT: u32 = 3;
pub const IDRETRY: u32 = 4;
pub const IDIGNORE: u32 = 5;
pub const IDYES: u32 = 6;
pub const IDNO: u32 = 7;
pub const IDCLOSE: u32 = 8;
pub const IDHELP: u32 = 9;
pub const IDTRYAGAIN: u32 = 10;
pub const IDCONTINUE: u32 = 11;
pub const IDTIMEOUT: u32 = 32000;
pub const ES_LEFT: u32 = 0;
pub const ES_CENTER: u32 = 1;
pub const ES_RIGHT: u32 = 2;
pub const ES_MULTILINE: u32 = 4;
pub const ES_UPPERCASE: u32 = 8;
pub const ES_LOWERCASE: u32 = 16;
pub const ES_PASSWORD: u32 = 32;
pub const ES_AUTOVSCROLL: u32 = 64;
pub const ES_AUTOHSCROLL: u32 = 128;
pub const ES_NOHIDESEL: u32 = 256;
pub const ES_OEMCONVERT: u32 = 1024;
pub const ES_READONLY: u32 = 2048;
pub const ES_WANTRETURN: u32 = 4096;
pub const ES_NUMBER: u32 = 8192;
pub const EN_SETFOCUS: u32 = 256;
pub const EN_KILLFOCUS: u32 = 512;
pub const EN_CHANGE: u32 = 768;
pub const EN_UPDATE: u32 = 1024;
pub const EN_ERRSPACE: u32 = 1280;
pub const EN_MAXTEXT: u32 = 1281;
pub const EN_HSCROLL: u32 = 1537;
pub const EN_VSCROLL: u32 = 1538;
pub const EN_ALIGN_LTR_EC: u32 = 1792;
pub const EN_ALIGN_RTL_EC: u32 = 1793;
pub const EN_BEFORE_PASTE: u32 = 2048;
pub const EN_AFTER_PASTE: u32 = 2049;
pub const EC_LEFTMARGIN: u32 = 1;
pub const EC_RIGHTMARGIN: u32 = 2;
pub const EC_USEFONTINFO: u32 = 65535;
pub const EMSIS_COMPOSITIONSTRING: u32 = 1;
pub const EIMES_GETCOMPSTRATONCE: u32 = 1;
pub const EIMES_CANCELCOMPSTRINFOCUS: u32 = 2;
pub const EIMES_COMPLETECOMPSTRKILLFOCUS: u32 = 4;
pub const EM_GETSEL: u32 = 176;
pub const EM_SETSEL: u32 = 177;
pub const EM_GETRECT: u32 = 178;
pub const EM_SETRECT: u32 = 179;
pub const EM_SETRECTNP: u32 = 180;
pub const EM_SCROLL: u32 = 181;
pub const EM_LINESCROLL: u32 = 182;
pub const EM_SCROLLCARET: u32 = 183;
pub const EM_GETMODIFY: u32 = 184;
pub const EM_SETMODIFY: u32 = 185;
pub const EM_GETLINECOUNT: u32 = 186;
pub const EM_LINEINDEX: u32 = 187;
pub const EM_SETHANDLE: u32 = 188;
pub const EM_GETHANDLE: u32 = 189;
pub const EM_GETTHUMB: u32 = 190;
pub const EM_LINELENGTH: u32 = 193;
pub const EM_REPLACESEL: u32 = 194;
pub const EM_GETLINE: u32 = 196;
pub const EM_LIMITTEXT: u32 = 197;
pub const EM_CANUNDO: u32 = 198;
pub const EM_UNDO: u32 = 199;
pub const EM_FMTLINES: u32 = 200;
pub const EM_LINEFROMCHAR: u32 = 201;
pub const EM_SETTABSTOPS: u32 = 203;
pub const EM_SETPASSWORDCHAR: u32 = 204;
pub const EM_EMPTYUNDOBUFFER: u32 = 205;
pub const EM_GETFIRSTVISIBLELINE: u32 = 206;
pub const EM_SETREADONLY: u32 = 207;
pub const EM_SETWORDBREAKPROC: u32 = 208;
pub const EM_GETWORDBREAKPROC: u32 = 209;
pub const EM_GETPASSWORDCHAR: u32 = 210;
pub const EM_SETMARGINS: u32 = 211;
pub const EM_GETMARGINS: u32 = 212;
pub const EM_SETLIMITTEXT: u32 = 197;
pub const EM_GETLIMITTEXT: u32 = 213;
pub const EM_POSFROMCHAR: u32 = 214;
pub const EM_CHARFROMPOS: u32 = 215;
pub const EM_SETIMESTATUS: u32 = 216;
pub const EM_GETIMESTATUS: u32 = 217;
pub const EM_ENABLEFEATURE: u32 = 218;
pub const WB_LEFT: u32 = 0;
pub const WB_RIGHT: u32 = 1;
pub const WB_ISDELIMITER: u32 = 2;
pub const BS_PUSHBUTTON: u32 = 0;
pub const BS_DEFPUSHBUTTON: u32 = 1;
pub const BS_CHECKBOX: u32 = 2;
pub const BS_AUTOCHECKBOX: u32 = 3;
pub const BS_RADIOBUTTON: u32 = 4;
pub const BS_3STATE: u32 = 5;
pub const BS_AUTO3STATE: u32 = 6;
pub const BS_GROUPBOX: u32 = 7;
pub const BS_USERBUTTON: u32 = 8;
pub const BS_AUTORADIOBUTTON: u32 = 9;
pub const BS_PUSHBOX: u32 = 10;
pub const BS_OWNERDRAW: u32 = 11;
pub const BS_TYPEMASK: u32 = 15;
pub const BS_LEFTTEXT: u32 = 32;
pub const BS_TEXT: u32 = 0;
pub const BS_ICON: u32 = 64;
pub const BS_BITMAP: u32 = 128;
pub const BS_LEFT: u32 = 256;
pub const BS_RIGHT: u32 = 512;
pub const BS_CENTER: u32 = 768;
pub const BS_TOP: u32 = 1024;
pub const BS_BOTTOM: u32 = 2048;
pub const BS_VCENTER: u32 = 3072;
pub const BS_PUSHLIKE: u32 = 4096;
pub const BS_MULTILINE: u32 = 8192;
pub const BS_NOTIFY: u32 = 16384;
pub const BS_FLAT: u32 = 32768;
pub const BS_RIGHTBUTTON: u32 = 32;
pub const BN_CLICKED: u32 = 0;
pub const BN_PAINT: u32 = 1;
pub const BN_HILITE: u32 = 2;
pub const BN_UNHILITE: u32 = 3;
pub const BN_DISABLE: u32 = 4;
pub const BN_DOUBLECLICKED: u32 = 5;
pub const BN_PUSHED: u32 = 2;
pub const BN_UNPUSHED: u32 = 3;
pub const BN_DBLCLK: u32 = 5;
pub const BN_SETFOCUS: u32 = 6;
pub const BN_KILLFOCUS: u32 = 7;
pub const BM_GETCHECK: u32 = 240;
pub const BM_SETCHECK: u32 = 241;
pub const BM_GETSTATE: u32 = 242;
pub const BM_SETSTATE: u32 = 243;
pub const BM_SETSTYLE: u32 = 244;
pub const BM_CLICK: u32 = 245;
pub const BM_GETIMAGE: u32 = 246;
pub const BM_SETIMAGE: u32 = 247;
pub const BM_SETDONTCLICK: u32 = 248;
pub const BST_UNCHECKED: u32 = 0;
pub const BST_CHECKED: u32 = 1;
pub const BST_INDETERMINATE: u32 = 2;
pub const BST_PUSHED: u32 = 4;
pub const BST_FOCUS: u32 = 8;
pub const SS_LEFT: u32 = 0;
pub const SS_CENTER: u32 = 1;
pub const SS_RIGHT: u32 = 2;
pub const SS_ICON: u32 = 3;
pub const SS_BLACKRECT: u32 = 4;
pub const SS_GRAYRECT: u32 = 5;
pub const SS_WHITERECT: u32 = 6;
pub const SS_BLACKFRAME: u32 = 7;
pub const SS_GRAYFRAME: u32 = 8;
pub const SS_WHITEFRAME: u32 = 9;
pub const SS_USERITEM: u32 = 10;
pub const SS_SIMPLE: u32 = 11;
pub const SS_LEFTNOWORDWRAP: u32 = 12;
pub const SS_OWNERDRAW: u32 = 13;
pub const SS_BITMAP: u32 = 14;
pub const SS_ENHMETAFILE: u32 = 15;
pub const SS_ETCHEDHORZ: u32 = 16;
pub const SS_ETCHEDVERT: u32 = 17;
pub const SS_ETCHEDFRAME: u32 = 18;
pub const SS_TYPEMASK: u32 = 31;
pub const SS_REALSIZECONTROL: u32 = 64;
pub const SS_NOPREFIX: u32 = 128;
pub const SS_NOTIFY: u32 = 256;
pub const SS_CENTERIMAGE: u32 = 512;
pub const SS_RIGHTJUST: u32 = 1024;
pub const SS_REALSIZEIMAGE: u32 = 2048;
pub const SS_SUNKEN: u32 = 4096;
pub const SS_EDITCONTROL: u32 = 8192;
pub const SS_ENDELLIPSIS: u32 = 16384;
pub const SS_PATHELLIPSIS: u32 = 32768;
pub const SS_WORDELLIPSIS: u32 = 49152;
pub const SS_ELLIPSISMASK: u32 = 49152;
pub const STM_SETICON: u32 = 368;
pub const STM_GETICON: u32 = 369;
pub const STM_SETIMAGE: u32 = 370;
pub const STM_GETIMAGE: u32 = 371;
pub const STN_CLICKED: u32 = 0;
pub const STN_DBLCLK: u32 = 1;
pub const STN_ENABLE: u32 = 2;
pub const STN_DISABLE: u32 = 3;
pub const STM_MSGMAX: u32 = 372;
pub const DWL_MSGRESULT: u32 = 0;
pub const DWL_DLGPROC: u32 = 4;
pub const DWL_USER: u32 = 8;
pub const DWLP_MSGRESULT: u32 = 0;
pub const DDL_READWRITE: u32 = 0;
pub const DDL_READONLY: u32 = 1;
pub const DDL_HIDDEN: u32 = 2;
pub const DDL_SYSTEM: u32 = 4;
pub const DDL_DIRECTORY: u32 = 16;
pub const DDL_ARCHIVE: u32 = 32;
pub const DDL_POSTMSGS: u32 = 8192;
pub const DDL_DRIVES: u32 = 16384;
pub const DDL_EXCLUSIVE: u32 = 32768;
pub const DS_ABSALIGN: u32 = 1;
pub const DS_SYSMODAL: u32 = 2;
pub const DS_LOCALEDIT: u32 = 32;
pub const DS_SETFONT: u32 = 64;
pub const DS_MODALFRAME: u32 = 128;
pub const DS_NOIDLEMSG: u32 = 256;
pub const DS_SETFOREGROUND: u32 = 512;
pub const DS_3DLOOK: u32 = 4;
pub const DS_FIXEDSYS: u32 = 8;
pub const DS_NOFAILCREATE: u32 = 16;
pub const DS_CONTROL: u32 = 1024;
pub const DS_CENTER: u32 = 2048;
pub const DS_CENTERMOUSE: u32 = 4096;
pub const DS_CONTEXTHELP: u32 = 8192;
pub const DS_SHELLFONT: u32 = 72;
pub const DM_GETDEFID: u32 = 1024;
pub const DM_SETDEFID: u32 = 1025;
pub const DM_REPOSITION: u32 = 1026;
pub const DC_HASDEFID: u32 = 21323;
pub const DLGC_WANTARROWS: u32 = 1;
pub const DLGC_WANTTAB: u32 = 2;
pub const DLGC_WANTALLKEYS: u32 = 4;
pub const DLGC_WANTMESSAGE: u32 = 4;
pub const DLGC_HASSETSEL: u32 = 8;
pub const DLGC_DEFPUSHBUTTON: u32 = 16;
pub const DLGC_UNDEFPUSHBUTTON: u32 = 32;
pub const DLGC_RADIOBUTTON: u32 = 64;
pub const DLGC_WANTCHARS: u32 = 128;
pub const DLGC_STATIC: u32 = 256;
pub const DLGC_BUTTON: u32 = 8192;
pub const LB_CTLCODE: u32 = 0;
pub const LB_OKAY: u32 = 0;
pub const LB_ERR: i32 = -1;
pub const LB_ERRSPACE: i32 = -2;
pub const LBN_ERRSPACE: i32 = -2;
pub const LBN_SELCHANGE: u32 = 1;
pub const LBN_DBLCLK: u32 = 2;
pub const LBN_SELCANCEL: u32 = 3;
pub const LBN_SETFOCUS: u32 = 4;
pub const LBN_KILLFOCUS: u32 = 5;
pub const LB_ADDSTRING: u32 = 384;
pub const LB_INSERTSTRING: u32 = 385;
pub const LB_DELETESTRING: u32 = 386;
pub const LB_SELITEMRANGEEX: u32 = 387;
pub const LB_RESETCONTENT: u32 = 388;
pub const LB_SETSEL: u32 = 389;
pub const LB_SETCURSEL: u32 = 390;
pub const LB_GETSEL: u32 = 391;
pub const LB_GETCURSEL: u32 = 392;
pub const LB_GETTEXT: u32 = 393;
pub const LB_GETTEXTLEN: u32 = 394;
pub const LB_GETCOUNT: u32 = 395;
pub const LB_SELECTSTRING: u32 = 396;
pub const LB_DIR: u32 = 397;
pub const LB_GETTOPINDEX: u32 = 398;
pub const LB_FINDSTRING: u32 = 399;
pub const LB_GETSELCOUNT: u32 = 400;
pub const LB_GETSELITEMS: u32 = 401;
pub const LB_SETTABSTOPS: u32 = 402;
pub const LB_GETHORIZONTALEXTENT: u32 = 403;
pub const LB_SETHORIZONTALEXTENT: u32 = 404;
pub const LB_SETCOLUMNWIDTH: u32 = 405;
pub const LB_ADDFILE: u32 = 406;
pub const LB_SETTOPINDEX: u32 = 407;
pub const LB_GETITEMRECT: u32 = 408;
pub const LB_GETITEMDATA: u32 = 409;
pub const LB_SETITEMDATA: u32 = 410;
pub const LB_SELITEMRANGE: u32 = 411;
pub const LB_SETANCHORINDEX: u32 = 412;
pub const LB_GETANCHORINDEX: u32 = 413;
pub const LB_SETCARETINDEX: u32 = 414;
pub const LB_GETCARETINDEX: u32 = 415;
pub const LB_SETITEMHEIGHT: u32 = 416;
pub const LB_GETITEMHEIGHT: u32 = 417;
pub const LB_FINDSTRINGEXACT: u32 = 418;
pub const LB_SETLOCALE: u32 = 421;
pub const LB_GETLOCALE: u32 = 422;
pub const LB_SETCOUNT: u32 = 423;
pub const LB_INITSTORAGE: u32 = 424;
pub const LB_ITEMFROMPOINT: u32 = 425;
pub const LB_GETLISTBOXINFO: u32 = 434;
pub const LB_MSGMAX: u32 = 435;
pub const LBS_NOTIFY: u32 = 1;
pub const LBS_SORT: u32 = 2;
pub const LBS_NOREDRAW: u32 = 4;
pub const LBS_MULTIPLESEL: u32 = 8;
pub const LBS_OWNERDRAWFIXED: u32 = 16;
pub const LBS_OWNERDRAWVARIABLE: u32 = 32;
pub const LBS_HASSTRINGS: u32 = 64;
pub const LBS_USETABSTOPS: u32 = 128;
pub const LBS_NOINTEGRALHEIGHT: u32 = 256;
pub const LBS_MULTICOLUMN: u32 = 512;
pub const LBS_WANTKEYBOARDINPUT: u32 = 1024;
pub const LBS_EXTENDEDSEL: u32 = 2048;
pub const LBS_DISABLENOSCROLL: u32 = 4096;
pub const LBS_NODATA: u32 = 8192;
pub const LBS_NOSEL: u32 = 16384;
pub const LBS_COMBOBOX: u32 = 32768;
pub const LBS_STANDARD: u32 = 10485763;
pub const CB_OKAY: u32 = 0;
pub const CB_ERR: i32 = -1;
pub const CB_ERRSPACE: i32 = -2;
pub const CBN_ERRSPACE: i32 = -1;
pub const CBN_SELCHANGE: u32 = 1;
pub const CBN_DBLCLK: u32 = 2;
pub const CBN_SETFOCUS: u32 = 3;
pub const CBN_KILLFOCUS: u32 = 4;
pub const CBN_EDITCHANGE: u32 = 5;
pub const CBN_EDITUPDATE: u32 = 6;
pub const CBN_DROPDOWN: u32 = 7;
pub const CBN_CLOSEUP: u32 = 8;
pub const CBN_SELENDOK: u32 = 9;
pub const CBN_SELENDCANCEL: u32 = 10;
pub const CBS_SIMPLE: u32 = 1;
pub const CBS_DROPDOWN: u32 = 2;
pub const CBS_DROPDOWNLIST: u32 = 3;
pub const CBS_OWNERDRAWFIXED: u32 = 16;
pub const CBS_OWNERDRAWVARIABLE: u32 = 32;
pub const CBS_AUTOHSCROLL: u32 = 64;
pub const CBS_OEMCONVERT: u32 = 128;
pub const CBS_SORT: u32 = 256;
pub const CBS_HASSTRINGS: u32 = 512;
pub const CBS_NOINTEGRALHEIGHT: u32 = 1024;
pub const CBS_DISABLENOSCROLL: u32 = 2048;
pub const CBS_UPPERCASE: u32 = 8192;
pub const CBS_LOWERCASE: u32 = 16384;
pub const CB_GETEDITSEL: u32 = 320;
pub const CB_LIMITTEXT: u32 = 321;
pub const CB_SETEDITSEL: u32 = 322;
pub const CB_ADDSTRING: u32 = 323;
pub const CB_DELETESTRING: u32 = 324;
pub const CB_DIR: u32 = 325;
pub const CB_GETCOUNT: u32 = 326;
pub const CB_GETCURSEL: u32 = 327;
pub const CB_GETLBTEXT: u32 = 328;
pub const CB_GETLBTEXTLEN: u32 = 329;
pub const CB_INSERTSTRING: u32 = 330;
pub const CB_RESETCONTENT: u32 = 331;
pub const CB_FINDSTRING: u32 = 332;
pub const CB_SELECTSTRING: u32 = 333;
pub const CB_SETCURSEL: u32 = 334;
pub const CB_SHOWDROPDOWN: u32 = 335;
pub const CB_GETITEMDATA: u32 = 336;
pub const CB_SETITEMDATA: u32 = 337;
pub const CB_GETDROPPEDCONTROLRECT: u32 = 338;
pub const CB_SETITEMHEIGHT: u32 = 339;
pub const CB_GETITEMHEIGHT: u32 = 340;
pub const CB_SETEXTENDEDUI: u32 = 341;
pub const CB_GETEXTENDEDUI: u32 = 342;
pub const CB_GETDROPPEDSTATE: u32 = 343;
pub const CB_FINDSTRINGEXACT: u32 = 344;
pub const CB_SETLOCALE: u32 = 345;
pub const CB_GETLOCALE: u32 = 346;
pub const CB_GETTOPINDEX: u32 = 347;
pub const CB_SETTOPINDEX: u32 = 348;
pub const CB_GETHORIZONTALEXTENT: u32 = 349;
pub const CB_SETHORIZONTALEXTENT: u32 = 350;
pub const CB_GETDROPPEDWIDTH: u32 = 351;
pub const CB_SETDROPPEDWIDTH: u32 = 352;
pub const CB_INITSTORAGE: u32 = 353;
pub const CB_GETCOMBOBOXINFO: u32 = 356;
pub const CB_MSGMAX: u32 = 357;
pub const SBS_HORZ: u32 = 0;
pub const SBS_VERT: u32 = 1;
pub const SBS_TOPALIGN: u32 = 2;
pub const SBS_LEFTALIGN: u32 = 2;
pub const SBS_BOTTOMALIGN: u32 = 4;
pub const SBS_RIGHTALIGN: u32 = 4;
pub const SBS_SIZEBOXTOPLEFTALIGN: u32 = 2;
pub const SBS_SIZEBOXBOTTOMRIGHTALIGN: u32 = 4;
pub const SBS_SIZEBOX: u32 = 8;
pub const SBS_SIZEGRIP: u32 = 16;
pub const SBM_SETPOS: u32 = 224;
pub const SBM_GETPOS: u32 = 225;
pub const SBM_SETRANGE: u32 = 226;
pub const SBM_SETRANGEREDRAW: u32 = 230;
pub const SBM_GETRANGE: u32 = 227;
pub const SBM_ENABLE_ARROWS: u32 = 228;
pub const SBM_SETSCROLLINFO: u32 = 233;
pub const SBM_GETSCROLLINFO: u32 = 234;
pub const SBM_GETSCROLLBARINFO: u32 = 235;
pub const SIF_RANGE: u32 = 1;
pub const SIF_PAGE: u32 = 2;
pub const SIF_POS: u32 = 4;
pub const SIF_DISABLENOSCROLL: u32 = 8;
pub const SIF_TRACKPOS: u32 = 16;
pub const SIF_ALL: u32 = 23;
pub const MDIS_ALLCHILDSTYLES: u32 = 1;
pub const MDITILE_VERTICAL: u32 = 0;
pub const MDITILE_HORIZONTAL: u32 = 1;
pub const MDITILE_SKIPDISABLED: u32 = 2;
pub const MDITILE_ZORDER: u32 = 4;
pub const HELP_CONTEXT: u32 = 1;
pub const HELP_QUIT: u32 = 2;
pub const HELP_INDEX: u32 = 3;
pub const HELP_CONTENTS: u32 = 3;
pub const HELP_HELPONHELP: u32 = 4;
pub const HELP_SETINDEX: u32 = 5;
pub const HELP_SETCONTENTS: u32 = 5;
pub const HELP_CONTEXTPOPUP: u32 = 8;
pub const HELP_FORCEFILE: u32 = 9;
pub const HELP_KEY: u32 = 257;
pub const HELP_COMMAND: u32 = 258;
pub const HELP_PARTIALKEY: u32 = 261;
pub const HELP_MULTIKEY: u32 = 513;
pub const HELP_SETWINPOS: u32 = 515;
pub const HELP_CONTEXTMENU: u32 = 10;
pub const HELP_FINDER: u32 = 11;
pub const HELP_WM_HELP: u32 = 12;
pub const HELP_SETPOPUP_POS: u32 = 13;
pub const HELP_TCARD: u32 = 32768;
pub const HELP_TCARD_DATA: u32 = 16;
pub const HELP_TCARD_OTHER_CALLER: u32 = 17;
pub const IDH_NO_HELP: u32 = 28440;
pub const IDH_MISSING_CONTEXT: u32 = 28441;
pub const IDH_GENERIC_HELP_BUTTON: u32 = 28442;
pub const IDH_OK: u32 = 28443;
pub const IDH_CANCEL: u32 = 28444;
pub const IDH_HELP: u32 = 28445;
pub const GR_GDIOBJECTS: u32 = 0;
pub const GR_USEROBJECTS: u32 = 1;
pub const GR_GDIOBJECTS_PEAK: u32 = 2;
pub const GR_USEROBJECTS_PEAK: u32 = 4;
pub const SPI_GETBEEP: u32 = 1;
pub const SPI_SETBEEP: u32 = 2;
pub const SPI_GETMOUSE: u32 = 3;
pub const SPI_SETMOUSE: u32 = 4;
pub const SPI_GETBORDER: u32 = 5;
pub const SPI_SETBORDER: u32 = 6;
pub const SPI_GETKEYBOARDSPEED: u32 = 10;
pub const SPI_SETKEYBOARDSPEED: u32 = 11;
pub const SPI_LANGDRIVER: u32 = 12;
pub const SPI_ICONHORIZONTALSPACING: u32 = 13;
pub const SPI_GETSCREENSAVETIMEOUT: u32 = 14;
pub const SPI_SETSCREENSAVETIMEOUT: u32 = 15;
pub const SPI_GETSCREENSAVEACTIVE: u32 = 16;
pub const SPI_SETSCREENSAVEACTIVE: u32 = 17;
pub const SPI_GETGRIDGRANULARITY: u32 = 18;
pub const SPI_SETGRIDGRANULARITY: u32 = 19;
pub const SPI_SETDESKWALLPAPER: u32 = 20;
pub const SPI_SETDESKPATTERN: u32 = 21;
pub const SPI_GETKEYBOARDDELAY: u32 = 22;
pub const SPI_SETKEYBOARDDELAY: u32 = 23;
pub const SPI_ICONVERTICALSPACING: u32 = 24;
pub const SPI_GETICONTITLEWRAP: u32 = 25;
pub const SPI_SETICONTITLEWRAP: u32 = 26;
pub const SPI_GETMENUDROPALIGNMENT: u32 = 27;
pub const SPI_SETMENUDROPALIGNMENT: u32 = 28;
pub const SPI_SETDOUBLECLKWIDTH: u32 = 29;
pub const SPI_SETDOUBLECLKHEIGHT: u32 = 30;
pub const SPI_GETICONTITLELOGFONT: u32 = 31;
pub const SPI_SETDOUBLECLICKTIME: u32 = 32;
pub const SPI_SETMOUSEBUTTONSWAP: u32 = 33;
pub const SPI_SETICONTITLELOGFONT: u32 = 34;
pub const SPI_GETFASTTASKSWITCH: u32 = 35;
pub const SPI_SETFASTTASKSWITCH: u32 = 36;
pub const SPI_SETDRAGFULLWINDOWS: u32 = 37;
pub const SPI_GETDRAGFULLWINDOWS: u32 = 38;
pub const SPI_GETNONCLIENTMETRICS: u32 = 41;
pub const SPI_SETNONCLIENTMETRICS: u32 = 42;
pub const SPI_GETMINIMIZEDMETRICS: u32 = 43;
pub const SPI_SETMINIMIZEDMETRICS: u32 = 44;
pub const SPI_GETICONMETRICS: u32 = 45;
pub const SPI_SETICONMETRICS: u32 = 46;
pub const SPI_SETWORKAREA: u32 = 47;
pub const SPI_GETWORKAREA: u32 = 48;
pub const SPI_SETPENWINDOWS: u32 = 49;
pub const SPI_GETHIGHCONTRAST: u32 = 66;
pub const SPI_SETHIGHCONTRAST: u32 = 67;
pub const SPI_GETKEYBOARDPREF: u32 = 68;
pub const SPI_SETKEYBOARDPREF: u32 = 69;
pub const SPI_GETSCREENREADER: u32 = 70;
pub const SPI_SETSCREENREADER: u32 = 71;
pub const SPI_GETANIMATION: u32 = 72;
pub const SPI_SETANIMATION: u32 = 73;
pub const SPI_GETFONTSMOOTHING: u32 = 74;
pub const SPI_SETFONTSMOOTHING: u32 = 75;
pub const SPI_SETDRAGWIDTH: u32 = 76;
pub const SPI_SETDRAGHEIGHT: u32 = 77;
pub const SPI_SETHANDHELD: u32 = 78;
pub const SPI_GETLOWPOWERTIMEOUT: u32 = 79;
pub const SPI_GETPOWEROFFTIMEOUT: u32 = 80;
pub const SPI_SETLOWPOWERTIMEOUT: u32 = 81;
pub const SPI_SETPOWEROFFTIMEOUT: u32 = 82;
pub const SPI_GETLOWPOWERACTIVE: u32 = 83;
pub const SPI_GETPOWEROFFACTIVE: u32 = 84;
pub const SPI_SETLOWPOWERACTIVE: u32 = 85;
pub const SPI_SETPOWEROFFACTIVE: u32 = 86;
pub const SPI_SETCURSORS: u32 = 87;
pub const SPI_SETICONS: u32 = 88;
pub const SPI_GETDEFAULTINPUTLANG: u32 = 89;
pub const SPI_SETDEFAULTINPUTLANG: u32 = 90;
pub const SPI_SETLANGTOGGLE: u32 = 91;
pub const SPI_GETWINDOWSEXTENSION: u32 = 92;
pub const SPI_SETMOUSETRAILS: u32 = 93;
pub const SPI_GETMOUSETRAILS: u32 = 94;
pub const SPI_SETSCREENSAVERRUNNING: u32 = 97;
pub const SPI_SCREENSAVERRUNNING: u32 = 97;
pub const SPI_GETFILTERKEYS: u32 = 50;
pub const SPI_SETFILTERKEYS: u32 = 51;
pub const SPI_GETTOGGLEKEYS: u32 = 52;
pub const SPI_SETTOGGLEKEYS: u32 = 53;
pub const SPI_GETMOUSEKEYS: u32 = 54;
pub const SPI_SETMOUSEKEYS: u32 = 55;
pub const SPI_GETSHOWSOUNDS: u32 = 56;
pub const SPI_SETSHOWSOUNDS: u32 = 57;
pub const SPI_GETSTICKYKEYS: u32 = 58;
pub const SPI_SETSTICKYKEYS: u32 = 59;
pub const SPI_GETACCESSTIMEOUT: u32 = 60;
pub const SPI_SETACCESSTIMEOUT: u32 = 61;
pub const SPI_GETSERIALKEYS: u32 = 62;
pub const SPI_SETSERIALKEYS: u32 = 63;
pub const SPI_GETSOUNDSENTRY: u32 = 64;
pub const SPI_SETSOUNDSENTRY: u32 = 65;
pub const SPI_GETSNAPTODEFBUTTON: u32 = 95;
pub const SPI_SETSNAPTODEFBUTTON: u32 = 96;
pub const SPI_GETMOUSEHOVERWIDTH: u32 = 98;
pub const SPI_SETMOUSEHOVERWIDTH: u32 = 99;
pub const SPI_GETMOUSEHOVERHEIGHT: u32 = 100;
pub const SPI_SETMOUSEHOVERHEIGHT: u32 = 101;
pub const SPI_GETMOUSEHOVERTIME: u32 = 102;
pub const SPI_SETMOUSEHOVERTIME: u32 = 103;
pub const SPI_GETWHEELSCROLLLINES: u32 = 104;
pub const SPI_SETWHEELSCROLLLINES: u32 = 105;
pub const SPI_GETMENUSHOWDELAY: u32 = 106;
pub const SPI_SETMENUSHOWDELAY: u32 = 107;
pub const SPI_GETWHEELSCROLLCHARS: u32 = 108;
pub const SPI_SETWHEELSCROLLCHARS: u32 = 109;
pub const SPI_GETSHOWIMEUI: u32 = 110;
pub const SPI_SETSHOWIMEUI: u32 = 111;
pub const SPI_GETMOUSESPEED: u32 = 112;
pub const SPI_SETMOUSESPEED: u32 = 113;
pub const SPI_GETSCREENSAVERRUNNING: u32 = 114;
pub const SPI_GETDESKWALLPAPER: u32 = 115;
pub const SPI_GETAUDIODESCRIPTION: u32 = 116;
pub const SPI_SETAUDIODESCRIPTION: u32 = 117;
pub const SPI_GETSCREENSAVESECURE: u32 = 118;
pub const SPI_SETSCREENSAVESECURE: u32 = 119;
pub const SPI_GETHUNGAPPTIMEOUT: u32 = 120;
pub const SPI_SETHUNGAPPTIMEOUT: u32 = 121;
pub const SPI_GETWAITTOKILLTIMEOUT: u32 = 122;
pub const SPI_SETWAITTOKILLTIMEOUT: u32 = 123;
pub const SPI_GETWAITTOKILLSERVICETIMEOUT: u32 = 124;
pub const SPI_SETWAITTOKILLSERVICETIMEOUT: u32 = 125;
pub const SPI_GETMOUSEDOCKTHRESHOLD: u32 = 126;
pub const SPI_SETMOUSEDOCKTHRESHOLD: u32 = 127;
pub const SPI_GETPENDOCKTHRESHOLD: u32 = 128;
pub const SPI_SETPENDOCKTHRESHOLD: u32 = 129;
pub const SPI_GETWINARRANGING: u32 = 130;
pub const SPI_SETWINARRANGING: u32 = 131;
pub const SPI_GETMOUSEDRAGOUTTHRESHOLD: u32 = 132;
pub const SPI_SETMOUSEDRAGOUTTHRESHOLD: u32 = 133;
pub const SPI_GETPENDRAGOUTTHRESHOLD: u32 = 134;
pub const SPI_SETPENDRAGOUTTHRESHOLD: u32 = 135;
pub const SPI_GETMOUSESIDEMOVETHRESHOLD: u32 = 136;
pub const SPI_SETMOUSESIDEMOVETHRESHOLD: u32 = 137;
pub const SPI_GETPENSIDEMOVETHRESHOLD: u32 = 138;
pub const SPI_SETPENSIDEMOVETHRESHOLD: u32 = 139;
pub const SPI_GETDRAGFROMMAXIMIZE: u32 = 140;
pub const SPI_SETDRAGFROMMAXIMIZE: u32 = 141;
pub const SPI_GETSNAPSIZING: u32 = 142;
pub const SPI_SETSNAPSIZING: u32 = 143;
pub const SPI_GETDOCKMOVING: u32 = 144;
pub const SPI_SETDOCKMOVING: u32 = 145;
pub const MAX_TOUCH_PREDICTION_FILTER_TAPS: u32 = 3;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY: u32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME: u32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP: u32 = 1;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_DELTA: f64 = 0.001;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN: f64 = 0.9;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX: f64 = 0.999;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE: f64 = 0.001;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA: f64 = 0.99;
pub const SPI_GETTOUCHPREDICTIONPARAMETERS: u32 = 156;
pub const SPI_SETTOUCHPREDICTIONPARAMETERS: u32 = 157;
pub const MAX_LOGICALDPIOVERRIDE: u32 = 2;
pub const MIN_LOGICALDPIOVERRIDE: i32 = -2;
pub const SPI_GETLOGICALDPIOVERRIDE: u32 = 158;
pub const SPI_SETLOGICALDPIOVERRIDE: u32 = 159;
pub const SPI_GETMENURECT: u32 = 162;
pub const SPI_SETMENURECT: u32 = 163;
pub const SPI_GETACTIVEWINDOWTRACKING: u32 = 4096;
pub const SPI_SETACTIVEWINDOWTRACKING: u32 = 4097;
pub const SPI_GETMENUANIMATION: u32 = 4098;
pub const SPI_SETMENUANIMATION: u32 = 4099;
pub const SPI_GETCOMBOBOXANIMATION: u32 = 4100;
pub const SPI_SETCOMBOBOXANIMATION: u32 = 4101;
pub const SPI_GETLISTBOXSMOOTHSCROLLING: u32 = 4102;
pub const SPI_SETLISTBOXSMOOTHSCROLLING: u32 = 4103;
pub const SPI_GETGRADIENTCAPTIONS: u32 = 4104;
pub const SPI_SETGRADIENTCAPTIONS: u32 = 4105;
pub const SPI_GETKEYBOARDCUES: u32 = 4106;
pub const SPI_SETKEYBOARDCUES: u32 = 4107;
pub const SPI_GETMENUUNDERLINES: u32 = 4106;
pub const SPI_SETMENUUNDERLINES: u32 = 4107;
pub const SPI_GETACTIVEWNDTRKZORDER: u32 = 4108;
pub const SPI_SETACTIVEWNDTRKZORDER: u32 = 4109;
pub const SPI_GETHOTTRACKING: u32 = 4110;
pub const SPI_SETHOTTRACKING: u32 = 4111;
pub const SPI_GETMENUFADE: u32 = 4114;
pub const SPI_SETMENUFADE: u32 = 4115;
pub const SPI_GETSELECTIONFADE: u32 = 4116;
pub const SPI_SETSELECTIONFADE: u32 = 4117;
pub const SPI_GETTOOLTIPANIMATION: u32 = 4118;
pub const SPI_SETTOOLTIPANIMATION: u32 = 4119;
pub const SPI_GETTOOLTIPFADE: u32 = 4120;
pub const SPI_SETTOOLTIPFADE: u32 = 4121;
pub const SPI_GETCURSORSHADOW: u32 = 4122;
pub const SPI_SETCURSORSHADOW: u32 = 4123;
pub const SPI_GETMOUSESONAR: u32 = 4124;
pub const SPI_SETMOUSESONAR: u32 = 4125;
pub const SPI_GETMOUSECLICKLOCK: u32 = 4126;
pub const SPI_SETMOUSECLICKLOCK: u32 = 4127;
pub const SPI_GETMOUSEVANISH: u32 = 4128;
pub const SPI_SETMOUSEVANISH: u32 = 4129;
pub const SPI_GETFLATMENU: u32 = 4130;
pub const SPI_SETFLATMENU: u32 = 4131;
pub const SPI_GETDROPSHADOW: u32 = 4132;
pub const SPI_SETDROPSHADOW: u32 = 4133;
pub const SPI_GETBLOCKSENDINPUTRESETS: u32 = 4134;
pub const SPI_SETBLOCKSENDINPUTRESETS: u32 = 4135;
pub const SPI_GETUIEFFECTS: u32 = 4158;
pub const SPI_SETUIEFFECTS: u32 = 4159;
pub const SPI_GETDISABLEOVERLAPPEDCONTENT: u32 = 4160;
pub const SPI_SETDISABLEOVERLAPPEDCONTENT: u32 = 4161;
pub const SPI_GETCLIENTAREAANIMATION: u32 = 4162;
pub const SPI_SETCLIENTAREAANIMATION: u32 = 4163;
pub const SPI_GETCLEARTYPE: u32 = 4168;
pub const SPI_SETCLEARTYPE: u32 = 4169;
pub const SPI_GETSPEECHRECOGNITION: u32 = 4170;
pub const SPI_SETSPEECHRECOGNITION: u32 = 4171;
pub const SPI_GETCARETBROWSING: u32 = 4172;
pub const SPI_SETCARETBROWSING: u32 = 4173;
pub const SPI_GETTHREADLOCALINPUTSETTINGS: u32 = 4174;
pub const SPI_SETTHREADLOCALINPUTSETTINGS: u32 = 4175;
pub const SPI_GETSYSTEMLANGUAGEBAR: u32 = 4176;
pub const SPI_SETSYSTEMLANGUAGEBAR: u32 = 4177;
pub const SPI_GETFOREGROUNDLOCKTIMEOUT: u32 = 8192;
pub const SPI_SETFOREGROUNDLOCKTIMEOUT: u32 = 8193;
pub const SPI_GETACTIVEWNDTRKTIMEOUT: u32 = 8194;
pub const SPI_SETACTIVEWNDTRKTIMEOUT: u32 = 8195;
pub const SPI_GETFOREGROUNDFLASHCOUNT: u32 = 8196;
pub const SPI_SETFOREGROUNDFLASHCOUNT: u32 = 8197;
pub const SPI_GETCARETWIDTH: u32 = 8198;
pub const SPI_SETCARETWIDTH: u32 = 8199;
pub const SPI_GETMOUSECLICKLOCKTIME: u32 = 8200;
pub const SPI_SETMOUSECLICKLOCKTIME: u32 = 8201;
pub const SPI_GETFONTSMOOTHINGTYPE: u32 = 8202;
pub const SPI_SETFONTSMOOTHINGTYPE: u32 = 8203;
pub const FE_FONTSMOOTHINGSTANDARD: u32 = 1;
pub const FE_FONTSMOOTHINGCLEARTYPE: u32 = 2;
pub const SPI_GETFONTSMOOTHINGCONTRAST: u32 = 8204;
pub const SPI_SETFONTSMOOTHINGCONTRAST: u32 = 8205;
pub const SPI_GETFOCUSBORDERWIDTH: u32 = 8206;
pub const SPI_SETFOCUSBORDERWIDTH: u32 = 8207;
pub const SPI_GETFOCUSBORDERHEIGHT: u32 = 8208;
pub const SPI_SETFOCUSBORDERHEIGHT: u32 = 8209;
pub const SPI_GETFONTSMOOTHINGORIENTATION: u32 = 8210;
pub const SPI_SETFONTSMOOTHINGORIENTATION: u32 = 8211;
pub const FE_FONTSMOOTHINGORIENTATIONBGR: u32 = 0;
pub const FE_FONTSMOOTHINGORIENTATIONRGB: u32 = 1;
pub const SPI_GETMINIMUMHITRADIUS: u32 = 8212;
pub const SPI_SETMINIMUMHITRADIUS: u32 = 8213;
pub const SPI_GETMESSAGEDURATION: u32 = 8214;
pub const SPI_SETMESSAGEDURATION: u32 = 8215;
pub const SPI_GETCONTACTVISUALIZATION: u32 = 8216;
pub const SPI_SETCONTACTVISUALIZATION: u32 = 8217;
pub const CONTACTVISUALIZATION_OFF: u32 = 0;
pub const CONTACTVISUALIZATION_ON: u32 = 1;
pub const CONTACTVISUALIZATION_PRESENTATIONMODE: u32 = 2;
pub const SPI_GETGESTUREVISUALIZATION: u32 = 8218;
pub const SPI_SETGESTUREVISUALIZATION: u32 = 8219;
pub const GESTUREVISUALIZATION_OFF: u32 = 0;
pub const GESTUREVISUALIZATION_ON: u32 = 31;
pub const GESTUREVISUALIZATION_TAP: u32 = 1;
pub const GESTUREVISUALIZATION_DOUBLETAP: u32 = 2;
pub const GESTUREVISUALIZATION_PRESSANDTAP: u32 = 4;
pub const GESTUREVISUALIZATION_PRESSANDHOLD: u32 = 8;
pub const GESTUREVISUALIZATION_RIGHTTAP: u32 = 16;
pub const SPI_GETMOUSEWHEELROUTING: u32 = 8220;
pub const SPI_SETMOUSEWHEELROUTING: u32 = 8221;
pub const MOUSEWHEEL_ROUTING_FOCUS: u32 = 0;
pub const MOUSEWHEEL_ROUTING_HYBRID: u32 = 1;
pub const MOUSEWHEEL_ROUTING_MOUSE_POS: u32 = 2;
pub const SPI_GETPENVISUALIZATION: u32 = 8222;
pub const SPI_SETPENVISUALIZATION: u32 = 8223;
pub const PENVISUALIZATION_ON: u32 = 35;
pub const PENVISUALIZATION_OFF: u32 = 0;
pub const PENVISUALIZATION_TAP: u32 = 1;
pub const PENVISUALIZATION_DOUBLETAP: u32 = 2;
pub const PENVISUALIZATION_CURSOR: u32 = 32;
pub const SPI_GETPENARBITRATIONTYPE: u32 = 8224;
pub const SPI_SETPENARBITRATIONTYPE: u32 = 8225;
pub const PENARBITRATIONTYPE_NONE: u32 = 0;
pub const PENARBITRATIONTYPE_WIN8: u32 = 1;
pub const PENARBITRATIONTYPE_FIS: u32 = 2;
pub const PENARBITRATIONTYPE_SPT: u32 = 3;
pub const PENARBITRATIONTYPE_MAX: u32 = 4;
pub const SPI_GETCARETTIMEOUT: u32 = 8226;
pub const SPI_SETCARETTIMEOUT: u32 = 8227;
pub const SPI_GETHANDEDNESS: u32 = 8228;
pub const SPI_SETHANDEDNESS: u32 = 8229;
pub const SPIF_UPDATEINIFILE: u32 = 1;
pub const SPIF_SENDWININICHANGE: u32 = 2;
pub const SPIF_SENDCHANGE: u32 = 2;
pub const METRICS_USEDEFAULT: i32 = -1;
pub const ARW_BOTTOMLEFT: u32 = 0;
pub const ARW_BOTTOMRIGHT: u32 = 1;
pub const ARW_TOPLEFT: u32 = 2;
pub const ARW_TOPRIGHT: u32 = 3;
pub const ARW_STARTMASK: u32 = 3;
pub const ARW_STARTRIGHT: u32 = 1;
pub const ARW_STARTTOP: u32 = 2;
pub const ARW_LEFT: u32 = 0;
pub const ARW_RIGHT: u32 = 0;
pub const ARW_UP: u32 = 4;
pub const ARW_DOWN: u32 = 4;
pub const ARW_HIDE: u32 = 8;
pub const SERKF_SERIALKEYSON: u32 = 1;
pub const SERKF_AVAILABLE: u32 = 2;
pub const SERKF_INDICATOR: u32 = 4;
pub const HCF_HIGHCONTRASTON: u32 = 1;
pub const HCF_AVAILABLE: u32 = 2;
pub const HCF_HOTKEYACTIVE: u32 = 4;
pub const HCF_CONFIRMHOTKEY: u32 = 8;
pub const HCF_HOTKEYSOUND: u32 = 16;
pub const HCF_INDICATOR: u32 = 32;
pub const HCF_HOTKEYAVAILABLE: u32 = 64;
pub const HCF_LOGONDESKTOP: u32 = 256;
pub const HCF_DEFAULTDESKTOP: u32 = 512;
pub const HCF_OPTION_NOTHEMECHANGE: u32 = 4096;
pub const CDS_UPDATEREGISTRY: u32 = 1;
pub const CDS_TEST: u32 = 2;
pub const CDS_FULLSCREEN: u32 = 4;
pub const CDS_GLOBAL: u32 = 8;
pub const CDS_SET_PRIMARY: u32 = 16;
pub const CDS_VIDEOPARAMETERS: u32 = 32;
pub const CDS_ENABLE_UNSAFE_MODES: u32 = 256;
pub const CDS_DISABLE_UNSAFE_MODES: u32 = 512;
pub const CDS_RESET: u32 = 1073741824;
pub const CDS_RESET_EX: u32 = 536870912;
pub const CDS_NORESET: u32 = 268435456;
pub const VP_COMMAND_GET: u32 = 1;
pub const VP_COMMAND_SET: u32 = 2;
pub const VP_FLAGS_TV_MODE: u32 = 1;
pub const VP_FLAGS_TV_STANDARD: u32 = 2;
pub const VP_FLAGS_FLICKER: u32 = 4;
pub const VP_FLAGS_OVERSCAN: u32 = 8;
pub const VP_FLAGS_MAX_UNSCALED: u32 = 16;
pub const VP_FLAGS_POSITION: u32 = 32;
pub const VP_FLAGS_BRIGHTNESS: u32 = 64;
pub const VP_FLAGS_CONTRAST: u32 = 128;
pub const VP_FLAGS_COPYPROTECT: u32 = 256;
pub const VP_MODE_WIN_GRAPHICS: u32 = 1;
pub const VP_MODE_TV_PLAYBACK: u32 = 2;
pub const VP_TV_STANDARD_NTSC_M: u32 = 1;
pub const VP_TV_STANDARD_NTSC_M_J: u32 = 2;
pub const VP_TV_STANDARD_PAL_B: u32 = 4;
pub const VP_TV_STANDARD_PAL_D: u32 = 8;
pub const VP_TV_STANDARD_PAL_H: u32 = 16;
pub const VP_TV_STANDARD_PAL_I: u32 = 32;
pub const VP_TV_STANDARD_PAL_M: u32 = 64;
pub const VP_TV_STANDARD_PAL_N: u32 = 128;
pub const VP_TV_STANDARD_SECAM_B: u32 = 256;
pub const VP_TV_STANDARD_SECAM_D: u32 = 512;
pub const VP_TV_STANDARD_SECAM_G: u32 = 1024;
pub const VP_TV_STANDARD_SECAM_H: u32 = 2048;
pub const VP_TV_STANDARD_SECAM_K: u32 = 4096;
pub const VP_TV_STANDARD_SECAM_K1: u32 = 8192;
pub const VP_TV_STANDARD_SECAM_L: u32 = 16384;
pub const VP_TV_STANDARD_WIN_VGA: u32 = 32768;
pub const VP_TV_STANDARD_NTSC_433: u32 = 65536;
pub const VP_TV_STANDARD_PAL_G: u32 = 131072;
pub const VP_TV_STANDARD_PAL_60: u32 = 262144;
pub const VP_TV_STANDARD_SECAM_L1: u32 = 524288;
pub const VP_CP_TYPE_APS_TRIGGER: u32 = 1;
pub const VP_CP_TYPE_MACROVISION: u32 = 2;
pub const VP_CP_CMD_ACTIVATE: u32 = 1;
pub const VP_CP_CMD_DEACTIVATE: u32 = 2;
pub const VP_CP_CMD_CHANGE: u32 = 4;
pub const DISP_CHANGE_SUCCESSFUL: u32 = 0;
pub const DISP_CHANGE_RESTART: u32 = 1;
pub const DISP_CHANGE_FAILED: i32 = -1;
pub const DISP_CHANGE_BADMODE: i32 = -2;
pub const DISP_CHANGE_NOTUPDATED: i32 = -3;
pub const DISP_CHANGE_BADFLAGS: i32 = -4;
pub const DISP_CHANGE_BADPARAM: i32 = -5;
pub const DISP_CHANGE_BADDUALVIEW: i32 = -6;
pub const EDS_RAWMODE: u32 = 2;
pub const EDS_ROTATEDMODE: u32 = 4;
pub const EDD_GET_DEVICE_INTERFACE_NAME: u32 = 1;
pub const FKF_FILTERKEYSON: u32 = 1;
pub const FKF_AVAILABLE: u32 = 2;
pub const FKF_HOTKEYACTIVE: u32 = 4;
pub const FKF_CONFIRMHOTKEY: u32 = 8;
pub const FKF_HOTKEYSOUND: u32 = 16;
pub const FKF_INDICATOR: u32 = 32;
pub const FKF_CLICKON: u32 = 64;
pub const SKF_STICKYKEYSON: u32 = 1;
pub const SKF_AVAILABLE: u32 = 2;
pub const SKF_HOTKEYACTIVE: u32 = 4;
pub const SKF_CONFIRMHOTKEY: u32 = 8;
pub const SKF_HOTKEYSOUND: u32 = 16;
pub const SKF_INDICATOR: u32 = 32;
pub const SKF_AUDIBLEFEEDBACK: u32 = 64;
pub const SKF_TRISTATE: u32 = 128;
pub const SKF_TWOKEYSOFF: u32 = 256;
pub const SKF_LALTLATCHED: u32 = 268435456;
pub const SKF_LCTLLATCHED: u32 = 67108864;
pub const SKF_LSHIFTLATCHED: u32 = 16777216;
pub const SKF_RALTLATCHED: u32 = 536870912;
pub const SKF_RCTLLATCHED: u32 = 134217728;
pub const SKF_RSHIFTLATCHED: u32 = 33554432;
pub const SKF_LWINLATCHED: u32 = 1073741824;
pub const SKF_RWINLATCHED: u32 = 2147483648;
pub const SKF_LALTLOCKED: u32 = 1048576;
pub const SKF_LCTLLOCKED: u32 = 262144;
pub const SKF_LSHIFTLOCKED: u32 = 65536;
pub const SKF_RALTLOCKED: u32 = 2097152;
pub const SKF_RCTLLOCKED: u32 = 524288;
pub const SKF_RSHIFTLOCKED: u32 = 131072;
pub const SKF_LWINLOCKED: u32 = 4194304;
pub const SKF_RWINLOCKED: u32 = 8388608;
pub const MKF_MOUSEKEYSON: u32 = 1;
pub const MKF_AVAILABLE: u32 = 2;
pub const MKF_HOTKEYACTIVE: u32 = 4;
pub const MKF_CONFIRMHOTKEY: u32 = 8;
pub const MKF_HOTKEYSOUND: u32 = 16;
pub const MKF_INDICATOR: u32 = 32;
pub const MKF_MODIFIERS: u32 = 64;
pub const MKF_REPLACENUMBERS: u32 = 128;
pub const MKF_LEFTBUTTONSEL: u32 = 268435456;
pub const MKF_RIGHTBUTTONSEL: u32 = 536870912;
pub const MKF_LEFTBUTTONDOWN: u32 = 16777216;
pub const MKF_RIGHTBUTTONDOWN: u32 = 33554432;
pub const MKF_MOUSEMODE: u32 = 2147483648;
pub const ATF_TIMEOUTON: u32 = 1;
pub const ATF_ONOFFFEEDBACK: u32 = 2;
pub const SSGF_NONE: u32 = 0;
pub const SSGF_DISPLAY: u32 = 3;
pub const SSTF_NONE: u32 = 0;
pub const SSTF_CHARS: u32 = 1;
pub const SSTF_BORDER: u32 = 2;
pub const SSTF_DISPLAY: u32 = 3;
pub const SSWF_NONE: u32 = 0;
pub const SSWF_TITLE: u32 = 1;
pub const SSWF_WINDOW: u32 = 2;
pub const SSWF_DISPLAY: u32 = 3;
pub const SSWF_CUSTOM: u32 = 4;
pub const SSF_SOUNDSENTRYON: u32 = 1;
pub const SSF_AVAILABLE: u32 = 2;
pub const SSF_INDICATOR: u32 = 4;
pub const TKF_TOGGLEKEYSON: u32 = 1;
pub const TKF_AVAILABLE: u32 = 2;
pub const TKF_HOTKEYACTIVE: u32 = 4;
pub const TKF_CONFIRMHOTKEY: u32 = 8;
pub const TKF_HOTKEYSOUND: u32 = 16;
pub const TKF_INDICATOR: u32 = 32;
pub const SLE_ERROR: u32 = 1;
pub const SLE_MINORERROR: u32 = 2;
pub const SLE_WARNING: u32 = 3;
pub const MONITOR_DEFAULTTONULL: u32 = 0;
pub const MONITOR_DEFAULTTOPRIMARY: u32 = 1;
pub const MONITOR_DEFAULTTONEAREST: u32 = 2;
pub const MONITORINFOF_PRIMARY: u32 = 1;
pub const WINEVENT_OUTOFCONTEXT: u32 = 0;
pub const WINEVENT_SKIPOWNTHREAD: u32 = 1;
pub const WINEVENT_SKIPOWNPROCESS: u32 = 2;
pub const WINEVENT_INCONTEXT: u32 = 4;
pub const CHILDID_SELF: u32 = 0;
pub const INDEXID_OBJECT: u32 = 0;
pub const INDEXID_CONTAINER: u32 = 0;
pub const EVENT_MIN: u32 = 1;
pub const EVENT_MAX: u32 = 2147483647;
pub const EVENT_SYSTEM_SOUND: u32 = 1;
pub const EVENT_SYSTEM_ALERT: u32 = 2;
pub const EVENT_SYSTEM_FOREGROUND: u32 = 3;
pub const EVENT_SYSTEM_MENUSTART: u32 = 4;
pub const EVENT_SYSTEM_MENUEND: u32 = 5;
pub const EVENT_SYSTEM_MENUPOPUPSTART: u32 = 6;
pub const EVENT_SYSTEM_MENUPOPUPEND: u32 = 7;
pub const EVENT_SYSTEM_CAPTURESTART: u32 = 8;
pub const EVENT_SYSTEM_CAPTUREEND: u32 = 9;
pub const EVENT_SYSTEM_MOVESIZESTART: u32 = 10;
pub const EVENT_SYSTEM_MOVESIZEEND: u32 = 11;
pub const EVENT_SYSTEM_CONTEXTHELPSTART: u32 = 12;
pub const EVENT_SYSTEM_CONTEXTHELPEND: u32 = 13;
pub const EVENT_SYSTEM_DRAGDROPSTART: u32 = 14;
pub const EVENT_SYSTEM_DRAGDROPEND: u32 = 15;
pub const EVENT_SYSTEM_DIALOGSTART: u32 = 16;
pub const EVENT_SYSTEM_DIALOGEND: u32 = 17;
pub const EVENT_SYSTEM_SCROLLINGSTART: u32 = 18;
pub const EVENT_SYSTEM_SCROLLINGEND: u32 = 19;
pub const EVENT_SYSTEM_SWITCHSTART: u32 = 20;
pub const EVENT_SYSTEM_SWITCHEND: u32 = 21;
pub const EVENT_SYSTEM_MINIMIZESTART: u32 = 22;
pub const EVENT_SYSTEM_MINIMIZEEND: u32 = 23;
pub const EVENT_SYSTEM_DESKTOPSWITCH: u32 = 32;
pub const EVENT_SYSTEM_SWITCHER_APPGRABBED: u32 = 36;
pub const EVENT_SYSTEM_SWITCHER_APPOVERTARGET: u32 = 37;
pub const EVENT_SYSTEM_SWITCHER_APPDROPPED: u32 = 38;
pub const EVENT_SYSTEM_SWITCHER_CANCELLED: u32 = 39;
pub const EVENT_SYSTEM_IME_KEY_NOTIFICATION: u32 = 41;
pub const EVENT_SYSTEM_END: u32 = 255;
pub const EVENT_OEM_DEFINED_START: u32 = 257;
pub const EVENT_OEM_DEFINED_END: u32 = 511;
pub const EVENT_UIA_EVENTID_START: u32 = 19968;
pub const EVENT_UIA_EVENTID_END: u32 = 20223;
pub const EVENT_UIA_PROPID_START: u32 = 29952;
pub const EVENT_UIA_PROPID_END: u32 = 30207;
pub const EVENT_CONSOLE_CARET: u32 = 16385;
pub const EVENT_CONSOLE_UPDATE_REGION: u32 = 16386;
pub const EVENT_CONSOLE_UPDATE_SIMPLE: u32 = 16387;
pub const EVENT_CONSOLE_UPDATE_SCROLL: u32 = 16388;
pub const EVENT_CONSOLE_LAYOUT: u32 = 16389;
pub const EVENT_CONSOLE_START_APPLICATION: u32 = 16390;
pub const EVENT_CONSOLE_END_APPLICATION: u32 = 16391;
pub const CONSOLE_APPLICATION_16BIT: u32 = 0;
pub const CONSOLE_CARET_SELECTION: u32 = 1;
pub const CONSOLE_CARET_VISIBLE: u32 = 2;
pub const EVENT_CONSOLE_END: u32 = 16639;
pub const EVENT_OBJECT_CREATE: u32 = 32768;
pub const EVENT_OBJECT_DESTROY: u32 = 32769;
pub const EVENT_OBJECT_SHOW: u32 = 32770;
pub const EVENT_OBJECT_HIDE: u32 = 32771;
pub const EVENT_OBJECT_REORDER: u32 = 32772;
pub const EVENT_OBJECT_FOCUS: u32 = 32773;
pub const EVENT_OBJECT_SELECTION: u32 = 32774;
pub const EVENT_OBJECT_SELECTIONADD: u32 = 32775;
pub const EVENT_OBJECT_SELECTIONREMOVE: u32 = 32776;
pub const EVENT_OBJECT_SELECTIONWITHIN: u32 = 32777;
pub const EVENT_OBJECT_STATECHANGE: u32 = 32778;
pub const EVENT_OBJECT_LOCATIONCHANGE: u32 = 32779;
pub const EVENT_OBJECT_NAMECHANGE: u32 = 32780;
pub const EVENT_OBJECT_DESCRIPTIONCHANGE: u32 = 32781;
pub const EVENT_OBJECT_VALUECHANGE: u32 = 32782;
pub const EVENT_OBJECT_PARENTCHANGE: u32 = 32783;
pub const EVENT_OBJECT_HELPCHANGE: u32 = 32784;
pub const EVENT_OBJECT_DEFACTIONCHANGE: u32 = 32785;
pub const EVENT_OBJECT_ACCELERATORCHANGE: u32 = 32786;
pub const EVENT_OBJECT_INVOKED: u32 = 32787;
pub const EVENT_OBJECT_TEXTSELECTIONCHANGED: u32 = 32788;
pub const EVENT_OBJECT_CONTENTSCROLLED: u32 = 32789;
pub const EVENT_SYSTEM_ARRANGMENTPREVIEW: u32 = 32790;
pub const EVENT_OBJECT_CLOAKED: u32 = 32791;
pub const EVENT_OBJECT_UNCLOAKED: u32 = 32792;
pub const EVENT_OBJECT_LIVEREGIONCHANGED: u32 = 32793;
pub const EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED: u32 = 32800;
pub const EVENT_OBJECT_DRAGSTART: u32 = 32801;
pub const EVENT_OBJECT_DRAGCANCEL: u32 = 32802;
pub const EVENT_OBJECT_DRAGCOMPLETE: u32 = 32803;
pub const EVENT_OBJECT_DRAGENTER: u32 = 32804;
pub const EVENT_OBJECT_DRAGLEAVE: u32 = 32805;
pub const EVENT_OBJECT_DRAGDROPPED: u32 = 32806;
pub const EVENT_OBJECT_IME_SHOW: u32 = 32807;
pub const EVENT_OBJECT_IME_HIDE: u32 = 32808;
pub const EVENT_OBJECT_IME_CHANGE: u32 = 32809;
pub const EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED: u32 = 32816;
pub const EVENT_OBJECT_END: u32 = 33023;
pub const EVENT_AIA_START: u32 = 40960;
pub const EVENT_AIA_END: u32 = 45055;
pub const SOUND_SYSTEM_STARTUP: u32 = 1;
pub const SOUND_SYSTEM_SHUTDOWN: u32 = 2;
pub const SOUND_SYSTEM_BEEP: u32 = 3;
pub const SOUND_SYSTEM_ERROR: u32 = 4;
pub const SOUND_SYSTEM_QUESTION: u32 = 5;
pub const SOUND_SYSTEM_WARNING: u32 = 6;
pub const SOUND_SYSTEM_INFORMATION: u32 = 7;
pub const SOUND_SYSTEM_MAXIMIZE: u32 = 8;
pub const SOUND_SYSTEM_MINIMIZE: u32 = 9;
pub const SOUND_SYSTEM_RESTOREUP: u32 = 10;
pub const SOUND_SYSTEM_RESTOREDOWN: u32 = 11;
pub const SOUND_SYSTEM_APPSTART: u32 = 12;
pub const SOUND_SYSTEM_FAULT: u32 = 13;
pub const SOUND_SYSTEM_APPEND: u32 = 14;
pub const SOUND_SYSTEM_MENUCOMMAND: u32 = 15;
pub const SOUND_SYSTEM_MENUPOPUP: u32 = 16;
pub const CSOUND_SYSTEM: u32 = 16;
pub const ALERT_SYSTEM_INFORMATIONAL: u32 = 1;
pub const ALERT_SYSTEM_WARNING: u32 = 2;
pub const ALERT_SYSTEM_ERROR: u32 = 3;
pub const ALERT_SYSTEM_QUERY: u32 = 4;
pub const ALERT_SYSTEM_CRITICAL: u32 = 5;
pub const CALERT_SYSTEM: u32 = 6;
pub const GUI_CARETBLINKING: u32 = 1;
pub const GUI_INMOVESIZE: u32 = 2;
pub const GUI_INMENUMODE: u32 = 4;
pub const GUI_SYSTEMMENUMODE: u32 = 8;
pub const GUI_POPUPMENUMODE: u32 = 16;
pub const GUI_16BITTASK: u32 = 0;
pub const USER_DEFAULT_SCREEN_DPI: u32 = 96;
pub const STATE_SYSTEM_UNAVAILABLE: u32 = 1;
pub const STATE_SYSTEM_SELECTED: u32 = 2;
pub const STATE_SYSTEM_FOCUSED: u32 = 4;
pub const STATE_SYSTEM_PRESSED: u32 = 8;
pub const STATE_SYSTEM_CHECKED: u32 = 16;
pub const STATE_SYSTEM_MIXED: u32 = 32;
pub const STATE_SYSTEM_INDETERMINATE: u32 = 32;
pub const STATE_SYSTEM_READONLY: u32 = 64;
pub const STATE_SYSTEM_HOTTRACKED: u32 = 128;
pub const STATE_SYSTEM_DEFAULT: u32 = 256;
pub const STATE_SYSTEM_EXPANDED: u32 = 512;
pub const STATE_SYSTEM_COLLAPSED: u32 = 1024;
pub const STATE_SYSTEM_BUSY: u32 = 2048;
pub const STATE_SYSTEM_FLOATING: u32 = 4096;
pub const STATE_SYSTEM_MARQUEED: u32 = 8192;
pub const STATE_SYSTEM_ANIMATED: u32 = 16384;
pub const STATE_SYSTEM_INVISIBLE: u32 = 32768;
pub const STATE_SYSTEM_OFFSCREEN: u32 = 65536;
pub const STATE_SYSTEM_SIZEABLE: u32 = 131072;
pub const STATE_SYSTEM_MOVEABLE: u32 = 262144;
pub const STATE_SYSTEM_SELFVOICING: u32 = 524288;
pub const STATE_SYSTEM_FOCUSABLE: u32 = 1048576;
pub const STATE_SYSTEM_SELECTABLE: u32 = 2097152;
pub const STATE_SYSTEM_LINKED: u32 = 4194304;
pub const STATE_SYSTEM_TRAVERSED: u32 = 8388608;
pub const STATE_SYSTEM_MULTISELECTABLE: u32 = 16777216;
pub const STATE_SYSTEM_EXTSELECTABLE: u32 = 33554432;
pub const STATE_SYSTEM_ALERT_LOW: u32 = 67108864;
pub const STATE_SYSTEM_ALERT_MEDIUM: u32 = 134217728;
pub const STATE_SYSTEM_ALERT_HIGH: u32 = 268435456;
pub const STATE_SYSTEM_PROTECTED: u32 = 536870912;
pub const STATE_SYSTEM_VALID: u32 = 1073741823;
pub const CCHILDREN_TITLEBAR: u32 = 5;
pub const CCHILDREN_SCROLLBAR: u32 = 5;
pub const CURSOR_SHOWING: u32 = 1;
pub const CURSOR_SUPPRESSED: u32 = 2;
pub const WS_ACTIVECAPTION: u32 = 1;
pub const GA_PARENT: u32 = 1;
pub const GA_ROOT: u32 = 2;
pub const GA_ROOTOWNER: u32 = 3;
pub const RIM_INPUT: u32 = 0;
pub const RIM_INPUTSINK: u32 = 1;
pub const RIM_TYPEMOUSE: u32 = 0;
pub const RIM_TYPEKEYBOARD: u32 = 1;
pub const RIM_TYPEHID: u32 = 2;
pub const RIM_TYPEMAX: u32 = 2;
pub const RI_MOUSE_LEFT_BUTTON_DOWN: u32 = 1;
pub const RI_MOUSE_LEFT_BUTTON_UP: u32 = 2;
pub const RI_MOUSE_RIGHT_BUTTON_DOWN: u32 = 4;
pub const RI_MOUSE_RIGHT_BUTTON_UP: u32 = 8;
pub const RI_MOUSE_MIDDLE_BUTTON_DOWN: u32 = 16;
pub const RI_MOUSE_MIDDLE_BUTTON_UP: u32 = 32;
pub const RI_MOUSE_BUTTON_1_DOWN: u32 = 1;
pub const RI_MOUSE_BUTTON_1_UP: u32 = 2;
pub const RI_MOUSE_BUTTON_2_DOWN: u32 = 4;
pub const RI_MOUSE_BUTTON_2_UP: u32 = 8;
pub const RI_MOUSE_BUTTON_3_DOWN: u32 = 16;
pub const RI_MOUSE_BUTTON_3_UP: u32 = 32;
pub const RI_MOUSE_BUTTON_4_DOWN: u32 = 64;
pub const RI_MOUSE_BUTTON_4_UP: u32 = 128;
pub const RI_MOUSE_BUTTON_5_DOWN: u32 = 256;
pub const RI_MOUSE_BUTTON_5_UP: u32 = 512;
pub const RI_MOUSE_WHEEL: u32 = 1024;
pub const RI_MOUSE_HWHEEL: u32 = 2048;
pub const MOUSE_MOVE_RELATIVE: u32 = 0;
pub const MOUSE_MOVE_ABSOLUTE: u32 = 1;
pub const MOUSE_VIRTUAL_DESKTOP: u32 = 2;
pub const MOUSE_ATTRIBUTES_CHANGED: u32 = 4;
pub const MOUSE_MOVE_NOCOALESCE: u32 = 8;
pub const KEYBOARD_OVERRUN_MAKE_CODE: u32 = 255;
pub const RI_KEY_MAKE: u32 = 0;
pub const RI_KEY_BREAK: u32 = 1;
pub const RI_KEY_E0: u32 = 2;
pub const RI_KEY_E1: u32 = 4;
pub const RI_KEY_TERMSRV_SET_LED: u32 = 8;
pub const RI_KEY_TERMSRV_SHADOW: u32 = 16;
pub const RID_INPUT: u32 = 268435459;
pub const RID_HEADER: u32 = 268435461;
pub const RIDI_PREPARSEDDATA: u32 = 536870917;
pub const RIDI_DEVICENAME: u32 = 536870919;
pub const RIDI_DEVICEINFO: u32 = 536870923;
pub const RIDEV_REMOVE: u32 = 1;
pub const RIDEV_EXCLUDE: u32 = 16;
pub const RIDEV_PAGEONLY: u32 = 32;
pub const RIDEV_NOLEGACY: u32 = 48;
pub const RIDEV_INPUTSINK: u32 = 256;
pub const RIDEV_CAPTUREMOUSE: u32 = 512;
pub const RIDEV_NOHOTKEYS: u32 = 512;
pub const RIDEV_APPKEYS: u32 = 1024;
pub const RIDEV_EXINPUTSINK: u32 = 4096;
pub const RIDEV_DEVNOTIFY: u32 = 8192;
pub const RIDEV_EXMODEMASK: u32 = 240;
pub const GIDC_ARRIVAL: u32 = 1;
pub const GIDC_REMOVAL: u32 = 2;
pub const POINTER_DEVICE_PRODUCT_STRING_MAX: u32 = 520;
pub const PDC_ARRIVAL: u32 = 1;
pub const PDC_REMOVAL: u32 = 2;
pub const PDC_ORIENTATION_0: u32 = 4;
pub const PDC_ORIENTATION_90: u32 = 8;
pub const PDC_ORIENTATION_180: u32 = 16;
pub const PDC_ORIENTATION_270: u32 = 32;
pub const PDC_MODE_DEFAULT: u32 = 64;
pub const PDC_MODE_CENTERED: u32 = 128;
pub const PDC_MAPPING_CHANGE: u32 = 256;
pub const PDC_RESOLUTION: u32 = 512;
pub const PDC_ORIGIN: u32 = 1024;
pub const PDC_MODE_ASPECTRATIOPRESERVED: u32 = 2048;
pub const MSGFLT_ADD: u32 = 1;
pub const MSGFLT_REMOVE: u32 = 2;
pub const MSGFLTINFO_NONE: u32 = 0;
pub const MSGFLTINFO_ALREADYALLOWED_FORWND: u32 = 1;
pub const MSGFLTINFO_ALREADYDISALLOWED_FORWND: u32 = 2;
pub const MSGFLTINFO_ALLOWED_HIGHER: u32 = 3;
pub const MSGFLT_RESET: u32 = 0;
pub const MSGFLT_ALLOW: u32 = 1;
pub const MSGFLT_DISALLOW: u32 = 2;
pub const GF_BEGIN: u32 = 1;
pub const GF_INERTIA: u32 = 2;
pub const GF_END: u32 = 4;
pub const GID_BEGIN: u32 = 1;
pub const GID_END: u32 = 2;
pub const GID_ZOOM: u32 = 3;
pub const GID_PAN: u32 = 4;
pub const GID_ROTATE: u32 = 5;
pub const GID_TWOFINGERTAP: u32 = 6;
pub const GID_PRESSANDTAP: u32 = 7;
pub const GID_ROLLOVER: u32 = 7;
pub const GC_ALLGESTURES: u32 = 1;
pub const GC_ZOOM: u32 = 1;
pub const GC_PAN: u32 = 1;
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY: u32 = 2;
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY: u32 = 4;
pub const GC_PAN_WITH_GUTTER: u32 = 8;
pub const GC_PAN_WITH_INERTIA: u32 = 16;
pub const GC_ROTATE: u32 = 1;
pub const GC_TWOFINGERTAP: u32 = 1;
pub const GC_PRESSANDTAP: u32 = 1;
pub const GC_ROLLOVER: u32 = 1;
pub const GESTURECONFIGMAXCOUNT: u32 = 256;
pub const GCF_INCLUDE_ANCESTORS: u32 = 1;
pub const NID_INTEGRATED_TOUCH: u32 = 1;
pub const NID_EXTERNAL_TOUCH: u32 = 2;
pub const NID_INTEGRATED_PEN: u32 = 4;
pub const NID_EXTERNAL_PEN: u32 = 8;
pub const NID_MULTI_INPUT: u32 = 64;
pub const NID_READY: u32 = 128;
pub const MAX_STR_BLOCKREASON: u32 = 256;
pub const WM_TOOLTIPDISMISS: u32 = 837;
pub const MAX_LEADBYTES: u32 = 12;
pub const MAX_DEFAULTCHAR: u32 = 2;
pub const HIGH_SURROGATE_START: u32 = 55296;
pub const HIGH_SURROGATE_END: u32 = 56319;
pub const LOW_SURROGATE_START: u32 = 56320;
pub const LOW_SURROGATE_END: u32 = 57343;
pub const MB_PRECOMPOSED: u32 = 1;
pub const MB_COMPOSITE: u32 = 2;
pub const MB_USEGLYPHCHARS: u32 = 4;
pub const MB_ERR_INVALID_CHARS: u32 = 8;
pub const WC_COMPOSITECHECK: u32 = 512;
pub const WC_DISCARDNS: u32 = 16;
pub const WC_SEPCHARS: u32 = 32;
pub const WC_DEFAULTCHAR: u32 = 64;
pub const WC_ERR_INVALID_CHARS: u32 = 128;
pub const WC_NO_BEST_FIT_CHARS: u32 = 1024;
pub const CT_CTYPE1: u32 = 1;
pub const CT_CTYPE2: u32 = 2;
pub const CT_CTYPE3: u32 = 4;
pub const C1_UPPER: u32 = 1;
pub const C1_LOWER: u32 = 2;
pub const C1_DIGIT: u32 = 4;
pub const C1_SPACE: u32 = 8;
pub const C1_PUNCT: u32 = 16;
pub const C1_CNTRL: u32 = 32;
pub const C1_BLANK: u32 = 64;
pub const C1_XDIGIT: u32 = 128;
pub const C1_ALPHA: u32 = 256;
pub const C1_DEFINED: u32 = 512;
pub const C2_LEFTTORIGHT: u32 = 1;
pub const C2_RIGHTTOLEFT: u32 = 2;
pub const C2_EUROPENUMBER: u32 = 3;
pub const C2_EUROPESEPARATOR: u32 = 4;
pub const C2_EUROPETERMINATOR: u32 = 5;
pub const C2_ARABICNUMBER: u32 = 6;
pub const C2_COMMONSEPARATOR: u32 = 7;
pub const C2_BLOCKSEPARATOR: u32 = 8;
pub const C2_SEGMENTSEPARATOR: u32 = 9;
pub const C2_WHITESPACE: u32 = 10;
pub const C2_OTHERNEUTRAL: u32 = 11;
pub const C2_NOTAPPLICABLE: u32 = 0;
pub const C3_NONSPACING: u32 = 1;
pub const C3_DIACRITIC: u32 = 2;
pub const C3_VOWELMARK: u32 = 4;
pub const C3_SYMBOL: u32 = 8;
pub const C3_KATAKANA: u32 = 16;
pub const C3_HIRAGANA: u32 = 32;
pub const C3_HALFWIDTH: u32 = 64;
pub const C3_FULLWIDTH: u32 = 128;
pub const C3_IDEOGRAPH: u32 = 256;
pub const C3_KASHIDA: u32 = 512;
pub const C3_LEXICAL: u32 = 1024;
pub const C3_HIGHSURROGATE: u32 = 2048;
pub const C3_LOWSURROGATE: u32 = 4096;
pub const C3_ALPHA: u32 = 32768;
pub const C3_NOTAPPLICABLE: u32 = 0;
pub const NORM_IGNORECASE: u32 = 1;
pub const NORM_IGNORENONSPACE: u32 = 2;
pub const NORM_IGNORESYMBOLS: u32 = 4;
pub const LINGUISTIC_IGNORECASE: u32 = 16;
pub const LINGUISTIC_IGNOREDIACRITIC: u32 = 32;
pub const NORM_IGNOREKANATYPE: u32 = 65536;
pub const NORM_IGNOREWIDTH: u32 = 131072;
pub const NORM_LINGUISTIC_CASING: u32 = 134217728;
pub const MAP_FOLDCZONE: u32 = 16;
pub const MAP_PRECOMPOSED: u32 = 32;
pub const MAP_COMPOSITE: u32 = 64;
pub const MAP_FOLDDIGITS: u32 = 128;
pub const MAP_EXPAND_LIGATURES: u32 = 8192;
pub const LCMAP_LOWERCASE: u32 = 256;
pub const LCMAP_UPPERCASE: u32 = 512;
pub const LCMAP_TITLECASE: u32 = 768;
pub const LCMAP_SORTKEY: u32 = 1024;
pub const LCMAP_BYTEREV: u32 = 2048;
pub const LCMAP_HIRAGANA: u32 = 1048576;
pub const LCMAP_KATAKANA: u32 = 2097152;
pub const LCMAP_HALFWIDTH: u32 = 4194304;
pub const LCMAP_FULLWIDTH: u32 = 8388608;
pub const LCMAP_LINGUISTIC_CASING: u32 = 16777216;
pub const LCMAP_SIMPLIFIED_CHINESE: u32 = 33554432;
pub const LCMAP_TRADITIONAL_CHINESE: u32 = 67108864;
pub const LCMAP_SORTHANDLE: u32 = 536870912;
pub const LCMAP_HASH: u32 = 262144;
pub const FIND_STARTSWITH: u32 = 1048576;
pub const FIND_ENDSWITH: u32 = 2097152;
pub const FIND_FROMSTART: u32 = 4194304;
pub const FIND_FROMEND: u32 = 8388608;
pub const LGRPID_INSTALLED: u32 = 1;
pub const LGRPID_SUPPORTED: u32 = 2;
pub const LCID_INSTALLED: u32 = 1;
pub const LCID_SUPPORTED: u32 = 2;
pub const LCID_ALTERNATE_SORTS: u32 = 4;
pub const LOCALE_ALL: u32 = 0;
pub const LOCALE_WINDOWS: u32 = 1;
pub const LOCALE_SUPPLEMENTAL: u32 = 2;
pub const LOCALE_ALTERNATE_SORTS: u32 = 4;
pub const LOCALE_REPLACEMENT: u32 = 8;
pub const LOCALE_NEUTRALDATA: u32 = 16;
pub const LOCALE_SPECIFICDATA: u32 = 32;
pub const CP_INSTALLED: u32 = 1;
pub const CP_SUPPORTED: u32 = 2;
pub const SORT_STRINGSORT: u32 = 4096;
pub const SORT_DIGITSASNUMBERS: u32 = 8;
pub const CSTR_LESS_THAN: u32 = 1;
pub const CSTR_EQUAL: u32 = 2;
pub const CSTR_GREATER_THAN: u32 = 3;
pub const CP_ACP: u32 = 0;
pub const CP_OEMCP: u32 = 1;
pub const CP_MACCP: u32 = 2;
pub const CP_THREAD_ACP: u32 = 3;
pub const CP_SYMBOL: u32 = 42;
pub const CP_UTF7: u32 = 65000;
pub const CP_UTF8: u32 = 65001;
pub const CTRY_DEFAULT: u32 = 0;
pub const CTRY_ALBANIA: u32 = 355;
pub const CTRY_ALGERIA: u32 = 213;
pub const CTRY_ARGENTINA: u32 = 54;
pub const CTRY_ARMENIA: u32 = 374;
pub const CTRY_AUSTRALIA: u32 = 61;
pub const CTRY_AUSTRIA: u32 = 43;
pub const CTRY_AZERBAIJAN: u32 = 994;
pub const CTRY_BAHRAIN: u32 = 973;
pub const CTRY_BELARUS: u32 = 375;
pub const CTRY_BELGIUM: u32 = 32;
pub const CTRY_BELIZE: u32 = 501;
pub const CTRY_BOLIVIA: u32 = 591;
pub const CTRY_BRAZIL: u32 = 55;
pub const CTRY_BRUNEI_DARUSSALAM: u32 = 673;
pub const CTRY_BULGARIA: u32 = 359;
pub const CTRY_CANADA: u32 = 2;
pub const CTRY_CARIBBEAN: u32 = 1;
pub const CTRY_CHILE: u32 = 56;
pub const CTRY_COLOMBIA: u32 = 57;
pub const CTRY_COSTA_RICA: u32 = 506;
pub const CTRY_CROATIA: u32 = 385;
pub const CTRY_CZECH: u32 = 420;
pub const CTRY_DENMARK: u32 = 45;
pub const CTRY_DOMINICAN_REPUBLIC: u32 = 1;
pub const CTRY_ECUADOR: u32 = 593;
pub const CTRY_EGYPT: u32 = 20;
pub const CTRY_EL_SALVADOR: u32 = 503;
pub const CTRY_ESTONIA: u32 = 372;
pub const CTRY_FAEROE_ISLANDS: u32 = 298;
pub const CTRY_FINLAND: u32 = 358;
pub const CTRY_FRANCE: u32 = 33;
pub const CTRY_GEORGIA: u32 = 995;
pub const CTRY_GERMANY: u32 = 49;
pub const CTRY_GREECE: u32 = 30;
pub const CTRY_GUATEMALA: u32 = 502;
pub const CTRY_HONDURAS: u32 = 504;
pub const CTRY_HONG_KONG: u32 = 852;
pub const CTRY_HUNGARY: u32 = 36;
pub const CTRY_ICELAND: u32 = 354;
pub const CTRY_INDIA: u32 = 91;
pub const CTRY_INDONESIA: u32 = 62;
pub const CTRY_IRAN: u32 = 981;
pub const CTRY_IRAQ: u32 = 964;
pub const CTRY_IRELAND: u32 = 353;
pub const CTRY_ISRAEL: u32 = 972;
pub const CTRY_ITALY: u32 = 39;
pub const CTRY_JAMAICA: u32 = 1;
pub const CTRY_JAPAN: u32 = 81;
pub const CTRY_JORDAN: u32 = 962;
pub const CTRY_KAZAKSTAN: u32 = 7;
pub const CTRY_KENYA: u32 = 254;
pub const CTRY_KUWAIT: u32 = 965;
pub const CTRY_KYRGYZSTAN: u32 = 996;
pub const CTRY_LATVIA: u32 = 371;
pub const CTRY_LEBANON: u32 = 961;
pub const CTRY_LIBYA: u32 = 218;
pub const CTRY_LIECHTENSTEIN: u32 = 41;
pub const CTRY_LITHUANIA: u32 = 370;
pub const CTRY_LUXEMBOURG: u32 = 352;
pub const CTRY_MACAU: u32 = 853;
pub const CTRY_MACEDONIA: u32 = 389;
pub const CTRY_MALAYSIA: u32 = 60;
pub const CTRY_MALDIVES: u32 = 960;
pub const CTRY_MEXICO: u32 = 52;
pub const CTRY_MONACO: u32 = 33;
pub const CTRY_MONGOLIA: u32 = 976;
pub const CTRY_MOROCCO: u32 = 212;
pub const CTRY_NETHERLANDS: u32 = 31;
pub const CTRY_NEW_ZEALAND: u32 = 64;
pub const CTRY_NICARAGUA: u32 = 505;
pub const CTRY_NORWAY: u32 = 47;
pub const CTRY_OMAN: u32 = 968;
pub const CTRY_PAKISTAN: u32 = 92;
pub const CTRY_PANAMA: u32 = 507;
pub const CTRY_PARAGUAY: u32 = 595;
pub const CTRY_PERU: u32 = 51;
pub const CTRY_PHILIPPINES: u32 = 63;
pub const CTRY_POLAND: u32 = 48;
pub const CTRY_PORTUGAL: u32 = 351;
pub const CTRY_PRCHINA: u32 = 86;
pub const CTRY_PUERTO_RICO: u32 = 1;
pub const CTRY_QATAR: u32 = 974;
pub const CTRY_ROMANIA: u32 = 40;
pub const CTRY_RUSSIA: u32 = 7;
pub const CTRY_SAUDI_ARABIA: u32 = 966;
pub const CTRY_SERBIA: u32 = 381;
pub const CTRY_SINGAPORE: u32 = 65;
pub const CTRY_SLOVAK: u32 = 421;
pub const CTRY_SLOVENIA: u32 = 386;
pub const CTRY_SOUTH_AFRICA: u32 = 27;
pub const CTRY_SOUTH_KOREA: u32 = 82;
pub const CTRY_SPAIN: u32 = 34;
pub const CTRY_SWEDEN: u32 = 46;
pub const CTRY_SWITZERLAND: u32 = 41;
pub const CTRY_SYRIA: u32 = 963;
pub const CTRY_TAIWAN: u32 = 886;
pub const CTRY_TATARSTAN: u32 = 7;
pub const CTRY_THAILAND: u32 = 66;
pub const CTRY_TRINIDAD_Y_TOBAGO: u32 = 1;
pub const CTRY_TUNISIA: u32 = 216;
pub const CTRY_TURKEY: u32 = 90;
pub const CTRY_UAE: u32 = 971;
pub const CTRY_UKRAINE: u32 = 380;
pub const CTRY_UNITED_KINGDOM: u32 = 44;
pub const CTRY_UNITED_STATES: u32 = 1;
pub const CTRY_URUGUAY: u32 = 598;
pub const CTRY_UZBEKISTAN: u32 = 7;
pub const CTRY_VENEZUELA: u32 = 58;
pub const CTRY_VIET_NAM: u32 = 84;
pub const CTRY_YEMEN: u32 = 967;
pub const CTRY_ZIMBABWE: u32 = 263;
pub const LOCALE_NOUSEROVERRIDE: u32 = 2147483648;
pub const LOCALE_USE_CP_ACP: u32 = 1073741824;
pub const LOCALE_RETURN_NUMBER: u32 = 536870912;
pub const LOCALE_RETURN_GENITIVE_NAMES: u32 = 268435456;
pub const LOCALE_ALLOW_NEUTRAL_NAMES: u32 = 134217728;
pub const LOCALE_SLOCALIZEDDISPLAYNAME: u32 = 2;
pub const LOCALE_SENGLISHDISPLAYNAME: u32 = 114;
pub const LOCALE_SNATIVEDISPLAYNAME: u32 = 115;
pub const LOCALE_SLOCALIZEDLANGUAGENAME: u32 = 111;
pub const LOCALE_SENGLISHLANGUAGENAME: u32 = 4097;
pub const LOCALE_SNATIVELANGUAGENAME: u32 = 4;
pub const LOCALE_SLOCALIZEDCOUNTRYNAME: u32 = 6;
pub const LOCALE_SENGLISHCOUNTRYNAME: u32 = 4098;
pub const LOCALE_SNATIVECOUNTRYNAME: u32 = 8;
pub const LOCALE_IDIALINGCODE: u32 = 5;
pub const LOCALE_SLIST: u32 = 12;
pub const LOCALE_IMEASURE: u32 = 13;
pub const LOCALE_SDECIMAL: u32 = 14;
pub const LOCALE_STHOUSAND: u32 = 15;
pub const LOCALE_SGROUPING: u32 = 16;
pub const LOCALE_IDIGITS: u32 = 17;
pub const LOCALE_ILZERO: u32 = 18;
pub const LOCALE_INEGNUMBER: u32 = 4112;
pub const LOCALE_SNATIVEDIGITS: u32 = 19;
pub const LOCALE_SCURRENCY: u32 = 20;
pub const LOCALE_SINTLSYMBOL: u32 = 21;
pub const LOCALE_SMONDECIMALSEP: u32 = 22;
pub const LOCALE_SMONTHOUSANDSEP: u32 = 23;
pub const LOCALE_SMONGROUPING: u32 = 24;
pub const LOCALE_ICURRDIGITS: u32 = 25;
pub const LOCALE_ICURRENCY: u32 = 27;
pub const LOCALE_INEGCURR: u32 = 28;
pub const LOCALE_SSHORTDATE: u32 = 31;
pub const LOCALE_SLONGDATE: u32 = 32;
pub const LOCALE_STIMEFORMAT: u32 = 4099;
pub const LOCALE_SAM: u32 = 40;
pub const LOCALE_SPM: u32 = 41;
pub const LOCALE_ICALENDARTYPE: u32 = 4105;
pub const LOCALE_IOPTIONALCALENDAR: u32 = 4107;
pub const LOCALE_IFIRSTDAYOFWEEK: u32 = 4108;
pub const LOCALE_IFIRSTWEEKOFYEAR: u32 = 4109;
pub const LOCALE_SDAYNAME1: u32 = 42;
pub const LOCALE_SDAYNAME2: u32 = 43;
pub const LOCALE_SDAYNAME3: u32 = 44;
pub const LOCALE_SDAYNAME4: u32 = 45;
pub const LOCALE_SDAYNAME5: u32 = 46;
pub const LOCALE_SDAYNAME6: u32 = 47;
pub const LOCALE_SDAYNAME7: u32 = 48;
pub const LOCALE_SABBREVDAYNAME1: u32 = 49;
pub const LOCALE_SABBREVDAYNAME2: u32 = 50;
pub const LOCALE_SABBREVDAYNAME3: u32 = 51;
pub const LOCALE_SABBREVDAYNAME4: u32 = 52;
pub const LOCALE_SABBREVDAYNAME5: u32 = 53;
pub const LOCALE_SABBREVDAYNAME6: u32 = 54;
pub const LOCALE_SABBREVDAYNAME7: u32 = 55;
pub const LOCALE_SMONTHNAME1: u32 = 56;
pub const LOCALE_SMONTHNAME2: u32 = 57;
pub const LOCALE_SMONTHNAME3: u32 = 58;
pub const LOCALE_SMONTHNAME4: u32 = 59;
pub const LOCALE_SMONTHNAME5: u32 = 60;
pub const LOCALE_SMONTHNAME6: u32 = 61;
pub const LOCALE_SMONTHNAME7: u32 = 62;
pub const LOCALE_SMONTHNAME8: u32 = 63;
pub const LOCALE_SMONTHNAME9: u32 = 64;
pub const LOCALE_SMONTHNAME10: u32 = 65;
pub const LOCALE_SMONTHNAME11: u32 = 66;
pub const LOCALE_SMONTHNAME12: u32 = 67;
pub const LOCALE_SMONTHNAME13: u32 = 4110;
pub const LOCALE_SABBREVMONTHNAME1: u32 = 68;
pub const LOCALE_SABBREVMONTHNAME2: u32 = 69;
pub const LOCALE_SABBREVMONTHNAME3: u32 = 70;
pub const LOCALE_SABBREVMONTHNAME4: u32 = 71;
pub const LOCALE_SABBREVMONTHNAME5: u32 = 72;
pub const LOCALE_SABBREVMONTHNAME6: u32 = 73;
pub const LOCALE_SABBREVMONTHNAME7: u32 = 74;
pub const LOCALE_SABBREVMONTHNAME8: u32 = 75;
pub const LOCALE_SABBREVMONTHNAME9: u32 = 76;
pub const LOCALE_SABBREVMONTHNAME10: u32 = 77;
pub const LOCALE_SABBREVMONTHNAME11: u32 = 78;
pub const LOCALE_SABBREVMONTHNAME12: u32 = 79;
pub const LOCALE_SABBREVMONTHNAME13: u32 = 4111;
pub const LOCALE_SPOSITIVESIGN: u32 = 80;
pub const LOCALE_SNEGATIVESIGN: u32 = 81;
pub const LOCALE_IPOSSIGNPOSN: u32 = 82;
pub const LOCALE_INEGSIGNPOSN: u32 = 83;
pub const LOCALE_IPOSSYMPRECEDES: u32 = 84;
pub const LOCALE_IPOSSEPBYSPACE: u32 = 85;
pub const LOCALE_INEGSYMPRECEDES: u32 = 86;
pub const LOCALE_INEGSEPBYSPACE: u32 = 87;
pub const LOCALE_FONTSIGNATURE: u32 = 88;
pub const LOCALE_SISO639LANGNAME: u32 = 89;
pub const LOCALE_SISO3166CTRYNAME: u32 = 90;
pub const LOCALE_IPAPERSIZE: u32 = 4106;
pub const LOCALE_SENGCURRNAME: u32 = 4103;
pub const LOCALE_SNATIVECURRNAME: u32 = 4104;
pub const LOCALE_SYEARMONTH: u32 = 4102;
pub const LOCALE_SSORTNAME: u32 = 4115;
pub const LOCALE_IDIGITSUBSTITUTION: u32 = 4116;
pub const LOCALE_SNAME: u32 = 92;
pub const LOCALE_SDURATION: u32 = 93;
pub const LOCALE_SSHORTESTDAYNAME1: u32 = 96;
pub const LOCALE_SSHORTESTDAYNAME2: u32 = 97;
pub const LOCALE_SSHORTESTDAYNAME3: u32 = 98;
pub const LOCALE_SSHORTESTDAYNAME4: u32 = 99;
pub const LOCALE_SSHORTESTDAYNAME5: u32 = 100;
pub const LOCALE_SSHORTESTDAYNAME6: u32 = 101;
pub const LOCALE_SSHORTESTDAYNAME7: u32 = 102;
pub const LOCALE_SISO639LANGNAME2: u32 = 103;
pub const LOCALE_SISO3166CTRYNAME2: u32 = 104;
pub const LOCALE_SNAN: u32 = 105;
pub const LOCALE_SPOSINFINITY: u32 = 106;
pub const LOCALE_SNEGINFINITY: u32 = 107;
pub const LOCALE_SSCRIPTS: u32 = 108;
pub const LOCALE_SPARENT: u32 = 109;
pub const LOCALE_SCONSOLEFALLBACKNAME: u32 = 110;
pub const LOCALE_IREADINGLAYOUT: u32 = 112;
pub const LOCALE_INEUTRAL: u32 = 113;
pub const LOCALE_INEGATIVEPERCENT: u32 = 116;
pub const LOCALE_IPOSITIVEPERCENT: u32 = 117;
pub const LOCALE_SPERCENT: u32 = 118;
pub const LOCALE_SPERMILLE: u32 = 119;
pub const LOCALE_SMONTHDAY: u32 = 120;
pub const LOCALE_SSHORTTIME: u32 = 121;
pub const LOCALE_SOPENTYPELANGUAGETAG: u32 = 122;
pub const LOCALE_SSORTLOCALE: u32 = 123;
pub const LOCALE_SRELATIVELONGDATE: u32 = 124;
pub const LOCALE_ICONSTRUCTEDLOCALE: u32 = 125;
pub const LOCALE_SSHORTESTAM: u32 = 126;
pub const LOCALE_SSHORTESTPM: u32 = 127;
pub const LOCALE_IUSEUTF8LEGACYACP: u32 = 1638;
pub const LOCALE_IUSEUTF8LEGACYOEMCP: u32 = 2457;
pub const LOCALE_IDEFAULTCODEPAGE: u32 = 11;
pub const LOCALE_IDEFAULTANSICODEPAGE: u32 = 4100;
pub const LOCALE_IDEFAULTMACCODEPAGE: u32 = 4113;
pub const LOCALE_IDEFAULTEBCDICCODEPAGE: u32 = 4114;
pub const LOCALE_ILANGUAGE: u32 = 1;
pub const LOCALE_SABBREVLANGNAME: u32 = 3;
pub const LOCALE_SABBREVCTRYNAME: u32 = 7;
pub const LOCALE_IGEOID: u32 = 91;
pub const LOCALE_IDEFAULTLANGUAGE: u32 = 9;
pub const LOCALE_IDEFAULTCOUNTRY: u32 = 10;
pub const LOCALE_IINTLCURRDIGITS: u32 = 26;
pub const LOCALE_SDATE: u32 = 29;
pub const LOCALE_STIME: u32 = 30;
pub const LOCALE_IDATE: u32 = 33;
pub const LOCALE_ILDATE: u32 = 34;
pub const LOCALE_ITIME: u32 = 35;
pub const LOCALE_ITIMEMARKPOSN: u32 = 4101;
pub const LOCALE_ICENTURY: u32 = 36;
pub const LOCALE_ITLZERO: u32 = 37;
pub const LOCALE_IDAYLZERO: u32 = 38;
pub const LOCALE_IMONLZERO: u32 = 39;
pub const LOCALE_SKEYBOARDSTOINSTALL: u32 = 94;
pub const LOCALE_SLANGUAGE: u32 = 2;
pub const LOCALE_SLANGDISPLAYNAME: u32 = 111;
pub const LOCALE_SENGLANGUAGE: u32 = 4097;
pub const LOCALE_SNATIVELANGNAME: u32 = 4;
pub const LOCALE_SCOUNTRY: u32 = 6;
pub const LOCALE_SENGCOUNTRY: u32 = 4098;
pub const LOCALE_SNATIVECTRYNAME: u32 = 8;
pub const LOCALE_ICOUNTRY: u32 = 5;
pub const LOCALE_S1159: u32 = 40;
pub const LOCALE_S2359: u32 = 41;
pub const TIME_NOMINUTESORSECONDS: u32 = 1;
pub const TIME_NOSECONDS: u32 = 2;
pub const TIME_NOTIMEMARKER: u32 = 4;
pub const TIME_FORCE24HOURFORMAT: u32 = 8;
pub const DATE_SHORTDATE: u32 = 1;
pub const DATE_LONGDATE: u32 = 2;
pub const DATE_USE_ALT_CALENDAR: u32 = 4;
pub const DATE_YEARMONTH: u32 = 8;
pub const DATE_LTRREADING: u32 = 16;
pub const DATE_RTLREADING: u32 = 32;
pub const DATE_AUTOLAYOUT: u32 = 64;
pub const DATE_MONTHDAY: u32 = 128;
pub const CAL_NOUSEROVERRIDE: u32 = 2147483648;
pub const CAL_USE_CP_ACP: u32 = 1073741824;
pub const CAL_RETURN_NUMBER: u32 = 536870912;
pub const CAL_RETURN_GENITIVE_NAMES: u32 = 268435456;
pub const CAL_ICALINTVALUE: u32 = 1;
pub const CAL_SCALNAME: u32 = 2;
pub const CAL_IYEAROFFSETRANGE: u32 = 3;
pub const CAL_SERASTRING: u32 = 4;
pub const CAL_SSHORTDATE: u32 = 5;
pub const CAL_SLONGDATE: u32 = 6;
pub const CAL_SDAYNAME1: u32 = 7;
pub const CAL_SDAYNAME2: u32 = 8;
pub const CAL_SDAYNAME3: u32 = 9;
pub const CAL_SDAYNAME4: u32 = 10;
pub const CAL_SDAYNAME5: u32 = 11;
pub const CAL_SDAYNAME6: u32 = 12;
pub const CAL_SDAYNAME7: u32 = 13;
pub const CAL_SABBREVDAYNAME1: u32 = 14;
pub const CAL_SABBREVDAYNAME2: u32 = 15;
pub const CAL_SABBREVDAYNAME3: u32 = 16;
pub const CAL_SABBREVDAYNAME4: u32 = 17;
pub const CAL_SABBREVDAYNAME5: u32 = 18;
pub const CAL_SABBREVDAYNAME6: u32 = 19;
pub const CAL_SABBREVDAYNAME7: u32 = 20;
pub const CAL_SMONTHNAME1: u32 = 21;
pub const CAL_SMONTHNAME2: u32 = 22;
pub const CAL_SMONTHNAME3: u32 = 23;
pub const CAL_SMONTHNAME4: u32 = 24;
pub const CAL_SMONTHNAME5: u32 = 25;
pub const CAL_SMONTHNAME6: u32 = 26;
pub const CAL_SMONTHNAME7: u32 = 27;
pub const CAL_SMONTHNAME8: u32 = 28;
pub const CAL_SMONTHNAME9: u32 = 29;
pub const CAL_SMONTHNAME10: u32 = 30;
pub const CAL_SMONTHNAME11: u32 = 31;
pub const CAL_SMONTHNAME12: u32 = 32;
pub const CAL_SMONTHNAME13: u32 = 33;
pub const CAL_SABBREVMONTHNAME1: u32 = 34;
pub const CAL_SABBREVMONTHNAME2: u32 = 35;
pub const CAL_SABBREVMONTHNAME3: u32 = 36;
pub const CAL_SABBREVMONTHNAME4: u32 = 37;
pub const CAL_SABBREVMONTHNAME5: u32 = 38;
pub const CAL_SABBREVMONTHNAME6: u32 = 39;
pub const CAL_SABBREVMONTHNAME7: u32 = 40;
pub const CAL_SABBREVMONTHNAME8: u32 = 41;
pub const CAL_SABBREVMONTHNAME9: u32 = 42;
pub const CAL_SABBREVMONTHNAME10: u32 = 43;
pub const CAL_SABBREVMONTHNAME11: u32 = 44;
pub const CAL_SABBREVMONTHNAME12: u32 = 45;
pub const CAL_SABBREVMONTHNAME13: u32 = 46;
pub const CAL_SYEARMONTH: u32 = 47;
pub const CAL_ITWODIGITYEARMAX: u32 = 48;
pub const CAL_SSHORTESTDAYNAME1: u32 = 49;
pub const CAL_SSHORTESTDAYNAME2: u32 = 50;
pub const CAL_SSHORTESTDAYNAME3: u32 = 51;
pub const CAL_SSHORTESTDAYNAME4: u32 = 52;
pub const CAL_SSHORTESTDAYNAME5: u32 = 53;
pub const CAL_SSHORTESTDAYNAME6: u32 = 54;
pub const CAL_SSHORTESTDAYNAME7: u32 = 55;
pub const CAL_SMONTHDAY: u32 = 56;
pub const CAL_SABBREVERASTRING: u32 = 57;
pub const CAL_SRELATIVELONGDATE: u32 = 58;
pub const CAL_SENGLISHERANAME: u32 = 59;
pub const CAL_SENGLISHABBREVERANAME: u32 = 60;
pub const CAL_SJAPANESEERAFIRSTYEAR: u32 = 61;
pub const ENUM_ALL_CALENDARS: u32 = 4294967295;
pub const CAL_GREGORIAN: u32 = 1;
pub const CAL_GREGORIAN_US: u32 = 2;
pub const CAL_JAPAN: u32 = 3;
pub const CAL_TAIWAN: u32 = 4;
pub const CAL_KOREA: u32 = 5;
pub const CAL_HIJRI: u32 = 6;
pub const CAL_THAI: u32 = 7;
pub const CAL_HEBREW: u32 = 8;
pub const CAL_GREGORIAN_ME_FRENCH: u32 = 9;
pub const CAL_GREGORIAN_ARABIC: u32 = 10;
pub const CAL_GREGORIAN_XLIT_ENGLISH: u32 = 11;
pub const CAL_GREGORIAN_XLIT_FRENCH: u32 = 12;
pub const CAL_PERSIAN: u32 = 22;
pub const CAL_UMALQURA: u32 = 23;
pub const LGRPID_WESTERN_EUROPE: u32 = 1;
pub const LGRPID_CENTRAL_EUROPE: u32 = 2;
pub const LGRPID_BALTIC: u32 = 3;
pub const LGRPID_GREEK: u32 = 4;
pub const LGRPID_CYRILLIC: u32 = 5;
pub const LGRPID_TURKIC: u32 = 6;
pub const LGRPID_TURKISH: u32 = 6;
pub const LGRPID_JAPANESE: u32 = 7;
pub const LGRPID_KOREAN: u32 = 8;
pub const LGRPID_TRADITIONAL_CHINESE: u32 = 9;
pub const LGRPID_SIMPLIFIED_CHINESE: u32 = 10;
pub const LGRPID_THAI: u32 = 11;
pub const LGRPID_HEBREW: u32 = 12;
pub const LGRPID_ARABIC: u32 = 13;
pub const LGRPID_VIETNAMESE: u32 = 14;
pub const LGRPID_INDIC: u32 = 15;
pub const LGRPID_GEORGIAN: u32 = 16;
pub const LGRPID_ARMENIAN: u32 = 17;
pub const MUI_LANGUAGE_ID: u32 = 4;
pub const MUI_LANGUAGE_NAME: u32 = 8;
pub const MUI_MERGE_SYSTEM_FALLBACK: u32 = 16;
pub const MUI_MERGE_USER_FALLBACK: u32 = 32;
pub const MUI_UI_FALLBACK: u32 = 48;
pub const MUI_THREAD_LANGUAGES: u32 = 64;
pub const MUI_CONSOLE_FILTER: u32 = 256;
pub const MUI_COMPLEX_SCRIPT_FILTER: u32 = 512;
pub const MUI_RESET_FILTERS: u32 = 1;
pub const MUI_USER_PREFERRED_UI_LANGUAGES: u32 = 16;
pub const MUI_USE_INSTALLED_LANGUAGES: u32 = 32;
pub const MUI_USE_SEARCH_ALL_LANGUAGES: u32 = 64;
pub const MUI_LANG_NEUTRAL_PE_FILE: u32 = 256;
pub const MUI_NON_LANG_NEUTRAL_FILE: u32 = 512;
pub const MUI_MACHINE_LANGUAGE_SETTINGS: u32 = 1024;
pub const MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL: u32 = 1;
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN: u32 = 2;
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI: u32 = 4;
pub const MUI_QUERY_TYPE: u32 = 1;
pub const MUI_QUERY_CHECKSUM: u32 = 2;
pub const MUI_QUERY_LANGUAGE_NAME: u32 = 4;
pub const MUI_QUERY_RESOURCE_TYPES: u32 = 8;
pub const MUI_FILEINFO_VERSION: u32 = 1;
pub const MUI_FULL_LANGUAGE: u32 = 1;
pub const MUI_PARTIAL_LANGUAGE: u32 = 2;
pub const MUI_LIP_LANGUAGE: u32 = 4;
pub const MUI_LANGUAGE_INSTALLED: u32 = 32;
pub const MUI_LANGUAGE_LICENSED: u32 = 64;
pub const GEOID_NOT_AVAILABLE: i32 = -1;
pub const SORTING_PARADIGM_NLS: u32 = 0;
pub const SORTING_PARADIGM_ICU: u32 = 16777216;
pub const GEO_NAME_USER_DEFAULT: u32 = 0;
pub const IDN_ALLOW_UNASSIGNED: u32 = 1;
pub const IDN_USE_STD3_ASCII_RULES: u32 = 2;
pub const IDN_EMAIL_ADDRESS: u32 = 4;
pub const IDN_RAW_PUNYCODE: u32 = 8;
pub const VS_ALLOW_LATIN: u32 = 1;
pub const GSS_ALLOW_INHERITED_COMMON: u32 = 1;
pub const MUI_FORMAT_REG_COMPAT: u32 = 1;
pub const MUI_FORMAT_INF_COMPAT: u32 = 2;
pub const MUI_VERIFY_FILE_EXISTS: u32 = 4;
pub const MUI_SKIP_STRING_CACHE: u32 = 8;
pub const MUI_IMMUTABLE_LOOKUP: u32 = 16;
pub const LOCALE_NAME_USER_DEFAULT: u32 = 0;
pub const LOCALE_NAME_INVARIANT: &[u8; 1usize] = b"\0";
pub const LOCALE_NAME_SYSTEM_DEFAULT: &[u8; 22usize] = b"!x-sys-default-locale\0";
pub const RIGHT_ALT_PRESSED: u32 = 1;
pub const LEFT_ALT_PRESSED: u32 = 2;
pub const RIGHT_CTRL_PRESSED: u32 = 4;
pub const LEFT_CTRL_PRESSED: u32 = 8;
pub const SHIFT_PRESSED: u32 = 16;
pub const NUMLOCK_ON: u32 = 32;
pub const SCROLLLOCK_ON: u32 = 64;
pub const CAPSLOCK_ON: u32 = 128;
pub const ENHANCED_KEY: u32 = 256;
pub const NLS_DBCSCHAR: u32 = 65536;
pub const NLS_ALPHANUMERIC: u32 = 0;
pub const NLS_KATAKANA: u32 = 131072;
pub const NLS_HIRAGANA: u32 = 262144;
pub const NLS_ROMAN: u32 = 4194304;
pub const NLS_IME_CONVERSION: u32 = 8388608;
pub const ALTNUMPAD_BIT: u32 = 67108864;
pub const NLS_IME_DISABLE: u32 = 536870912;
pub const FROM_LEFT_1ST_BUTTON_PRESSED: u32 = 1;
pub const RIGHTMOST_BUTTON_PRESSED: u32 = 2;
pub const FROM_LEFT_2ND_BUTTON_PRESSED: u32 = 4;
pub const FROM_LEFT_3RD_BUTTON_PRESSED: u32 = 8;
pub const FROM_LEFT_4TH_BUTTON_PRESSED: u32 = 16;
pub const MOUSE_MOVED: u32 = 1;
pub const DOUBLE_CLICK: u32 = 2;
pub const MOUSE_WHEELED: u32 = 4;
pub const MOUSE_HWHEELED: u32 = 8;
pub const KEY_EVENT: u32 = 1;
pub const MOUSE_EVENT: u32 = 2;
pub const WINDOW_BUFFER_SIZE_EVENT: u32 = 4;
pub const MENU_EVENT: u32 = 8;
pub const FOCUS_EVENT: u32 = 16;
pub const ENABLE_PROCESSED_INPUT: u32 = 1;
pub const ENABLE_LINE_INPUT: u32 = 2;
pub const ENABLE_ECHO_INPUT: u32 = 4;
pub const ENABLE_WINDOW_INPUT: u32 = 8;
pub const ENABLE_MOUSE_INPUT: u32 = 16;
pub const ENABLE_INSERT_MODE: u32 = 32;
pub const ENABLE_QUICK_EDIT_MODE: u32 = 64;
pub const ENABLE_EXTENDED_FLAGS: u32 = 128;
pub const ENABLE_AUTO_POSITION: u32 = 256;
pub const ENABLE_VIRTUAL_TERMINAL_INPUT: u32 = 512;
pub const ENABLE_PROCESSED_OUTPUT: u32 = 1;
pub const ENABLE_WRAP_AT_EOL_OUTPUT: u32 = 2;
pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING: u32 = 4;
pub const DISABLE_NEWLINE_AUTO_RETURN: u32 = 8;
pub const ENABLE_LVB_GRID_WORLDWIDE: u32 = 16;
pub const CTRL_C_EVENT: u32 = 0;
pub const CTRL_BREAK_EVENT: u32 = 1;
pub const CTRL_CLOSE_EVENT: u32 = 2;
pub const CTRL_LOGOFF_EVENT: u32 = 5;
pub const CTRL_SHUTDOWN_EVENT: u32 = 6;
pub const PSEUDOCONSOLE_INHERIT_CURSOR: u32 = 1;
pub const FOREGROUND_BLUE: u32 = 1;
pub const FOREGROUND_GREEN: u32 = 2;
pub const FOREGROUND_RED: u32 = 4;
pub const FOREGROUND_INTENSITY: u32 = 8;
pub const BACKGROUND_BLUE: u32 = 16;
pub const BACKGROUND_GREEN: u32 = 32;
pub const BACKGROUND_RED: u32 = 64;
pub const BACKGROUND_INTENSITY: u32 = 128;
pub const COMMON_LVB_LEADING_BYTE: u32 = 256;
pub const COMMON_LVB_TRAILING_BYTE: u32 = 512;
pub const COMMON_LVB_GRID_HORIZONTAL: u32 = 1024;
pub const COMMON_LVB_GRID_LVERTICAL: u32 = 2048;
pub const COMMON_LVB_GRID_RVERTICAL: u32 = 4096;
pub const COMMON_LVB_REVERSE_VIDEO: u32 = 16384;
pub const COMMON_LVB_UNDERSCORE: u32 = 32768;
pub const COMMON_LVB_SBCSDBCS: u32 = 768;
pub const CONSOLE_NO_SELECTION: u32 = 0;
pub const CONSOLE_SELECTION_IN_PROGRESS: u32 = 1;
pub const CONSOLE_SELECTION_NOT_EMPTY: u32 = 2;
pub const CONSOLE_MOUSE_SELECTION: u32 = 4;
pub const CONSOLE_MOUSE_DOWN: u32 = 8;
pub const HISTORY_NO_DUP_FLAG: u32 = 1;
pub const CONSOLE_FULLSCREEN: u32 = 1;
pub const CONSOLE_FULLSCREEN_HARDWARE: u32 = 2;
pub const CONSOLE_FULLSCREEN_MODE: u32 = 1;
pub const CONSOLE_WINDOWED_MODE: u32 = 2;
pub const CONSOLE_TEXTMODE_BUFFER: u32 = 1;
pub const VS_VERSION_INFO: u32 = 1;
pub const VS_USER_DEFINED: u32 = 100;
pub const VS_FFI_SIGNATURE: u32 = 4277077181;
pub const VS_FFI_STRUCVERSION: u32 = 65536;
pub const VS_FFI_FILEFLAGSMASK: u32 = 63;
pub const VS_FF_DEBUG: u32 = 1;
pub const VS_FF_PRERELEASE: u32 = 2;
pub const VS_FF_PATCHED: u32 = 4;
pub const VS_FF_PRIVATEBUILD: u32 = 8;
pub const VS_FF_INFOINFERRED: u32 = 16;
pub const VS_FF_SPECIALBUILD: u32 = 32;
pub const VOS_UNKNOWN: u32 = 0;
pub const VOS_DOS: u32 = 65536;
pub const VOS_OS216: u32 = 131072;
pub const VOS_OS232: u32 = 196608;
pub const VOS_NT: u32 = 262144;
pub const VOS_WINCE: u32 = 327680;
pub const VOS__BASE: u32 = 0;
pub const VOS__WINDOWS16: u32 = 1;
pub const VOS__PM16: u32 = 2;
pub const VOS__PM32: u32 = 3;
pub const VOS__WINDOWS32: u32 = 4;
pub const VOS_DOS_WINDOWS16: u32 = 65537;
pub const VOS_DOS_WINDOWS32: u32 = 65540;
pub const VOS_OS216_PM16: u32 = 131074;
pub const VOS_OS232_PM32: u32 = 196611;
pub const VOS_NT_WINDOWS32: u32 = 262148;
pub const VFT_UNKNOWN: u32 = 0;
pub const VFT_APP: u32 = 1;
pub const VFT_DLL: u32 = 2;
pub const VFT_DRV: u32 = 3;
pub const VFT_FONT: u32 = 4;
pub const VFT_VXD: u32 = 5;
pub const VFT_STATIC_LIB: u32 = 7;
pub const VFT2_UNKNOWN: u32 = 0;
pub const VFT2_DRV_PRINTER: u32 = 1;
pub const VFT2_DRV_KEYBOARD: u32 = 2;
pub const VFT2_DRV_LANGUAGE: u32 = 3;
pub const VFT2_DRV_DISPLAY: u32 = 4;
pub const VFT2_DRV_MOUSE: u32 = 5;
pub const VFT2_DRV_NETWORK: u32 = 6;
pub const VFT2_DRV_SYSTEM: u32 = 7;
pub const VFT2_DRV_INSTALLABLE: u32 = 8;
pub const VFT2_DRV_SOUND: u32 = 9;
pub const VFT2_DRV_COMM: u32 = 10;
pub const VFT2_DRV_INPUTMETHOD: u32 = 11;
pub const VFT2_DRV_VERSIONED_PRINTER: u32 = 12;
pub const VFT2_FONT_RASTER: u32 = 1;
pub const VFT2_FONT_VECTOR: u32 = 2;
pub const VFT2_FONT_TRUETYPE: u32 = 3;
pub const VFFF_ISSHAREDFILE: u32 = 1;
pub const VFF_CURNEDEST: u32 = 1;
pub const VFF_FILEINUSE: u32 = 2;
pub const VFF_BUFFTOOSMALL: u32 = 4;
pub const VIFF_FORCEINSTALL: u32 = 1;
pub const VIFF_DONTDELETEOLD: u32 = 2;
pub const VIF_TEMPFILE: u32 = 1;
pub const VIF_MISMATCH: u32 = 2;
pub const VIF_SRCOLD: u32 = 4;
pub const VIF_DIFFLANG: u32 = 8;
pub const VIF_DIFFCODEPG: u32 = 16;
pub const VIF_DIFFTYPE: u32 = 32;
pub const VIF_WRITEPROT: u32 = 64;
pub const VIF_FILEINUSE: u32 = 128;
pub const VIF_OUTOFSPACE: u32 = 256;
pub const VIF_ACCESSVIOLATION: u32 = 512;
pub const VIF_SHARINGVIOLATION: u32 = 1024;
pub const VIF_CANNOTCREATE: u32 = 2048;
pub const VIF_CANNOTDELETE: u32 = 4096;
pub const VIF_CANNOTRENAME: u32 = 8192;
pub const VIF_CANNOTDELETECUR: u32 = 16384;
pub const VIF_OUTOFMEMORY: u32 = 32768;
pub const VIF_CANNOTREADSRC: u32 = 65536;
pub const VIF_CANNOTREADDST: u32 = 131072;
pub const VIF_BUFFTOOSMALL: u32 = 262144;
pub const VIF_CANNOTLOADLZ32: u32 = 524288;
pub const VIF_CANNOTLOADCABINET: u32 = 1048576;
pub const FILE_VER_GET_LOCALISED: u32 = 1;
pub const FILE_VER_GET_NEUTRAL: u32 = 2;
pub const FILE_VER_GET_PREFETCHED: u32 = 4;
pub const RRF_RT_REG_NONE: u32 = 1;
pub const RRF_RT_REG_SZ: u32 = 2;
pub const RRF_RT_REG_EXPAND_SZ: u32 = 4;
pub const RRF_RT_REG_BINARY: u32 = 8;
pub const RRF_RT_REG_DWORD: u32 = 16;
pub const RRF_RT_REG_MULTI_SZ: u32 = 32;
pub const RRF_RT_REG_QWORD: u32 = 64;
pub const RRF_RT_DWORD: u32 = 24;
pub const RRF_RT_QWORD: u32 = 72;
pub const RRF_RT_ANY: u32 = 65535;
pub const RRF_SUBKEY_WOW6464KEY: u32 = 65536;
pub const RRF_SUBKEY_WOW6432KEY: u32 = 131072;
pub const RRF_WOW64_MASK: u32 = 196608;
pub const RRF_NOEXPAND: u32 = 268435456;
pub const RRF_ZEROONFAILURE: u32 = 536870912;
pub const REG_PROCESS_APPKEY: u32 = 1;
pub const REG_USE_CURRENT_SECURITY_CONTEXT: u32 = 2;
pub const PROVIDER_KEEPS_VALUE_LENGTH: u32 = 1;
pub const WIN31_CLASS: u32 = 0;
pub const REG_MUI_STRING_TRUNCATE: u32 = 1;
pub const REG_SECURE_CONNECTION: u32 = 1;
pub const SHTDN_REASON_FLAG_COMMENT_REQUIRED: u32 = 16777216;
pub const SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED: u32 = 33554432;
pub const SHTDN_REASON_FLAG_CLEAN_UI: u32 = 67108864;
pub const SHTDN_REASON_FLAG_DIRTY_UI: u32 = 134217728;
pub const SHTDN_REASON_FLAG_MOBILE_UI_RESERVED: u32 = 268435456;
pub const SHTDN_REASON_FLAG_USER_DEFINED: u32 = 1073741824;
pub const SHTDN_REASON_FLAG_PLANNED: u32 = 2147483648;
pub const SHTDN_REASON_MAJOR_OTHER: u32 = 0;
pub const SHTDN_REASON_MAJOR_NONE: u32 = 0;
pub const SHTDN_REASON_MAJOR_HARDWARE: u32 = 65536;
pub const SHTDN_REASON_MAJOR_OPERATINGSYSTEM: u32 = 131072;
pub const SHTDN_REASON_MAJOR_SOFTWARE: u32 = 196608;
pub const SHTDN_REASON_MAJOR_APPLICATION: u32 = 262144;
pub const SHTDN_REASON_MAJOR_SYSTEM: u32 = 327680;
pub const SHTDN_REASON_MAJOR_POWER: u32 = 393216;
pub const SHTDN_REASON_MAJOR_LEGACY_API: u32 = 458752;
pub const SHTDN_REASON_MINOR_OTHER: u32 = 0;
pub const SHTDN_REASON_MINOR_NONE: u32 = 255;
pub const SHTDN_REASON_MINOR_MAINTENANCE: u32 = 1;
pub const SHTDN_REASON_MINOR_INSTALLATION: u32 = 2;
pub const SHTDN_REASON_MINOR_UPGRADE: u32 = 3;
pub const SHTDN_REASON_MINOR_RECONFIG: u32 = 4;
pub const SHTDN_REASON_MINOR_HUNG: u32 = 5;
pub const SHTDN_REASON_MINOR_UNSTABLE: u32 = 6;
pub const SHTDN_REASON_MINOR_DISK: u32 = 7;
pub const SHTDN_REASON_MINOR_PROCESSOR: u32 = 8;
pub const SHTDN_REASON_MINOR_NETWORKCARD: u32 = 9;
pub const SHTDN_REASON_MINOR_POWER_SUPPLY: u32 = 10;
pub const SHTDN_REASON_MINOR_CORDUNPLUGGED: u32 = 11;
pub const SHTDN_REASON_MINOR_ENVIRONMENT: u32 = 12;
pub const SHTDN_REASON_MINOR_HARDWARE_DRIVER: u32 = 13;
pub const SHTDN_REASON_MINOR_OTHERDRIVER: u32 = 14;
pub const SHTDN_REASON_MINOR_BLUESCREEN: u32 = 15;
pub const SHTDN_REASON_MINOR_SERVICEPACK: u32 = 16;
pub const SHTDN_REASON_MINOR_HOTFIX: u32 = 17;
pub const SHTDN_REASON_MINOR_SECURITYFIX: u32 = 18;
pub const SHTDN_REASON_MINOR_SECURITY: u32 = 19;
pub const SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY: u32 = 20;
pub const SHTDN_REASON_MINOR_WMI: u32 = 21;
pub const SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL: u32 = 22;
pub const SHTDN_REASON_MINOR_HOTFIX_UNINSTALL: u32 = 23;
pub const SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL: u32 = 24;
pub const SHTDN_REASON_MINOR_MMC: u32 = 25;
pub const SHTDN_REASON_MINOR_SYSTEMRESTORE: u32 = 26;
pub const SHTDN_REASON_MINOR_TERMSRV: u32 = 32;
pub const SHTDN_REASON_MINOR_DC_PROMOTION: u32 = 33;
pub const SHTDN_REASON_MINOR_DC_DEMOTION: u32 = 34;
pub const SHTDN_REASON_UNKNOWN: u32 = 255;
pub const SHTDN_REASON_LEGACY_API: u32 = 2147942400;
pub const SHTDN_REASON_VALID_BIT_MASK: u32 = 3238002687;
pub const PCLEANUI: u32 = 2214592512;
pub const UCLEANUI: u32 = 67108864;
pub const PDIRTYUI: u32 = 2281701376;
pub const UDIRTYUI: u32 = 134217728;
pub const MAX_REASON_NAME_LEN: u32 = 64;
pub const MAX_REASON_DESC_LEN: u32 = 256;
pub const MAX_REASON_BUGID_LEN: u32 = 32;
pub const MAX_REASON_COMMENT_LEN: u32 = 512;
pub const SHUTDOWN_TYPE_LEN: u32 = 32;
pub const POLICY_SHOWREASONUI_NEVER: u32 = 0;
pub const POLICY_SHOWREASONUI_ALWAYS: u32 = 1;
pub const POLICY_SHOWREASONUI_WORKSTATIONONLY: u32 = 2;
pub const POLICY_SHOWREASONUI_SERVERONLY: u32 = 3;
pub const SNAPSHOT_POLICY_NEVER: u32 = 0;
pub const SNAPSHOT_POLICY_ALWAYS: u32 = 1;
pub const SNAPSHOT_POLICY_UNPLANNED: u32 = 2;
pub const MAX_NUM_REASONS: u32 = 256;
pub const REASON_SWINSTALL: u32 = 196610;
pub const REASON_HWINSTALL: u32 = 65538;
pub const REASON_SERVICEHANG: u32 = 196613;
pub const REASON_UNSTABLE: u32 = 327686;
pub const REASON_SWHWRECONF: u32 = 196612;
pub const REASON_OTHER: u32 = 0;
pub const REASON_UNKNOWN: u32 = 255;
pub const REASON_LEGACY_API: u32 = 2147942400;
pub const REASON_PLANNED_FLAG: u32 = 2147483648;
pub const MAX_SHUTDOWN_TIMEOUT: u32 = 315360000;
pub const SHUTDOWN_FORCE_OTHERS: u32 = 1;
pub const SHUTDOWN_FORCE_SELF: u32 = 2;
pub const SHUTDOWN_RESTART: u32 = 4;
pub const SHUTDOWN_POWEROFF: u32 = 8;
pub const SHUTDOWN_NOREBOOT: u32 = 16;
pub const SHUTDOWN_GRACE_OVERRIDE: u32 = 32;
pub const SHUTDOWN_INSTALL_UPDATES: u32 = 64;
pub const SHUTDOWN_RESTARTAPPS: u32 = 128;
pub const SHUTDOWN_SKIP_SVC_PRESHUTDOWN: u32 = 256;
pub const SHUTDOWN_HYBRID: u32 = 512;
pub const SHUTDOWN_RESTART_BOOTOPTIONS: u32 = 1024;
pub const SHUTDOWN_SOFT_REBOOT: u32 = 2048;
pub const SHUTDOWN_MOBILE_UI: u32 = 4096;
pub const SHUTDOWN_ARSO: u32 = 8192;
pub const SHUTDOWN_CHECK_SAFE_FOR_SERVER: u32 = 16384;
pub const SHUTDOWN_VAIL_CONTAINER: u32 = 32768;
pub const SHUTDOWN_SYSTEM_INITIATED: u32 = 65536;
pub const WNNC_NET_MSNET: u32 = 65536;
pub const WNNC_NET_SMB: u32 = 131072;
pub const WNNC_NET_NETWARE: u32 = 196608;
pub const WNNC_NET_VINES: u32 = 262144;
pub const WNNC_NET_10NET: u32 = 327680;
pub const WNNC_NET_LOCUS: u32 = 393216;
pub const WNNC_NET_SUN_PC_NFS: u32 = 458752;
pub const WNNC_NET_LANSTEP: u32 = 524288;
pub const WNNC_NET_9TILES: u32 = 589824;
pub const WNNC_NET_LANTASTIC: u32 = 655360;
pub const WNNC_NET_AS400: u32 = 720896;
pub const WNNC_NET_FTP_NFS: u32 = 786432;
pub const WNNC_NET_PATHWORKS: u32 = 851968;
pub const WNNC_NET_LIFENET: u32 = 917504;
pub const WNNC_NET_POWERLAN: u32 = 983040;
pub const WNNC_NET_BWNFS: u32 = 1048576;
pub const WNNC_NET_COGENT: u32 = 1114112;
pub const WNNC_NET_FARALLON: u32 = 1179648;
pub const WNNC_NET_APPLETALK: u32 = 1245184;
pub const WNNC_NET_INTERGRAPH: u32 = 1310720;
pub const WNNC_NET_SYMFONET: u32 = 1376256;
pub const WNNC_NET_CLEARCASE: u32 = 1441792;
pub const WNNC_NET_FRONTIER: u32 = 1507328;
pub const WNNC_NET_BMC: u32 = 1572864;
pub const WNNC_NET_DCE: u32 = 1638400;
pub const WNNC_NET_AVID: u32 = 1703936;
pub const WNNC_NET_DOCUSPACE: u32 = 1769472;
pub const WNNC_NET_MANGOSOFT: u32 = 1835008;
pub const WNNC_NET_SERNET: u32 = 1900544;
pub const WNNC_NET_RIVERFRONT1: u32 = 1966080;
pub const WNNC_NET_RIVERFRONT2: u32 = 2031616;
pub const WNNC_NET_DECORB: u32 = 2097152;
pub const WNNC_NET_PROTSTOR: u32 = 2162688;
pub const WNNC_NET_FJ_REDIR: u32 = 2228224;
pub const WNNC_NET_DISTINCT: u32 = 2293760;
pub const WNNC_NET_TWINS: u32 = 2359296;
pub const WNNC_NET_RDR2SAMPLE: u32 = 2424832;
pub const WNNC_NET_CSC: u32 = 2490368;
pub const WNNC_NET_3IN1: u32 = 2555904;
pub const WNNC_NET_EXTENDNET: u32 = 2686976;
pub const WNNC_NET_STAC: u32 = 2752512;
pub const WNNC_NET_FOXBAT: u32 = 2818048;
pub const WNNC_NET_YAHOO: u32 = 2883584;
pub const WNNC_NET_EXIFS: u32 = 2949120;
pub const WNNC_NET_DAV: u32 = 3014656;
pub const WNNC_NET_KNOWARE: u32 = 3080192;
pub const WNNC_NET_OBJECT_DIRE: u32 = 3145728;
pub const WNNC_NET_MASFAX: u32 = 3211264;
pub const WNNC_NET_HOB_NFS: u32 = 3276800;
pub const WNNC_NET_SHIVA: u32 = 3342336;
pub const WNNC_NET_IBMAL: u32 = 3407872;
pub const WNNC_NET_LOCK: u32 = 3473408;
pub const WNNC_NET_TERMSRV: u32 = 3538944;
pub const WNNC_NET_SRT: u32 = 3604480;
pub const WNNC_NET_QUINCY: u32 = 3670016;
pub const WNNC_NET_OPENAFS: u32 = 3735552;
pub const WNNC_NET_AVID1: u32 = 3801088;
pub const WNNC_NET_DFS: u32 = 3866624;
pub const WNNC_NET_KWNP: u32 = 3932160;
pub const WNNC_NET_ZENWORKS: u32 = 3997696;
pub const WNNC_NET_DRIVEONWEB: u32 = 4063232;
pub const WNNC_NET_VMWARE: u32 = 4128768;
pub const WNNC_NET_RSFX: u32 = 4194304;
pub const WNNC_NET_MFILES: u32 = 4259840;
pub const WNNC_NET_MS_NFS: u32 = 4325376;
pub const WNNC_NET_GOOGLE: u32 = 4390912;
pub const WNNC_NET_NDFS: u32 = 4456448;
pub const WNNC_NET_DOCUSHARE: u32 = 4521984;
pub const WNNC_NET_AURISTOR_FS: u32 = 4587520;
pub const WNNC_NET_SECUREAGENT: u32 = 4653056;
pub const WNNC_NET_9P: u32 = 4718592;
pub const WNNC_CRED_MANAGER: u32 = 4294901760;
pub const WNNC_NET_LANMAN: u32 = 131072;
pub const RESOURCE_CONNECTED: u32 = 1;
pub const RESOURCE_GLOBALNET: u32 = 2;
pub const RESOURCE_REMEMBERED: u32 = 3;
pub const RESOURCE_RECENT: u32 = 4;
pub const RESOURCE_CONTEXT: u32 = 5;
pub const RESOURCETYPE_ANY: u32 = 0;
pub const RESOURCETYPE_DISK: u32 = 1;
pub const RESOURCETYPE_PRINT: u32 = 2;
pub const RESOURCETYPE_RESERVED: u32 = 8;
pub const RESOURCETYPE_UNKNOWN: u32 = 4294967295;
pub const RESOURCEUSAGE_CONNECTABLE: u32 = 1;
pub const RESOURCEUSAGE_CONTAINER: u32 = 2;
pub const RESOURCEUSAGE_NOLOCALDEVICE: u32 = 4;
pub const RESOURCEUSAGE_SIBLING: u32 = 8;
pub const RESOURCEUSAGE_ATTACHED: u32 = 16;
pub const RESOURCEUSAGE_ALL: u32 = 19;
pub const RESOURCEUSAGE_RESERVED: u32 = 2147483648;
pub const RESOURCEDISPLAYTYPE_GENERIC: u32 = 0;
pub const RESOURCEDISPLAYTYPE_DOMAIN: u32 = 1;
pub const RESOURCEDISPLAYTYPE_SERVER: u32 = 2;
pub const RESOURCEDISPLAYTYPE_SHARE: u32 = 3;
pub const RESOURCEDISPLAYTYPE_FILE: u32 = 4;
pub const RESOURCEDISPLAYTYPE_GROUP: u32 = 5;
pub const RESOURCEDISPLAYTYPE_NETWORK: u32 = 6;
pub const RESOURCEDISPLAYTYPE_ROOT: u32 = 7;
pub const RESOURCEDISPLAYTYPE_SHAREADMIN: u32 = 8;
pub const RESOURCEDISPLAYTYPE_DIRECTORY: u32 = 9;
pub const RESOURCEDISPLAYTYPE_TREE: u32 = 10;
pub const RESOURCEDISPLAYTYPE_NDSCONTAINER: u32 = 11;
pub const NETPROPERTY_PERSISTENT: u32 = 1;
pub const CONNECT_UPDATE_PROFILE: u32 = 1;
pub const CONNECT_UPDATE_RECENT: u32 = 2;
pub const CONNECT_TEMPORARY: u32 = 4;
pub const CONNECT_INTERACTIVE: u32 = 8;
pub const CONNECT_PROMPT: u32 = 16;
pub const CONNECT_NEED_DRIVE: u32 = 32;
pub const CONNECT_REFCOUNT: u32 = 64;
pub const CONNECT_REDIRECT: u32 = 128;
pub const CONNECT_LOCALDRIVE: u32 = 256;
pub const CONNECT_CURRENT_MEDIA: u32 = 512;
pub const CONNECT_DEFERRED: u32 = 1024;
pub const CONNECT_RESERVED: u32 = 4278190080;
pub const CONNECT_COMMANDLINE: u32 = 2048;
pub const CONNECT_CMD_SAVECRED: u32 = 4096;
pub const CONNECT_CRED_RESET: u32 = 8192;
pub const CONNECT_REQUIRE_INTEGRITY: u32 = 16384;
pub const CONNECT_REQUIRE_PRIVACY: u32 = 32768;
pub const CONNECT_WRITE_THROUGH_SEMANTICS: u32 = 65536;
pub const CONNECT_GLOBAL_MAPPING: u32 = 262144;
pub const CONNDLG_RO_PATH: u32 = 1;
pub const CONNDLG_CONN_POINT: u32 = 2;
pub const CONNDLG_USE_MRU: u32 = 4;
pub const CONNDLG_HIDE_BOX: u32 = 8;
pub const CONNDLG_PERSIST: u32 = 16;
pub const CONNDLG_NOT_PERSIST: u32 = 32;
pub const DISC_UPDATE_PROFILE: u32 = 1;
pub const DISC_NO_FORCE: u32 = 64;
pub const UNIVERSAL_NAME_INFO_LEVEL: u32 = 1;
pub const REMOTE_NAME_INFO_LEVEL: u32 = 2;
pub const WNFMT_MULTILINE: u32 = 1;
pub const WNFMT_ABBREVIATED: u32 = 2;
pub const WNFMT_INENUM: u32 = 16;
pub const WNFMT_CONNECTION: u32 = 32;
pub const NETINFO_DLL16: u32 = 1;
pub const NETINFO_DISKRED: u32 = 4;
pub const NETINFO_PRINTERRED: u32 = 8;
pub const WN_SUCCESS: u32 = 0;
pub const WN_NO_ERROR: u32 = 0;
pub const WN_NOT_SUPPORTED: u32 = 50;
pub const WN_CANCEL: u32 = 1223;
pub const WN_RETRY: u32 = 1237;
pub const WN_NET_ERROR: u32 = 59;
pub const WN_MORE_DATA: u32 = 234;
pub const WN_BAD_POINTER: u32 = 487;
pub const WN_BAD_VALUE: u32 = 87;
pub const WN_BAD_USER: u32 = 2202;
pub const WN_BAD_PASSWORD: u32 = 86;
pub const WN_ACCESS_DENIED: u32 = 5;
pub const WN_FUNCTION_BUSY: u32 = 170;
pub const WN_WINDOWS_ERROR: u32 = 59;
pub const WN_OUT_OF_MEMORY: u32 = 8;
pub const WN_NO_NETWORK: u32 = 1222;
pub const WN_EXTENDED_ERROR: u32 = 1208;
pub const WN_BAD_LEVEL: u32 = 124;
pub const WN_BAD_HANDLE: u32 = 6;
pub const WN_NOT_INITIALIZING: u32 = 1247;
pub const WN_NO_MORE_DEVICES: u32 = 1248;
pub const WN_NOT_CONNECTED: u32 = 2250;
pub const WN_OPEN_FILES: u32 = 2401;
pub const WN_DEVICE_IN_USE: u32 = 2404;
pub const WN_BAD_NETNAME: u32 = 67;
pub const WN_BAD_LOCALNAME: u32 = 1200;
pub const WN_ALREADY_CONNECTED: u32 = 85;
pub const WN_DEVICE_ERROR: u32 = 31;
pub const WN_CONNECTION_CLOSED: u32 = 1201;
pub const WN_NO_NET_OR_BAD_PATH: u32 = 1203;
pub const WN_BAD_PROVIDER: u32 = 1204;
pub const WN_CANNOT_OPEN_PROFILE: u32 = 1205;
pub const WN_BAD_PROFILE: u32 = 1206;
pub const WN_BAD_DEV_TYPE: u32 = 66;
pub const WN_DEVICE_ALREADY_REMEMBERED: u32 = 1202;
pub const WN_CONNECTED_OTHER_PASSWORD: u32 = 2108;
pub const WN_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 2109;
pub const WN_NO_MORE_ENTRIES: u32 = 259;
pub const WN_NOT_CONTAINER: u32 = 1207;
pub const WN_NOT_AUTHENTICATED: u32 = 1244;
pub const WN_NOT_LOGGED_ON: u32 = 1245;
pub const WN_NOT_VALIDATED: u32 = 1311;
pub const WNCON_FORNETCARD: u32 = 1;
pub const WNCON_NOTROUTED: u32 = 2;
pub const WNCON_SLOWLINK: u32 = 4;
pub const WNCON_DYNAMIC: u32 = 8;
pub const CDERR_DIALOGFAILURE: u32 = 65535;
pub const CDERR_GENERALCODES: u32 = 0;
pub const CDERR_STRUCTSIZE: u32 = 1;
pub const CDERR_INITIALIZATION: u32 = 2;
pub const CDERR_NOTEMPLATE: u32 = 3;
pub const CDERR_NOHINSTANCE: u32 = 4;
pub const CDERR_LOADSTRFAILURE: u32 = 5;
pub const CDERR_FINDRESFAILURE: u32 = 6;
pub const CDERR_LOADRESFAILURE: u32 = 7;
pub const CDERR_LOCKRESFAILURE: u32 = 8;
pub const CDERR_MEMALLOCFAILURE: u32 = 9;
pub const CDERR_MEMLOCKFAILURE: u32 = 10;
pub const CDERR_NOHOOK: u32 = 11;
pub const CDERR_REGISTERMSGFAIL: u32 = 12;
pub const PDERR_PRINTERCODES: u32 = 4096;
pub const PDERR_SETUPFAILURE: u32 = 4097;
pub const PDERR_PARSEFAILURE: u32 = 4098;
pub const PDERR_RETDEFFAILURE: u32 = 4099;
pub const PDERR_LOADDRVFAILURE: u32 = 4100;
pub const PDERR_GETDEVMODEFAIL: u32 = 4101;
pub const PDERR_INITFAILURE: u32 = 4102;
pub const PDERR_NODEVICES: u32 = 4103;
pub const PDERR_NODEFAULTPRN: u32 = 4104;
pub const PDERR_DNDMMISMATCH: u32 = 4105;
pub const PDERR_CREATEICFAILURE: u32 = 4106;
pub const PDERR_PRINTERNOTFOUND: u32 = 4107;
pub const PDERR_DEFAULTDIFFERENT: u32 = 4108;
pub const CFERR_CHOOSEFONTCODES: u32 = 8192;
pub const CFERR_NOFONTS: u32 = 8193;
pub const CFERR_MAXLESSTHANMIN: u32 = 8194;
pub const FNERR_FILENAMECODES: u32 = 12288;
pub const FNERR_SUBCLASSFAILURE: u32 = 12289;
pub const FNERR_INVALIDFILENAME: u32 = 12290;
pub const FNERR_BUFFERTOOSMALL: u32 = 12291;
pub const FRERR_FINDREPLACECODES: u32 = 16384;
pub const FRERR_BUFFERLENGTHZERO: u32 = 16385;
pub const CCERR_CHOOSECOLORCODES: u32 = 20480;
pub const WM_DDE_FIRST: u32 = 992;
pub const WM_DDE_INITIATE: u32 = 992;
pub const WM_DDE_TERMINATE: u32 = 993;
pub const WM_DDE_ADVISE: u32 = 994;
pub const WM_DDE_UNADVISE: u32 = 995;
pub const WM_DDE_ACK: u32 = 996;
pub const WM_DDE_DATA: u32 = 997;
pub const WM_DDE_REQUEST: u32 = 998;
pub const WM_DDE_POKE: u32 = 999;
pub const WM_DDE_EXECUTE: u32 = 1000;
pub const WM_DDE_LAST: u32 = 1000;
pub const XST_NULL: u32 = 0;
pub const XST_INCOMPLETE: u32 = 1;
pub const XST_CONNECTED: u32 = 2;
pub const XST_INIT1: u32 = 3;
pub const XST_INIT2: u32 = 4;
pub const XST_REQSENT: u32 = 5;
pub const XST_DATARCVD: u32 = 6;
pub const XST_POKESENT: u32 = 7;
pub const XST_POKEACKRCVD: u32 = 8;
pub const XST_EXECSENT: u32 = 9;
pub const XST_EXECACKRCVD: u32 = 10;
pub const XST_ADVSENT: u32 = 11;
pub const XST_UNADVSENT: u32 = 12;
pub const XST_ADVACKRCVD: u32 = 13;
pub const XST_UNADVACKRCVD: u32 = 14;
pub const XST_ADVDATASENT: u32 = 15;
pub const XST_ADVDATAACKRCVD: u32 = 16;
pub const CADV_LATEACK: u32 = 65535;
pub const ST_CONNECTED: u32 = 1;
pub const ST_ADVISE: u32 = 2;
pub const ST_ISLOCAL: u32 = 4;
pub const ST_BLOCKED: u32 = 8;
pub const ST_CLIENT: u32 = 16;
pub const ST_TERMINATED: u32 = 32;
pub const ST_INLIST: u32 = 64;
pub const ST_BLOCKNEXT: u32 = 128;
pub const ST_ISSELF: u32 = 256;
pub const DDE_FACK: u32 = 32768;
pub const DDE_FBUSY: u32 = 16384;
pub const DDE_FDEFERUPD: u32 = 16384;
pub const DDE_FACKREQ: u32 = 32768;
pub const DDE_FRELEASE: u32 = 8192;
pub const DDE_FREQUESTED: u32 = 4096;
pub const DDE_FAPPSTATUS: u32 = 255;
pub const DDE_FNOTPROCESSED: u32 = 0;
pub const DDE_FACKRESERVED: i32 = -49408;
pub const DDE_FADVRESERVED: i32 = -49153;
pub const DDE_FDATRESERVED: i32 = -45057;
pub const DDE_FPOKRESERVED: i32 = -8193;
pub const MSGF_DDEMGR: u32 = 32769;
pub const CP_WINANSI: u32 = 1004;
pub const CP_WINUNICODE: u32 = 1200;
pub const CP_WINNEUTRAL: u32 = 1004;
pub const XTYPF_NOBLOCK: u32 = 2;
pub const XTYPF_NODATA: u32 = 4;
pub const XTYPF_ACKREQ: u32 = 8;
pub const XCLASS_MASK: u32 = 64512;
pub const XCLASS_BOOL: u32 = 4096;
pub const XCLASS_DATA: u32 = 8192;
pub const XCLASS_FLAGS: u32 = 16384;
pub const XCLASS_NOTIFICATION: u32 = 32768;
pub const XTYP_ERROR: u32 = 32770;
pub const XTYP_ADVDATA: u32 = 16400;
pub const XTYP_ADVREQ: u32 = 8226;
pub const XTYP_ADVSTART: u32 = 4144;
pub const XTYP_ADVSTOP: u32 = 32832;
pub const XTYP_EXECUTE: u32 = 16464;
pub const XTYP_CONNECT: u32 = 4194;
pub const XTYP_CONNECT_CONFIRM: u32 = 32882;
pub const XTYP_XACT_COMPLETE: u32 = 32896;
pub const XTYP_POKE: u32 = 16528;
pub const XTYP_REGISTER: u32 = 32930;
pub const XTYP_REQUEST: u32 = 8368;
pub const XTYP_DISCONNECT: u32 = 32962;
pub const XTYP_UNREGISTER: u32 = 32978;
pub const XTYP_WILDCONNECT: u32 = 8418;
pub const XTYP_MASK: u32 = 240;
pub const XTYP_SHIFT: u32 = 4;
pub const TIMEOUT_ASYNC: u32 = 4294967295;
pub const QID_SYNC: u32 = 4294967295;
pub const SZDDESYS_TOPIC: &[u8; 7usize] = b"System\0";
pub const SZDDESYS_ITEM_TOPICS: &[u8; 7usize] = b"Topics\0";
pub const SZDDESYS_ITEM_SYSITEMS: &[u8; 9usize] = b"SysItems\0";
pub const SZDDESYS_ITEM_RTNMSG: &[u8; 14usize] = b"ReturnMessage\0";
pub const SZDDESYS_ITEM_STATUS: &[u8; 7usize] = b"Status\0";
pub const SZDDESYS_ITEM_FORMATS: &[u8; 8usize] = b"Formats\0";
pub const SZDDESYS_ITEM_HELP: &[u8; 5usize] = b"Help\0";
pub const SZDDE_ITEM_ITEMLIST: &[u8; 14usize] = b"TopicItemList\0";
pub const CBF_FAIL_SELFCONNECTIONS: u32 = 4096;
pub const CBF_FAIL_CONNECTIONS: u32 = 8192;
pub const CBF_FAIL_ADVISES: u32 = 16384;
pub const CBF_FAIL_EXECUTES: u32 = 32768;
pub const CBF_FAIL_POKES: u32 = 65536;
pub const CBF_FAIL_REQUESTS: u32 = 131072;
pub const CBF_FAIL_ALLSVRXACTIONS: u32 = 258048;
pub const CBF_SKIP_CONNECT_CONFIRMS: u32 = 262144;
pub const CBF_SKIP_REGISTRATIONS: u32 = 524288;
pub const CBF_SKIP_UNREGISTRATIONS: u32 = 1048576;
pub const CBF_SKIP_DISCONNECTS: u32 = 2097152;
pub const CBF_SKIP_ALLNOTIFICATIONS: u32 = 3932160;
pub const APPCMD_CLIENTONLY: u32 = 16;
pub const APPCMD_FILTERINITS: u32 = 32;
pub const APPCMD_MASK: u32 = 4080;
pub const APPCLASS_STANDARD: u32 = 0;
pub const APPCLASS_MASK: u32 = 15;
pub const EC_ENABLEALL: u32 = 0;
pub const EC_ENABLEONE: u32 = 128;
pub const EC_DISABLE: u32 = 8;
pub const EC_QUERYWAITING: u32 = 2;
pub const DNS_REGISTER: u32 = 1;
pub const DNS_UNREGISTER: u32 = 2;
pub const DNS_FILTERON: u32 = 4;
pub const DNS_FILTEROFF: u32 = 8;
pub const HDATA_APPOWNED: u32 = 1;
pub const DMLERR_NO_ERROR: u32 = 0;
pub const DMLERR_FIRST: u32 = 16384;
pub const DMLERR_ADVACKTIMEOUT: u32 = 16384;
pub const DMLERR_BUSY: u32 = 16385;
pub const DMLERR_DATAACKTIMEOUT: u32 = 16386;
pub const DMLERR_DLL_NOT_INITIALIZED: u32 = 16387;
pub const DMLERR_DLL_USAGE: u32 = 16388;
pub const DMLERR_EXECACKTIMEOUT: u32 = 16389;
pub const DMLERR_INVALIDPARAMETER: u32 = 16390;
pub const DMLERR_LOW_MEMORY: u32 = 16391;
pub const DMLERR_MEMORY_ERROR: u32 = 16392;
pub const DMLERR_NOTPROCESSED: u32 = 16393;
pub const DMLERR_NO_CONV_ESTABLISHED: u32 = 16394;
pub const DMLERR_POKEACKTIMEOUT: u32 = 16395;
pub const DMLERR_POSTMSG_FAILED: u32 = 16396;
pub const DMLERR_REENTRANCY: u32 = 16397;
pub const DMLERR_SERVER_DIED: u32 = 16398;
pub const DMLERR_SYS_ERROR: u32 = 16399;
pub const DMLERR_UNADVACKTIMEOUT: u32 = 16400;
pub const DMLERR_UNFOUND_QUEUE_ID: u32 = 16401;
pub const DMLERR_LAST: u32 = 16401;
pub const MH_CREATE: u32 = 1;
pub const MH_KEEP: u32 = 2;
pub const MH_DELETE: u32 = 3;
pub const MH_CLEANUP: u32 = 4;
pub const MAX_MONITORS: u32 = 4;
pub const APPCLASS_MONITOR: u32 = 1;
pub const XTYP_MONITOR: u32 = 33010;
pub const MF_HSZ_INFO: u32 = 16777216;
pub const MF_SENDMSGS: u32 = 33554432;
pub const MF_POSTMSGS: u32 = 67108864;
pub const MF_CALLBACKS: u32 = 134217728;
pub const MF_ERRORS: u32 = 268435456;
pub const MF_LINKS: u32 = 536870912;
pub const MF_CONV: u32 = 1073741824;
pub const MF_MASK: u32 = 4278190080;
pub const ctlFirst: u32 = 1024;
pub const ctlLast: u32 = 1279;
pub const psh1: u32 = 1024;
pub const psh2: u32 = 1025;
pub const psh3: u32 = 1026;
pub const psh4: u32 = 1027;
pub const psh5: u32 = 1028;
pub const psh6: u32 = 1029;
pub const psh7: u32 = 1030;
pub const psh8: u32 = 1031;
pub const psh9: u32 = 1032;
pub const psh10: u32 = 1033;
pub const psh11: u32 = 1034;
pub const psh12: u32 = 1035;
pub const psh13: u32 = 1036;
pub const psh14: u32 = 1037;
pub const psh15: u32 = 1038;
pub const pshHelp: u32 = 1038;
pub const psh16: u32 = 1039;
pub const chx1: u32 = 1040;
pub const chx2: u32 = 1041;
pub const chx3: u32 = 1042;
pub const chx4: u32 = 1043;
pub const chx5: u32 = 1044;
pub const chx6: u32 = 1045;
pub const chx7: u32 = 1046;
pub const chx8: u32 = 1047;
pub const chx9: u32 = 1048;
pub const chx10: u32 = 1049;
pub const chx11: u32 = 1050;
pub const chx12: u32 = 1051;
pub const chx13: u32 = 1052;
pub const chx14: u32 = 1053;
pub const chx15: u32 = 1054;
pub const chx16: u32 = 1055;
pub const rad1: u32 = 1056;
pub const rad2: u32 = 1057;
pub const rad3: u32 = 1058;
pub const rad4: u32 = 1059;
pub const rad5: u32 = 1060;
pub const rad6: u32 = 1061;
pub const rad7: u32 = 1062;
pub const rad8: u32 = 1063;
pub const rad9: u32 = 1064;
pub const rad10: u32 = 1065;
pub const rad11: u32 = 1066;
pub const rad12: u32 = 1067;
pub const rad13: u32 = 1068;
pub const rad14: u32 = 1069;
pub const rad15: u32 = 1070;
pub const rad16: u32 = 1071;
pub const grp1: u32 = 1072;
pub const grp2: u32 = 1073;
pub const grp3: u32 = 1074;
pub const grp4: u32 = 1075;
pub const frm1: u32 = 1076;
pub const frm2: u32 = 1077;
pub const frm3: u32 = 1078;
pub const frm4: u32 = 1079;
pub const rct1: u32 = 1080;
pub const rct2: u32 = 1081;
pub const rct3: u32 = 1082;
pub const rct4: u32 = 1083;
pub const ico1: u32 = 1084;
pub const ico2: u32 = 1085;
pub const ico3: u32 = 1086;
pub const ico4: u32 = 1087;
pub const stc1: u32 = 1088;
pub const stc2: u32 = 1089;
pub const stc3: u32 = 1090;
pub const stc4: u32 = 1091;
pub const stc5: u32 = 1092;
pub const stc6: u32 = 1093;
pub const stc7: u32 = 1094;
pub const stc8: u32 = 1095;
pub const stc9: u32 = 1096;
pub const stc10: u32 = 1097;
pub const stc11: u32 = 1098;
pub const stc12: u32 = 1099;
pub const stc13: u32 = 1100;
pub const stc14: u32 = 1101;
pub const stc15: u32 = 1102;
pub const stc16: u32 = 1103;
pub const stc17: u32 = 1104;
pub const stc18: u32 = 1105;
pub const stc19: u32 = 1106;
pub const stc20: u32 = 1107;
pub const stc21: u32 = 1108;
pub const stc22: u32 = 1109;
pub const stc23: u32 = 1110;
pub const stc24: u32 = 1111;
pub const stc25: u32 = 1112;
pub const stc26: u32 = 1113;
pub const stc27: u32 = 1114;
pub const stc28: u32 = 1115;
pub const stc29: u32 = 1116;
pub const stc30: u32 = 1117;
pub const stc31: u32 = 1118;
pub const stc32: u32 = 1119;
pub const lst1: u32 = 1120;
pub const lst2: u32 = 1121;
pub const lst3: u32 = 1122;
pub const lst4: u32 = 1123;
pub const lst5: u32 = 1124;
pub const lst6: u32 = 1125;
pub const lst7: u32 = 1126;
pub const lst8: u32 = 1127;
pub const lst9: u32 = 1128;
pub const lst10: u32 = 1129;
pub const lst11: u32 = 1130;
pub const lst12: u32 = 1131;
pub const lst13: u32 = 1132;
pub const lst14: u32 = 1133;
pub const lst15: u32 = 1134;
pub const lst16: u32 = 1135;
pub const cmb1: u32 = 1136;
pub const cmb2: u32 = 1137;
pub const cmb3: u32 = 1138;
pub const cmb4: u32 = 1139;
pub const cmb5: u32 = 1140;
pub const cmb6: u32 = 1141;
pub const cmb7: u32 = 1142;
pub const cmb8: u32 = 1143;
pub const cmb9: u32 = 1144;
pub const cmb10: u32 = 1145;
pub const cmb11: u32 = 1146;
pub const cmb12: u32 = 1147;
pub const cmb13: u32 = 1148;
pub const cmb14: u32 = 1149;
pub const cmb15: u32 = 1150;
pub const cmb16: u32 = 1151;
pub const edt1: u32 = 1152;
pub const edt2: u32 = 1153;
pub const edt3: u32 = 1154;
pub const edt4: u32 = 1155;
pub const edt5: u32 = 1156;
pub const edt6: u32 = 1157;
pub const edt7: u32 = 1158;
pub const edt8: u32 = 1159;
pub const edt9: u32 = 1160;
pub const edt10: u32 = 1161;
pub const edt11: u32 = 1162;
pub const edt12: u32 = 1163;
pub const edt13: u32 = 1164;
pub const edt14: u32 = 1165;
pub const edt15: u32 = 1166;
pub const edt16: u32 = 1167;
pub const scr1: u32 = 1168;
pub const scr2: u32 = 1169;
pub const scr3: u32 = 1170;
pub const scr4: u32 = 1171;
pub const scr5: u32 = 1172;
pub const scr6: u32 = 1173;
pub const scr7: u32 = 1174;
pub const scr8: u32 = 1175;
pub const ctl1: u32 = 1184;
pub const FILEOPENORD: u32 = 1536;
pub const MULTIFILEOPENORD: u32 = 1537;
pub const PRINTDLGORD: u32 = 1538;
pub const PRNSETUPDLGORD: u32 = 1539;
pub const FINDDLGORD: u32 = 1540;
pub const REPLACEDLGORD: u32 = 1541;
pub const FONTDLGORD: u32 = 1542;
pub const FORMATDLGORD31: u32 = 1543;
pub const FORMATDLGORD30: u32 = 1544;
pub const RUNDLGORD: u32 = 1545;
pub const PAGESETUPDLGORD: u32 = 1546;
pub const NEWFILEOPENORD: u32 = 1547;
pub const PRINTDLGEXORD: u32 = 1549;
pub const PAGESETUPDLGORDMOTIF: u32 = 1550;
pub const COLORMGMTDLGORD: u32 = 1551;
pub const NEWFILEOPENV2ORD: u32 = 1552;
pub const NEWFILEOPENV3ORD: u32 = 1553;
pub const NEWFORMATDLGWITHLINK: u32 = 1591;
pub const IDC_MANAGE_LINK: u32 = 1592;
pub const LZERROR_BADINHANDLE: i32 = -1;
pub const LZERROR_BADOUTHANDLE: i32 = -2;
pub const LZERROR_READ: i32 = -3;
pub const LZERROR_WRITE: i32 = -4;
pub const LZERROR_GLOBALLOC: i32 = -5;
pub const LZERROR_GLOBLOCK: i32 = -6;
pub const LZERROR_BADVALUE: i32 = -7;
pub const LZERROR_UNKNOWNALG: i32 = -8;
pub const MAXPNAMELEN: u32 = 32;
pub const MAXERRORLENGTH: u32 = 256;
pub const MAX_JOYSTICKOEMVXDNAME: u32 = 260;
pub const TIME_MS: u32 = 1;
pub const TIME_SAMPLES: u32 = 2;
pub const TIME_BYTES: u32 = 4;
pub const TIME_SMPTE: u32 = 8;
pub const TIME_MIDI: u32 = 16;
pub const TIME_TICKS: u32 = 32;
pub const MM_JOY1MOVE: u32 = 928;
pub const MM_JOY2MOVE: u32 = 929;
pub const MM_JOY1ZMOVE: u32 = 930;
pub const MM_JOY2ZMOVE: u32 = 931;
pub const MM_JOY1BUTTONDOWN: u32 = 949;
pub const MM_JOY2BUTTONDOWN: u32 = 950;
pub const MM_JOY1BUTTONUP: u32 = 951;
pub const MM_JOY2BUTTONUP: u32 = 952;
pub const MM_MCINOTIFY: u32 = 953;
pub const MM_WOM_OPEN: u32 = 955;
pub const MM_WOM_CLOSE: u32 = 956;
pub const MM_WOM_DONE: u32 = 957;
pub const MM_WIM_OPEN: u32 = 958;
pub const MM_WIM_CLOSE: u32 = 959;
pub const MM_WIM_DATA: u32 = 960;
pub const MM_MIM_OPEN: u32 = 961;
pub const MM_MIM_CLOSE: u32 = 962;
pub const MM_MIM_DATA: u32 = 963;
pub const MM_MIM_LONGDATA: u32 = 964;
pub const MM_MIM_ERROR: u32 = 965;
pub const MM_MIM_LONGERROR: u32 = 966;
pub const MM_MOM_OPEN: u32 = 967;
pub const MM_MOM_CLOSE: u32 = 968;
pub const MM_MOM_DONE: u32 = 969;
pub const MM_DRVM_OPEN: u32 = 976;
pub const MM_DRVM_CLOSE: u32 = 977;
pub const MM_DRVM_DATA: u32 = 978;
pub const MM_DRVM_ERROR: u32 = 979;
pub const MM_STREAM_OPEN: u32 = 980;
pub const MM_STREAM_CLOSE: u32 = 981;
pub const MM_STREAM_DONE: u32 = 982;
pub const MM_STREAM_ERROR: u32 = 983;
pub const MM_MOM_POSITIONCB: u32 = 970;
pub const MM_MCISIGNAL: u32 = 971;
pub const MM_MIM_MOREDATA: u32 = 972;
pub const MM_MIXM_LINE_CHANGE: u32 = 976;
pub const MM_MIXM_CONTROL_CHANGE: u32 = 977;
pub const MMSYSERR_BASE: u32 = 0;
pub const WAVERR_BASE: u32 = 32;
pub const MIDIERR_BASE: u32 = 64;
pub const TIMERR_BASE: u32 = 96;
pub const JOYERR_BASE: u32 = 160;
pub const MCIERR_BASE: u32 = 256;
pub const MIXERR_BASE: u32 = 1024;
pub const MCI_STRING_OFFSET: u32 = 512;
pub const MCI_VD_OFFSET: u32 = 1024;
pub const MCI_CD_OFFSET: u32 = 1088;
pub const MCI_WAVE_OFFSET: u32 = 1152;
pub const MCI_SEQ_OFFSET: u32 = 1216;
pub const MMSYSERR_NOERROR: u32 = 0;
pub const MMSYSERR_ERROR: u32 = 1;
pub const MMSYSERR_BADDEVICEID: u32 = 2;
pub const MMSYSERR_NOTENABLED: u32 = 3;
pub const MMSYSERR_ALLOCATED: u32 = 4;
pub const MMSYSERR_INVALHANDLE: u32 = 5;
pub const MMSYSERR_NODRIVER: u32 = 6;
pub const MMSYSERR_NOMEM: u32 = 7;
pub const MMSYSERR_NOTSUPPORTED: u32 = 8;
pub const MMSYSERR_BADERRNUM: u32 = 9;
pub const MMSYSERR_INVALFLAG: u32 = 10;
pub const MMSYSERR_INVALPARAM: u32 = 11;
pub const MMSYSERR_HANDLEBUSY: u32 = 12;
pub const MMSYSERR_INVALIDALIAS: u32 = 13;
pub const MMSYSERR_BADDB: u32 = 14;
pub const MMSYSERR_KEYNOTFOUND: u32 = 15;
pub const MMSYSERR_READERROR: u32 = 16;
pub const MMSYSERR_WRITEERROR: u32 = 17;
pub const MMSYSERR_DELETEERROR: u32 = 18;
pub const MMSYSERR_VALNOTFOUND: u32 = 19;
pub const MMSYSERR_NODRIVERCB: u32 = 20;
pub const MMSYSERR_MOREDATA: u32 = 21;
pub const MMSYSERR_LASTERROR: u32 = 21;
pub const CALLBACK_TYPEMASK: u32 = 458752;
pub const CALLBACK_NULL: u32 = 0;
pub const CALLBACK_WINDOW: u32 = 65536;
pub const CALLBACK_TASK: u32 = 131072;
pub const CALLBACK_FUNCTION: u32 = 196608;
pub const CALLBACK_THREAD: u32 = 131072;
pub const CALLBACK_EVENT: u32 = 327680;
pub const MCIERR_INVALID_DEVICE_ID: u32 = 257;
pub const MCIERR_UNRECOGNIZED_KEYWORD: u32 = 259;
pub const MCIERR_UNRECOGNIZED_COMMAND: u32 = 261;
pub const MCIERR_HARDWARE: u32 = 262;
pub const MCIERR_INVALID_DEVICE_NAME: u32 = 263;
pub const MCIERR_OUT_OF_MEMORY: u32 = 264;
pub const MCIERR_DEVICE_OPEN: u32 = 265;
pub const MCIERR_CANNOT_LOAD_DRIVER: u32 = 266;
pub const MCIERR_MISSING_COMMAND_STRING: u32 = 267;
pub const MCIERR_PARAM_OVERFLOW: u32 = 268;
pub const MCIERR_MISSING_STRING_ARGUMENT: u32 = 269;
pub const MCIERR_BAD_INTEGER: u32 = 270;
pub const MCIERR_PARSER_INTERNAL: u32 = 271;
pub const MCIERR_DRIVER_INTERNAL: u32 = 272;
pub const MCIERR_MISSING_PARAMETER: u32 = 273;
pub const MCIERR_UNSUPPORTED_FUNCTION: u32 = 274;
pub const MCIERR_FILE_NOT_FOUND: u32 = 275;
pub const MCIERR_DEVICE_NOT_READY: u32 = 276;
pub const MCIERR_INTERNAL: u32 = 277;
pub const MCIERR_DRIVER: u32 = 278;
pub const MCIERR_CANNOT_USE_ALL: u32 = 279;
pub const MCIERR_MULTIPLE: u32 = 280;
pub const MCIERR_EXTENSION_NOT_FOUND: u32 = 281;
pub const MCIERR_OUTOFRANGE: u32 = 282;
pub const MCIERR_FLAGS_NOT_COMPATIBLE: u32 = 284;
pub const MCIERR_FILE_NOT_SAVED: u32 = 286;
pub const MCIERR_DEVICE_TYPE_REQUIRED: u32 = 287;
pub const MCIERR_DEVICE_LOCKED: u32 = 288;
pub const MCIERR_DUPLICATE_ALIAS: u32 = 289;
pub const MCIERR_BAD_CONSTANT: u32 = 290;
pub const MCIERR_MUST_USE_SHAREABLE: u32 = 291;
pub const MCIERR_MISSING_DEVICE_NAME: u32 = 292;
pub const MCIERR_BAD_TIME_FORMAT: u32 = 293;
pub const MCIERR_NO_CLOSING_QUOTE: u32 = 294;
pub const MCIERR_DUPLICATE_FLAGS: u32 = 295;
pub const MCIERR_INVALID_FILE: u32 = 296;
pub const MCIERR_NULL_PARAMETER_BLOCK: u32 = 297;
pub const MCIERR_UNNAMED_RESOURCE: u32 = 298;
pub const MCIERR_NEW_REQUIRES_ALIAS: u32 = 299;
pub const MCIERR_NOTIFY_ON_AUTO_OPEN: u32 = 300;
pub const MCIERR_NO_ELEMENT_ALLOWED: u32 = 301;
pub const MCIERR_NONAPPLICABLE_FUNCTION: u32 = 302;
pub const MCIERR_ILLEGAL_FOR_AUTO_OPEN: u32 = 303;
pub const MCIERR_FILENAME_REQUIRED: u32 = 304;
pub const MCIERR_EXTRA_CHARACTERS: u32 = 305;
pub const MCIERR_DEVICE_NOT_INSTALLED: u32 = 306;
pub const MCIERR_GET_CD: u32 = 307;
pub const MCIERR_SET_CD: u32 = 308;
pub const MCIERR_SET_DRIVE: u32 = 309;
pub const MCIERR_DEVICE_LENGTH: u32 = 310;
pub const MCIERR_DEVICE_ORD_LENGTH: u32 = 311;
pub const MCIERR_NO_INTEGER: u32 = 312;
pub const MCIERR_WAVE_OUTPUTSINUSE: u32 = 320;
pub const MCIERR_WAVE_SETOUTPUTINUSE: u32 = 321;
pub const MCIERR_WAVE_INPUTSINUSE: u32 = 322;
pub const MCIERR_WAVE_SETINPUTINUSE: u32 = 323;
pub const MCIERR_WAVE_OUTPUTUNSPECIFIED: u32 = 324;
pub const MCIERR_WAVE_INPUTUNSPECIFIED: u32 = 325;
pub const MCIERR_WAVE_OUTPUTSUNSUITABLE: u32 = 326;
pub const MCIERR_WAVE_SETOUTPUTUNSUITABLE: u32 = 327;
pub const MCIERR_WAVE_INPUTSUNSUITABLE: u32 = 328;
pub const MCIERR_WAVE_SETINPUTUNSUITABLE: u32 = 329;
pub const MCIERR_SEQ_DIV_INCOMPATIBLE: u32 = 336;
pub const MCIERR_SEQ_PORT_INUSE: u32 = 337;
pub const MCIERR_SEQ_PORT_NONEXISTENT: u32 = 338;
pub const MCIERR_SEQ_PORT_MAPNODEVICE: u32 = 339;
pub const MCIERR_SEQ_PORT_MISCERROR: u32 = 340;
pub const MCIERR_SEQ_TIMER: u32 = 341;
pub const MCIERR_SEQ_PORTUNSPECIFIED: u32 = 342;
pub const MCIERR_SEQ_NOMIDIPRESENT: u32 = 343;
pub const MCIERR_NO_WINDOW: u32 = 346;
pub const MCIERR_CREATEWINDOW: u32 = 347;
pub const MCIERR_FILE_READ: u32 = 348;
pub const MCIERR_FILE_WRITE: u32 = 349;
pub const MCIERR_NO_IDENTITY: u32 = 350;
pub const MCIERR_CUSTOM_DRIVER_BASE: u32 = 512;
pub const MCI_OPEN: u32 = 2051;
pub const MCI_CLOSE: u32 = 2052;
pub const MCI_ESCAPE: u32 = 2053;
pub const MCI_PLAY: u32 = 2054;
pub const MCI_SEEK: u32 = 2055;
pub const MCI_STOP: u32 = 2056;
pub const MCI_PAUSE: u32 = 2057;
pub const MCI_INFO: u32 = 2058;
pub const MCI_GETDEVCAPS: u32 = 2059;
pub const MCI_SPIN: u32 = 2060;
pub const MCI_SET: u32 = 2061;
pub const MCI_STEP: u32 = 2062;
pub const MCI_RECORD: u32 = 2063;
pub const MCI_SYSINFO: u32 = 2064;
pub const MCI_BREAK: u32 = 2065;
pub const MCI_SAVE: u32 = 2067;
pub const MCI_STATUS: u32 = 2068;
pub const MCI_CUE: u32 = 2096;
pub const MCI_REALIZE: u32 = 2112;
pub const MCI_WINDOW: u32 = 2113;
pub const MCI_PUT: u32 = 2114;
pub const MCI_WHERE: u32 = 2115;
pub const MCI_FREEZE: u32 = 2116;
pub const MCI_UNFREEZE: u32 = 2117;
pub const MCI_LOAD: u32 = 2128;
pub const MCI_CUT: u32 = 2129;
pub const MCI_COPY: u32 = 2130;
pub const MCI_PASTE: u32 = 2131;
pub const MCI_UPDATE: u32 = 2132;
pub const MCI_RESUME: u32 = 2133;
pub const MCI_DELETE: u32 = 2134;
pub const MCI_LAST: u32 = 4095;
pub const MCI_DEVTYPE_VCR: u32 = 513;
pub const MCI_DEVTYPE_VIDEODISC: u32 = 514;
pub const MCI_DEVTYPE_OVERLAY: u32 = 515;
pub const MCI_DEVTYPE_CD_AUDIO: u32 = 516;
pub const MCI_DEVTYPE_DAT: u32 = 517;
pub const MCI_DEVTYPE_SCANNER: u32 = 518;
pub const MCI_DEVTYPE_ANIMATION: u32 = 519;
pub const MCI_DEVTYPE_DIGITAL_VIDEO: u32 = 520;
pub const MCI_DEVTYPE_OTHER: u32 = 521;
pub const MCI_DEVTYPE_WAVEFORM_AUDIO: u32 = 522;
pub const MCI_DEVTYPE_SEQUENCER: u32 = 523;
pub const MCI_DEVTYPE_FIRST: u32 = 513;
pub const MCI_DEVTYPE_LAST: u32 = 523;
pub const MCI_DEVTYPE_FIRST_USER: u32 = 4096;
pub const MCI_MODE_NOT_READY: u32 = 524;
pub const MCI_MODE_STOP: u32 = 525;
pub const MCI_MODE_PLAY: u32 = 526;
pub const MCI_MODE_RECORD: u32 = 527;
pub const MCI_MODE_SEEK: u32 = 528;
pub const MCI_MODE_PAUSE: u32 = 529;
pub const MCI_MODE_OPEN: u32 = 530;
pub const MCI_FORMAT_MILLISECONDS: u32 = 0;
pub const MCI_FORMAT_HMS: u32 = 1;
pub const MCI_FORMAT_MSF: u32 = 2;
pub const MCI_FORMAT_FRAMES: u32 = 3;
pub const MCI_FORMAT_SMPTE_24: u32 = 4;
pub const MCI_FORMAT_SMPTE_25: u32 = 5;
pub const MCI_FORMAT_SMPTE_30: u32 = 6;
pub const MCI_FORMAT_SMPTE_30DROP: u32 = 7;
pub const MCI_FORMAT_BYTES: u32 = 8;
pub const MCI_FORMAT_SAMPLES: u32 = 9;
pub const MCI_FORMAT_TMSF: u32 = 10;
pub const MCI_NOTIFY_SUCCESSFUL: u32 = 1;
pub const MCI_NOTIFY_SUPERSEDED: u32 = 2;
pub const MCI_NOTIFY_ABORTED: u32 = 4;
pub const MCI_NOTIFY_FAILURE: u32 = 8;
pub const MCI_NOTIFY: u32 = 1;
pub const MCI_WAIT: u32 = 2;
pub const MCI_FROM: u32 = 4;
pub const MCI_TO: u32 = 8;
pub const MCI_TRACK: u32 = 16;
pub const MCI_OPEN_SHAREABLE: u32 = 256;
pub const MCI_OPEN_ELEMENT: u32 = 512;
pub const MCI_OPEN_ALIAS: u32 = 1024;
pub const MCI_OPEN_ELEMENT_ID: u32 = 2048;
pub const MCI_OPEN_TYPE_ID: u32 = 4096;
pub const MCI_OPEN_TYPE: u32 = 8192;
pub const MCI_SEEK_TO_START: u32 = 256;
pub const MCI_SEEK_TO_END: u32 = 512;
pub const MCI_STATUS_ITEM: u32 = 256;
pub const MCI_STATUS_START: u32 = 512;
pub const MCI_STATUS_LENGTH: u32 = 1;
pub const MCI_STATUS_POSITION: u32 = 2;
pub const MCI_STATUS_NUMBER_OF_TRACKS: u32 = 3;
pub const MCI_STATUS_MODE: u32 = 4;
pub const MCI_STATUS_MEDIA_PRESENT: u32 = 5;
pub const MCI_STATUS_TIME_FORMAT: u32 = 6;
pub const MCI_STATUS_READY: u32 = 7;
pub const MCI_STATUS_CURRENT_TRACK: u32 = 8;
pub const MCI_INFO_PRODUCT: u32 = 256;
pub const MCI_INFO_FILE: u32 = 512;
pub const MCI_INFO_MEDIA_UPC: u32 = 1024;
pub const MCI_INFO_MEDIA_IDENTITY: u32 = 2048;
pub const MCI_INFO_NAME: u32 = 4096;
pub const MCI_INFO_COPYRIGHT: u32 = 8192;
pub const MCI_GETDEVCAPS_ITEM: u32 = 256;
pub const MCI_GETDEVCAPS_CAN_RECORD: u32 = 1;
pub const MCI_GETDEVCAPS_HAS_AUDIO: u32 = 2;
pub const MCI_GETDEVCAPS_HAS_VIDEO: u32 = 3;
pub const MCI_GETDEVCAPS_DEVICE_TYPE: u32 = 4;
pub const MCI_GETDEVCAPS_USES_FILES: u32 = 5;
pub const MCI_GETDEVCAPS_COMPOUND_DEVICE: u32 = 6;
pub const MCI_GETDEVCAPS_CAN_EJECT: u32 = 7;
pub const MCI_GETDEVCAPS_CAN_PLAY: u32 = 8;
pub const MCI_GETDEVCAPS_CAN_SAVE: u32 = 9;
pub const MCI_SYSINFO_QUANTITY: u32 = 256;
pub const MCI_SYSINFO_OPEN: u32 = 512;
pub const MCI_SYSINFO_NAME: u32 = 1024;
pub const MCI_SYSINFO_INSTALLNAME: u32 = 2048;
pub const MCI_SET_DOOR_OPEN: u32 = 256;
pub const MCI_SET_DOOR_CLOSED: u32 = 512;
pub const MCI_SET_TIME_FORMAT: u32 = 1024;
pub const MCI_SET_AUDIO: u32 = 2048;
pub const MCI_SET_VIDEO: u32 = 4096;
pub const MCI_SET_ON: u32 = 8192;
pub const MCI_SET_OFF: u32 = 16384;
pub const MCI_SET_AUDIO_ALL: u32 = 0;
pub const MCI_SET_AUDIO_LEFT: u32 = 1;
pub const MCI_SET_AUDIO_RIGHT: u32 = 2;
pub const MCI_BREAK_KEY: u32 = 256;
pub const MCI_BREAK_HWND: u32 = 512;
pub const MCI_BREAK_OFF: u32 = 1024;
pub const MCI_RECORD_INSERT: u32 = 256;
pub const MCI_RECORD_OVERWRITE: u32 = 512;
pub const MCI_SAVE_FILE: u32 = 256;
pub const MCI_LOAD_FILE: u32 = 256;
pub const MCI_VD_MODE_PARK: u32 = 1025;
pub const MCI_VD_MEDIA_CLV: u32 = 1026;
pub const MCI_VD_MEDIA_CAV: u32 = 1027;
pub const MCI_VD_MEDIA_OTHER: u32 = 1028;
pub const MCI_VD_FORMAT_TRACK: u32 = 16385;
pub const MCI_VD_PLAY_REVERSE: u32 = 65536;
pub const MCI_VD_PLAY_FAST: u32 = 131072;
pub const MCI_VD_PLAY_SPEED: u32 = 262144;
pub const MCI_VD_PLAY_SCAN: u32 = 524288;
pub const MCI_VD_PLAY_SLOW: u32 = 1048576;
pub const MCI_VD_SEEK_REVERSE: u32 = 65536;
pub const MCI_VD_STATUS_SPEED: u32 = 16386;
pub const MCI_VD_STATUS_FORWARD: u32 = 16387;
pub const MCI_VD_STATUS_MEDIA_TYPE: u32 = 16388;
pub const MCI_VD_STATUS_SIDE: u32 = 16389;
pub const MCI_VD_STATUS_DISC_SIZE: u32 = 16390;
pub const MCI_VD_GETDEVCAPS_CLV: u32 = 65536;
pub const MCI_VD_GETDEVCAPS_CAV: u32 = 131072;
pub const MCI_VD_SPIN_UP: u32 = 65536;
pub const MCI_VD_SPIN_DOWN: u32 = 131072;
pub const MCI_VD_GETDEVCAPS_CAN_REVERSE: u32 = 16386;
pub const MCI_VD_GETDEVCAPS_FAST_RATE: u32 = 16387;
pub const MCI_VD_GETDEVCAPS_SLOW_RATE: u32 = 16388;
pub const MCI_VD_GETDEVCAPS_NORMAL_RATE: u32 = 16389;
pub const MCI_VD_STEP_FRAMES: u32 = 65536;
pub const MCI_VD_STEP_REVERSE: u32 = 131072;
pub const MCI_VD_ESCAPE_STRING: u32 = 256;
pub const MCI_CDA_STATUS_TYPE_TRACK: u32 = 16385;
pub const MCI_CDA_TRACK_AUDIO: u32 = 1088;
pub const MCI_CDA_TRACK_OTHER: u32 = 1089;
pub const MCI_WAVE_PCM: u32 = 1152;
pub const MCI_WAVE_MAPPER: u32 = 1153;
pub const MCI_WAVE_OPEN_BUFFER: u32 = 65536;
pub const MCI_WAVE_SET_FORMATTAG: u32 = 65536;
pub const MCI_WAVE_SET_CHANNELS: u32 = 131072;
pub const MCI_WAVE_SET_SAMPLESPERSEC: u32 = 262144;
pub const MCI_WAVE_SET_AVGBYTESPERSEC: u32 = 524288;
pub const MCI_WAVE_SET_BLOCKALIGN: u32 = 1048576;
pub const MCI_WAVE_SET_BITSPERSAMPLE: u32 = 2097152;
pub const MCI_WAVE_INPUT: u32 = 4194304;
pub const MCI_WAVE_OUTPUT: u32 = 8388608;
pub const MCI_WAVE_STATUS_FORMATTAG: u32 = 16385;
pub const MCI_WAVE_STATUS_CHANNELS: u32 = 16386;
pub const MCI_WAVE_STATUS_SAMPLESPERSEC: u32 = 16387;
pub const MCI_WAVE_STATUS_AVGBYTESPERSEC: u32 = 16388;
pub const MCI_WAVE_STATUS_BLOCKALIGN: u32 = 16389;
pub const MCI_WAVE_STATUS_BITSPERSAMPLE: u32 = 16390;
pub const MCI_WAVE_STATUS_LEVEL: u32 = 16391;
pub const MCI_WAVE_SET_ANYINPUT: u32 = 67108864;
pub const MCI_WAVE_SET_ANYOUTPUT: u32 = 134217728;
pub const MCI_WAVE_GETDEVCAPS_INPUTS: u32 = 16385;
pub const MCI_WAVE_GETDEVCAPS_OUTPUTS: u32 = 16386;
pub const MCI_SEQ_DIV_PPQN: u32 = 1216;
pub const MCI_SEQ_DIV_SMPTE_24: u32 = 1217;
pub const MCI_SEQ_DIV_SMPTE_25: u32 = 1218;
pub const MCI_SEQ_DIV_SMPTE_30DROP: u32 = 1219;
pub const MCI_SEQ_DIV_SMPTE_30: u32 = 1220;
pub const MCI_SEQ_FORMAT_SONGPTR: u32 = 16385;
pub const MCI_SEQ_FILE: u32 = 16386;
pub const MCI_SEQ_MIDI: u32 = 16387;
pub const MCI_SEQ_SMPTE: u32 = 16388;
pub const MCI_SEQ_NONE: u32 = 65533;
pub const MCI_SEQ_MAPPER: u32 = 65535;
pub const MCI_SEQ_STATUS_TEMPO: u32 = 16386;
pub const MCI_SEQ_STATUS_PORT: u32 = 16387;
pub const MCI_SEQ_STATUS_SLAVE: u32 = 16391;
pub const MCI_SEQ_STATUS_MASTER: u32 = 16392;
pub const MCI_SEQ_STATUS_OFFSET: u32 = 16393;
pub const MCI_SEQ_STATUS_DIVTYPE: u32 = 16394;
pub const MCI_SEQ_STATUS_NAME: u32 = 16395;
pub const MCI_SEQ_STATUS_COPYRIGHT: u32 = 16396;
pub const MCI_SEQ_SET_TEMPO: u32 = 65536;
pub const MCI_SEQ_SET_PORT: u32 = 131072;
pub const MCI_SEQ_SET_SLAVE: u32 = 262144;
pub const MCI_SEQ_SET_MASTER: u32 = 524288;
pub const MCI_SEQ_SET_OFFSET: u32 = 16777216;
pub const MCI_ANIM_OPEN_WS: u32 = 65536;
pub const MCI_ANIM_OPEN_PARENT: u32 = 131072;
pub const MCI_ANIM_OPEN_NOSTATIC: u32 = 262144;
pub const MCI_ANIM_PLAY_SPEED: u32 = 65536;
pub const MCI_ANIM_PLAY_REVERSE: u32 = 131072;
pub const MCI_ANIM_PLAY_FAST: u32 = 262144;
pub const MCI_ANIM_PLAY_SLOW: u32 = 524288;
pub const MCI_ANIM_PLAY_SCAN: u32 = 1048576;
pub const MCI_ANIM_STEP_REVERSE: u32 = 65536;
pub const MCI_ANIM_STEP_FRAMES: u32 = 131072;
pub const MCI_ANIM_STATUS_SPEED: u32 = 16385;
pub const MCI_ANIM_STATUS_FORWARD: u32 = 16386;
pub const MCI_ANIM_STATUS_HWND: u32 = 16387;
pub const MCI_ANIM_STATUS_HPAL: u32 = 16388;
pub const MCI_ANIM_STATUS_STRETCH: u32 = 16389;
pub const MCI_ANIM_INFO_TEXT: u32 = 65536;
pub const MCI_ANIM_GETDEVCAPS_CAN_REVERSE: u32 = 16385;
pub const MCI_ANIM_GETDEVCAPS_FAST_RATE: u32 = 16386;
pub const MCI_ANIM_GETDEVCAPS_SLOW_RATE: u32 = 16387;
pub const MCI_ANIM_GETDEVCAPS_NORMAL_RATE: u32 = 16388;
pub const MCI_ANIM_GETDEVCAPS_PALETTES: u32 = 16390;
pub const MCI_ANIM_GETDEVCAPS_CAN_STRETCH: u32 = 16391;
pub const MCI_ANIM_GETDEVCAPS_MAX_WINDOWS: u32 = 16392;
pub const MCI_ANIM_REALIZE_NORM: u32 = 65536;
pub const MCI_ANIM_REALIZE_BKGD: u32 = 131072;
pub const MCI_ANIM_WINDOW_HWND: u32 = 65536;
pub const MCI_ANIM_WINDOW_STATE: u32 = 262144;
pub const MCI_ANIM_WINDOW_TEXT: u32 = 524288;
pub const MCI_ANIM_WINDOW_ENABLE_STRETCH: u32 = 1048576;
pub const MCI_ANIM_WINDOW_DISABLE_STRETCH: u32 = 2097152;
pub const MCI_ANIM_WINDOW_DEFAULT: u32 = 0;
pub const MCI_ANIM_RECT: u32 = 65536;
pub const MCI_ANIM_PUT_SOURCE: u32 = 131072;
pub const MCI_ANIM_PUT_DESTINATION: u32 = 262144;
pub const MCI_ANIM_WHERE_SOURCE: u32 = 131072;
pub const MCI_ANIM_WHERE_DESTINATION: u32 = 262144;
pub const MCI_ANIM_UPDATE_HDC: u32 = 131072;
pub const MCI_OVLY_OPEN_WS: u32 = 65536;
pub const MCI_OVLY_OPEN_PARENT: u32 = 131072;
pub const MCI_OVLY_STATUS_HWND: u32 = 16385;
pub const MCI_OVLY_STATUS_STRETCH: u32 = 16386;
pub const MCI_OVLY_INFO_TEXT: u32 = 65536;
pub const MCI_OVLY_GETDEVCAPS_CAN_STRETCH: u32 = 16385;
pub const MCI_OVLY_GETDEVCAPS_CAN_FREEZE: u32 = 16386;
pub const MCI_OVLY_GETDEVCAPS_MAX_WINDOWS: u32 = 16387;
pub const MCI_OVLY_WINDOW_HWND: u32 = 65536;
pub const MCI_OVLY_WINDOW_STATE: u32 = 262144;
pub const MCI_OVLY_WINDOW_TEXT: u32 = 524288;
pub const MCI_OVLY_WINDOW_ENABLE_STRETCH: u32 = 1048576;
pub const MCI_OVLY_WINDOW_DISABLE_STRETCH: u32 = 2097152;
pub const MCI_OVLY_WINDOW_DEFAULT: u32 = 0;
pub const MCI_OVLY_RECT: u32 = 65536;
pub const MCI_OVLY_PUT_SOURCE: u32 = 131072;
pub const MCI_OVLY_PUT_DESTINATION: u32 = 262144;
pub const MCI_OVLY_PUT_FRAME: u32 = 524288;
pub const MCI_OVLY_PUT_VIDEO: u32 = 1048576;
pub const MCI_OVLY_WHERE_SOURCE: u32 = 131072;
pub const MCI_OVLY_WHERE_DESTINATION: u32 = 262144;
pub const MCI_OVLY_WHERE_FRAME: u32 = 524288;
pub const MCI_OVLY_WHERE_VIDEO: u32 = 1048576;
pub const DRV_LOAD: u32 = 1;
pub const DRV_ENABLE: u32 = 2;
pub const DRV_OPEN: u32 = 3;
pub const DRV_CLOSE: u32 = 4;
pub const DRV_DISABLE: u32 = 5;
pub const DRV_FREE: u32 = 6;
pub const DRV_CONFIGURE: u32 = 7;
pub const DRV_QUERYCONFIGURE: u32 = 8;
pub const DRV_INSTALL: u32 = 9;
pub const DRV_REMOVE: u32 = 10;
pub const DRV_EXITSESSION: u32 = 11;
pub const DRV_POWER: u32 = 15;
pub const DRV_RESERVED: u32 = 2048;
pub const DRV_USER: u32 = 16384;
pub const DRVCNF_CANCEL: u32 = 0;
pub const DRVCNF_OK: u32 = 1;
pub const DRVCNF_RESTART: u32 = 2;
pub const DRV_CANCEL: u32 = 0;
pub const DRV_OK: u32 = 1;
pub const DRV_RESTART: u32 = 2;
pub const DRV_MCI_FIRST: u32 = 2048;
pub const DRV_MCI_LAST: u32 = 6143;
pub const MMIOERR_BASE: u32 = 256;
pub const MMIOERR_FILENOTFOUND: u32 = 257;
pub const MMIOERR_OUTOFMEMORY: u32 = 258;
pub const MMIOERR_CANNOTOPEN: u32 = 259;
pub const MMIOERR_CANNOTCLOSE: u32 = 260;
pub const MMIOERR_CANNOTREAD: u32 = 261;
pub const MMIOERR_CANNOTWRITE: u32 = 262;
pub const MMIOERR_CANNOTSEEK: u32 = 263;
pub const MMIOERR_CANNOTEXPAND: u32 = 264;
pub const MMIOERR_CHUNKNOTFOUND: u32 = 265;
pub const MMIOERR_UNBUFFERED: u32 = 266;
pub const MMIOERR_PATHNOTFOUND: u32 = 267;
pub const MMIOERR_ACCESSDENIED: u32 = 268;
pub const MMIOERR_SHARINGVIOLATION: u32 = 269;
pub const MMIOERR_NETWORKERROR: u32 = 270;
pub const MMIOERR_TOOMANYOPENFILES: u32 = 271;
pub const MMIOERR_INVALIDFILE: u32 = 272;
pub const CFSEPCHAR: u8 = 43u8;
pub const MMIO_RWMODE: u32 = 3;
pub const MMIO_SHAREMODE: u32 = 112;
pub const MMIO_CREATE: u32 = 4096;
pub const MMIO_PARSE: u32 = 256;
pub const MMIO_DELETE: u32 = 512;
pub const MMIO_EXIST: u32 = 16384;
pub const MMIO_ALLOCBUF: u32 = 65536;
pub const MMIO_GETTEMP: u32 = 131072;
pub const MMIO_DIRTY: u32 = 268435456;
pub const MMIO_READ: u32 = 0;
pub const MMIO_WRITE: u32 = 1;
pub const MMIO_READWRITE: u32 = 2;
pub const MMIO_COMPAT: u32 = 0;
pub const MMIO_EXCLUSIVE: u32 = 16;
pub const MMIO_DENYWRITE: u32 = 32;
pub const MMIO_DENYREAD: u32 = 48;
pub const MMIO_DENYNONE: u32 = 64;
pub const MMIO_FHOPEN: u32 = 16;
pub const MMIO_EMPTYBUF: u32 = 16;
pub const MMIO_TOUPPER: u32 = 16;
pub const MMIO_INSTALLPROC: u32 = 65536;
pub const MMIO_GLOBALPROC: u32 = 268435456;
pub const MMIO_REMOVEPROC: u32 = 131072;
pub const MMIO_UNICODEPROC: u32 = 16777216;
pub const MMIO_FINDPROC: u32 = 262144;
pub const MMIO_FINDCHUNK: u32 = 16;
pub const MMIO_FINDRIFF: u32 = 32;
pub const MMIO_FINDLIST: u32 = 64;
pub const MMIO_CREATERIFF: u32 = 32;
pub const MMIO_CREATELIST: u32 = 64;
pub const MMIOM_READ: u32 = 0;
pub const MMIOM_WRITE: u32 = 1;
pub const MMIOM_SEEK: u32 = 2;
pub const MMIOM_OPEN: u32 = 3;
pub const MMIOM_CLOSE: u32 = 4;
pub const MMIOM_WRITEFLUSH: u32 = 5;
pub const MMIOM_RENAME: u32 = 6;
pub const MMIOM_USER: u32 = 32768;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const MMIO_DEFAULTBUFFER: u32 = 8192;
pub const TIME_ONESHOT: u32 = 0;
pub const TIME_PERIODIC: u32 = 1;
pub const TIME_CALLBACK_FUNCTION: u32 = 0;
pub const TIME_CALLBACK_EVENT_SET: u32 = 16;
pub const TIME_CALLBACK_EVENT_PULSE: u32 = 32;
pub const TIME_KILL_SYNCHRONOUS: u32 = 256;
pub const SND_SYNC: u32 = 0;
pub const SND_ASYNC: u32 = 1;
pub const SND_NODEFAULT: u32 = 2;
pub const SND_MEMORY: u32 = 4;
pub const SND_LOOP: u32 = 8;
pub const SND_NOSTOP: u32 = 16;
pub const SND_NOWAIT: u32 = 8192;
pub const SND_ALIAS: u32 = 65536;
pub const SND_ALIAS_ID: u32 = 1114112;
pub const SND_FILENAME: u32 = 131072;
pub const SND_RESOURCE: u32 = 262148;
pub const SND_PURGE: u32 = 64;
pub const SND_APPLICATION: u32 = 128;
pub const SND_SENTRY: u32 = 524288;
pub const SND_RING: u32 = 1048576;
pub const SND_SYSTEM: u32 = 2097152;
pub const SND_ALIAS_START: u32 = 0;
pub const WAVERR_BADFORMAT: u32 = 32;
pub const WAVERR_STILLPLAYING: u32 = 33;
pub const WAVERR_UNPREPARED: u32 = 34;
pub const WAVERR_SYNC: u32 = 35;
pub const WAVERR_LASTERROR: u32 = 35;
pub const WOM_OPEN: u32 = 955;
pub const WOM_CLOSE: u32 = 956;
pub const WOM_DONE: u32 = 957;
pub const WIM_OPEN: u32 = 958;
pub const WIM_CLOSE: u32 = 959;
pub const WIM_DATA: u32 = 960;
pub const WAVE_FORMAT_QUERY: u32 = 1;
pub const WAVE_ALLOWSYNC: u32 = 2;
pub const WAVE_MAPPED: u32 = 4;
pub const WAVE_FORMAT_DIRECT: u32 = 8;
pub const WAVE_FORMAT_DIRECT_QUERY: u32 = 9;
pub const WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE: u32 = 16;
pub const WHDR_DONE: u32 = 1;
pub const WHDR_PREPARED: u32 = 2;
pub const WHDR_BEGINLOOP: u32 = 4;
pub const WHDR_ENDLOOP: u32 = 8;
pub const WHDR_INQUEUE: u32 = 16;
pub const WAVECAPS_PITCH: u32 = 1;
pub const WAVECAPS_PLAYBACKRATE: u32 = 2;
pub const WAVECAPS_VOLUME: u32 = 4;
pub const WAVECAPS_LRVOLUME: u32 = 8;
pub const WAVECAPS_SYNC: u32 = 16;
pub const WAVECAPS_SAMPLEACCURATE: u32 = 32;
pub const WAVE_INVALIDFORMAT: u32 = 0;
pub const WAVE_FORMAT_1M08: u32 = 1;
pub const WAVE_FORMAT_1S08: u32 = 2;
pub const WAVE_FORMAT_1M16: u32 = 4;
pub const WAVE_FORMAT_1S16: u32 = 8;
pub const WAVE_FORMAT_2M08: u32 = 16;
pub const WAVE_FORMAT_2S08: u32 = 32;
pub const WAVE_FORMAT_2M16: u32 = 64;
pub const WAVE_FORMAT_2S16: u32 = 128;
pub const WAVE_FORMAT_4M08: u32 = 256;
pub const WAVE_FORMAT_4S08: u32 = 512;
pub const WAVE_FORMAT_4M16: u32 = 1024;
pub const WAVE_FORMAT_4S16: u32 = 2048;
pub const WAVE_FORMAT_44M08: u32 = 256;
pub const WAVE_FORMAT_44S08: u32 = 512;
pub const WAVE_FORMAT_44M16: u32 = 1024;
pub const WAVE_FORMAT_44S16: u32 = 2048;
pub const WAVE_FORMAT_48M08: u32 = 4096;
pub const WAVE_FORMAT_48S08: u32 = 8192;
pub const WAVE_FORMAT_48M16: u32 = 16384;
pub const WAVE_FORMAT_48S16: u32 = 32768;
pub const WAVE_FORMAT_96M08: u32 = 65536;
pub const WAVE_FORMAT_96S08: u32 = 131072;
pub const WAVE_FORMAT_96M16: u32 = 262144;
pub const WAVE_FORMAT_96S16: u32 = 524288;
pub const WAVE_FORMAT_PCM: u32 = 1;
pub const MIDIERR_UNPREPARED: u32 = 64;
pub const MIDIERR_STILLPLAYING: u32 = 65;
pub const MIDIERR_NOMAP: u32 = 66;
pub const MIDIERR_NOTREADY: u32 = 67;
pub const MIDIERR_NODEVICE: u32 = 68;
pub const MIDIERR_INVALIDSETUP: u32 = 69;
pub const MIDIERR_BADOPENMODE: u32 = 70;
pub const MIDIERR_DONT_CONTINUE: u32 = 71;
pub const MIDIERR_LASTERROR: u32 = 71;
pub const MIDIPATCHSIZE: u32 = 128;
pub const MIM_OPEN: u32 = 961;
pub const MIM_CLOSE: u32 = 962;
pub const MIM_DATA: u32 = 963;
pub const MIM_LONGDATA: u32 = 964;
pub const MIM_ERROR: u32 = 965;
pub const MIM_LONGERROR: u32 = 966;
pub const MOM_OPEN: u32 = 967;
pub const MOM_CLOSE: u32 = 968;
pub const MOM_DONE: u32 = 969;
pub const MIM_MOREDATA: u32 = 972;
pub const MOM_POSITIONCB: u32 = 970;
pub const MIDI_IO_STATUS: u32 = 32;
pub const MIDI_CACHE_ALL: u32 = 1;
pub const MIDI_CACHE_BESTFIT: u32 = 2;
pub const MIDI_CACHE_QUERY: u32 = 3;
pub const MIDI_UNCACHE: u32 = 4;
pub const MOD_MIDIPORT: u32 = 1;
pub const MOD_SYNTH: u32 = 2;
pub const MOD_SQSYNTH: u32 = 3;
pub const MOD_FMSYNTH: u32 = 4;
pub const MOD_MAPPER: u32 = 5;
pub const MOD_WAVETABLE: u32 = 6;
pub const MOD_SWSYNTH: u32 = 7;
pub const MIDICAPS_VOLUME: u32 = 1;
pub const MIDICAPS_LRVOLUME: u32 = 2;
pub const MIDICAPS_CACHE: u32 = 4;
pub const MIDICAPS_STREAM: u32 = 8;
pub const MHDR_DONE: u32 = 1;
pub const MHDR_PREPARED: u32 = 2;
pub const MHDR_INQUEUE: u32 = 4;
pub const MHDR_ISSTRM: u32 = 8;
pub const MEVT_F_SHORT: u32 = 0;
pub const MEVT_F_LONG: u32 = 2147483648;
pub const MEVT_F_CALLBACK: u32 = 1073741824;
pub const MIDISTRM_ERROR: i32 = -2;
pub const MIDIPROP_SET: u32 = 2147483648;
pub const MIDIPROP_GET: u32 = 1073741824;
pub const MIDIPROP_TIMEDIV: u32 = 1;
pub const MIDIPROP_TEMPO: u32 = 2;
pub const AUXCAPS_CDAUDIO: u32 = 1;
pub const AUXCAPS_AUXIN: u32 = 2;
pub const AUXCAPS_VOLUME: u32 = 1;
pub const AUXCAPS_LRVOLUME: u32 = 2;
pub const MIXER_SHORT_NAME_CHARS: u32 = 16;
pub const MIXER_LONG_NAME_CHARS: u32 = 64;
pub const MIXERR_INVALLINE: u32 = 1024;
pub const MIXERR_INVALCONTROL: u32 = 1025;
pub const MIXERR_INVALVALUE: u32 = 1026;
pub const MIXERR_LASTERROR: u32 = 1026;
pub const MIXER_OBJECTF_HANDLE: u32 = 2147483648;
pub const MIXER_OBJECTF_MIXER: u32 = 0;
pub const MIXER_OBJECTF_HMIXER: u32 = 2147483648;
pub const MIXER_OBJECTF_WAVEOUT: u32 = 268435456;
pub const MIXER_OBJECTF_HWAVEOUT: u32 = 2415919104;
pub const MIXER_OBJECTF_WAVEIN: u32 = 536870912;
pub const MIXER_OBJECTF_HWAVEIN: u32 = 2684354560;
pub const MIXER_OBJECTF_MIDIOUT: u32 = 805306368;
pub const MIXER_OBJECTF_HMIDIOUT: u32 = 2952790016;
pub const MIXER_OBJECTF_MIDIIN: u32 = 1073741824;
pub const MIXER_OBJECTF_HMIDIIN: u32 = 3221225472;
pub const MIXER_OBJECTF_AUX: u32 = 1342177280;
pub const MIXERLINE_LINEF_ACTIVE: u32 = 1;
pub const MIXERLINE_LINEF_DISCONNECTED: u32 = 32768;
pub const MIXERLINE_LINEF_SOURCE: u32 = 2147483648;
pub const MIXERLINE_COMPONENTTYPE_DST_FIRST: u32 = 0;
pub const MIXERLINE_COMPONENTTYPE_DST_UNDEFINED: u32 = 0;
pub const MIXERLINE_COMPONENTTYPE_DST_DIGITAL: u32 = 1;
pub const MIXERLINE_COMPONENTTYPE_DST_LINE: u32 = 2;
pub const MIXERLINE_COMPONENTTYPE_DST_MONITOR: u32 = 3;
pub const MIXERLINE_COMPONENTTYPE_DST_SPEAKERS: u32 = 4;
pub const MIXERLINE_COMPONENTTYPE_DST_HEADPHONES: u32 = 5;
pub const MIXERLINE_COMPONENTTYPE_DST_TELEPHONE: u32 = 6;
pub const MIXERLINE_COMPONENTTYPE_DST_WAVEIN: u32 = 7;
pub const MIXERLINE_COMPONENTTYPE_DST_VOICEIN: u32 = 8;
pub const MIXERLINE_COMPONENTTYPE_DST_LAST: u32 = 8;
pub const MIXERLINE_COMPONENTTYPE_SRC_FIRST: u32 = 4096;
pub const MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED: u32 = 4096;
pub const MIXERLINE_COMPONENTTYPE_SRC_DIGITAL: u32 = 4097;
pub const MIXERLINE_COMPONENTTYPE_SRC_LINE: u32 = 4098;
pub const MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE: u32 = 4099;
pub const MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER: u32 = 4100;
pub const MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC: u32 = 4101;
pub const MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE: u32 = 4102;
pub const MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER: u32 = 4103;
pub const MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT: u32 = 4104;
pub const MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY: u32 = 4105;
pub const MIXERLINE_COMPONENTTYPE_SRC_ANALOG: u32 = 4106;
pub const MIXERLINE_COMPONENTTYPE_SRC_LAST: u32 = 4106;
pub const MIXERLINE_TARGETTYPE_UNDEFINED: u32 = 0;
pub const MIXERLINE_TARGETTYPE_WAVEOUT: u32 = 1;
pub const MIXERLINE_TARGETTYPE_WAVEIN: u32 = 2;
pub const MIXERLINE_TARGETTYPE_MIDIOUT: u32 = 3;
pub const MIXERLINE_TARGETTYPE_MIDIIN: u32 = 4;
pub const MIXERLINE_TARGETTYPE_AUX: u32 = 5;
pub const MIXER_GETLINEINFOF_DESTINATION: u32 = 0;
pub const MIXER_GETLINEINFOF_SOURCE: u32 = 1;
pub const MIXER_GETLINEINFOF_LINEID: u32 = 2;
pub const MIXER_GETLINEINFOF_COMPONENTTYPE: u32 = 3;
pub const MIXER_GETLINEINFOF_TARGETTYPE: u32 = 4;
pub const MIXER_GETLINEINFOF_QUERYMASK: u32 = 15;
pub const MIXERCONTROL_CONTROLF_UNIFORM: u32 = 1;
pub const MIXERCONTROL_CONTROLF_MULTIPLE: u32 = 2;
pub const MIXERCONTROL_CONTROLF_DISABLED: u32 = 2147483648;
pub const MIXERCONTROL_CT_CLASS_MASK: u32 = 4026531840;
pub const MIXERCONTROL_CT_CLASS_CUSTOM: u32 = 0;
pub const MIXERCONTROL_CT_CLASS_METER: u32 = 268435456;
pub const MIXERCONTROL_CT_CLASS_SWITCH: u32 = 536870912;
pub const MIXERCONTROL_CT_CLASS_NUMBER: u32 = 805306368;
pub const MIXERCONTROL_CT_CLASS_SLIDER: u32 = 1073741824;
pub const MIXERCONTROL_CT_CLASS_FADER: u32 = 1342177280;
pub const MIXERCONTROL_CT_CLASS_TIME: u32 = 1610612736;
pub const MIXERCONTROL_CT_CLASS_LIST: u32 = 1879048192;
pub const MIXERCONTROL_CT_SUBCLASS_MASK: u32 = 251658240;
pub const MIXERCONTROL_CT_SC_SWITCH_BOOLEAN: u32 = 0;
pub const MIXERCONTROL_CT_SC_SWITCH_BUTTON: u32 = 16777216;
pub const MIXERCONTROL_CT_SC_METER_POLLED: u32 = 0;
pub const MIXERCONTROL_CT_SC_TIME_MICROSECS: u32 = 0;
pub const MIXERCONTROL_CT_SC_TIME_MILLISECS: u32 = 16777216;
pub const MIXERCONTROL_CT_SC_LIST_SINGLE: u32 = 0;
pub const MIXERCONTROL_CT_SC_LIST_MULTIPLE: u32 = 16777216;
pub const MIXERCONTROL_CT_UNITS_MASK: u32 = 16711680;
pub const MIXERCONTROL_CT_UNITS_CUSTOM: u32 = 0;
pub const MIXERCONTROL_CT_UNITS_BOOLEAN: u32 = 65536;
pub const MIXERCONTROL_CT_UNITS_SIGNED: u32 = 131072;
pub const MIXERCONTROL_CT_UNITS_UNSIGNED: u32 = 196608;
pub const MIXERCONTROL_CT_UNITS_DECIBELS: u32 = 262144;
pub const MIXERCONTROL_CT_UNITS_PERCENT: u32 = 327680;
pub const MIXERCONTROL_CONTROLTYPE_CUSTOM: u32 = 0;
pub const MIXERCONTROL_CONTROLTYPE_BOOLEANMETER: u32 = 268500992;
pub const MIXERCONTROL_CONTROLTYPE_SIGNEDMETER: u32 = 268566528;
pub const MIXERCONTROL_CONTROLTYPE_PEAKMETER: u32 = 268566529;
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER: u32 = 268632064;
pub const MIXERCONTROL_CONTROLTYPE_BOOLEAN: u32 = 536936448;
pub const MIXERCONTROL_CONTROLTYPE_ONOFF: u32 = 536936449;
pub const MIXERCONTROL_CONTROLTYPE_MUTE: u32 = 536936450;
pub const MIXERCONTROL_CONTROLTYPE_MONO: u32 = 536936451;
pub const MIXERCONTROL_CONTROLTYPE_LOUDNESS: u32 = 536936452;
pub const MIXERCONTROL_CONTROLTYPE_STEREOENH: u32 = 536936453;
pub const MIXERCONTROL_CONTROLTYPE_BASS_BOOST: u32 = 536945271;
pub const MIXERCONTROL_CONTROLTYPE_BUTTON: u32 = 553713664;
pub const MIXERCONTROL_CONTROLTYPE_DECIBELS: u32 = 805568512;
pub const MIXERCONTROL_CONTROLTYPE_SIGNED: u32 = 805437440;
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNED: u32 = 805502976;
pub const MIXERCONTROL_CONTROLTYPE_PERCENT: u32 = 805634048;
pub const MIXERCONTROL_CONTROLTYPE_SLIDER: u32 = 1073872896;
pub const MIXERCONTROL_CONTROLTYPE_PAN: u32 = 1073872897;
pub const MIXERCONTROL_CONTROLTYPE_QSOUNDPAN: u32 = 1073872898;
pub const MIXERCONTROL_CONTROLTYPE_FADER: u32 = 1342373888;
pub const MIXERCONTROL_CONTROLTYPE_VOLUME: u32 = 1342373889;
pub const MIXERCONTROL_CONTROLTYPE_BASS: u32 = 1342373890;
pub const MIXERCONTROL_CONTROLTYPE_TREBLE: u32 = 1342373891;
pub const MIXERCONTROL_CONTROLTYPE_EQUALIZER: u32 = 1342373892;
pub const MIXERCONTROL_CONTROLTYPE_SINGLESELECT: u32 = 1879113728;
pub const MIXERCONTROL_CONTROLTYPE_MUX: u32 = 1879113729;
pub const MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT: u32 = 1895890944;
pub const MIXERCONTROL_CONTROLTYPE_MIXER: u32 = 1895890945;
pub const MIXERCONTROL_CONTROLTYPE_MICROTIME: u32 = 1610809344;
pub const MIXERCONTROL_CONTROLTYPE_MILLITIME: u32 = 1627586560;
pub const MIXER_GETLINECONTROLSF_ALL: u32 = 0;
pub const MIXER_GETLINECONTROLSF_ONEBYID: u32 = 1;
pub const MIXER_GETLINECONTROLSF_ONEBYTYPE: u32 = 2;
pub const MIXER_GETLINECONTROLSF_QUERYMASK: u32 = 15;
pub const MIXER_GETCONTROLDETAILSF_VALUE: u32 = 0;
pub const MIXER_GETCONTROLDETAILSF_LISTTEXT: u32 = 1;
pub const MIXER_GETCONTROLDETAILSF_QUERYMASK: u32 = 15;
pub const MIXER_SETCONTROLDETAILSF_VALUE: u32 = 0;
pub const MIXER_SETCONTROLDETAILSF_CUSTOM: u32 = 1;
pub const MIXER_SETCONTROLDETAILSF_QUERYMASK: u32 = 15;
pub const TIMERR_NOERROR: u32 = 0;
pub const TIMERR_NOCANDO: u32 = 97;
pub const TIMERR_STRUCT: u32 = 129;
pub const JOYERR_NOERROR: u32 = 0;
pub const JOYERR_PARMS: u32 = 165;
pub const JOYERR_NOCANDO: u32 = 166;
pub const JOYERR_UNPLUGGED: u32 = 167;
pub const JOY_BUTTON1: u32 = 1;
pub const JOY_BUTTON2: u32 = 2;
pub const JOY_BUTTON3: u32 = 4;
pub const JOY_BUTTON4: u32 = 8;
pub const JOY_BUTTON1CHG: u32 = 256;
pub const JOY_BUTTON2CHG: u32 = 512;
pub const JOY_BUTTON3CHG: u32 = 1024;
pub const JOY_BUTTON4CHG: u32 = 2048;
pub const JOY_BUTTON5: u32 = 16;
pub const JOY_BUTTON6: u32 = 32;
pub const JOY_BUTTON7: u32 = 64;
pub const JOY_BUTTON8: u32 = 128;
pub const JOY_BUTTON9: u32 = 256;
pub const JOY_BUTTON10: u32 = 512;
pub const JOY_BUTTON11: u32 = 1024;
pub const JOY_BUTTON12: u32 = 2048;
pub const JOY_BUTTON13: u32 = 4096;
pub const JOY_BUTTON14: u32 = 8192;
pub const JOY_BUTTON15: u32 = 16384;
pub const JOY_BUTTON16: u32 = 32768;
pub const JOY_BUTTON17: u32 = 65536;
pub const JOY_BUTTON18: u32 = 131072;
pub const JOY_BUTTON19: u32 = 262144;
pub const JOY_BUTTON20: u32 = 524288;
pub const JOY_BUTTON21: u32 = 1048576;
pub const JOY_BUTTON22: u32 = 2097152;
pub const JOY_BUTTON23: u32 = 4194304;
pub const JOY_BUTTON24: u32 = 8388608;
pub const JOY_BUTTON25: u32 = 16777216;
pub const JOY_BUTTON26: u32 = 33554432;
pub const JOY_BUTTON27: u32 = 67108864;
pub const JOY_BUTTON28: u32 = 134217728;
pub const JOY_BUTTON29: u32 = 268435456;
pub const JOY_BUTTON30: u32 = 536870912;
pub const JOY_BUTTON31: u32 = 1073741824;
pub const JOY_BUTTON32: u32 = 2147483648;
pub const JOY_POVFORWARD: u32 = 0;
pub const JOY_POVRIGHT: u32 = 9000;
pub const JOY_POVBACKWARD: u32 = 18000;
pub const JOY_POVLEFT: u32 = 27000;
pub const JOY_RETURNX: u32 = 1;
pub const JOY_RETURNY: u32 = 2;
pub const JOY_RETURNZ: u32 = 4;
pub const JOY_RETURNR: u32 = 8;
pub const JOY_RETURNU: u32 = 16;
pub const JOY_RETURNV: u32 = 32;
pub const JOY_RETURNPOV: u32 = 64;
pub const JOY_RETURNBUTTONS: u32 = 128;
pub const JOY_RETURNRAWDATA: u32 = 256;
pub const JOY_RETURNPOVCTS: u32 = 512;
pub const JOY_RETURNCENTERED: u32 = 1024;
pub const JOY_USEDEADZONE: u32 = 2048;
pub const JOY_RETURNALL: u32 = 255;
pub const JOY_CAL_READALWAYS: u32 = 65536;
pub const JOY_CAL_READXYONLY: u32 = 131072;
pub const JOY_CAL_READ3: u32 = 262144;
pub const JOY_CAL_READ4: u32 = 524288;
pub const JOY_CAL_READXONLY: u32 = 1048576;
pub const JOY_CAL_READYONLY: u32 = 2097152;
pub const JOY_CAL_READ5: u32 = 4194304;
pub const JOY_CAL_READ6: u32 = 8388608;
pub const JOY_CAL_READZONLY: u32 = 16777216;
pub const JOY_CAL_READRONLY: u32 = 33554432;
pub const JOY_CAL_READUONLY: u32 = 67108864;
pub const JOY_CAL_READVONLY: u32 = 134217728;
pub const JOYSTICKID1: u32 = 0;
pub const JOYSTICKID2: u32 = 1;
pub const JOYCAPS_HASZ: u32 = 1;
pub const JOYCAPS_HASR: u32 = 2;
pub const JOYCAPS_HASU: u32 = 4;
pub const JOYCAPS_HASV: u32 = 8;
pub const JOYCAPS_HASPOV: u32 = 16;
pub const JOYCAPS_POV4DIR: u32 = 32;
pub const JOYCAPS_POVCTS: u32 = 64;
pub const NEWTRANSPARENT: u32 = 3;
pub const QUERYROPSUPPORT: u32 = 40;
pub const SELECTDIB: u32 = 41;
pub const NCBNAMSZ: u32 = 16;
pub const MAX_LANA: u32 = 254;
pub const NAME_FLAGS_MASK: u32 = 135;
pub const GROUP_NAME: u32 = 128;
pub const UNIQUE_NAME: u32 = 0;
pub const REGISTERING: u32 = 0;
pub const REGISTERED: u32 = 4;
pub const DEREGISTERED: u32 = 5;
pub const DUPLICATE: u32 = 6;
pub const DUPLICATE_DEREG: u32 = 7;
pub const LISTEN_OUTSTANDING: u32 = 1;
pub const CALL_PENDING: u32 = 2;
pub const SESSION_ESTABLISHED: u32 = 3;
pub const HANGUP_PENDING: u32 = 4;
pub const HANGUP_COMPLETE: u32 = 5;
pub const SESSION_ABORTED: u32 = 6;
pub const ALL_TRANSPORTS: &[u8; 5usize] = b"M\0\0\0\0";
pub const MS_NBF: &[u8; 5usize] = b"MNBF\0";
pub const NCBCALL: u32 = 16;
pub const NCBLISTEN: u32 = 17;
pub const NCBHANGUP: u32 = 18;
pub const NCBSEND: u32 = 20;
pub const NCBRECV: u32 = 21;
pub const NCBRECVANY: u32 = 22;
pub const NCBCHAINSEND: u32 = 23;
pub const NCBDGSEND: u32 = 32;
pub const NCBDGRECV: u32 = 33;
pub const NCBDGSENDBC: u32 = 34;
pub const NCBDGRECVBC: u32 = 35;
pub const NCBADDNAME: u32 = 48;
pub const NCBDELNAME: u32 = 49;
pub const NCBRESET: u32 = 50;
pub const NCBASTAT: u32 = 51;
pub const NCBSSTAT: u32 = 52;
pub const NCBCANCEL: u32 = 53;
pub const NCBADDGRNAME: u32 = 54;
pub const NCBENUM: u32 = 55;
pub const NCBUNLINK: u32 = 112;
pub const NCBSENDNA: u32 = 113;
pub const NCBCHAINSENDNA: u32 = 114;
pub const NCBLANSTALERT: u32 = 115;
pub const NCBACTION: u32 = 119;
pub const NCBFINDNAME: u32 = 120;
pub const NCBTRACE: u32 = 121;
pub const ASYNCH: u32 = 128;
pub const NRC_GOODRET: u32 = 0;
pub const NRC_BUFLEN: u32 = 1;
pub const NRC_ILLCMD: u32 = 3;
pub const NRC_CMDTMO: u32 = 5;
pub const NRC_INCOMP: u32 = 6;
pub const NRC_BADDR: u32 = 7;
pub const NRC_SNUMOUT: u32 = 8;
pub const NRC_NORES: u32 = 9;
pub const NRC_SCLOSED: u32 = 10;
pub const NRC_CMDCAN: u32 = 11;
pub const NRC_DUPNAME: u32 = 13;
pub const NRC_NAMTFUL: u32 = 14;
pub const NRC_ACTSES: u32 = 15;
pub const NRC_LOCTFUL: u32 = 17;
pub const NRC_REMTFUL: u32 = 18;
pub const NRC_ILLNN: u32 = 19;
pub const NRC_NOCALL: u32 = 20;
pub const NRC_NOWILD: u32 = 21;
pub const NRC_INUSE: u32 = 22;
pub const NRC_NAMERR: u32 = 23;
pub const NRC_SABORT: u32 = 24;
pub const NRC_NAMCONF: u32 = 25;
pub const NRC_IFBUSY: u32 = 33;
pub const NRC_TOOMANY: u32 = 34;
pub const NRC_BRIDGE: u32 = 35;
pub const NRC_CANOCCR: u32 = 36;
pub const NRC_CANCEL: u32 = 38;
pub const NRC_DUPENV: u32 = 48;
pub const NRC_ENVNOTDEF: u32 = 52;
pub const NRC_OSRESNOTAV: u32 = 53;
pub const NRC_MAXAPPS: u32 = 54;
pub const NRC_NOSAPS: u32 = 55;
pub const NRC_NORESOURCES: u32 = 56;
pub const NRC_INVADDRESS: u32 = 57;
pub const NRC_INVDDID: u32 = 59;
pub const NRC_LOCKFAIL: u32 = 60;
pub const NRC_OPENERR: u32 = 63;
pub const NRC_SYSTEM: u32 = 64;
pub const NRC_PENDING: u32 = 255;
pub const RPC_C_BINDING_INFINITE_TIMEOUT: u32 = 10;
pub const RPC_C_BINDING_MIN_TIMEOUT: u32 = 0;
pub const RPC_C_BINDING_DEFAULT_TIMEOUT: u32 = 5;
pub const RPC_C_BINDING_MAX_TIMEOUT: u32 = 9;
pub const RPC_C_CANCEL_INFINITE_TIMEOUT: i32 = -1;
pub const RPC_C_LISTEN_MAX_CALLS_DEFAULT: u32 = 1234;
pub const RPC_C_PROTSEQ_MAX_REQS_DEFAULT: u32 = 10;
pub const RPC_C_BIND_TO_ALL_NICS: u32 = 1;
pub const RPC_C_USE_INTERNET_PORT: u32 = 1;
pub const RPC_C_USE_INTRANET_PORT: u32 = 2;
pub const RPC_C_DONT_FAIL: u32 = 4;
pub const RPC_C_RPCHTTP_USE_LOAD_BALANCE: u32 = 8;
pub const RPC_C_TRY_ENFORCE_MAX_CALLS: u32 = 16;
pub const RPC_C_OPT_BINDING_NONCAUSAL: u32 = 9;
pub const RPC_C_OPT_SECURITY_CALLBACK: u32 = 10;
pub const RPC_C_OPT_UNIQUE_BINDING: u32 = 11;
pub const RPC_C_OPT_TRANS_SEND_BUFFER_SIZE: u32 = 5;
pub const RPC_C_OPT_CALL_TIMEOUT: u32 = 12;
pub const RPC_C_OPT_DONT_LINGER: u32 = 13;
pub const RPC_C_OPT_TRUST_PEER: u32 = 14;
pub const RPC_C_OPT_ASYNC_BLOCK: u32 = 15;
pub const RPC_C_OPT_OPTIMIZE_TIME: u32 = 16;
pub const RPC_C_OPT_MAX_OPTIONS: u32 = 17;
pub const RPC_C_FULL_CERT_CHAIN: u32 = 1;
pub const RPC_C_STATS_CALLS_IN: u32 = 0;
pub const RPC_C_STATS_CALLS_OUT: u32 = 1;
pub const RPC_C_STATS_PKTS_IN: u32 = 2;
pub const RPC_C_STATS_PKTS_OUT: u32 = 3;
pub const RPC_C_AUTHN_LEVEL_DEFAULT: u32 = 0;
pub const RPC_C_AUTHN_LEVEL_NONE: u32 = 1;
pub const RPC_C_AUTHN_LEVEL_CONNECT: u32 = 2;
pub const RPC_C_AUTHN_LEVEL_CALL: u32 = 3;
pub const RPC_C_AUTHN_LEVEL_PKT: u32 = 4;
pub const RPC_C_AUTHN_LEVEL_PKT_INTEGRITY: u32 = 5;
pub const RPC_C_AUTHN_LEVEL_PKT_PRIVACY: u32 = 6;
pub const RPC_C_IMP_LEVEL_DEFAULT: u32 = 0;
pub const RPC_C_IMP_LEVEL_ANONYMOUS: u32 = 1;
pub const RPC_C_IMP_LEVEL_IDENTIFY: u32 = 2;
pub const RPC_C_IMP_LEVEL_IMPERSONATE: u32 = 3;
pub const RPC_C_IMP_LEVEL_DELEGATE: u32 = 4;
pub const RPC_C_QOS_IDENTITY_STATIC: u32 = 0;
pub const RPC_C_QOS_IDENTITY_DYNAMIC: u32 = 1;
pub const RPC_C_QOS_CAPABILITIES_DEFAULT: u32 = 0;
pub const RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH: u32 = 1;
pub const RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC: u32 = 2;
pub const RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY: u32 = 4;
pub const RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE: u32 = 8;
pub const RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT: u32 = 16;
pub const RPC_C_QOS_CAPABILITIES_SCHANNEL_FULL_AUTH_IDENTITY: u32 = 32;
pub const RPC_C_PROTECT_LEVEL_DEFAULT: u32 = 0;
pub const RPC_C_PROTECT_LEVEL_NONE: u32 = 1;
pub const RPC_C_PROTECT_LEVEL_CONNECT: u32 = 2;
pub const RPC_C_PROTECT_LEVEL_CALL: u32 = 3;
pub const RPC_C_PROTECT_LEVEL_PKT: u32 = 4;
pub const RPC_C_PROTECT_LEVEL_PKT_INTEGRITY: u32 = 5;
pub const RPC_C_PROTECT_LEVEL_PKT_PRIVACY: u32 = 6;
pub const RPC_C_AUTHN_NONE: u32 = 0;
pub const RPC_C_AUTHN_DCE_PRIVATE: u32 = 1;
pub const RPC_C_AUTHN_DCE_PUBLIC: u32 = 2;
pub const RPC_C_AUTHN_DEC_PUBLIC: u32 = 4;
pub const RPC_C_AUTHN_GSS_NEGOTIATE: u32 = 9;
pub const RPC_C_AUTHN_WINNT: u32 = 10;
pub const RPC_C_AUTHN_GSS_SCHANNEL: u32 = 14;
pub const RPC_C_AUTHN_GSS_KERBEROS: u32 = 16;
pub const RPC_C_AUTHN_DPA: u32 = 17;
pub const RPC_C_AUTHN_MSN: u32 = 18;
pub const RPC_C_AUTHN_DIGEST: u32 = 21;
pub const RPC_C_AUTHN_KERNEL: u32 = 20;
pub const RPC_C_AUTHN_NEGO_EXTENDER: u32 = 30;
pub const RPC_C_AUTHN_PKU2U: u32 = 31;
pub const RPC_C_AUTHN_LIVE_SSP: u32 = 32;
pub const RPC_C_AUTHN_LIVEXP_SSP: u32 = 35;
pub const RPC_C_AUTHN_CLOUD_AP: u32 = 36;
pub const RPC_C_AUTHN_MSONLINE: u32 = 82;
pub const RPC_C_AUTHN_MQ: u32 = 100;
pub const RPC_C_AUTHN_DEFAULT: u32 = 4294967295;
pub const RPC_C_SECURITY_QOS_VERSION: u32 = 1;
pub const RPC_C_SECURITY_QOS_VERSION_1: u32 = 1;
pub const SEC_WINNT_AUTH_IDENTITY_ANSI: u32 = 1;
pub const SEC_WINNT_AUTH_IDENTITY_UNICODE: u32 = 2;
pub const RPC_C_SECURITY_QOS_VERSION_2: u32 = 2;
pub const RPC_C_AUTHN_INFO_TYPE_HTTP: u32 = 1;
pub const RPC_C_HTTP_AUTHN_TARGET_SERVER: u32 = 1;
pub const RPC_C_HTTP_AUTHN_TARGET_PROXY: u32 = 2;
pub const RPC_C_HTTP_AUTHN_SCHEME_BASIC: u32 = 1;
pub const RPC_C_HTTP_AUTHN_SCHEME_NTLM: u32 = 2;
pub const RPC_C_HTTP_AUTHN_SCHEME_PASSPORT: u32 = 4;
pub const RPC_C_HTTP_AUTHN_SCHEME_DIGEST: u32 = 8;
pub const RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE: u32 = 16;
pub const RPC_C_HTTP_AUTHN_SCHEME_CERT: u32 = 65536;
pub const RPC_C_HTTP_FLAG_USE_SSL: u32 = 1;
pub const RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME: u32 = 2;
pub const RPC_C_HTTP_FLAG_IGNORE_CERT_CN_INVALID: u32 = 8;
pub const RPC_C_HTTP_FLAG_ENABLE_CERT_REVOCATION_CHECK: u32 = 16;
pub const RPC_C_SECURITY_QOS_VERSION_3: u32 = 3;
pub const RPC_C_SECURITY_QOS_VERSION_4: u32 = 4;
pub const RPC_C_SECURITY_QOS_VERSION_5: u32 = 5;
pub const RPC_PROTSEQ_TCP: u32 = 1;
pub const RPC_PROTSEQ_NMP: u32 = 2;
pub const RPC_PROTSEQ_LRPC: u32 = 3;
pub const RPC_PROTSEQ_HTTP: u32 = 4;
pub const RPC_BHT_OBJECT_UUID_VALID: u32 = 1;
pub const RPC_BHO_NONCAUSAL: u32 = 1;
pub const RPC_BHO_DONTLINGER: u32 = 2;
pub const RPC_BHO_EXCLUSIVE_AND_GUARANTEED: u32 = 4;
pub const RPC_C_AUTHZ_NONE: u32 = 0;
pub const RPC_C_AUTHZ_NAME: u32 = 1;
pub const RPC_C_AUTHZ_DCE: u32 = 2;
pub const RPC_C_AUTHZ_DEFAULT: u32 = 4294967295;
pub const DCE_C_ERROR_STRING_LEN: u32 = 256;
pub const RPC_C_EP_ALL_ELTS: u32 = 0;
pub const RPC_C_EP_MATCH_BY_IF: u32 = 1;
pub const RPC_C_EP_MATCH_BY_OBJ: u32 = 2;
pub const RPC_C_EP_MATCH_BY_BOTH: u32 = 3;
pub const RPC_C_VERS_ALL: u32 = 1;
pub const RPC_C_VERS_COMPATIBLE: u32 = 2;
pub const RPC_C_VERS_EXACT: u32 = 3;
pub const RPC_C_VERS_MAJOR_ONLY: u32 = 4;
pub const RPC_C_VERS_UPTO: u32 = 5;
pub const RPC_C_MGMT_INQ_IF_IDS: u32 = 0;
pub const RPC_C_MGMT_INQ_PRINC_NAME: u32 = 1;
pub const RPC_C_MGMT_INQ_STATS: u32 = 2;
pub const RPC_C_MGMT_IS_SERVER_LISTEN: u32 = 3;
pub const RPC_C_MGMT_STOP_SERVER_LISTEN: u32 = 4;
pub const RPC_C_PARM_MAX_PACKET_LENGTH: u32 = 1;
pub const RPC_C_PARM_BUFFER_LENGTH: u32 = 2;
pub const RPC_IF_AUTOLISTEN: u32 = 1;
pub const RPC_IF_OLE: u32 = 2;
pub const RPC_IF_ALLOW_UNKNOWN_AUTHORITY: u32 = 4;
pub const RPC_IF_ALLOW_SECURE_ONLY: u32 = 8;
pub const RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH: u32 = 16;
pub const RPC_IF_ALLOW_LOCAL_ONLY: u32 = 32;
pub const RPC_IF_SEC_NO_CACHE: u32 = 64;
pub const RPC_IF_SEC_CACHE_PER_PROC: u32 = 128;
pub const RPC_IF_ASYNC_CALLBACK: u32 = 256;
pub const RPC_FW_IF_FLAG_DCOM: u32 = 1;
pub const RPC_CONTEXT_HANDLE_DEFAULT_FLAGS: u32 = 0;
pub const RPC_CONTEXT_HANDLE_FLAGS: u32 = 805306368;
pub const RPC_CONTEXT_HANDLE_SERIALIZE: u32 = 268435456;
pub const RPC_CONTEXT_HANDLE_DONT_SERIALIZE: u32 = 536870912;
pub const RPC_TYPE_STRICT_CONTEXT_HANDLE: u32 = 1073741824;
pub const RPC_TYPE_DISCONNECT_EVENT_CONTEXT_HANDLE: u32 = 2147483648;
pub const RPC_NCA_FLAGS_DEFAULT: u32 = 0;
pub const RPC_NCA_FLAGS_IDEMPOTENT: u32 = 1;
pub const RPC_NCA_FLAGS_BROADCAST: u32 = 2;
pub const RPC_NCA_FLAGS_MAYBE: u32 = 4;
pub const RPCFLG_HAS_GUARANTEE: u32 = 16;
pub const RPCFLG_WINRT_REMOTE_ASYNC: u32 = 32;
pub const RPC_BUFFER_COMPLETE: u32 = 4096;
pub const RPC_BUFFER_PARTIAL: u32 = 8192;
pub const RPC_BUFFER_EXTRA: u32 = 16384;
pub const RPC_BUFFER_ASYNC: u32 = 32768;
pub const RPC_BUFFER_NONOTIFY: u32 = 65536;
pub const RPCFLG_MESSAGE: u32 = 16777216;
pub const RPCFLG_AUTO_COMPLETE: u32 = 134217728;
pub const RPCFLG_LOCAL_CALL: u32 = 268435456;
pub const RPCFLG_INPUT_SYNCHRONOUS: u32 = 536870912;
pub const RPCFLG_ASYNCHRONOUS: u32 = 1073741824;
pub const RPCFLG_NON_NDR: u32 = 2147483648;
pub const RPCFLG_HAS_MULTI_SYNTAXES: u32 = 33554432;
pub const RPCFLG_HAS_CALLBACK: u32 = 67108864;
pub const RPCFLG_ACCESSIBILITY_BIT1: u32 = 1048576;
pub const RPCFLG_ACCESSIBILITY_BIT2: u32 = 2097152;
pub const RPCFLG_ACCESS_LOCAL: u32 = 4194304;
pub const NDR_CUSTOM_OR_DEFAULT_ALLOCATOR: u32 = 268435456;
pub const NDR_DEFAULT_ALLOCATOR: u32 = 536870912;
pub const RPCFLG_NDR64_CONTAINS_ARM_LAYOUT: u32 = 67108864;
pub const RPCFLG_SENDER_WAITING_FOR_REPLY: u32 = 8388608;
pub const RPC_FLAGS_VALID_BIT: u32 = 32768;
pub const NT351_INTERFACE_SIZE: u32 = 64;
pub const RPC_INTERFACE_HAS_PIPES: u32 = 1;
pub const RPC_SYSTEM_HANDLE_FREE_UNRETRIEVED: u32 = 1;
pub const RPC_SYSTEM_HANDLE_FREE_RETRIEVED: u32 = 2;
pub const RPC_SYSTEM_HANDLE_FREE_ALL: u32 = 3;
pub const RPC_SYSTEM_HANDLE_FREE_ERROR_ON_CLOSE: u32 = 4;
pub const TRANSPORT_TYPE_CN: u32 = 1;
pub const TRANSPORT_TYPE_DG: u32 = 2;
pub const TRANSPORT_TYPE_LPC: u32 = 4;
pub const TRANSPORT_TYPE_WMSG: u32 = 8;
pub const RPC_P_ADDR_FORMAT_TCP_IPV4: u32 = 1;
pub const RPC_P_ADDR_FORMAT_TCP_IPV6: u32 = 2;
pub const RPC_C_OPT_SESSION_ID: u32 = 6;
pub const RPC_C_OPT_COOKIE_AUTH: u32 = 7;
pub const RPC_C_OPT_RESOURCE_TYPE_UUID: u32 = 8;
pub const RPC_PROXY_CONNECTION_TYPE_IN_PROXY: u32 = 0;
pub const RPC_PROXY_CONNECTION_TYPE_OUT_PROXY: u32 = 1;
pub const RPC_C_OPT_PRIVATE_SUPPRESS_WAKE: u32 = 1;
pub const RPC_C_OPT_PRIVATE_DO_NOT_DISTURB: u32 = 2;
pub const RPC_C_OPT_PRIVATE_BREAK_ON_SUSPEND: u32 = 3;
pub const RPC_C_NS_SYNTAX_DEFAULT: u32 = 0;
pub const RPC_C_NS_SYNTAX_DCE: u32 = 3;
pub const RPC_C_PROFILE_DEFAULT_ELT: u32 = 0;
pub const RPC_C_PROFILE_ALL_ELT: u32 = 1;
pub const RPC_C_PROFILE_ALL_ELTS: u32 = 1;
pub const RPC_C_PROFILE_MATCH_BY_IF: u32 = 2;
pub const RPC_C_PROFILE_MATCH_BY_MBR: u32 = 3;
pub const RPC_C_PROFILE_MATCH_BY_BOTH: u32 = 4;
pub const RPC_C_NS_DEFAULT_EXP_AGE: i32 = -1;
pub const RPC_S_OK: u32 = 0;
pub const RPC_S_INVALID_ARG: u32 = 87;
pub const RPC_S_OUT_OF_MEMORY: u32 = 14;
pub const RPC_S_OUT_OF_THREADS: u32 = 164;
pub const RPC_S_INVALID_LEVEL: u32 = 87;
pub const RPC_S_BUFFER_TOO_SMALL: u32 = 122;
pub const RPC_S_INVALID_SECURITY_DESC: u32 = 1338;
pub const RPC_S_ACCESS_DENIED: u32 = 5;
pub const RPC_S_SERVER_OUT_OF_MEMORY: u32 = 1130;
pub const RPC_S_ASYNC_CALL_PENDING: u32 = 997;
pub const RPC_S_UNKNOWN_PRINCIPAL: u32 = 1332;
pub const RPC_S_TIMEOUT: u32 = 1460;
pub const RPC_S_RUNTIME_UNINITIALIZED: u32 = 1;
pub const RPC_S_NOT_ENOUGH_QUOTA: u32 = 1816;
pub const RPC_X_NO_MEMORY: u32 = 14;
pub const RPC_X_INVALID_BOUND: u32 = 1734;
pub const RPC_X_INVALID_TAG: u32 = 1733;
pub const RPC_X_ENUM_VALUE_TOO_LARGE: u32 = 1781;
pub const RPC_X_SS_CONTEXT_MISMATCH: u32 = 6;
pub const RPC_X_INVALID_BUFFER: u32 = 1784;
pub const RPC_X_PIPE_APP_MEMORY: u32 = 14;
pub const RPC_X_INVALID_PIPE_OPERATION: u32 = 1831;
pub const RPC_C_NOTIFY_ON_SEND_COMPLETE: u32 = 1;
pub const RPC_C_INFINITE_TIMEOUT: u32 = 4294967295;
pub const MaxNumberOfEEInfoParams: u32 = 4;
pub const RPC_EEINFO_VERSION: u32 = 1;
pub const EEInfoPreviousRecordsMissing: u32 = 1;
pub const EEInfoNextRecordsMissing: u32 = 2;
pub const EEInfoUseFileTime: u32 = 4;
pub const EEInfoGCCOM: u32 = 11;
pub const EEInfoGCFRS: u32 = 12;
pub const RPC_QUERY_SERVER_PRINCIPAL_NAME: u32 = 2;
pub const RPC_QUERY_CLIENT_PRINCIPAL_NAME: u32 = 4;
pub const RPC_QUERY_CALL_LOCAL_ADDRESS: u32 = 8;
pub const RPC_QUERY_CLIENT_PID: u32 = 16;
pub const RPC_QUERY_IS_CLIENT_LOCAL: u32 = 32;
pub const RPC_QUERY_NO_AUTH_REQUIRED: u32 = 64;
pub const RPC_CALL_ATTRIBUTES_VERSION: u32 = 3;
pub const RPC_QUERY_CLIENT_ID: u32 = 128;
pub const RPC_CALL_STATUS_CANCELLED: u32 = 1;
pub const RPC_CALL_STATUS_DISCONNECTED: u32 = 2;
pub const ABM_NEW: u32 = 0;
pub const ABM_REMOVE: u32 = 1;
pub const ABM_QUERYPOS: u32 = 2;
pub const ABM_SETPOS: u32 = 3;
pub const ABM_GETSTATE: u32 = 4;
pub const ABM_GETTASKBARPOS: u32 = 5;
pub const ABM_ACTIVATE: u32 = 6;
pub const ABM_GETAUTOHIDEBAR: u32 = 7;
pub const ABM_SETAUTOHIDEBAR: u32 = 8;
pub const ABM_WINDOWPOSCHANGED: u32 = 9;
pub const ABM_SETSTATE: u32 = 10;
pub const ABM_GETAUTOHIDEBAREX: u32 = 11;
pub const ABM_SETAUTOHIDEBAREX: u32 = 12;
pub const ABN_STATECHANGE: u32 = 0;
pub const ABN_POSCHANGED: u32 = 1;
pub const ABN_FULLSCREENAPP: u32 = 2;
pub const ABN_WINDOWARRANGE: u32 = 3;
pub const ABS_AUTOHIDE: u32 = 1;
pub const ABS_ALWAYSONTOP: u32 = 2;
pub const ABE_LEFT: u32 = 0;
pub const ABE_TOP: u32 = 1;
pub const ABE_RIGHT: u32 = 2;
pub const ABE_BOTTOM: u32 = 3;
pub const FO_MOVE: u32 = 1;
pub const FO_COPY: u32 = 2;
pub const FO_DELETE: u32 = 3;
pub const FO_RENAME: u32 = 4;
pub const FOF_MULTIDESTFILES: u32 = 1;
pub const FOF_CONFIRMMOUSE: u32 = 2;
pub const FOF_SILENT: u32 = 4;
pub const FOF_RENAMEONCOLLISION: u32 = 8;
pub const FOF_NOCONFIRMATION: u32 = 16;
pub const FOF_WANTMAPPINGHANDLE: u32 = 32;
pub const FOF_ALLOWUNDO: u32 = 64;
pub const FOF_FILESONLY: u32 = 128;
pub const FOF_SIMPLEPROGRESS: u32 = 256;
pub const FOF_NOCONFIRMMKDIR: u32 = 512;
pub const FOF_NOERRORUI: u32 = 1024;
pub const FOF_NOCOPYSECURITYATTRIBS: u32 = 2048;
pub const FOF_NORECURSION: u32 = 4096;
pub const FOF_NO_CONNECTED_ELEMENTS: u32 = 8192;
pub const FOF_WANTNUKEWARNING: u32 = 16384;
pub const FOF_NORECURSEREPARSE: u32 = 32768;
pub const FOF_NO_UI: u32 = 1556;
pub const PO_DELETE: u32 = 19;
pub const PO_RENAME: u32 = 20;
pub const PO_PORTCHANGE: u32 = 32;
pub const PO_REN_PORT: u32 = 52;
pub const SE_ERR_FNF: u32 = 2;
pub const SE_ERR_PNF: u32 = 3;
pub const SE_ERR_ACCESSDENIED: u32 = 5;
pub const SE_ERR_OOM: u32 = 8;
pub const SE_ERR_DLLNOTFOUND: u32 = 32;
pub const SE_ERR_SHARE: u32 = 26;
pub const SE_ERR_ASSOCINCOMPLETE: u32 = 27;
pub const SE_ERR_DDETIMEOUT: u32 = 28;
pub const SE_ERR_DDEFAIL: u32 = 29;
pub const SE_ERR_DDEBUSY: u32 = 30;
pub const SE_ERR_NOASSOC: u32 = 31;
pub const SEE_MASK_DEFAULT: u32 = 0;
pub const SEE_MASK_CLASSNAME: u32 = 1;
pub const SEE_MASK_CLASSKEY: u32 = 3;
pub const SEE_MASK_IDLIST: u32 = 4;
pub const SEE_MASK_INVOKEIDLIST: u32 = 12;
pub const SEE_MASK_HOTKEY: u32 = 32;
pub const SEE_MASK_NOCLOSEPROCESS: u32 = 64;
pub const SEE_MASK_CONNECTNETDRV: u32 = 128;
pub const SEE_MASK_NOASYNC: u32 = 256;
pub const SEE_MASK_FLAG_DDEWAIT: u32 = 256;
pub const SEE_MASK_DOENVSUBST: u32 = 512;
pub const SEE_MASK_FLAG_NO_UI: u32 = 1024;
pub const SEE_MASK_UNICODE: u32 = 16384;
pub const SEE_MASK_NO_CONSOLE: u32 = 32768;
pub const SEE_MASK_ASYNCOK: u32 = 1048576;
pub const SEE_MASK_HMONITOR: u32 = 2097152;
pub const SEE_MASK_NOZONECHECKS: u32 = 8388608;
pub const SEE_MASK_NOQUERYCLASSSTORE: u32 = 16777216;
pub const SEE_MASK_WAITFORINPUTIDLE: u32 = 33554432;
pub const SEE_MASK_FLAG_LOG_USAGE: u32 = 67108864;
pub const SEE_MASK_FLAG_HINST_IS_SITE: u32 = 134217728;
pub const SHERB_NOCONFIRMATION: u32 = 1;
pub const SHERB_NOPROGRESSUI: u32 = 2;
pub const SHERB_NOSOUND: u32 = 4;
pub const NIN_SELECT: u32 = 1024;
pub const NINF_KEY: u32 = 1;
pub const NIN_KEYSELECT: u32 = 1025;
pub const NIN_BALLOONSHOW: u32 = 1026;
pub const NIN_BALLOONHIDE: u32 = 1027;
pub const NIN_BALLOONTIMEOUT: u32 = 1028;
pub const NIN_BALLOONUSERCLICK: u32 = 1029;
pub const NIN_POPUPOPEN: u32 = 1030;
pub const NIN_POPUPCLOSE: u32 = 1031;
pub const NIM_ADD: u32 = 0;
pub const NIM_MODIFY: u32 = 1;
pub const NIM_DELETE: u32 = 2;
pub const NIM_SETFOCUS: u32 = 3;
pub const NIM_SETVERSION: u32 = 4;
pub const NOTIFYICON_VERSION: u32 = 3;
pub const NOTIFYICON_VERSION_4: u32 = 4;
pub const NIF_MESSAGE: u32 = 1;
pub const NIF_ICON: u32 = 2;
pub const NIF_TIP: u32 = 4;
pub const NIF_STATE: u32 = 8;
pub const NIF_INFO: u32 = 16;
pub const NIF_GUID: u32 = 32;
pub const NIF_REALTIME: u32 = 64;
pub const NIF_SHOWTIP: u32 = 128;
pub const NIS_HIDDEN: u32 = 1;
pub const NIS_SHAREDICON: u32 = 2;
pub const NIIF_NONE: u32 = 0;
pub const NIIF_INFO: u32 = 1;
pub const NIIF_WARNING: u32 = 2;
pub const NIIF_ERROR: u32 = 3;
pub const NIIF_USER: u32 = 4;
pub const NIIF_ICON_MASK: u32 = 15;
pub const NIIF_NOSOUND: u32 = 16;
pub const NIIF_LARGE_ICON: u32 = 32;
pub const NIIF_RESPECT_QUIET_TIME: u32 = 128;
pub const SHGFI_ICON: u32 = 256;
pub const SHGFI_DISPLAYNAME: u32 = 512;
pub const SHGFI_TYPENAME: u32 = 1024;
pub const SHGFI_ATTRIBUTES: u32 = 2048;
pub const SHGFI_ICONLOCATION: u32 = 4096;
pub const SHGFI_EXETYPE: u32 = 8192;
pub const SHGFI_SYSICONINDEX: u32 = 16384;
pub const SHGFI_LINKOVERLAY: u32 = 32768;
pub const SHGFI_SELECTED: u32 = 65536;
pub const SHGFI_ATTR_SPECIFIED: u32 = 131072;
pub const SHGFI_LARGEICON: u32 = 0;
pub const SHGFI_SMALLICON: u32 = 1;
pub const SHGFI_OPENICON: u32 = 2;
pub const SHGFI_SHELLICONSIZE: u32 = 4;
pub const SHGFI_PIDL: u32 = 8;
pub const SHGFI_USEFILEATTRIBUTES: u32 = 16;
pub const SHGFI_ADDOVERLAYS: u32 = 32;
pub const SHGFI_OVERLAYINDEX: u32 = 64;
pub const SHGSI_ICONLOCATION: u32 = 0;
pub const SHGSI_ICON: u32 = 256;
pub const SHGSI_SYSICONINDEX: u32 = 16384;
pub const SHGSI_LINKOVERLAY: u32 = 32768;
pub const SHGSI_SELECTED: u32 = 65536;
pub const SHGSI_LARGEICON: u32 = 0;
pub const SHGSI_SMALLICON: u32 = 1;
pub const SHGSI_SHELLICONSIZE: u32 = 4;
pub const SHGNLI_PIDL: u32 = 1;
pub const SHGNLI_PREFIXNAME: u32 = 2;
pub const SHGNLI_NOUNIQUE: u32 = 4;
pub const SHGNLI_NOLNK: u32 = 8;
pub const SHGNLI_NOLOCNAME: u32 = 16;
pub const SHGNLI_USEURLEXT: u32 = 32;
pub const PRINTACTION_OPEN: u32 = 0;
pub const PRINTACTION_PROPERTIES: u32 = 1;
pub const PRINTACTION_NETINSTALL: u32 = 2;
pub const PRINTACTION_NETINSTALLLINK: u32 = 3;
pub const PRINTACTION_TESTPAGE: u32 = 4;
pub const PRINTACTION_OPENNETPRN: u32 = 5;
pub const PRINTACTION_DOCUMENTDEFAULTS: u32 = 6;
pub const PRINTACTION_SERVERPROPERTIES: u32 = 7;
pub const PRINT_PROP_FORCE_NAME: u32 = 1;
pub const OFFLINE_STATUS_LOCAL: u32 = 1;
pub const OFFLINE_STATUS_REMOTE: u32 = 2;
pub const OFFLINE_STATUS_INCOMPLETE: u32 = 4;
pub const SHIL_LARGE: u32 = 0;
pub const SHIL_SMALL: u32 = 1;
pub const SHIL_EXTRALARGE: u32 = 2;
pub const SHIL_SYSSMALL: u32 = 3;
pub const SHIL_JUMBO: u32 = 4;
pub const SHIL_LAST: u32 = 4;
pub const WC_NETADDRESS: &[u8; 18usize] = b"msctls_netaddress\0";
pub const NCM_GETADDRESS: u32 = 1025;
pub const NCM_SETALLOWTYPE: u32 = 1026;
pub const NCM_GETALLOWTYPE: u32 = 1027;
pub const NCM_DISPLAYERRORTIP: u32 = 1028;
pub const PERF_DATA_VERSION: u32 = 1;
pub const PERF_DATA_REVISION: u32 = 1;
pub const PERF_NO_INSTANCES: i32 = -1;
pub const PERF_METADATA_MULTIPLE_INSTANCES: i32 = -2;
pub const PERF_METADATA_NO_INSTANCES: i32 = -3;
pub const PERF_SIZE_DWORD: u32 = 0;
pub const PERF_SIZE_LARGE: u32 = 256;
pub const PERF_SIZE_ZERO: u32 = 512;
pub const PERF_SIZE_VARIABLE_LEN: u32 = 768;
pub const PERF_TYPE_NUMBER: u32 = 0;
pub const PERF_TYPE_COUNTER: u32 = 1024;
pub const PERF_TYPE_TEXT: u32 = 2048;
pub const PERF_TYPE_ZERO: u32 = 3072;
pub const PERF_NUMBER_HEX: u32 = 0;
pub const PERF_NUMBER_DECIMAL: u32 = 65536;
pub const PERF_NUMBER_DEC_1000: u32 = 131072;
pub const PERF_COUNTER_VALUE: u32 = 0;
pub const PERF_COUNTER_RATE: u32 = 65536;
pub const PERF_COUNTER_FRACTION: u32 = 131072;
pub const PERF_COUNTER_BASE: u32 = 196608;
pub const PERF_COUNTER_ELAPSED: u32 = 262144;
pub const PERF_COUNTER_QUEUELEN: u32 = 327680;
pub const PERF_COUNTER_HISTOGRAM: u32 = 393216;
pub const PERF_COUNTER_PRECISION: u32 = 458752;
pub const PERF_TEXT_UNICODE: u32 = 0;
pub const PERF_TEXT_ASCII: u32 = 65536;
pub const PERF_TIMER_TICK: u32 = 0;
pub const PERF_TIMER_100NS: u32 = 1048576;
pub const PERF_OBJECT_TIMER: u32 = 2097152;
pub const PERF_DELTA_COUNTER: u32 = 4194304;
pub const PERF_DELTA_BASE: u32 = 8388608;
pub const PERF_INVERSE_COUNTER: u32 = 16777216;
pub const PERF_MULTI_COUNTER: u32 = 33554432;
pub const PERF_DISPLAY_NO_SUFFIX: u32 = 0;
pub const PERF_DISPLAY_PER_SEC: u32 = 268435456;
pub const PERF_DISPLAY_PERCENT: u32 = 536870912;
pub const PERF_DISPLAY_SECONDS: u32 = 805306368;
pub const PERF_DISPLAY_NOSHOW: u32 = 1073741824;
pub const PERF_COUNTER_COUNTER: u32 = 272696320;
pub const PERF_COUNTER_TIMER: u32 = 541132032;
pub const PERF_COUNTER_QUEUELEN_TYPE: u32 = 4523008;
pub const PERF_COUNTER_LARGE_QUEUELEN_TYPE: u32 = 4523264;
pub const PERF_COUNTER_100NS_QUEUELEN_TYPE: u32 = 5571840;
pub const PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE: u32 = 6620416;
pub const PERF_COUNTER_BULK_COUNT: u32 = 272696576;
pub const PERF_COUNTER_TEXT: u32 = 2816;
pub const PERF_COUNTER_RAWCOUNT: u32 = 65536;
pub const PERF_COUNTER_LARGE_RAWCOUNT: u32 = 65792;
pub const PERF_COUNTER_RAWCOUNT_HEX: u32 = 0;
pub const PERF_COUNTER_LARGE_RAWCOUNT_HEX: u32 = 256;
pub const PERF_SAMPLE_FRACTION: u32 = 549585920;
pub const PERF_SAMPLE_COUNTER: u32 = 4260864;
pub const PERF_COUNTER_NODATA: u32 = 1073742336;
pub const PERF_COUNTER_TIMER_INV: u32 = 557909248;
pub const PERF_SAMPLE_BASE: u32 = 1073939457;
pub const PERF_AVERAGE_TIMER: u32 = 805438464;
pub const PERF_AVERAGE_BASE: u32 = 1073939458;
pub const PERF_AVERAGE_BULK: u32 = 1073874176;
pub const PERF_OBJ_TIME_TIMER: u32 = 543229184;
pub const PERF_100NSEC_TIMER: u32 = 542180608;
pub const PERF_100NSEC_TIMER_INV: u32 = 558957824;
pub const PERF_COUNTER_MULTI_TIMER: u32 = 574686464;
pub const PERF_COUNTER_MULTI_TIMER_INV: u32 = 591463680;
pub const PERF_COUNTER_MULTI_BASE: u32 = 1107494144;
pub const PERF_100NSEC_MULTI_TIMER: u32 = 575735040;
pub const PERF_100NSEC_MULTI_TIMER_INV: u32 = 592512256;
pub const PERF_RAW_FRACTION: u32 = 537003008;
pub const PERF_LARGE_RAW_FRACTION: u32 = 537003264;
pub const PERF_RAW_BASE: u32 = 1073939459;
pub const PERF_LARGE_RAW_BASE: u32 = 1073939712;
pub const PERF_ELAPSED_TIME: u32 = 807666944;
pub const PERF_COUNTER_HISTOGRAM_TYPE: u32 = 2147483648;
pub const PERF_COUNTER_DELTA: u32 = 4195328;
pub const PERF_COUNTER_LARGE_DELTA: u32 = 4195584;
pub const PERF_PRECISION_SYSTEM_TIMER: u32 = 541525248;
pub const PERF_PRECISION_100NS_TIMER: u32 = 542573824;
pub const PERF_PRECISION_OBJECT_TIMER: u32 = 543622400;
pub const PERF_PRECISION_TIMESTAMP: u32 = 1073939712;
pub const PERF_DETAIL_NOVICE: u32 = 100;
pub const PERF_DETAIL_ADVANCED: u32 = 200;
pub const PERF_DETAIL_EXPERT: u32 = 300;
pub const PERF_DETAIL_WIZARD: u32 = 400;
pub const PERF_NO_UNIQUE_ID: i32 = -1;
pub const MAX_PERF_OBJECTS_IN_QUERY_FUNCTION: u32 = 64;
pub const WINPERF_LOG_NONE: u32 = 0;
pub const WINPERF_LOG_USER: u32 = 1;
pub const WINPERF_LOG_DEBUG: u32 = 2;
pub const WINPERF_LOG_VERBOSE: u32 = 3;
pub const FD_SETSIZE: u32 = 64;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPORT_ECHO: u32 = 7;
pub const IPPORT_DISCARD: u32 = 9;
pub const IPPORT_SYSTAT: u32 = 11;
pub const IPPORT_DAYTIME: u32 = 13;
pub const IPPORT_NETSTAT: u32 = 15;
pub const IPPORT_FTP: u32 = 21;
pub const IPPORT_TELNET: u32 = 23;
pub const IPPORT_SMTP: u32 = 25;
pub const IPPORT_TIMESERVER: u32 = 37;
pub const IPPORT_NAMESERVER: u32 = 42;
pub const IPPORT_WHOIS: u32 = 43;
pub const IPPORT_MTP: u32 = 57;
pub const IPPORT_TFTP: u32 = 69;
pub const IPPORT_RJE: u32 = 77;
pub const IPPORT_FINGER: u32 = 79;
pub const IPPORT_TTYLINK: u32 = 87;
pub const IPPORT_SUPDUP: u32 = 95;
pub const IPPORT_EXECSERVER: u32 = 512;
pub const IPPORT_LOGINSERVER: u32 = 513;
pub const IPPORT_CMDSERVER: u32 = 514;
pub const IPPORT_EFSSERVER: u32 = 520;
pub const IPPORT_BIFFUDP: u32 = 512;
pub const IPPORT_WHOSERVER: u32 = 513;
pub const IPPORT_ROUTESERVER: u32 = 520;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IMPLINK_IP: u32 = 155;
pub const IMPLINK_LOWEXPER: u32 = 156;
pub const IMPLINK_HIGHEXPER: u32 = 158;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_NONE: u32 = 4294967295;
pub const WSADESCRIPTION_LEN: u32 = 256;
pub const WSASYS_STATUS_LEN: u32 = 128;
pub const IP_OPTIONS: u32 = 1;
pub const IP_MULTICAST_IF: u32 = 2;
pub const IP_MULTICAST_TTL: u32 = 3;
pub const IP_MULTICAST_LOOP: u32 = 4;
pub const IP_ADD_MEMBERSHIP: u32 = 5;
pub const IP_DROP_MEMBERSHIP: u32 = 6;
pub const IP_TTL: u32 = 7;
pub const IP_TOS: u32 = 8;
pub const IP_DONTFRAGMENT: u32 = 9;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const SOCKET_ERROR: i32 = -1;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_CONNDATA: u32 = 28672;
pub const SO_CONNOPT: u32 = 28673;
pub const SO_DISCDATA: u32 = 28674;
pub const SO_DISCOPT: u32 = 28675;
pub const SO_CONNDATALEN: u32 = 28676;
pub const SO_CONNOPTLEN: u32 = 28677;
pub const SO_DISCDATALEN: u32 = 28678;
pub const SO_DISCOPTLEN: u32 = 28679;
pub const SO_OPENTYPE: u32 = 28680;
pub const SO_SYNCHRONOUS_ALERT: u32 = 16;
pub const SO_SYNCHRONOUS_NONALERT: u32 = 32;
pub const SO_MAXDG: u32 = 28681;
pub const SO_MAXPATHDG: u32 = 28682;
pub const SO_UPDATE_ACCEPT_CONTEXT: u32 = 28683;
pub const SO_CONNECT_TIME: u32 = 28684;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_BSDURGENT: u32 = 28672;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_IPX: u32 = 6;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_NETBIOS: u32 = 17;
pub const AF_VOICEVIEW: u32 = 18;
pub const AF_FIREFOX: u32 = 19;
pub const AF_UNKNOWN1: u32 = 20;
pub const AF_BAN: u32 = 21;
pub const AF_MAX: u32 = 22;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_IPX: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_VOICEVIEW: u32 = 18;
pub const PF_FIREFOX: u32 = 19;
pub const PF_UNKNOWN1: u32 = 20;
pub const PF_BAN: u32 = 21;
pub const PF_MAX: u32 = 22;
pub const SOL_SOCKET: u32 = 65535;
pub const SOMAXCONN: u32 = 5;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_MAXIOVLEN: u32 = 16;
pub const MSG_PARTIAL: u32 = 32768;
pub const MAXGETHOSTSTRUCT: u32 = 1024;
pub const FD_READ: u32 = 1;
pub const FD_WRITE: u32 = 2;
pub const FD_OOB: u32 = 4;
pub const FD_ACCEPT: u32 = 8;
pub const FD_CONNECT: u32 = 16;
pub const FD_CLOSE: u32 = 32;
pub const HOST_NOT_FOUND: u32 = 11001;
pub const TRY_AGAIN: u32 = 11002;
pub const NO_RECOVERY: u32 = 11003;
pub const NO_DATA: u32 = 11004;
pub const WSANO_ADDRESS: u32 = 11004;
pub const NO_ADDRESS: u32 = 11004;
pub const TF_DISCONNECT: u32 = 1;
pub const TF_REUSE_SOCKET: u32 = 2;
pub const TF_WRITE_BEHIND: u32 = 4;
pub const ALG_CLASS_ANY: u32 = 0;
pub const ALG_CLASS_SIGNATURE: u32 = 8192;
pub const ALG_CLASS_MSG_ENCRYPT: u32 = 16384;
pub const ALG_CLASS_DATA_ENCRYPT: u32 = 24576;
pub const ALG_CLASS_HASH: u32 = 32768;
pub const ALG_CLASS_KEY_EXCHANGE: u32 = 40960;
pub const ALG_CLASS_ALL: u32 = 57344;
pub const ALG_TYPE_ANY: u32 = 0;
pub const ALG_TYPE_DSS: u32 = 512;
pub const ALG_TYPE_RSA: u32 = 1024;
pub const ALG_TYPE_BLOCK: u32 = 1536;
pub const ALG_TYPE_STREAM: u32 = 2048;
pub const ALG_TYPE_DH: u32 = 2560;
pub const ALG_TYPE_SECURECHANNEL: u32 = 3072;
pub const ALG_TYPE_ECDH: u32 = 3584;
pub const ALG_TYPE_THIRDPARTY: u32 = 4096;
pub const ALG_SID_ANY: u32 = 0;
pub const ALG_SID_THIRDPARTY_ANY: u32 = 0;
pub const ALG_SID_RSA_ANY: u32 = 0;
pub const ALG_SID_RSA_PKCS: u32 = 1;
pub const ALG_SID_RSA_MSATWORK: u32 = 2;
pub const ALG_SID_RSA_ENTRUST: u32 = 3;
pub const ALG_SID_RSA_PGP: u32 = 4;
pub const ALG_SID_DSS_ANY: u32 = 0;
pub const ALG_SID_DSS_PKCS: u32 = 1;
pub const ALG_SID_DSS_DMS: u32 = 2;
pub const ALG_SID_ECDSA: u32 = 3;
pub const ALG_SID_DES: u32 = 1;
pub const ALG_SID_3DES: u32 = 3;
pub const ALG_SID_DESX: u32 = 4;
pub const ALG_SID_IDEA: u32 = 5;
pub const ALG_SID_CAST: u32 = 6;
pub const ALG_SID_SAFERSK64: u32 = 7;
pub const ALG_SID_SAFERSK128: u32 = 8;
pub const ALG_SID_3DES_112: u32 = 9;
pub const ALG_SID_CYLINK_MEK: u32 = 12;
pub const ALG_SID_RC5: u32 = 13;
pub const ALG_SID_AES_128: u32 = 14;
pub const ALG_SID_AES_192: u32 = 15;
pub const ALG_SID_AES_256: u32 = 16;
pub const ALG_SID_AES: u32 = 17;
pub const ALG_SID_SKIPJACK: u32 = 10;
pub const ALG_SID_TEK: u32 = 11;
pub const CRYPT_MODE_CBCI: u32 = 6;
pub const CRYPT_MODE_CFBP: u32 = 7;
pub const CRYPT_MODE_OFBP: u32 = 8;
pub const CRYPT_MODE_CBCOFM: u32 = 9;
pub const CRYPT_MODE_CBCOFMI: u32 = 10;
pub const ALG_SID_RC2: u32 = 2;
pub const ALG_SID_RC4: u32 = 1;
pub const ALG_SID_SEAL: u32 = 2;
pub const ALG_SID_DH_SANDF: u32 = 1;
pub const ALG_SID_DH_EPHEM: u32 = 2;
pub const ALG_SID_AGREED_KEY_ANY: u32 = 3;
pub const ALG_SID_KEA: u32 = 4;
pub const ALG_SID_ECDH: u32 = 5;
pub const ALG_SID_ECDH_EPHEM: u32 = 6;
pub const ALG_SID_MD2: u32 = 1;
pub const ALG_SID_MD4: u32 = 2;
pub const ALG_SID_MD5: u32 = 3;
pub const ALG_SID_SHA: u32 = 4;
pub const ALG_SID_SHA1: u32 = 4;
pub const ALG_SID_MAC: u32 = 5;
pub const ALG_SID_RIPEMD: u32 = 6;
pub const ALG_SID_RIPEMD160: u32 = 7;
pub const ALG_SID_SSL3SHAMD5: u32 = 8;
pub const ALG_SID_HMAC: u32 = 9;
pub const ALG_SID_TLS1PRF: u32 = 10;
pub const ALG_SID_HASH_REPLACE_OWF: u32 = 11;
pub const ALG_SID_SHA_256: u32 = 12;
pub const ALG_SID_SHA_384: u32 = 13;
pub const ALG_SID_SHA_512: u32 = 14;
pub const ALG_SID_SSL3_MASTER: u32 = 1;
pub const ALG_SID_SCHANNEL_MASTER_HASH: u32 = 2;
pub const ALG_SID_SCHANNEL_MAC_KEY: u32 = 3;
pub const ALG_SID_PCT1_MASTER: u32 = 4;
pub const ALG_SID_SSL2_MASTER: u32 = 5;
pub const ALG_SID_TLS1_MASTER: u32 = 6;
pub const ALG_SID_SCHANNEL_ENC_KEY: u32 = 7;
pub const ALG_SID_ECMQV: u32 = 1;
pub const ALG_SID_EXAMPLE: u32 = 80;
pub const CALG_MD2: u32 = 32769;
pub const CALG_MD4: u32 = 32770;
pub const CALG_MD5: u32 = 32771;
pub const CALG_SHA: u32 = 32772;
pub const CALG_SHA1: u32 = 32772;
pub const CALG_MAC: u32 = 32773;
pub const CALG_RSA_SIGN: u32 = 9216;
pub const CALG_DSS_SIGN: u32 = 8704;
pub const CALG_NO_SIGN: u32 = 8192;
pub const CALG_RSA_KEYX: u32 = 41984;
pub const CALG_DES: u32 = 26113;
pub const CALG_3DES_112: u32 = 26121;
pub const CALG_3DES: u32 = 26115;
pub const CALG_DESX: u32 = 26116;
pub const CALG_RC2: u32 = 26114;
pub const CALG_RC4: u32 = 26625;
pub const CALG_SEAL: u32 = 26626;
pub const CALG_DH_SF: u32 = 43521;
pub const CALG_DH_EPHEM: u32 = 43522;
pub const CALG_AGREEDKEY_ANY: u32 = 43523;
pub const CALG_KEA_KEYX: u32 = 43524;
pub const CALG_HUGHES_MD5: u32 = 40963;
pub const CALG_SKIPJACK: u32 = 26122;
pub const CALG_TEK: u32 = 26123;
pub const CALG_CYLINK_MEK: u32 = 26124;
pub const CALG_SSL3_SHAMD5: u32 = 32776;
pub const CALG_SSL3_MASTER: u32 = 19457;
pub const CALG_SCHANNEL_MASTER_HASH: u32 = 19458;
pub const CALG_SCHANNEL_MAC_KEY: u32 = 19459;
pub const CALG_SCHANNEL_ENC_KEY: u32 = 19463;
pub const CALG_PCT1_MASTER: u32 = 19460;
pub const CALG_SSL2_MASTER: u32 = 19461;
pub const CALG_TLS1_MASTER: u32 = 19462;
pub const CALG_RC5: u32 = 26125;
pub const CALG_HMAC: u32 = 32777;
pub const CALG_TLS1PRF: u32 = 32778;
pub const CALG_HASH_REPLACE_OWF: u32 = 32779;
pub const CALG_AES_128: u32 = 26126;
pub const CALG_AES_192: u32 = 26127;
pub const CALG_AES_256: u32 = 26128;
pub const CALG_AES: u32 = 26129;
pub const CALG_SHA_256: u32 = 32780;
pub const CALG_SHA_384: u32 = 32781;
pub const CALG_SHA_512: u32 = 32782;
pub const CALG_ECDH: u32 = 43525;
pub const CALG_ECDH_EPHEM: u32 = 44550;
pub const CALG_ECMQV: u32 = 40961;
pub const CALG_ECDSA: u32 = 8707;
pub const CALG_NULLCIPHER: u32 = 24576;
pub const CALG_THIRDPARTY_KEY_EXCHANGE: u32 = 45056;
pub const CALG_THIRDPARTY_SIGNATURE: u32 = 12288;
pub const CALG_THIRDPARTY_CIPHER: u32 = 28672;
pub const CALG_THIRDPARTY_HASH: u32 = 36864;
pub const CRYPT_VERIFYCONTEXT: u32 = 4026531840;
pub const CRYPT_NEWKEYSET: u32 = 8;
pub const CRYPT_DELETEKEYSET: u32 = 16;
pub const CRYPT_MACHINE_KEYSET: u32 = 32;
pub const CRYPT_SILENT: u32 = 64;
pub const CRYPT_DEFAULT_CONTAINER_OPTIONAL: u32 = 128;
pub const CRYPT_EXPORTABLE: u32 = 1;
pub const CRYPT_USER_PROTECTED: u32 = 2;
pub const CRYPT_CREATE_SALT: u32 = 4;
pub const CRYPT_UPDATE_KEY: u32 = 8;
pub const CRYPT_NO_SALT: u32 = 16;
pub const CRYPT_PREGEN: u32 = 64;
pub const CRYPT_RECIPIENT: u32 = 16;
pub const CRYPT_INITIATOR: u32 = 64;
pub const CRYPT_ONLINE: u32 = 128;
pub const CRYPT_SF: u32 = 256;
pub const CRYPT_CREATE_IV: u32 = 512;
pub const CRYPT_KEK: u32 = 1024;
pub const CRYPT_DATA_KEY: u32 = 2048;
pub const CRYPT_VOLATILE: u32 = 4096;
pub const CRYPT_SGCKEY: u32 = 8192;
pub const CRYPT_USER_PROTECTED_STRONG: u32 = 1048576;
pub const CRYPT_ARCHIVABLE: u32 = 16384;
pub const CRYPT_FORCE_KEY_PROTECTION_HIGH: u32 = 32768;
pub const RSA1024BIT_KEY: u32 = 67108864;
pub const CRYPT_SERVER: u32 = 1024;
pub const KEY_LENGTH_MASK: u32 = 4294901760;
pub const CRYPT_Y_ONLY: u32 = 1;
pub const CRYPT_SSL2_FALLBACK: u32 = 2;
pub const CRYPT_DESTROYKEY: u32 = 4;
pub const CRYPT_OAEP: u32 = 64;
pub const CRYPT_BLOB_VER3: u32 = 128;
pub const CRYPT_IPSEC_HMAC_KEY: u32 = 256;
pub const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK: u32 = 32;
pub const CRYPT_SECRETDIGEST: u32 = 1;
pub const CRYPT_OWF_REPL_LM_HASH: u32 = 1;
pub const CRYPT_LITTLE_ENDIAN: u32 = 1;
pub const CRYPT_NOHASHOID: u32 = 1;
pub const CRYPT_TYPE2_FORMAT: u32 = 2;
pub const CRYPT_X931_FORMAT: u32 = 4;
pub const CRYPT_MACHINE_DEFAULT: u32 = 1;
pub const CRYPT_USER_DEFAULT: u32 = 2;
pub const CRYPT_DELETE_DEFAULT: u32 = 4;
pub const SIMPLEBLOB: u32 = 1;
pub const PUBLICKEYBLOB: u32 = 6;
pub const PRIVATEKEYBLOB: u32 = 7;
pub const PLAINTEXTKEYBLOB: u32 = 8;
pub const OPAQUEKEYBLOB: u32 = 9;
pub const PUBLICKEYBLOBEX: u32 = 10;
pub const SYMMETRICWRAPKEYBLOB: u32 = 11;
pub const KEYSTATEBLOB: u32 = 12;
pub const AT_KEYEXCHANGE: u32 = 1;
pub const AT_SIGNATURE: u32 = 2;
pub const CRYPT_USERDATA: u32 = 1;
pub const KP_IV: u32 = 1;
pub const KP_SALT: u32 = 2;
pub const KP_PADDING: u32 = 3;
pub const KP_MODE: u32 = 4;
pub const KP_MODE_BITS: u32 = 5;
pub const KP_PERMISSIONS: u32 = 6;
pub const KP_ALGID: u32 = 7;
pub const KP_BLOCKLEN: u32 = 8;
pub const KP_KEYLEN: u32 = 9;
pub const KP_SALT_EX: u32 = 10;
pub const KP_P: u32 = 11;
pub const KP_G: u32 = 12;
pub const KP_Q: u32 = 13;
pub const KP_X: u32 = 14;
pub const KP_Y: u32 = 15;
pub const KP_RA: u32 = 16;
pub const KP_RB: u32 = 17;
pub const KP_INFO: u32 = 18;
pub const KP_EFFECTIVE_KEYLEN: u32 = 19;
pub const KP_SCHANNEL_ALG: u32 = 20;
pub const KP_CLIENT_RANDOM: u32 = 21;
pub const KP_SERVER_RANDOM: u32 = 22;
pub const KP_RP: u32 = 23;
pub const KP_PRECOMP_MD5: u32 = 24;
pub const KP_PRECOMP_SHA: u32 = 25;
pub const KP_CERTIFICATE: u32 = 26;
pub const KP_CLEAR_KEY: u32 = 27;
pub const KP_PUB_EX_LEN: u32 = 28;
pub const KP_PUB_EX_VAL: u32 = 29;
pub const KP_KEYVAL: u32 = 30;
pub const KP_ADMIN_PIN: u32 = 31;
pub const KP_KEYEXCHANGE_PIN: u32 = 32;
pub const KP_SIGNATURE_PIN: u32 = 33;
pub const KP_PREHASH: u32 = 34;
pub const KP_ROUNDS: u32 = 35;
pub const KP_OAEP_PARAMS: u32 = 36;
pub const KP_CMS_KEY_INFO: u32 = 37;
pub const KP_CMS_DH_KEY_INFO: u32 = 38;
pub const KP_PUB_PARAMS: u32 = 39;
pub const KP_VERIFY_PARAMS: u32 = 40;
pub const KP_HIGHEST_VERSION: u32 = 41;
pub const KP_GET_USE_COUNT: u32 = 42;
pub const KP_PIN_ID: u32 = 43;
pub const KP_PIN_INFO: u32 = 44;
pub const PKCS5_PADDING: u32 = 1;
pub const RANDOM_PADDING: u32 = 2;
pub const ZERO_PADDING: u32 = 3;
pub const CRYPT_MODE_CBC: u32 = 1;
pub const CRYPT_MODE_ECB: u32 = 2;
pub const CRYPT_MODE_OFB: u32 = 3;
pub const CRYPT_MODE_CFB: u32 = 4;
pub const CRYPT_MODE_CTS: u32 = 5;
pub const CRYPT_ENCRYPT: u32 = 1;
pub const CRYPT_DECRYPT: u32 = 2;
pub const CRYPT_EXPORT: u32 = 4;
pub const CRYPT_READ: u32 = 8;
pub const CRYPT_WRITE: u32 = 16;
pub const CRYPT_MAC: u32 = 32;
pub const CRYPT_EXPORT_KEY: u32 = 64;
pub const CRYPT_IMPORT_KEY: u32 = 128;
pub const CRYPT_ARCHIVE: u32 = 256;
pub const HP_ALGID: u32 = 1;
pub const HP_HASHVAL: u32 = 2;
pub const HP_HASHSIZE: u32 = 4;
pub const HP_HMAC_INFO: u32 = 5;
pub const HP_TLS1PRF_LABEL: u32 = 6;
pub const HP_TLS1PRF_SEED: u32 = 7;
pub const CRYPT_FAILED: u32 = 0;
pub const CRYPT_SUCCEED: u32 = 1;
pub const PP_ENUMALGS: u32 = 1;
pub const PP_ENUMCONTAINERS: u32 = 2;
pub const PP_IMPTYPE: u32 = 3;
pub const PP_NAME: u32 = 4;
pub const PP_VERSION: u32 = 5;
pub const PP_CONTAINER: u32 = 6;
pub const PP_CHANGE_PASSWORD: u32 = 7;
pub const PP_KEYSET_SEC_DESCR: u32 = 8;
pub const PP_CERTCHAIN: u32 = 9;
pub const PP_KEY_TYPE_SUBTYPE: u32 = 10;
pub const PP_PROVTYPE: u32 = 16;
pub const PP_KEYSTORAGE: u32 = 17;
pub const PP_APPLI_CERT: u32 = 18;
pub const PP_SYM_KEYSIZE: u32 = 19;
pub const PP_SESSION_KEYSIZE: u32 = 20;
pub const PP_UI_PROMPT: u32 = 21;
pub const PP_ENUMALGS_EX: u32 = 22;
pub const PP_ENUMMANDROOTS: u32 = 25;
pub const PP_ENUMELECTROOTS: u32 = 26;
pub const PP_KEYSET_TYPE: u32 = 27;
pub const PP_ADMIN_PIN: u32 = 31;
pub const PP_KEYEXCHANGE_PIN: u32 = 32;
pub const PP_SIGNATURE_PIN: u32 = 33;
pub const PP_SIG_KEYSIZE_INC: u32 = 34;
pub const PP_KEYX_KEYSIZE_INC: u32 = 35;
pub const PP_UNIQUE_CONTAINER: u32 = 36;
pub const PP_SGC_INFO: u32 = 37;
pub const PP_USE_HARDWARE_RNG: u32 = 38;
pub const PP_KEYSPEC: u32 = 39;
pub const PP_ENUMEX_SIGNING_PROT: u32 = 40;
pub const PP_CRYPT_COUNT_KEY_USE: u32 = 41;
pub const PP_USER_CERTSTORE: u32 = 42;
pub const PP_SMARTCARD_READER: u32 = 43;
pub const PP_SMARTCARD_GUID: u32 = 45;
pub const PP_ROOT_CERTSTORE: u32 = 46;
pub const PP_SMARTCARD_READER_ICON: u32 = 47;
pub const CRYPT_FIRST: u32 = 1;
pub const CRYPT_NEXT: u32 = 2;
pub const CRYPT_SGC_ENUM: u32 = 4;
pub const CRYPT_IMPL_HARDWARE: u32 = 1;
pub const CRYPT_IMPL_SOFTWARE: u32 = 2;
pub const CRYPT_IMPL_MIXED: u32 = 3;
pub const CRYPT_IMPL_UNKNOWN: u32 = 4;
pub const CRYPT_IMPL_REMOVABLE: u32 = 8;
pub const CRYPT_SEC_DESCR: u32 = 1;
pub const CRYPT_PSTORE: u32 = 2;
pub const CRYPT_UI_PROMPT: u32 = 4;
pub const CRYPT_FLAG_PCT1: u32 = 1;
pub const CRYPT_FLAG_SSL2: u32 = 2;
pub const CRYPT_FLAG_SSL3: u32 = 4;
pub const CRYPT_FLAG_TLS1: u32 = 8;
pub const CRYPT_FLAG_IPSEC: u32 = 16;
pub const CRYPT_FLAG_SIGNING: u32 = 32;
pub const CRYPT_SGC: u32 = 1;
pub const CRYPT_FASTSGC: u32 = 2;
pub const PP_CLIENT_HWND: u32 = 1;
pub const PP_CONTEXT_INFO: u32 = 11;
pub const PP_KEYEXCHANGE_KEYSIZE: u32 = 12;
pub const PP_SIGNATURE_KEYSIZE: u32 = 13;
pub const PP_KEYEXCHANGE_ALG: u32 = 14;
pub const PP_SIGNATURE_ALG: u32 = 15;
pub const PP_DELETEKEY: u32 = 24;
pub const PP_PIN_PROMPT_STRING: u32 = 44;
pub const PP_SECURE_KEYEXCHANGE_PIN: u32 = 47;
pub const PP_SECURE_SIGNATURE_PIN: u32 = 48;
pub const PP_DISMISS_PIN_UI_SEC: u32 = 49;
pub const PP_IS_PFX_EPHEMERAL: u32 = 50;
pub const PROV_RSA_FULL: u32 = 1;
pub const PROV_RSA_SIG: u32 = 2;
pub const PROV_DSS: u32 = 3;
pub const PROV_FORTEZZA: u32 = 4;
pub const PROV_MS_EXCHANGE: u32 = 5;
pub const PROV_SSL: u32 = 6;
pub const PROV_RSA_SCHANNEL: u32 = 12;
pub const PROV_DSS_DH: u32 = 13;
pub const PROV_EC_ECDSA_SIG: u32 = 14;
pub const PROV_EC_ECNRA_SIG: u32 = 15;
pub const PROV_EC_ECDSA_FULL: u32 = 16;
pub const PROV_EC_ECNRA_FULL: u32 = 17;
pub const PROV_DH_SCHANNEL: u32 = 18;
pub const PROV_SPYRUS_LYNKS: u32 = 20;
pub const PROV_RNG: u32 = 21;
pub const PROV_INTEL_SEC: u32 = 22;
pub const PROV_REPLACE_OWF: u32 = 23;
pub const PROV_RSA_AES: u32 = 24;
pub const MS_DEF_PROV_A: &[u8; 43usize] = b"Microsoft Base Cryptographic Provider v1.0\0";
pub const MS_DEF_PROV_W: &[u8; 43usize] = b"Microsoft Base Cryptographic Provider v1.0\0";
pub const MS_DEF_PROV: &[u8; 43usize] = b"Microsoft Base Cryptographic Provider v1.0\0";
pub const MS_ENHANCED_PROV_A: &[u8; 47usize] = b"Microsoft Enhanced Cryptographic Provider v1.0\0";
pub const MS_ENHANCED_PROV_W: &[u8; 47usize] = b"Microsoft Enhanced Cryptographic Provider v1.0\0";
pub const MS_ENHANCED_PROV: &[u8; 47usize] = b"Microsoft Enhanced Cryptographic Provider v1.0\0";
pub const MS_STRONG_PROV_A: &[u8; 40usize] = b"Microsoft Strong Cryptographic Provider\0";
pub const MS_STRONG_PROV_W: &[u8; 40usize] = b"Microsoft Strong Cryptographic Provider\0";
pub const MS_STRONG_PROV: &[u8; 40usize] = b"Microsoft Strong Cryptographic Provider\0";
pub const MS_DEF_RSA_SIG_PROV_A: &[u8; 47usize] =
    b"Microsoft RSA Signature Cryptographic Provider\0";
pub const MS_DEF_RSA_SIG_PROV_W: &[u8; 47usize] =
    b"Microsoft RSA Signature Cryptographic Provider\0";
pub const MS_DEF_RSA_SIG_PROV: &[u8; 47usize] = b"Microsoft RSA Signature Cryptographic Provider\0";
pub const MS_DEF_RSA_SCHANNEL_PROV_A: &[u8; 46usize] =
    b"Microsoft RSA SChannel Cryptographic Provider\0";
pub const MS_DEF_RSA_SCHANNEL_PROV_W: &[u8; 46usize] =
    b"Microsoft RSA SChannel Cryptographic Provider\0";
pub const MS_DEF_RSA_SCHANNEL_PROV: &[u8; 46usize] =
    b"Microsoft RSA SChannel Cryptographic Provider\0";
pub const MS_DEF_DSS_PROV_A: &[u8; 42usize] = b"Microsoft Base DSS Cryptographic Provider\0";
pub const MS_DEF_DSS_PROV_W: &[u8; 42usize] = b"Microsoft Base DSS Cryptographic Provider\0";
pub const MS_DEF_DSS_PROV: &[u8; 42usize] = b"Microsoft Base DSS Cryptographic Provider\0";
pub const MS_DEF_DSS_DH_PROV_A: &[u8; 61usize] =
    b"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider\0";
pub const MS_DEF_DSS_DH_PROV_W: &[u8; 61usize] =
    b"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider\0";
pub const MS_DEF_DSS_DH_PROV: &[u8; 61usize] =
    b"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider\0";
pub const MS_ENH_DSS_DH_PROV_A: &[u8; 65usize] =
    b"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider\0";
pub const MS_ENH_DSS_DH_PROV_W: &[u8; 65usize] =
    b"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider\0";
pub const MS_ENH_DSS_DH_PROV: &[u8; 65usize] =
    b"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider\0";
pub const MS_DEF_DH_SCHANNEL_PROV_A: &[u8; 45usize] =
    b"Microsoft DH SChannel Cryptographic Provider\0";
pub const MS_DEF_DH_SCHANNEL_PROV_W: &[u8; 45usize] =
    b"Microsoft DH SChannel Cryptographic Provider\0";
pub const MS_DEF_DH_SCHANNEL_PROV: &[u8; 45usize] =
    b"Microsoft DH SChannel Cryptographic Provider\0";
pub const MS_SCARD_PROV_A: &[u8; 42usize] = b"Microsoft Base Smart Card Crypto Provider\0";
pub const MS_SCARD_PROV_W: &[u8; 42usize] = b"Microsoft Base Smart Card Crypto Provider\0";
pub const MS_SCARD_PROV: &[u8; 42usize] = b"Microsoft Base Smart Card Crypto Provider\0";
pub const MS_ENH_RSA_AES_PROV_A: &[u8; 54usize] =
    b"Microsoft Enhanced RSA and AES Cryptographic Provider\0";
pub const MS_ENH_RSA_AES_PROV_W: &[u8; 54usize] =
    b"Microsoft Enhanced RSA and AES Cryptographic Provider\0";
pub const MS_ENH_RSA_AES_PROV_XP_A: &[u8; 66usize] =
    b"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)\0";
pub const MS_ENH_RSA_AES_PROV_XP_W: &[u8; 66usize] =
    b"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)\0";
pub const MS_ENH_RSA_AES_PROV_XP: &[u8; 66usize] =
    b"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)\0";
pub const MS_ENH_RSA_AES_PROV: &[u8; 54usize] =
    b"Microsoft Enhanced RSA and AES Cryptographic Provider\0";
pub const MAXUIDLEN: u32 = 64;
pub const EXPO_OFFLOAD_REG_VALUE: &[u8; 12usize] = b"ExpoOffload\0";
pub const EXPO_OFFLOAD_FUNC_NAME: &[u8; 15usize] = b"OffloadModExpo\0";
pub const szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS: &[u8; 41usize] =
    b"Software\\Policies\\Microsoft\\Cryptography\0";
pub const szKEY_CACHE_ENABLED: &[u8; 17usize] = b"CachePrivateKeys\0";
pub const szKEY_CACHE_SECONDS: &[u8; 26usize] = b"PrivateKeyLifetimeSeconds\0";
pub const szPRIV_KEY_CACHE_MAX_ITEMS: &[u8; 21usize] = b"PrivKeyCacheMaxItems\0";
pub const cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT: u32 = 20;
pub const szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS: &[u8; 33usize] =
    b"PrivKeyCachePurgeIntervalSeconds\0";
pub const cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT: u32 = 86400;
pub const CUR_BLOB_VERSION: u32 = 2;
pub const SCHANNEL_MAC_KEY: u32 = 0;
pub const SCHANNEL_ENC_KEY: u32 = 1;
pub const INTERNATIONAL_USAGE: u32 = 1;
pub const BCRYPT_OBJECT_ALIGNMENT: u32 = 16;
pub const BCRYPT_KDF_HASH: &[u8; 5usize] = b"HASH\0";
pub const BCRYPT_KDF_HMAC: &[u8; 5usize] = b"HMAC\0";
pub const BCRYPT_KDF_TLS_PRF: &[u8; 8usize] = b"TLS_PRF\0";
pub const BCRYPT_KDF_SP80056A_CONCAT: &[u8; 17usize] = b"SP800_56A_CONCAT\0";
pub const BCRYPT_KDF_RAW_SECRET: &[u8; 9usize] = b"TRUNCATE\0";
pub const BCRYPT_KDF_HKDF: &[u8; 5usize] = b"HKDF\0";
pub const KDF_HASH_ALGORITHM: u32 = 0;
pub const KDF_SECRET_PREPEND: u32 = 1;
pub const KDF_SECRET_APPEND: u32 = 2;
pub const KDF_HMAC_KEY: u32 = 3;
pub const KDF_TLS_PRF_LABEL: u32 = 4;
pub const KDF_TLS_PRF_SEED: u32 = 5;
pub const KDF_SECRET_HANDLE: u32 = 6;
pub const KDF_TLS_PRF_PROTOCOL: u32 = 7;
pub const KDF_ALGORITHMID: u32 = 8;
pub const KDF_PARTYUINFO: u32 = 9;
pub const KDF_PARTYVINFO: u32 = 10;
pub const KDF_SUPPPUBINFO: u32 = 11;
pub const KDF_SUPPPRIVINFO: u32 = 12;
pub const KDF_LABEL: u32 = 13;
pub const KDF_CONTEXT: u32 = 14;
pub const KDF_SALT: u32 = 15;
pub const KDF_ITERATION_COUNT: u32 = 16;
pub const KDF_GENERIC_PARAMETER: u32 = 17;
pub const KDF_KEYBITLENGTH: u32 = 18;
pub const KDF_HKDF_SALT: u32 = 19;
pub const KDF_HKDF_INFO: u32 = 20;
pub const KDF_USE_SECRET_AS_HMAC_KEY_FLAG: u32 = 1;
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION: u32 = 1;
pub const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG: u32 = 1;
pub const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG: u32 = 2;
pub const BCRYPT_OPAQUE_KEY_BLOB: &[u8; 14usize] = b"OpaqueKeyBlob\0";
pub const BCRYPT_KEY_DATA_BLOB: &[u8; 12usize] = b"KeyDataBlob\0";
pub const BCRYPT_AES_WRAP_KEY_BLOB: &[u8; 19usize] = b"Rfc3565KeyWrapBlob\0";
pub const BCRYPT_OBJECT_LENGTH: &[u8; 13usize] = b"ObjectLength\0";
pub const BCRYPT_ALGORITHM_NAME: &[u8; 14usize] = b"AlgorithmName\0";
pub const BCRYPT_PROVIDER_HANDLE: &[u8; 15usize] = b"ProviderHandle\0";
pub const BCRYPT_CHAINING_MODE: &[u8; 13usize] = b"ChainingMode\0";
pub const BCRYPT_BLOCK_LENGTH: &[u8; 12usize] = b"BlockLength\0";
pub const BCRYPT_KEY_LENGTH: &[u8; 10usize] = b"KeyLength\0";
pub const BCRYPT_KEY_OBJECT_LENGTH: &[u8; 16usize] = b"KeyObjectLength\0";
pub const BCRYPT_KEY_STRENGTH: &[u8; 12usize] = b"KeyStrength\0";
pub const BCRYPT_KEY_LENGTHS: &[u8; 11usize] = b"KeyLengths\0";
pub const BCRYPT_BLOCK_SIZE_LIST: &[u8; 14usize] = b"BlockSizeList\0";
pub const BCRYPT_EFFECTIVE_KEY_LENGTH: &[u8; 19usize] = b"EffectiveKeyLength\0";
pub const BCRYPT_HASH_LENGTH: &[u8; 17usize] = b"HashDigestLength\0";
pub const BCRYPT_HASH_OID_LIST: &[u8; 12usize] = b"HashOIDList\0";
pub const BCRYPT_PADDING_SCHEMES: &[u8; 15usize] = b"PaddingSchemes\0";
pub const BCRYPT_SIGNATURE_LENGTH: &[u8; 16usize] = b"SignatureLength\0";
pub const BCRYPT_HASH_BLOCK_LENGTH: &[u8; 16usize] = b"HashBlockLength\0";
pub const BCRYPT_AUTH_TAG_LENGTH: &[u8; 14usize] = b"AuthTagLength\0";
pub const BCRYPT_PRIMITIVE_TYPE: &[u8; 14usize] = b"PrimitiveType\0";
pub const BCRYPT_IS_KEYED_HASH: &[u8; 12usize] = b"IsKeyedHash\0";
pub const BCRYPT_IS_REUSABLE_HASH: &[u8; 15usize] = b"IsReusableHash\0";
pub const BCRYPT_MESSAGE_BLOCK_LENGTH: &[u8; 19usize] = b"MessageBlockLength\0";
pub const BCRYPT_PUBLIC_KEY_LENGTH: &[u8; 16usize] = b"PublicKeyLength\0";
pub const BCRYPT_PCP_PLATFORM_TYPE_PROPERTY: &[u8; 18usize] = b"PCP_PLATFORM_TYPE\0";
pub const BCRYPT_PCP_PROVIDER_VERSION_PROPERTY: &[u8; 21usize] = b"PCP_PROVIDER_VERSION\0";
pub const BCRYPT_MULTI_OBJECT_LENGTH: &[u8; 18usize] = b"MultiObjectLength\0";
pub const BCRYPT_IS_IFX_TPM_WEAK_KEY: &[u8; 16usize] = b"IsIfxTpmWeakKey\0";
pub const BCRYPT_HKDF_HASH_ALGORITHM: &[u8; 18usize] = b"HkdfHashAlgorithm\0";
pub const BCRYPT_HKDF_SALT_AND_FINALIZE: &[u8; 20usize] = b"HkdfSaltAndFinalize\0";
pub const BCRYPT_HKDF_PRK_AND_FINALIZE: &[u8; 19usize] = b"HkdfPrkAndFinalize\0";
pub const BCRYPT_INITIALIZATION_VECTOR: &[u8; 3usize] = b"IV\0";
pub const BCRYPT_CHAIN_MODE_NA: &[u8; 16usize] = b"ChainingModeN/A\0";
pub const BCRYPT_CHAIN_MODE_CBC: &[u8; 16usize] = b"ChainingModeCBC\0";
pub const BCRYPT_CHAIN_MODE_ECB: &[u8; 16usize] = b"ChainingModeECB\0";
pub const BCRYPT_CHAIN_MODE_CFB: &[u8; 16usize] = b"ChainingModeCFB\0";
pub const BCRYPT_CHAIN_MODE_CCM: &[u8; 16usize] = b"ChainingModeCCM\0";
pub const BCRYPT_CHAIN_MODE_GCM: &[u8; 16usize] = b"ChainingModeGCM\0";
pub const BCRYPT_SUPPORTED_PAD_ROUTER: u32 = 1;
pub const BCRYPT_SUPPORTED_PAD_PKCS1_ENC: u32 = 2;
pub const BCRYPT_SUPPORTED_PAD_PKCS1_SIG: u32 = 4;
pub const BCRYPT_SUPPORTED_PAD_OAEP: u32 = 8;
pub const BCRYPT_SUPPORTED_PAD_PSS: u32 = 16;
pub const BCRYPT_PROV_DISPATCH: u32 = 1;
pub const BCRYPT_BLOCK_PADDING: u32 = 1;
pub const BCRYPT_GENERATE_IV: u32 = 32;
pub const BCRYPT_PAD_NONE: u32 = 1;
pub const BCRYPT_PAD_PKCS1: u32 = 2;
pub const BCRYPT_PAD_OAEP: u32 = 4;
pub const BCRYPT_PAD_PSS: u32 = 8;
pub const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID: u32 = 16;
pub const BCRYPTBUFFER_VERSION: u32 = 0;
pub const BCRYPT_PUBLIC_KEY_BLOB: &[u8; 11usize] = b"PUBLICBLOB\0";
pub const BCRYPT_PRIVATE_KEY_BLOB: &[u8; 12usize] = b"PRIVATEBLOB\0";
pub const BCRYPT_RSAPUBLIC_BLOB: &[u8; 14usize] = b"RSAPUBLICBLOB\0";
pub const BCRYPT_RSAPRIVATE_BLOB: &[u8; 15usize] = b"RSAPRIVATEBLOB\0";
pub const LEGACY_RSAPUBLIC_BLOB: &[u8; 15usize] = b"CAPIPUBLICBLOB\0";
pub const LEGACY_RSAPRIVATE_BLOB: &[u8; 16usize] = b"CAPIPRIVATEBLOB\0";
pub const BCRYPT_RSAPUBLIC_MAGIC: u32 = 826364754;
pub const BCRYPT_RSAPRIVATE_MAGIC: u32 = 843141970;
pub const BCRYPT_RSAFULLPRIVATE_BLOB: &[u8; 19usize] = b"RSAFULLPRIVATEBLOB\0";
pub const BCRYPT_RSAFULLPRIVATE_MAGIC: u32 = 859919186;
pub const BCRYPT_GLOBAL_PARAMETERS: &[u8; 21usize] = b"SecretAgreementParam\0";
pub const BCRYPT_PRIVATE_KEY: &[u8; 11usize] = b"PrivKeyVal\0";
pub const BCRYPT_ECCPUBLIC_BLOB: &[u8; 14usize] = b"ECCPUBLICBLOB\0";
pub const BCRYPT_ECCPRIVATE_BLOB: &[u8; 15usize] = b"ECCPRIVATEBLOB\0";
pub const BCRYPT_ECCFULLPUBLIC_BLOB: &[u8; 18usize] = b"ECCFULLPUBLICBLOB\0";
pub const BCRYPT_ECCFULLPRIVATE_BLOB: &[u8; 19usize] = b"ECCFULLPRIVATEBLOB\0";
pub const SSL_ECCPUBLIC_BLOB: &[u8; 17usize] = b"SSLECCPUBLICBLOB\0";
pub const BCRYPT_ECDH_PUBLIC_P256_MAGIC: u32 = 827016005;
pub const BCRYPT_ECDH_PRIVATE_P256_MAGIC: u32 = 843793221;
pub const BCRYPT_ECDH_PUBLIC_P384_MAGIC: u32 = 860570437;
pub const BCRYPT_ECDH_PRIVATE_P384_MAGIC: u32 = 877347653;
pub const BCRYPT_ECDH_PUBLIC_P521_MAGIC: u32 = 894124869;
pub const BCRYPT_ECDH_PRIVATE_P521_MAGIC: u32 = 910902085;
pub const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC: u32 = 1347109701;
pub const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC: u32 = 1447772997;
pub const BCRYPT_ECDSA_PUBLIC_P256_MAGIC: u32 = 827540293;
pub const BCRYPT_ECDSA_PRIVATE_P256_MAGIC: u32 = 844317509;
pub const BCRYPT_ECDSA_PUBLIC_P384_MAGIC: u32 = 861094725;
pub const BCRYPT_ECDSA_PRIVATE_P384_MAGIC: u32 = 877871941;
pub const BCRYPT_ECDSA_PUBLIC_P521_MAGIC: u32 = 894649157;
pub const BCRYPT_ECDSA_PRIVATE_P521_MAGIC: u32 = 911426373;
pub const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC: u32 = 1346650949;
pub const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC: u32 = 1447314245;
pub const BCRYPT_ECC_FULLKEY_BLOB_V1: u32 = 1;
pub const BCRYPT_DH_PUBLIC_BLOB: &[u8; 13usize] = b"DHPUBLICBLOB\0";
pub const BCRYPT_DH_PRIVATE_BLOB: &[u8; 14usize] = b"DHPRIVATEBLOB\0";
pub const LEGACY_DH_PUBLIC_BLOB: &[u8; 17usize] = b"CAPIDHPUBLICBLOB\0";
pub const LEGACY_DH_PRIVATE_BLOB: &[u8; 18usize] = b"CAPIDHPRIVATEBLOB\0";
pub const BCRYPT_DH_PUBLIC_MAGIC: u32 = 1112557636;
pub const BCRYPT_DH_PRIVATE_MAGIC: u32 = 1448101956;
pub const BCRYPT_DH_PARAMETERS: &[u8; 13usize] = b"DHParameters\0";
pub const BCRYPT_DH_PARAMETERS_MAGIC: u32 = 1297107012;
pub const BCRYPT_DSA_PUBLIC_BLOB: &[u8; 14usize] = b"DSAPUBLICBLOB\0";
pub const BCRYPT_DSA_PRIVATE_BLOB: &[u8; 15usize] = b"DSAPRIVATEBLOB\0";
pub const LEGACY_DSA_PUBLIC_BLOB: &[u8; 18usize] = b"CAPIDSAPUBLICBLOB\0";
pub const LEGACY_DSA_PRIVATE_BLOB: &[u8; 19usize] = b"CAPIDSAPRIVATEBLOB\0";
pub const LEGACY_DSA_V2_PUBLIC_BLOB: &[u8; 20usize] = b"V2CAPIDSAPUBLICBLOB\0";
pub const LEGACY_DSA_V2_PRIVATE_BLOB: &[u8; 21usize] = b"V2CAPIDSAPRIVATEBLOB\0";
pub const BCRYPT_DSA_PUBLIC_MAGIC: u32 = 1112560452;
pub const BCRYPT_DSA_PRIVATE_MAGIC: u32 = 1448104772;
pub const BCRYPT_DSA_PUBLIC_MAGIC_V2: u32 = 843206724;
pub const BCRYPT_DSA_PRIVATE_MAGIC_V2: u32 = 844517444;
pub const BCRYPT_KEY_DATA_BLOB_MAGIC: u32 = 1296188491;
pub const BCRYPT_KEY_DATA_BLOB_VERSION1: u32 = 1;
pub const BCRYPT_DSA_PARAMETERS: &[u8; 14usize] = b"DSAParameters\0";
pub const BCRYPT_DSA_PARAMETERS_MAGIC: u32 = 1297109828;
pub const BCRYPT_DSA_PARAMETERS_MAGIC_V2: u32 = 843927620;
pub const BCRYPT_ECC_PARAMETERS: &[u8; 14usize] = b"ECCParameters\0";
pub const BCRYPT_ECC_CURVE_NAME: &[u8; 13usize] = b"ECCCurveName\0";
pub const BCRYPT_ECC_CURVE_NAME_LIST: &[u8; 17usize] = b"ECCCurveNameList\0";
pub const BCRYPT_ECC_PARAMETERS_MAGIC: u32 = 1346585413;
pub const BCRYPT_ECC_CURVE_BRAINPOOLP160R1: &[u8; 16usize] = b"brainpoolP160r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP160T1: &[u8; 16usize] = b"brainpoolP160t1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP192R1: &[u8; 16usize] = b"brainpoolP192r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP192T1: &[u8; 16usize] = b"brainpoolP192t1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP224R1: &[u8; 16usize] = b"brainpoolP224r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP224T1: &[u8; 16usize] = b"brainpoolP224t1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP256R1: &[u8; 16usize] = b"brainpoolP256r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP256T1: &[u8; 16usize] = b"brainpoolP256t1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP320R1: &[u8; 16usize] = b"brainpoolP320r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP320T1: &[u8; 16usize] = b"brainpoolP320t1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP384R1: &[u8; 16usize] = b"brainpoolP384r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP384T1: &[u8; 16usize] = b"brainpoolP384t1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP512R1: &[u8; 16usize] = b"brainpoolP512r1\0";
pub const BCRYPT_ECC_CURVE_BRAINPOOLP512T1: &[u8; 16usize] = b"brainpoolP512t1\0";
pub const BCRYPT_ECC_CURVE_25519: &[u8; 11usize] = b"curve25519\0";
pub const BCRYPT_ECC_CURVE_EC192WAPI: &[u8; 10usize] = b"ec192wapi\0";
pub const BCRYPT_ECC_CURVE_NISTP192: &[u8; 9usize] = b"nistP192\0";
pub const BCRYPT_ECC_CURVE_NISTP224: &[u8; 9usize] = b"nistP224\0";
pub const BCRYPT_ECC_CURVE_NISTP256: &[u8; 9usize] = b"nistP256\0";
pub const BCRYPT_ECC_CURVE_NISTP384: &[u8; 9usize] = b"nistP384\0";
pub const BCRYPT_ECC_CURVE_NISTP521: &[u8; 9usize] = b"nistP521\0";
pub const BCRYPT_ECC_CURVE_NUMSP256T1: &[u8; 11usize] = b"numsP256t1\0";
pub const BCRYPT_ECC_CURVE_NUMSP384T1: &[u8; 11usize] = b"numsP384t1\0";
pub const BCRYPT_ECC_CURVE_NUMSP512T1: &[u8; 11usize] = b"numsP512t1\0";
pub const BCRYPT_ECC_CURVE_SECP160K1: &[u8; 10usize] = b"secP160k1\0";
pub const BCRYPT_ECC_CURVE_SECP160R1: &[u8; 10usize] = b"secP160r1\0";
pub const BCRYPT_ECC_CURVE_SECP160R2: &[u8; 10usize] = b"secP160r2\0";
pub const BCRYPT_ECC_CURVE_SECP192K1: &[u8; 10usize] = b"secP192k1\0";
pub const BCRYPT_ECC_CURVE_SECP192R1: &[u8; 10usize] = b"secP192r1\0";
pub const BCRYPT_ECC_CURVE_SECP224K1: &[u8; 10usize] = b"secP224k1\0";
pub const BCRYPT_ECC_CURVE_SECP224R1: &[u8; 10usize] = b"secP224r1\0";
pub const BCRYPT_ECC_CURVE_SECP256K1: &[u8; 10usize] = b"secP256k1\0";
pub const BCRYPT_ECC_CURVE_SECP256R1: &[u8; 10usize] = b"secP256r1\0";
pub const BCRYPT_ECC_CURVE_SECP384R1: &[u8; 10usize] = b"secP384r1\0";
pub const BCRYPT_ECC_CURVE_SECP521R1: &[u8; 10usize] = b"secP521r1\0";
pub const BCRYPT_ECC_CURVE_WTLS7: &[u8; 6usize] = b"wtls7\0";
pub const BCRYPT_ECC_CURVE_WTLS9: &[u8; 6usize] = b"wtls9\0";
pub const BCRYPT_ECC_CURVE_WTLS12: &[u8; 7usize] = b"wtls12\0";
pub const BCRYPT_ECC_CURVE_X962P192V1: &[u8; 11usize] = b"x962P192v1\0";
pub const BCRYPT_ECC_CURVE_X962P192V2: &[u8; 11usize] = b"x962P192v2\0";
pub const BCRYPT_ECC_CURVE_X962P192V3: &[u8; 11usize] = b"x962P192v3\0";
pub const BCRYPT_ECC_CURVE_X962P239V1: &[u8; 11usize] = b"x962P239v1\0";
pub const BCRYPT_ECC_CURVE_X962P239V2: &[u8; 11usize] = b"x962P239v2\0";
pub const BCRYPT_ECC_CURVE_X962P239V3: &[u8; 11usize] = b"x962P239v3\0";
pub const BCRYPT_ECC_CURVE_X962P256V1: &[u8; 11usize] = b"x962P256v1\0";
pub const MS_PRIMITIVE_PROVIDER: &[u8; 29usize] = b"Microsoft Primitive Provider\0";
pub const MS_PLATFORM_CRYPTO_PROVIDER: &[u8; 35usize] = b"Microsoft Platform Crypto Provider\0";
pub const BCRYPT_RSA_ALGORITHM: &[u8; 4usize] = b"RSA\0";
pub const BCRYPT_RSA_SIGN_ALGORITHM: &[u8; 9usize] = b"RSA_SIGN\0";
pub const BCRYPT_DH_ALGORITHM: &[u8; 3usize] = b"DH\0";
pub const BCRYPT_DSA_ALGORITHM: &[u8; 4usize] = b"DSA\0";
pub const BCRYPT_RC2_ALGORITHM: &[u8; 4usize] = b"RC2\0";
pub const BCRYPT_RC4_ALGORITHM: &[u8; 4usize] = b"RC4\0";
pub const BCRYPT_AES_ALGORITHM: &[u8; 4usize] = b"AES\0";
pub const BCRYPT_DES_ALGORITHM: &[u8; 4usize] = b"DES\0";
pub const BCRYPT_DESX_ALGORITHM: &[u8; 5usize] = b"DESX\0";
pub const BCRYPT_3DES_ALGORITHM: &[u8; 5usize] = b"3DES\0";
pub const BCRYPT_3DES_112_ALGORITHM: &[u8; 9usize] = b"3DES_112\0";
pub const BCRYPT_MD2_ALGORITHM: &[u8; 4usize] = b"MD2\0";
pub const BCRYPT_MD4_ALGORITHM: &[u8; 4usize] = b"MD4\0";
pub const BCRYPT_MD5_ALGORITHM: &[u8; 4usize] = b"MD5\0";
pub const BCRYPT_SHA1_ALGORITHM: &[u8; 5usize] = b"SHA1\0";
pub const BCRYPT_SHA256_ALGORITHM: &[u8; 7usize] = b"SHA256\0";
pub const BCRYPT_SHA384_ALGORITHM: &[u8; 7usize] = b"SHA384\0";
pub const BCRYPT_SHA512_ALGORITHM: &[u8; 7usize] = b"SHA512\0";
pub const BCRYPT_AES_GMAC_ALGORITHM: &[u8; 9usize] = b"AES-GMAC\0";
pub const BCRYPT_AES_CMAC_ALGORITHM: &[u8; 9usize] = b"AES-CMAC\0";
pub const BCRYPT_ECDSA_P256_ALGORITHM: &[u8; 11usize] = b"ECDSA_P256\0";
pub const BCRYPT_ECDSA_P384_ALGORITHM: &[u8; 11usize] = b"ECDSA_P384\0";
pub const BCRYPT_ECDSA_P521_ALGORITHM: &[u8; 11usize] = b"ECDSA_P521\0";
pub const BCRYPT_ECDH_P256_ALGORITHM: &[u8; 10usize] = b"ECDH_P256\0";
pub const BCRYPT_ECDH_P384_ALGORITHM: &[u8; 10usize] = b"ECDH_P384\0";
pub const BCRYPT_ECDH_P521_ALGORITHM: &[u8; 10usize] = b"ECDH_P521\0";
pub const BCRYPT_RNG_ALGORITHM: &[u8; 4usize] = b"RNG\0";
pub const BCRYPT_RNG_FIPS186_DSA_ALGORITHM: &[u8; 14usize] = b"FIPS186DSARNG\0";
pub const BCRYPT_RNG_DUAL_EC_ALGORITHM: &[u8; 10usize] = b"DUALECRNG\0";
pub const BCRYPT_SP800108_CTR_HMAC_ALGORITHM: &[u8; 19usize] = b"SP800_108_CTR_HMAC\0";
pub const BCRYPT_SP80056A_CONCAT_ALGORITHM: &[u8; 17usize] = b"SP800_56A_CONCAT\0";
pub const BCRYPT_PBKDF2_ALGORITHM: &[u8; 7usize] = b"PBKDF2\0";
pub const BCRYPT_CAPI_KDF_ALGORITHM: &[u8; 9usize] = b"CAPI_KDF\0";
pub const BCRYPT_TLS1_1_KDF_ALGORITHM: &[u8; 11usize] = b"TLS1_1_KDF\0";
pub const BCRYPT_TLS1_2_KDF_ALGORITHM: &[u8; 11usize] = b"TLS1_2_KDF\0";
pub const BCRYPT_ECDSA_ALGORITHM: &[u8; 6usize] = b"ECDSA\0";
pub const BCRYPT_ECDH_ALGORITHM: &[u8; 5usize] = b"ECDH\0";
pub const BCRYPT_XTS_AES_ALGORITHM: &[u8; 8usize] = b"XTS-AES\0";
pub const BCRYPT_HKDF_ALGORITHM: &[u8; 5usize] = b"HKDF\0";
pub const BCRYPT_CHACHA20_POLY1305_ALGORITHM: &[u8; 18usize] = b"CHACHA20_POLY1305\0";
pub const BCRYPT_CIPHER_INTERFACE: u32 = 1;
pub const BCRYPT_HASH_INTERFACE: u32 = 2;
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE: u32 = 3;
pub const BCRYPT_SECRET_AGREEMENT_INTERFACE: u32 = 4;
pub const BCRYPT_SIGNATURE_INTERFACE: u32 = 5;
pub const BCRYPT_RNG_INTERFACE: u32 = 6;
pub const BCRYPT_KEY_DERIVATION_INTERFACE: u32 = 7;
pub const BCRYPT_ALG_HANDLE_HMAC_FLAG: u32 = 8;
pub const BCRYPT_HASH_REUSABLE_FLAG: u32 = 32;
pub const BCRYPT_CAPI_AES_FLAG: u32 = 16;
pub const BCRYPT_MULTI_FLAG: u32 = 64;
pub const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG: u32 = 4;
pub const BCRYPT_BUFFERS_LOCKED_FLAG: u32 = 64;
pub const BCRYPT_EXTENDED_KEYSIZE: u32 = 128;
pub const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS: u32 = 256;
pub const BCRYPT_CIPHER_OPERATION: u32 = 1;
pub const BCRYPT_HASH_OPERATION: u32 = 2;
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION: u32 = 4;
pub const BCRYPT_SECRET_AGREEMENT_OPERATION: u32 = 8;
pub const BCRYPT_SIGNATURE_OPERATION: u32 = 16;
pub const BCRYPT_RNG_OPERATION: u32 = 32;
pub const BCRYPT_KEY_DERIVATION_OPERATION: u32 = 64;
pub const BCRYPT_PUBLIC_KEY_FLAG: u32 = 1;
pub const BCRYPT_PRIVATE_KEY_FLAG: u32 = 2;
pub const BCRYPT_NO_KEY_VALIDATION: u32 = 8;
pub const BCRYPT_KEY_VALIDATION_RANGE: u32 = 16;
pub const BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER: u32 = 24;
pub const BCRYPT_KEY_VALIDATION_REGENERATE: u32 = 32;
pub const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER: u32 = 1;
pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: u32 = 2;
pub const BCRYPT_HASH_INTERFACE_MAJORVERSION_2: u32 = 2;
pub const CRYPT_MIN_DEPENDENCIES: u32 = 1;
pub const CRYPT_PROCESS_ISOLATE: u32 = 65536;
pub const CRYPT_UM: u32 = 1;
pub const CRYPT_KM: u32 = 2;
pub const CRYPT_MM: u32 = 3;
pub const CRYPT_ANY: u32 = 4;
pub const CRYPT_OVERWRITE: u32 = 1;
pub const CRYPT_LOCAL: u32 = 1;
pub const CRYPT_DOMAIN: u32 = 2;
pub const CRYPT_EXCLUSIVE: u32 = 1;
pub const CRYPT_OVERRIDE: u32 = 65536;
pub const CRYPT_ALL_FUNCTIONS: u32 = 1;
pub const CRYPT_ALL_PROVIDERS: u32 = 2;
pub const CRYPT_PRIORITY_TOP: u32 = 0;
pub const CRYPT_PRIORITY_BOTTOM: u32 = 4294967295;
pub const CRYPT_DEFAULT_CONTEXT: &[u8; 8usize] = b"Default\0";
pub const NCRYPT_MAX_KEY_NAME_LENGTH: u32 = 512;
pub const NCRYPT_MAX_ALG_ID_LENGTH: u32 = 512;
pub const MS_KEY_STORAGE_PROVIDER: &[u8; 40usize] = b"Microsoft Software Key Storage Provider\0";
pub const MS_SMART_CARD_KEY_STORAGE_PROVIDER: &[u8; 42usize] =
    b"Microsoft Smart Card Key Storage Provider\0";
pub const MS_PLATFORM_KEY_STORAGE_PROVIDER: &[u8; 35usize] =
    b"Microsoft Platform Crypto Provider\0";
pub const MS_NGC_KEY_STORAGE_PROVIDER: &[u8; 40usize] =
    b"Microsoft Passport Key Storage Provider\0";
pub const TPM_RSA_SRK_SEAL_KEY: &[u8; 68usize] =
    b"MICROSOFT_PCP_KSP_RSA_SEAL_KEY_3BD1C4BF-004E-4E2F-8A4D-0BF633DCB074\0";
pub const NCRYPT_RSA_ALGORITHM: &[u8; 4usize] = b"RSA\0";
pub const NCRYPT_RSA_SIGN_ALGORITHM: &[u8; 9usize] = b"RSA_SIGN\0";
pub const NCRYPT_DH_ALGORITHM: &[u8; 3usize] = b"DH\0";
pub const NCRYPT_DSA_ALGORITHM: &[u8; 4usize] = b"DSA\0";
pub const NCRYPT_MD2_ALGORITHM: &[u8; 4usize] = b"MD2\0";
pub const NCRYPT_MD4_ALGORITHM: &[u8; 4usize] = b"MD4\0";
pub const NCRYPT_MD5_ALGORITHM: &[u8; 4usize] = b"MD5\0";
pub const NCRYPT_SHA1_ALGORITHM: &[u8; 5usize] = b"SHA1\0";
pub const NCRYPT_SHA256_ALGORITHM: &[u8; 7usize] = b"SHA256\0";
pub const NCRYPT_SHA384_ALGORITHM: &[u8; 7usize] = b"SHA384\0";
pub const NCRYPT_SHA512_ALGORITHM: &[u8; 7usize] = b"SHA512\0";
pub const NCRYPT_ECDSA_P256_ALGORITHM: &[u8; 11usize] = b"ECDSA_P256\0";
pub const NCRYPT_ECDSA_P384_ALGORITHM: &[u8; 11usize] = b"ECDSA_P384\0";
pub const NCRYPT_ECDSA_P521_ALGORITHM: &[u8; 11usize] = b"ECDSA_P521\0";
pub const NCRYPT_ECDH_P256_ALGORITHM: &[u8; 10usize] = b"ECDH_P256\0";
pub const NCRYPT_ECDH_P384_ALGORITHM: &[u8; 10usize] = b"ECDH_P384\0";
pub const NCRYPT_ECDH_P521_ALGORITHM: &[u8; 10usize] = b"ECDH_P521\0";
pub const NCRYPT_AES_ALGORITHM: &[u8; 4usize] = b"AES\0";
pub const NCRYPT_RC2_ALGORITHM: &[u8; 4usize] = b"RC2\0";
pub const NCRYPT_3DES_ALGORITHM: &[u8; 5usize] = b"3DES\0";
pub const NCRYPT_DES_ALGORITHM: &[u8; 4usize] = b"DES\0";
pub const NCRYPT_DESX_ALGORITHM: &[u8; 5usize] = b"DESX\0";
pub const NCRYPT_3DES_112_ALGORITHM: &[u8; 9usize] = b"3DES_112\0";
pub const NCRYPT_SP800108_CTR_HMAC_ALGORITHM: &[u8; 19usize] = b"SP800_108_CTR_HMAC\0";
pub const NCRYPT_SP80056A_CONCAT_ALGORITHM: &[u8; 17usize] = b"SP800_56A_CONCAT\0";
pub const NCRYPT_PBKDF2_ALGORITHM: &[u8; 7usize] = b"PBKDF2\0";
pub const NCRYPT_CAPI_KDF_ALGORITHM: &[u8; 9usize] = b"CAPI_KDF\0";
pub const NCRYPT_ECDSA_ALGORITHM: &[u8; 6usize] = b"ECDSA\0";
pub const NCRYPT_ECDH_ALGORITHM: &[u8; 5usize] = b"ECDH\0";
pub const NCRYPT_KEY_STORAGE_ALGORITHM: &[u8; 12usize] = b"KEY_STORAGE\0";
pub const NCRYPT_HMAC_SHA256_ALGORITHM: &[u8; 12usize] = b"HMAC-SHA256\0";
pub const NCRYPT_CIPHER_INTERFACE: u32 = 1;
pub const NCRYPT_HASH_INTERFACE: u32 = 2;
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE: u32 = 3;
pub const NCRYPT_SECRET_AGREEMENT_INTERFACE: u32 = 4;
pub const NCRYPT_SIGNATURE_INTERFACE: u32 = 5;
pub const NCRYPT_KEY_DERIVATION_INTERFACE: u32 = 7;
pub const NCRYPT_KEY_STORAGE_INTERFACE: u32 = 65537;
pub const NCRYPT_SCHANNEL_INTERFACE: u32 = 65538;
pub const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE: u32 = 65539;
pub const NCRYPT_KEY_PROTECTION_INTERFACE: u32 = 65540;
pub const NCRYPT_RSA_ALGORITHM_GROUP: &[u8; 4usize] = b"RSA\0";
pub const NCRYPT_DH_ALGORITHM_GROUP: &[u8; 3usize] = b"DH\0";
pub const NCRYPT_DSA_ALGORITHM_GROUP: &[u8; 4usize] = b"DSA\0";
pub const NCRYPT_ECDSA_ALGORITHM_GROUP: &[u8; 6usize] = b"ECDSA\0";
pub const NCRYPT_ECDH_ALGORITHM_GROUP: &[u8; 5usize] = b"ECDH\0";
pub const NCRYPT_AES_ALGORITHM_GROUP: &[u8; 4usize] = b"AES\0";
pub const NCRYPT_RC2_ALGORITHM_GROUP: &[u8; 4usize] = b"RC2\0";
pub const NCRYPT_DES_ALGORITHM_GROUP: &[u8; 4usize] = b"DES\0";
pub const NCRYPT_KEY_DERIVATION_GROUP: &[u8; 15usize] = b"KEY_DERIVATION\0";
pub const NCRYPTBUFFER_VERSION: u32 = 0;
pub const NCRYPTBUFFER_EMPTY: u32 = 0;
pub const NCRYPTBUFFER_DATA: u32 = 1;
pub const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING: u32 = 3;
pub const NCRYPTBUFFER_PROTECTION_FLAGS: u32 = 4;
pub const NCRYPTBUFFER_SSL_CLIENT_RANDOM: u32 = 20;
pub const NCRYPTBUFFER_SSL_SERVER_RANDOM: u32 = 21;
pub const NCRYPTBUFFER_SSL_HIGHEST_VERSION: u32 = 22;
pub const NCRYPTBUFFER_SSL_CLEAR_KEY: u32 = 23;
pub const NCRYPTBUFFER_SSL_KEY_ARG_DATA: u32 = 24;
pub const NCRYPTBUFFER_SSL_SESSION_HASH: u32 = 25;
pub const NCRYPTBUFFER_PKCS_OID: u32 = 40;
pub const NCRYPTBUFFER_PKCS_ALG_OID: u32 = 41;
pub const NCRYPTBUFFER_PKCS_ALG_PARAM: u32 = 42;
pub const NCRYPTBUFFER_PKCS_ALG_ID: u32 = 43;
pub const NCRYPTBUFFER_PKCS_ATTRS: u32 = 44;
pub const NCRYPTBUFFER_PKCS_KEY_NAME: u32 = 45;
pub const NCRYPTBUFFER_PKCS_SECRET: u32 = 46;
pub const NCRYPTBUFFER_CERT_BLOB: u32 = 47;
pub const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE: u32 = 48;
pub const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE: u32 = 49;
pub const NCRYPTBUFFER_KEY_PROPERTY_FLAGS: u32 = 50;
pub const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB: u32 = 51;
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE: u32 = 52;
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED: u32 = 53;
pub const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS: u32 = 54;
pub const NCRYPTBUFFER_ECC_CURVE_NAME: u32 = 60;
pub const NCRYPTBUFFER_ECC_PARAMETERS: u32 = 61;
pub const NCRYPTBUFFER_TPM_SEAL_PASSWORD: u32 = 70;
pub const NCRYPTBUFFER_TPM_SEAL_POLICYINFO: u32 = 71;
pub const NCRYPTBUFFER_TPM_SEAL_TICKET: u32 = 72;
pub const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION: u32 = 73;
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK: u32 = 80;
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE: u32 = 81;
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE: u32 = 82;
pub const NCRYPT_CIPHER_NO_PADDING_FLAG: u32 = 0;
pub const NCRYPT_CIPHER_BLOCK_PADDING_FLAG: u32 = 1;
pub const NCRYPT_CIPHER_OTHER_PADDING_FLAG: u32 = 2;
pub const NCRYPT_PLATFORM_ATTEST_MAGIC: u32 = 1146110288;
pub const NCRYPT_KEY_ATTEST_MAGIC: u32 = 1146110283;
pub const NCRYPT_CLAIM_AUTHORITY_ONLY: u32 = 1;
pub const NCRYPT_CLAIM_SUBJECT_ONLY: u32 = 2;
pub const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY: u32 = 258;
pub const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT: u32 = 3;
pub const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT: u32 = 4;
pub const NCRYPT_CLAIM_UNKNOWN: u32 = 4096;
pub const NCRYPT_CLAIM_PLATFORM: u32 = 65536;
pub const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION: u32 = 1;
pub const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY: u32 = 2;
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0: u32 = 0;
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION: u32 = 0;
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0: u32 = 0;
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION: u32 = 0;
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0: u32 = 0;
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION: u32 = 0;
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0: u32 = 0;
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION: u32 = 0;
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0: u32 = 0;
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION: u32 = 0;
pub const NCRYPT_NO_PADDING_FLAG: u32 = 1;
pub const NCRYPT_PAD_PKCS1_FLAG: u32 = 2;
pub const NCRYPT_PAD_OAEP_FLAG: u32 = 4;
pub const NCRYPT_PAD_PSS_FLAG: u32 = 8;
pub const NCRYPT_PAD_CIPHER_FLAG: u32 = 16;
pub const NCRYPT_ATTESTATION_FLAG: u32 = 32;
pub const NCRYPT_SEALING_FLAG: u32 = 256;
pub const NCRYPT_REGISTER_NOTIFY_FLAG: u32 = 1;
pub const NCRYPT_UNREGISTER_NOTIFY_FLAG: u32 = 2;
pub const NCRYPT_NO_KEY_VALIDATION: u32 = 8;
pub const NCRYPT_MACHINE_KEY_FLAG: u32 = 32;
pub const NCRYPT_SILENT_FLAG: u32 = 64;
pub const NCRYPT_OVERWRITE_KEY_FLAG: u32 = 128;
pub const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG: u32 = 512;
pub const NCRYPT_DO_NOT_FINALIZE_FLAG: u32 = 1024;
pub const NCRYPT_EXPORT_LEGACY_FLAG: u32 = 2048;
pub const NCRYPT_IGNORE_DEVICE_STATE_FLAG: u32 = 4096;
pub const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG: u32 = 8192;
pub const NCRYPT_NO_CACHED_PASSWORD: u32 = 16384;
pub const NCRYPT_PROTECT_TO_LOCAL_SYSTEM: u32 = 32768;
pub const NCRYPT_PERSIST_ONLY_FLAG: u32 = 1073741824;
pub const NCRYPT_PERSIST_FLAG: u32 = 2147483648;
pub const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG: u32 = 65536;
pub const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG: u32 = 131072;
pub const NCRYPT_USE_PER_BOOT_KEY_FLAG: u32 = 262144;
pub const NCRYPT_CIPHER_OPERATION: u32 = 1;
pub const NCRYPT_HASH_OPERATION: u32 = 2;
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION: u32 = 4;
pub const NCRYPT_SECRET_AGREEMENT_OPERATION: u32 = 8;
pub const NCRYPT_SIGNATURE_OPERATION: u32 = 16;
pub const NCRYPT_RNG_OPERATION: u32 = 32;
pub const NCRYPT_KEY_DERIVATION_OPERATION: u32 = 64;
pub const NCRYPT_AUTHORITY_KEY_FLAG: u32 = 256;
pub const NCRYPT_EXTENDED_ERRORS_FLAG: u32 = 268435456;
pub const NCRYPT_NAME_PROPERTY: &[u8; 5usize] = b"Name\0";
pub const NCRYPT_UNIQUE_NAME_PROPERTY: &[u8; 12usize] = b"Unique Name\0";
pub const NCRYPT_ALGORITHM_PROPERTY: &[u8; 15usize] = b"Algorithm Name\0";
pub const NCRYPT_LENGTH_PROPERTY: &[u8; 7usize] = b"Length\0";
pub const NCRYPT_LENGTHS_PROPERTY: &[u8; 8usize] = b"Lengths\0";
pub const NCRYPT_BLOCK_LENGTH_PROPERTY: &[u8; 13usize] = b"Block Length\0";
pub const NCRYPT_PUBLIC_LENGTH_PROPERTY: &[u8; 16usize] = b"PublicKeyLength\0";
pub const NCRYPT_SIGNATURE_LENGTH_PROPERTY: &[u8; 16usize] = b"SignatureLength\0";
pub const NCRYPT_CHAINING_MODE_PROPERTY: &[u8; 14usize] = b"Chaining Mode\0";
pub const NCRYPT_AUTH_TAG_LENGTH: &[u8; 14usize] = b"AuthTagLength\0";
pub const NCRYPT_UI_POLICY_PROPERTY: &[u8; 10usize] = b"UI Policy\0";
pub const NCRYPT_EXPORT_POLICY_PROPERTY: &[u8; 14usize] = b"Export Policy\0";
pub const NCRYPT_WINDOW_HANDLE_PROPERTY: &[u8; 12usize] = b"HWND Handle\0";
pub const NCRYPT_USE_CONTEXT_PROPERTY: &[u8; 12usize] = b"Use Context\0";
pub const NCRYPT_IMPL_TYPE_PROPERTY: &[u8; 10usize] = b"Impl Type\0";
pub const NCRYPT_KEY_USAGE_PROPERTY: &[u8; 10usize] = b"Key Usage\0";
pub const NCRYPT_KEY_TYPE_PROPERTY: &[u8; 9usize] = b"Key Type\0";
pub const NCRYPT_VERSION_PROPERTY: &[u8; 8usize] = b"Version\0";
pub const NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY: &[u8; 23usize] = b"Security Descr Support\0";
pub const NCRYPT_SECURITY_DESCR_PROPERTY: &[u8; 15usize] = b"Security Descr\0";
pub const NCRYPT_USE_COUNT_ENABLED_PROPERTY: &[u8; 18usize] = b"Enabled Use Count\0";
pub const NCRYPT_USE_COUNT_PROPERTY: &[u8; 10usize] = b"Use Count\0";
pub const NCRYPT_LAST_MODIFIED_PROPERTY: &[u8; 9usize] = b"Modified\0";
pub const NCRYPT_MAX_NAME_LENGTH_PROPERTY: &[u8; 16usize] = b"Max Name Length\0";
pub const NCRYPT_ALGORITHM_GROUP_PROPERTY: &[u8; 16usize] = b"Algorithm Group\0";
pub const NCRYPT_DH_PARAMETERS_PROPERTY: &[u8; 13usize] = b"DHParameters\0";
pub const NCRYPT_ECC_PARAMETERS_PROPERTY: &[u8; 14usize] = b"ECCParameters\0";
pub const NCRYPT_ECC_CURVE_NAME_PROPERTY: &[u8; 13usize] = b"ECCCurveName\0";
pub const NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY: &[u8; 17usize] = b"ECCCurveNameList\0";
pub const NCRYPT_USE_VIRTUAL_ISOLATION_PROPERTY: &[u8; 12usize] = b"Virtual Iso\0";
pub const NCRYPT_USE_PER_BOOT_KEY_PROPERTY: &[u8; 13usize] = b"Per Boot Key\0";
pub const NCRYPT_PROVIDER_HANDLE_PROPERTY: &[u8; 16usize] = b"Provider Handle\0";
pub const NCRYPT_PIN_PROPERTY: &[u8; 13usize] = b"SmartCardPin\0";
pub const NCRYPT_READER_PROPERTY: &[u8; 16usize] = b"SmartCardReader\0";
pub const NCRYPT_SMARTCARD_GUID_PROPERTY: &[u8; 14usize] = b"SmartCardGuid\0";
pub const NCRYPT_CERTIFICATE_PROPERTY: &[u8; 24usize] = b"SmartCardKeyCertificate\0";
pub const NCRYPT_PIN_PROMPT_PROPERTY: &[u8; 19usize] = b"SmartCardPinPrompt\0";
pub const NCRYPT_USER_CERTSTORE_PROPERTY: &[u8; 23usize] = b"SmartCardUserCertStore\0";
pub const NCRYPT_ROOT_CERTSTORE_PROPERTY: &[u8; 23usize] = b"SmartcardRootCertStore\0";
pub const NCRYPT_SECURE_PIN_PROPERTY: &[u8; 19usize] = b"SmartCardSecurePin\0";
pub const NCRYPT_ASSOCIATED_ECDH_KEY: &[u8; 27usize] = b"SmartCardAssociatedECDHKey\0";
pub const NCRYPT_SCARD_PIN_ID: &[u8; 15usize] = b"SmartCardPinId\0";
pub const NCRYPT_SCARD_PIN_INFO: &[u8; 17usize] = b"SmartCardPinInfo\0";
pub const NCRYPT_READER_ICON_PROPERTY: &[u8; 20usize] = b"SmartCardReaderIcon\0";
pub const NCRYPT_KDF_SECRET_VALUE: &[u8; 13usize] = b"KDFKeySecret\0";
pub const NCRYPT_DISMISS_UI_TIMEOUT_SEC_PROPERTY: &[u8; 33usize] =
    b"SmartCardDismissUITimeoutSeconds\0";
pub const NCRYPT_PCP_PLATFORM_TYPE_PROPERTY: &[u8; 18usize] = b"PCP_PLATFORM_TYPE\0";
pub const NCRYPT_PCP_PROVIDER_VERSION_PROPERTY: &[u8; 21usize] = b"PCP_PROVIDER_VERSION\0";
pub const NCRYPT_PCP_EKPUB_PROPERTY: &[u8; 10usize] = b"PCP_EKPUB\0";
pub const NCRYPT_PCP_EKCERT_PROPERTY: &[u8; 11usize] = b"PCP_EKCERT\0";
pub const NCRYPT_PCP_EKNVCERT_PROPERTY: &[u8; 13usize] = b"PCP_EKNVCERT\0";
pub const NCRYPT_PCP_RSA_EKPUB_PROPERTY: &[u8; 14usize] = b"PCP_RSA_EKPUB\0";
pub const NCRYPT_PCP_RSA_EKCERT_PROPERTY: &[u8; 15usize] = b"PCP_RSA_EKCERT\0";
pub const NCRYPT_PCP_RSA_EKNVCERT_PROPERTY: &[u8; 17usize] = b"PCP_RSA_EKNVCERT\0";
pub const NCRYPT_PCP_ECC_EKPUB_PROPERTY: &[u8; 14usize] = b"PCP_ECC_EKPUB\0";
pub const NCRYPT_PCP_ECC_EKCERT_PROPERTY: &[u8; 15usize] = b"PCP_ECC_EKCERT\0";
pub const NCRYPT_PCP_ECC_EKNVCERT_PROPERTY: &[u8; 17usize] = b"PCP_ECC_EKNVCERT\0";
pub const NCRYPT_PCP_SRKPUB_PROPERTY: &[u8; 11usize] = b"PCP_SRKPUB\0";
pub const NCRYPT_PCP_PCRTABLE_PROPERTY: &[u8; 13usize] = b"PCP_PCRTABLE\0";
pub const NCRYPT_PCP_CHANGEPASSWORD_PROPERTY: &[u8; 19usize] = b"PCP_CHANGEPASSWORD\0";
pub const NCRYPT_PCP_PASSWORD_REQUIRED_PROPERTY: &[u8; 22usize] = b"PCP_PASSWORD_REQUIRED\0";
pub const NCRYPT_PCP_USAGEAUTH_PROPERTY: &[u8; 14usize] = b"PCP_USAGEAUTH\0";
pub const NCRYPT_PCP_MIGRATIONPASSWORD_PROPERTY: &[u8; 22usize] = b"PCP_MIGRATIONPASSWORD\0";
pub const NCRYPT_PCP_EXPORT_ALLOWED_PROPERTY: &[u8; 19usize] = b"PCP_EXPORT_ALLOWED\0";
pub const NCRYPT_PCP_STORAGEPARENT_PROPERTY: &[u8; 18usize] = b"PCP_STORAGEPARENT\0";
pub const NCRYPT_PCP_PROVIDERHANDLE_PROPERTY: &[u8; 20usize] = b"PCP_PROVIDERMHANDLE\0";
pub const NCRYPT_PCP_PLATFORMHANDLE_PROPERTY: &[u8; 19usize] = b"PCP_PLATFORMHANDLE\0";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRMASK_PROPERTY: &[u8; 29usize] =
    b"PCP_PLATFORM_BINDING_PCRMASK\0";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGESTLIST_PROPERTY: &[u8; 35usize] =
    b"PCP_PLATFORM_BINDING_PCRDIGESTLIST\0";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGEST_PROPERTY: &[u8; 31usize] =
    b"PCP_PLATFORM_BINDING_PCRDIGEST\0";
pub const NCRYPT_PCP_KEY_USAGE_POLICY_PROPERTY: &[u8; 21usize] = b"PCP_KEY_USAGE_POLICY\0";
pub const NCRYPT_PCP_RSA_SCHEME_PROPERTY: &[u8; 15usize] = b"PCP_RSA_SCHEME\0";
pub const NCRYPT_PCP_TPM12_IDBINDING_PROPERTY: &[u8; 20usize] = b"PCP_TPM12_IDBINDING\0";
pub const NCRYPT_PCP_TPM12_IDBINDING_DYNAMIC_PROPERTY: &[u8; 28usize] =
    b"PCP_TPM12_IDBINDING_DYNAMIC\0";
pub const NCRYPT_PCP_TPM12_IDACTIVATION_PROPERTY: &[u8; 23usize] = b"PCP_TPM12_IDACTIVATION\0";
pub const NCRYPT_PCP_KEYATTESTATION_PROPERTY: &[u8; 25usize] = b"PCP_TPM12_KEYATTESTATION\0";
pub const NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY: &[u8; 35usize] =
    b"PCP_ALTERNATE_KEY_STORAGE_LOCATION\0";
pub const NCRYPT_PCP_PLATFORM_BINDING_PCRALGID_PROPERTY: &[u8; 30usize] =
    b"PCP_PLATFORM_BINDING_PCRALGID\0";
pub const NCRYPT_PCP_HMAC_AUTH_POLICYREF: &[u8; 24usize] = b"PCP_HMAC_AUTH_POLICYREF\0";
pub const NCRYPT_PCP_HMAC_AUTH_POLICYINFO: &[u8; 25usize] = b"PCP_HMAC_AUTH_POLICYINFO\0";
pub const NCRYPT_PCP_HMAC_AUTH_NONCE: &[u8; 20usize] = b"PCP_HMAC_AUTH_NONCE\0";
pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE: &[u8; 24usize] = b"PCP_HMAC_AUTH_SIGNATURE\0";
pub const NCRYPT_PCP_HMAC_AUTH_TICKET: &[u8; 21usize] = b"PCP_HMAC_AUTH_TICKET\0";
pub const NCRYPT_PCP_NO_DA_PROTECTION_PROPERTY: &[u8; 21usize] = b"PCP_NO_DA_PROTECTION\0";
pub const NCRYPT_PCP_TPM_MANUFACTURER_ID_PROPERTY: &[u8; 24usize] = b"PCP_TPM_MANUFACTURER_ID\0";
pub const NCRYPT_PCP_TPM_FW_VERSION_PROPERTY: &[u8; 19usize] = b"PCP_TPM_FW_VERSION\0";
pub const NCRYPT_PCP_TPM2BNAME_PROPERTY: &[u8; 14usize] = b"PCP_TPM2BNAME\0";
pub const NCRYPT_PCP_TPM_VERSION_PROPERTY: &[u8; 16usize] = b"PCP_TPM_VERSION\0";
pub const NCRYPT_PCP_RAW_POLICYDIGEST_PROPERTY: &[u8; 21usize] = b"PCP_RAW_POLICYDIGEST\0";
pub const NCRYPT_PCP_KEY_CREATIONHASH_PROPERTY: &[u8; 21usize] = b"PCP_KEY_CREATIONHASH\0";
pub const NCRYPT_PCP_KEY_CREATIONTICKET_PROPERTY: &[u8; 23usize] = b"PCP_KEY_CREATIONTICKET\0";
pub const NCRYPT_PCP_RSA_SCHEME_HASH_ALG_PROPERTY: &[u8; 24usize] = b"PCP_RSA_SCHEME_HASH_ALG\0";
pub const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED_PROPERTY: &[u8; 34usize] =
    b"PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED\0";
pub const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY_PROPERTY: &[u8; 37usize] =
    b"PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY\0";
pub const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED: u32 = 0;
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1: u32 = 1;
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2: u32 = 2;
pub const NCRYPT_PCP_SESSIONID_PROPERTY: &[u8; 14usize] = b"PCP_SESSIONID\0";
pub const NCRYPT_PCP_PSS_SALT_SIZE_PROPERTY: &[u8; 14usize] = b"PSS Salt Size\0";
pub const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN: u32 = 0;
pub const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM: u32 = 1;
pub const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE: u32 = 2;
pub const NCRYPT_PCP_INTERMEDIATE_CA_EKCERT_PROPERTY: &[u8; 27usize] =
    b"PCP_INTERMEDIATE_CA_EKCERT\0";
pub const NCRYPT_PCP_PCRTABLE_ALGORITHM_PROPERTY: &[u8; 23usize] = b"PCP_PCRTABLE_ALGORITHM\0";
pub const NCRYPT_PCP_SYMMETRIC_KEYBITS_PROPERTY: &[u8; 22usize] = b"PCP_SYMMETRIC_KEYBITS\0";
pub const NCRYPT_TPM_PAD_PSS_IGNORE_SALT: u32 = 32;
pub const NCRYPT_TPM12_PROVIDER: u32 = 65536;
pub const NCRYPT_PCP_SIGNATURE_KEY: u32 = 1;
pub const NCRYPT_PCP_ENCRYPTION_KEY: u32 = 2;
pub const NCRYPT_PCP_GENERIC_KEY: u32 = 3;
pub const NCRYPT_PCP_STORAGE_KEY: u32 = 4;
pub const NCRYPT_PCP_IDENTITY_KEY: u32 = 8;
pub const NCRYPT_PCP_HMACVERIFICATION_KEY: u32 = 16;
pub const NCRYPT_SCARD_NGC_KEY_NAME: &[u8; 20usize] = b"SmartCardNgcKeyName\0";
pub const NCRYPT_INITIALIZATION_VECTOR: &[u8; 3usize] = b"IV\0";
pub const NCRYPT_CHANGEPASSWORD_PROPERTY: &[u8; 19usize] = b"PCP_CHANGEPASSWORD\0";
pub const NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY: &[u8; 35usize] =
    b"PCP_ALTERNATE_KEY_STORAGE_LOCATION\0";
pub const NCRYPT_KEY_ACCESS_POLICY_PROPERTY: &[u8; 18usize] = b"Key Access Policy\0";
pub const NCRYPT_MAX_PROPERTY_NAME: u32 = 64;
pub const NCRYPT_MAX_PROPERTY_DATA: u32 = 1048576;
pub const NCRYPT_ALLOW_EXPORT_FLAG: u32 = 1;
pub const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG: u32 = 2;
pub const NCRYPT_ALLOW_ARCHIVING_FLAG: u32 = 4;
pub const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG: u32 = 8;
pub const NCRYPT_IMPL_HARDWARE_FLAG: u32 = 1;
pub const NCRYPT_IMPL_SOFTWARE_FLAG: u32 = 2;
pub const NCRYPT_IMPL_REMOVABLE_FLAG: u32 = 8;
pub const NCRYPT_IMPL_HARDWARE_RNG_FLAG: u32 = 16;
pub const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG: u32 = 32;
pub const NCRYPT_ALLOW_DECRYPT_FLAG: u32 = 1;
pub const NCRYPT_ALLOW_SIGNING_FLAG: u32 = 2;
pub const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG: u32 = 4;
pub const NCRYPT_ALLOW_KEY_IMPORT_FLAG: u32 = 8;
pub const NCRYPT_ALLOW_ALL_USAGES: u32 = 16777215;
pub const NCRYPT_UI_PROTECT_KEY_FLAG: u32 = 1;
pub const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG: u32 = 2;
pub const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG: u32 = 4;
pub const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG: u32 = 8;
pub const NCRYPT_PIN_CACHE_FREE_APPLICATION_TICKET_PROPERTY: &[u8; 30usize] =
    b"PinCacheFreeApplicationTicket\0";
pub const NCRYPT_PIN_CACHE_FLAGS_PROPERTY: &[u8; 14usize] = b"PinCacheFlags\0";
pub const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG: u32 = 1;
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_PROPERTY: &[u8; 26usize] =
    b"PinCacheApplicationTicket\0";
pub const NCRYPT_PIN_CACHE_APPLICATION_IMAGE_PROPERTY: &[u8; 25usize] =
    b"PinCacheApplicationImage\0";
pub const NCRYPT_PIN_CACHE_APPLICATION_STATUS_PROPERTY: &[u8; 26usize] =
    b"PinCacheApplicationStatus\0";
pub const NCRYPT_PIN_CACHE_PIN_PROPERTY: &[u8; 12usize] = b"PinCachePin\0";
pub const NCRYPT_PIN_CACHE_IS_GESTURE_REQUIRED_PROPERTY: &[u8; 26usize] =
    b"PinCacheIsGestureRequired\0";
pub const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG: u32 = 1;
pub const NCRYPT_PIN_CACHE_PIN_BYTE_LENGTH: u32 = 90;
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH: u32 = 90;
pub const NCRYPT_PIN_CACHE_CLEAR_PROPERTY: &[u8; 14usize] = b"PinCacheClear\0";
pub const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION: u32 = 1;
pub const NCRYPT_KEY_ACCESS_POLICY_VERSION: u32 = 1;
pub const NCRYPT_ALLOW_SILENT_KEY_ACCESS: u32 = 1;
pub const NCRYPT_CIPHER_KEY_BLOB_MAGIC: u32 = 1380470851;
pub const NCRYPT_KDF_KEY_BLOB_MAGIC: u32 = 826688587;
pub const NCRYPT_PROTECTED_KEY_BLOB_MAGIC: u32 = 1263817296;
pub const NCRYPT_CIPHER_KEY_BLOB: &[u8; 14usize] = b"CipherKeyBlob\0";
pub const NCRYPT_KDF_KEY_BLOB: &[u8; 11usize] = b"KDFKeyBlob\0";
pub const NCRYPT_PROTECTED_KEY_BLOB: &[u8; 17usize] = b"ProtectedKeyBlob\0";
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB: &[u8; 23usize] = b"PcpTpmProtectedKeyBlob\0";
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC: u32 = 1297371211;
pub const NCRYPT_PKCS7_ENVELOPE_BLOB: &[u8; 15usize] = b"PKCS7_ENVELOPE\0";
pub const NCRYPT_PKCS8_PRIVATE_KEY_BLOB: &[u8; 17usize] = b"PKCS8_PRIVATEKEY\0";
pub const NCRYPT_OPAQUETRANSPORT_BLOB: &[u8; 16usize] = b"OpaqueTransport\0";
pub const NCRYPT_ISOLATED_KEY_ENVELOPE_BLOB: &[u8; 22usize] = b"ISOLATED_KEY_ENVELOPE\0";
pub const szOID_RSA: &[u8; 15usize] = b"1.2.840.113549\0";
pub const szOID_PKCS: &[u8; 17usize] = b"1.2.840.113549.1\0";
pub const szOID_RSA_HASH: &[u8; 17usize] = b"1.2.840.113549.2\0";
pub const szOID_RSA_ENCRYPT: &[u8; 17usize] = b"1.2.840.113549.3\0";
pub const szOID_PKCS_1: &[u8; 19usize] = b"1.2.840.113549.1.1\0";
pub const szOID_PKCS_2: &[u8; 19usize] = b"1.2.840.113549.1.2\0";
pub const szOID_PKCS_3: &[u8; 19usize] = b"1.2.840.113549.1.3\0";
pub const szOID_PKCS_4: &[u8; 19usize] = b"1.2.840.113549.1.4\0";
pub const szOID_PKCS_5: &[u8; 19usize] = b"1.2.840.113549.1.5\0";
pub const szOID_PKCS_6: &[u8; 19usize] = b"1.2.840.113549.1.6\0";
pub const szOID_PKCS_7: &[u8; 19usize] = b"1.2.840.113549.1.7\0";
pub const szOID_PKCS_8: &[u8; 19usize] = b"1.2.840.113549.1.8\0";
pub const szOID_PKCS_9: &[u8; 19usize] = b"1.2.840.113549.1.9\0";
pub const szOID_PKCS_10: &[u8; 20usize] = b"1.2.840.113549.1.10\0";
pub const szOID_PKCS_12: &[u8; 20usize] = b"1.2.840.113549.1.12\0";
pub const szOID_RSA_RSA: &[u8; 21usize] = b"1.2.840.113549.1.1.1\0";
pub const szOID_RSA_MD2RSA: &[u8; 21usize] = b"1.2.840.113549.1.1.2\0";
pub const szOID_RSA_MD4RSA: &[u8; 21usize] = b"1.2.840.113549.1.1.3\0";
pub const szOID_RSA_MD5RSA: &[u8; 21usize] = b"1.2.840.113549.1.1.4\0";
pub const szOID_RSA_SHA1RSA: &[u8; 21usize] = b"1.2.840.113549.1.1.5\0";
pub const szOID_RSA_SETOAEP_RSA: &[u8; 21usize] = b"1.2.840.113549.1.1.6\0";
pub const szOID_RSAES_OAEP: &[u8; 21usize] = b"1.2.840.113549.1.1.7\0";
pub const szOID_RSA_MGF1: &[u8; 21usize] = b"1.2.840.113549.1.1.8\0";
pub const szOID_RSA_PSPECIFIED: &[u8; 21usize] = b"1.2.840.113549.1.1.9\0";
pub const szOID_RSA_SSA_PSS: &[u8; 22usize] = b"1.2.840.113549.1.1.10\0";
pub const szOID_RSA_SHA256RSA: &[u8; 22usize] = b"1.2.840.113549.1.1.11\0";
pub const szOID_RSA_SHA384RSA: &[u8; 22usize] = b"1.2.840.113549.1.1.12\0";
pub const szOID_RSA_SHA512RSA: &[u8; 22usize] = b"1.2.840.113549.1.1.13\0";
pub const szOID_RSA_DH: &[u8; 21usize] = b"1.2.840.113549.1.3.1\0";
pub const szOID_RSA_data: &[u8; 21usize] = b"1.2.840.113549.1.7.1\0";
pub const szOID_RSA_signedData: &[u8; 21usize] = b"1.2.840.113549.1.7.2\0";
pub const szOID_RSA_envelopedData: &[u8; 21usize] = b"1.2.840.113549.1.7.3\0";
pub const szOID_RSA_signEnvData: &[u8; 21usize] = b"1.2.840.113549.1.7.4\0";
pub const szOID_RSA_digestedData: &[u8; 21usize] = b"1.2.840.113549.1.7.5\0";
pub const szOID_RSA_hashedData: &[u8; 21usize] = b"1.2.840.113549.1.7.5\0";
pub const szOID_RSA_encryptedData: &[u8; 21usize] = b"1.2.840.113549.1.7.6\0";
pub const szOID_RSA_emailAddr: &[u8; 21usize] = b"1.2.840.113549.1.9.1\0";
pub const szOID_RSA_unstructName: &[u8; 21usize] = b"1.2.840.113549.1.9.2\0";
pub const szOID_RSA_contentType: &[u8; 21usize] = b"1.2.840.113549.1.9.3\0";
pub const szOID_RSA_messageDigest: &[u8; 21usize] = b"1.2.840.113549.1.9.4\0";
pub const szOID_RSA_signingTime: &[u8; 21usize] = b"1.2.840.113549.1.9.5\0";
pub const szOID_RSA_counterSign: &[u8; 21usize] = b"1.2.840.113549.1.9.6\0";
pub const szOID_RSA_challengePwd: &[u8; 21usize] = b"1.2.840.113549.1.9.7\0";
pub const szOID_RSA_unstructAddr: &[u8; 21usize] = b"1.2.840.113549.1.9.8\0";
pub const szOID_RSA_extCertAttrs: &[u8; 21usize] = b"1.2.840.113549.1.9.9\0";
pub const szOID_RSA_certExtensions: &[u8; 22usize] = b"1.2.840.113549.1.9.14\0";
pub const szOID_RSA_SMIMECapabilities: &[u8; 22usize] = b"1.2.840.113549.1.9.15\0";
pub const szOID_RSA_preferSignedData: &[u8; 24usize] = b"1.2.840.113549.1.9.15.1\0";
pub const szOID_TIMESTAMP_TOKEN: &[u8; 26usize] = b"1.2.840.113549.1.9.16.1.4\0";
pub const szOID_RFC3161_counterSign: &[u8; 22usize] = b"1.3.6.1.4.1.311.3.3.1\0";
pub const szOID_RFC3161v21_counterSign: &[u8; 22usize] = b"1.3.6.1.4.1.311.3.3.2\0";
pub const szOID_RFC3161v21_thumbprints: &[u8; 22usize] = b"1.3.6.1.4.1.311.3.3.3\0";
pub const szOID_RSA_SMIMEalg: &[u8; 24usize] = b"1.2.840.113549.1.9.16.3\0";
pub const szOID_RSA_SMIMEalgESDH: &[u8; 26usize] = b"1.2.840.113549.1.9.16.3.5\0";
pub const szOID_RSA_SMIMEalgCMS3DESwrap: &[u8; 26usize] = b"1.2.840.113549.1.9.16.3.6\0";
pub const szOID_RSA_SMIMEalgCMSRC2wrap: &[u8; 26usize] = b"1.2.840.113549.1.9.16.3.7\0";
pub const szOID_RSA_MD2: &[u8; 19usize] = b"1.2.840.113549.2.2\0";
pub const szOID_RSA_MD4: &[u8; 19usize] = b"1.2.840.113549.2.4\0";
pub const szOID_RSA_MD5: &[u8; 19usize] = b"1.2.840.113549.2.5\0";
pub const szOID_RSA_RC2CBC: &[u8; 19usize] = b"1.2.840.113549.3.2\0";
pub const szOID_RSA_RC4: &[u8; 19usize] = b"1.2.840.113549.3.4\0";
pub const szOID_RSA_DES_EDE3_CBC: &[u8; 19usize] = b"1.2.840.113549.3.7\0";
pub const szOID_RSA_RC5_CBCPad: &[u8; 19usize] = b"1.2.840.113549.3.9\0";
pub const szOID_ANSI_X942: &[u8; 14usize] = b"1.2.840.10046\0";
pub const szOID_ANSI_X942_DH: &[u8; 18usize] = b"1.2.840.10046.2.1\0";
pub const szOID_X957: &[u8; 14usize] = b"1.2.840.10040\0";
pub const szOID_X957_DSA: &[u8; 18usize] = b"1.2.840.10040.4.1\0";
pub const szOID_X957_SHA1DSA: &[u8; 18usize] = b"1.2.840.10040.4.3\0";
pub const szOID_ECC_PUBLIC_KEY: &[u8; 18usize] = b"1.2.840.10045.2.1\0";
pub const szOID_ECC_CURVE_P256: &[u8; 20usize] = b"1.2.840.10045.3.1.7\0";
pub const szOID_ECC_CURVE_P384: &[u8; 13usize] = b"1.3.132.0.34\0";
pub const szOID_ECC_CURVE_P521: &[u8; 13usize] = b"1.3.132.0.35\0";
pub const szOID_ECC_CURVE_BRAINPOOLP160R1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.1\0";
pub const szOID_ECC_CURVE_BRAINPOOLP160T1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.2\0";
pub const szOID_ECC_CURVE_BRAINPOOLP192R1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.3\0";
pub const szOID_ECC_CURVE_BRAINPOOLP192T1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.4\0";
pub const szOID_ECC_CURVE_BRAINPOOLP224R1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.5\0";
pub const szOID_ECC_CURVE_BRAINPOOLP224T1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.6\0";
pub const szOID_ECC_CURVE_BRAINPOOLP256R1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.7\0";
pub const szOID_ECC_CURVE_BRAINPOOLP256T1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.8\0";
pub const szOID_ECC_CURVE_BRAINPOOLP320R1: &[u8; 21usize] = b"1.3.36.3.3.2.8.1.1.9\0";
pub const szOID_ECC_CURVE_BRAINPOOLP320T1: &[u8; 22usize] = b"1.3.36.3.3.2.8.1.1.10\0";
pub const szOID_ECC_CURVE_BRAINPOOLP384R1: &[u8; 22usize] = b"1.3.36.3.3.2.8.1.1.11\0";
pub const szOID_ECC_CURVE_BRAINPOOLP384T1: &[u8; 22usize] = b"1.3.36.3.3.2.8.1.1.12\0";
pub const szOID_ECC_CURVE_BRAINPOOLP512R1: &[u8; 22usize] = b"1.3.36.3.3.2.8.1.1.13\0";
pub const szOID_ECC_CURVE_BRAINPOOLP512T1: &[u8; 22usize] = b"1.3.36.3.3.2.8.1.1.14\0";
pub const szOID_ECC_CURVE_EC192WAPI: &[u8; 22usize] = b"1.2.156.11235.1.1.2.1\0";
pub const szOID_CN_ECDSA_SHA256: &[u8; 20usize] = b"1.2.156.11235.1.1.1\0";
pub const szOID_ECC_CURVE_NISTP192: &[u8; 20usize] = b"1.2.840.10045.3.1.1\0";
pub const szOID_ECC_CURVE_NISTP224: &[u8; 13usize] = b"1.3.132.0.33\0";
pub const szOID_ECC_CURVE_NISTP256: &[u8; 20usize] = b"1.2.840.10045.3.1.7\0";
pub const szOID_ECC_CURVE_NISTP384: &[u8; 13usize] = b"1.3.132.0.34\0";
pub const szOID_ECC_CURVE_NISTP521: &[u8; 13usize] = b"1.3.132.0.35\0";
pub const szOID_ECC_CURVE_SECP160K1: &[u8; 12usize] = b"1.3.132.0.9\0";
pub const szOID_ECC_CURVE_SECP160R1: &[u8; 12usize] = b"1.3.132.0.8\0";
pub const szOID_ECC_CURVE_SECP160R2: &[u8; 13usize] = b"1.3.132.0.30\0";
pub const szOID_ECC_CURVE_SECP192K1: &[u8; 13usize] = b"1.3.132.0.31\0";
pub const szOID_ECC_CURVE_SECP192R1: &[u8; 20usize] = b"1.2.840.10045.3.1.1\0";
pub const szOID_ECC_CURVE_SECP224K1: &[u8; 13usize] = b"1.3.132.0.32\0";
pub const szOID_ECC_CURVE_SECP224R1: &[u8; 13usize] = b"1.3.132.0.33\0";
pub const szOID_ECC_CURVE_SECP256K1: &[u8; 13usize] = b"1.3.132.0.10\0";
pub const szOID_ECC_CURVE_SECP256R1: &[u8; 20usize] = b"1.2.840.10045.3.1.7\0";
pub const szOID_ECC_CURVE_SECP384R1: &[u8; 13usize] = b"1.3.132.0.34\0";
pub const szOID_ECC_CURVE_SECP521R1: &[u8; 13usize] = b"1.3.132.0.35\0";
pub const szOID_ECC_CURVE_WTLS7: &[u8; 13usize] = b"1.3.132.0.30\0";
pub const szOID_ECC_CURVE_WTLS9: &[u8; 14usize] = b"2.23.43.1.4.9\0";
pub const szOID_ECC_CURVE_WTLS12: &[u8; 13usize] = b"1.3.132.0.33\0";
pub const szOID_ECC_CURVE_X962P192V1: &[u8; 20usize] = b"1.2.840.10045.3.1.1\0";
pub const szOID_ECC_CURVE_X962P192V2: &[u8; 20usize] = b"1.2.840.10045.3.1.2\0";
pub const szOID_ECC_CURVE_X962P192V3: &[u8; 20usize] = b"1.2.840.10045.3.1.3\0";
pub const szOID_ECC_CURVE_X962P239V1: &[u8; 20usize] = b"1.2.840.10045.3.1.4\0";
pub const szOID_ECC_CURVE_X962P239V2: &[u8; 20usize] = b"1.2.840.10045.3.1.5\0";
pub const szOID_ECC_CURVE_X962P239V3: &[u8; 20usize] = b"1.2.840.10045.3.1.6\0";
pub const szOID_ECC_CURVE_X962P256V1: &[u8; 20usize] = b"1.2.840.10045.3.1.7\0";
pub const szOID_ECDSA_SHA1: &[u8; 18usize] = b"1.2.840.10045.4.1\0";
pub const szOID_ECDSA_SPECIFIED: &[u8; 18usize] = b"1.2.840.10045.4.3\0";
pub const szOID_ECDSA_SHA256: &[u8; 20usize] = b"1.2.840.10045.4.3.2\0";
pub const szOID_ECDSA_SHA384: &[u8; 20usize] = b"1.2.840.10045.4.3.3\0";
pub const szOID_ECDSA_SHA512: &[u8; 20usize] = b"1.2.840.10045.4.3.4\0";
pub const szOID_NIST_AES128_CBC: &[u8; 23usize] = b"2.16.840.1.101.3.4.1.2\0";
pub const szOID_NIST_AES192_CBC: &[u8; 24usize] = b"2.16.840.1.101.3.4.1.22\0";
pub const szOID_NIST_AES256_CBC: &[u8; 24usize] = b"2.16.840.1.101.3.4.1.42\0";
pub const szOID_NIST_AES128_WRAP: &[u8; 23usize] = b"2.16.840.1.101.3.4.1.5\0";
pub const szOID_NIST_AES192_WRAP: &[u8; 24usize] = b"2.16.840.1.101.3.4.1.25\0";
pub const szOID_NIST_AES256_WRAP: &[u8; 24usize] = b"2.16.840.1.101.3.4.1.45\0";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF: &[u8; 22usize] = b"1.3.133.16.840.63.0.2\0";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF: &[u8; 15usize] = b"1.3.132.1.11.1\0";
pub const szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF: &[u8; 15usize] = b"1.3.132.1.11.2\0";
pub const szOID_DS: &[u8; 4usize] = b"2.5\0";
pub const szOID_DSALG: &[u8; 6usize] = b"2.5.8\0";
pub const szOID_DSALG_CRPT: &[u8; 8usize] = b"2.5.8.1\0";
pub const szOID_DSALG_HASH: &[u8; 8usize] = b"2.5.8.2\0";
pub const szOID_DSALG_SIGN: &[u8; 8usize] = b"2.5.8.3\0";
pub const szOID_DSALG_RSA: &[u8; 10usize] = b"2.5.8.1.1\0";
pub const szOID_OIW: &[u8; 7usize] = b"1.3.14\0";
pub const szOID_OIWSEC: &[u8; 11usize] = b"1.3.14.3.2\0";
pub const szOID_OIWSEC_md4RSA: &[u8; 13usize] = b"1.3.14.3.2.2\0";
pub const szOID_OIWSEC_md5RSA: &[u8; 13usize] = b"1.3.14.3.2.3\0";
pub const szOID_OIWSEC_md4RSA2: &[u8; 13usize] = b"1.3.14.3.2.4\0";
pub const szOID_OIWSEC_desECB: &[u8; 13usize] = b"1.3.14.3.2.6\0";
pub const szOID_OIWSEC_desCBC: &[u8; 13usize] = b"1.3.14.3.2.7\0";
pub const szOID_OIWSEC_desOFB: &[u8; 13usize] = b"1.3.14.3.2.8\0";
pub const szOID_OIWSEC_desCFB: &[u8; 13usize] = b"1.3.14.3.2.9\0";
pub const szOID_OIWSEC_desMAC: &[u8; 14usize] = b"1.3.14.3.2.10\0";
pub const szOID_OIWSEC_rsaSign: &[u8; 14usize] = b"1.3.14.3.2.11\0";
pub const szOID_OIWSEC_dsa: &[u8; 14usize] = b"1.3.14.3.2.12\0";
pub const szOID_OIWSEC_shaDSA: &[u8; 14usize] = b"1.3.14.3.2.13\0";
pub const szOID_OIWSEC_mdc2RSA: &[u8; 14usize] = b"1.3.14.3.2.14\0";
pub const szOID_OIWSEC_shaRSA: &[u8; 14usize] = b"1.3.14.3.2.15\0";
pub const szOID_OIWSEC_dhCommMod: &[u8; 14usize] = b"1.3.14.3.2.16\0";
pub const szOID_OIWSEC_desEDE: &[u8; 14usize] = b"1.3.14.3.2.17\0";
pub const szOID_OIWSEC_sha: &[u8; 14usize] = b"1.3.14.3.2.18\0";
pub const szOID_OIWSEC_mdc2: &[u8; 14usize] = b"1.3.14.3.2.19\0";
pub const szOID_OIWSEC_dsaComm: &[u8; 14usize] = b"1.3.14.3.2.20\0";
pub const szOID_OIWSEC_dsaCommSHA: &[u8; 14usize] = b"1.3.14.3.2.21\0";
pub const szOID_OIWSEC_rsaXchg: &[u8; 14usize] = b"1.3.14.3.2.22\0";
pub const szOID_OIWSEC_keyHashSeal: &[u8; 14usize] = b"1.3.14.3.2.23\0";
pub const szOID_OIWSEC_md2RSASign: &[u8; 14usize] = b"1.3.14.3.2.24\0";
pub const szOID_OIWSEC_md5RSASign: &[u8; 14usize] = b"1.3.14.3.2.25\0";
pub const szOID_OIWSEC_sha1: &[u8; 14usize] = b"1.3.14.3.2.26\0";
pub const szOID_OIWSEC_dsaSHA1: &[u8; 14usize] = b"1.3.14.3.2.27\0";
pub const szOID_OIWSEC_dsaCommSHA1: &[u8; 14usize] = b"1.3.14.3.2.28\0";
pub const szOID_OIWSEC_sha1RSASign: &[u8; 14usize] = b"1.3.14.3.2.29\0";
pub const szOID_OIWDIR: &[u8; 11usize] = b"1.3.14.7.2\0";
pub const szOID_OIWDIR_CRPT: &[u8; 13usize] = b"1.3.14.7.2.1\0";
pub const szOID_OIWDIR_HASH: &[u8; 13usize] = b"1.3.14.7.2.2\0";
pub const szOID_OIWDIR_SIGN: &[u8; 13usize] = b"1.3.14.7.2.3\0";
pub const szOID_OIWDIR_md2: &[u8; 15usize] = b"1.3.14.7.2.2.1\0";
pub const szOID_OIWDIR_md2RSA: &[u8; 15usize] = b"1.3.14.7.2.3.1\0";
pub const szOID_INFOSEC: &[u8; 19usize] = b"2.16.840.1.101.2.1\0";
pub const szOID_INFOSEC_sdnsSignature: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.1\0";
pub const szOID_INFOSEC_mosaicSignature: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.2\0";
pub const szOID_INFOSEC_sdnsConfidentiality: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.3\0";
pub const szOID_INFOSEC_mosaicConfidentiality: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.4\0";
pub const szOID_INFOSEC_sdnsIntegrity: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.5\0";
pub const szOID_INFOSEC_mosaicIntegrity: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.6\0";
pub const szOID_INFOSEC_sdnsTokenProtection: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.7\0";
pub const szOID_INFOSEC_mosaicTokenProtection: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.8\0";
pub const szOID_INFOSEC_sdnsKeyManagement: &[u8; 23usize] = b"2.16.840.1.101.2.1.1.9\0";
pub const szOID_INFOSEC_mosaicKeyManagement: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.10\0";
pub const szOID_INFOSEC_sdnsKMandSig: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.11\0";
pub const szOID_INFOSEC_mosaicKMandSig: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.12\0";
pub const szOID_INFOSEC_SuiteASignature: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.13\0";
pub const szOID_INFOSEC_SuiteAConfidentiality: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.14\0";
pub const szOID_INFOSEC_SuiteAIntegrity: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.15\0";
pub const szOID_INFOSEC_SuiteATokenProtection: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.16\0";
pub const szOID_INFOSEC_SuiteAKeyManagement: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.17\0";
pub const szOID_INFOSEC_SuiteAKMandSig: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.18\0";
pub const szOID_INFOSEC_mosaicUpdatedSig: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.19\0";
pub const szOID_INFOSEC_mosaicKMandUpdSig: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.20\0";
pub const szOID_INFOSEC_mosaicUpdatedInteg: &[u8; 24usize] = b"2.16.840.1.101.2.1.1.21\0";
pub const szOID_NIST_sha256: &[u8; 23usize] = b"2.16.840.1.101.3.4.2.1\0";
pub const szOID_NIST_sha384: &[u8; 23usize] = b"2.16.840.1.101.3.4.2.2\0";
pub const szOID_NIST_sha512: &[u8; 23usize] = b"2.16.840.1.101.3.4.2.3\0";
pub const szOID_COMMON_NAME: &[u8; 8usize] = b"2.5.4.3\0";
pub const szOID_SUR_NAME: &[u8; 8usize] = b"2.5.4.4\0";
pub const szOID_DEVICE_SERIAL_NUMBER: &[u8; 8usize] = b"2.5.4.5\0";
pub const szOID_COUNTRY_NAME: &[u8; 8usize] = b"2.5.4.6\0";
pub const szOID_LOCALITY_NAME: &[u8; 8usize] = b"2.5.4.7\0";
pub const szOID_STATE_OR_PROVINCE_NAME: &[u8; 8usize] = b"2.5.4.8\0";
pub const szOID_STREET_ADDRESS: &[u8; 8usize] = b"2.5.4.9\0";
pub const szOID_ORGANIZATION_NAME: &[u8; 9usize] = b"2.5.4.10\0";
pub const szOID_ORGANIZATIONAL_UNIT_NAME: &[u8; 9usize] = b"2.5.4.11\0";
pub const szOID_TITLE: &[u8; 9usize] = b"2.5.4.12\0";
pub const szOID_DESCRIPTION: &[u8; 9usize] = b"2.5.4.13\0";
pub const szOID_SEARCH_GUIDE: &[u8; 9usize] = b"2.5.4.14\0";
pub const szOID_BUSINESS_CATEGORY: &[u8; 9usize] = b"2.5.4.15\0";
pub const szOID_POSTAL_ADDRESS: &[u8; 9usize] = b"2.5.4.16\0";
pub const szOID_POSTAL_CODE: &[u8; 9usize] = b"2.5.4.17\0";
pub const szOID_POST_OFFICE_BOX: &[u8; 9usize] = b"2.5.4.18\0";
pub const szOID_PHYSICAL_DELIVERY_OFFICE_NAME: &[u8; 9usize] = b"2.5.4.19\0";
pub const szOID_TELEPHONE_NUMBER: &[u8; 9usize] = b"2.5.4.20\0";
pub const szOID_TELEX_NUMBER: &[u8; 9usize] = b"2.5.4.21\0";
pub const szOID_TELETEXT_TERMINAL_IDENTIFIER: &[u8; 9usize] = b"2.5.4.22\0";
pub const szOID_FACSIMILE_TELEPHONE_NUMBER: &[u8; 9usize] = b"2.5.4.23\0";
pub const szOID_X21_ADDRESS: &[u8; 9usize] = b"2.5.4.24\0";
pub const szOID_INTERNATIONAL_ISDN_NUMBER: &[u8; 9usize] = b"2.5.4.25\0";
pub const szOID_REGISTERED_ADDRESS: &[u8; 9usize] = b"2.5.4.26\0";
pub const szOID_DESTINATION_INDICATOR: &[u8; 9usize] = b"2.5.4.27\0";
pub const szOID_PREFERRED_DELIVERY_METHOD: &[u8; 9usize] = b"2.5.4.28\0";
pub const szOID_PRESENTATION_ADDRESS: &[u8; 9usize] = b"2.5.4.29\0";
pub const szOID_SUPPORTED_APPLICATION_CONTEXT: &[u8; 9usize] = b"2.5.4.30\0";
pub const szOID_MEMBER: &[u8; 9usize] = b"2.5.4.31\0";
pub const szOID_OWNER: &[u8; 9usize] = b"2.5.4.32\0";
pub const szOID_ROLE_OCCUPANT: &[u8; 9usize] = b"2.5.4.33\0";
pub const szOID_SEE_ALSO: &[u8; 9usize] = b"2.5.4.34\0";
pub const szOID_USER_PASSWORD: &[u8; 9usize] = b"2.5.4.35\0";
pub const szOID_USER_CERTIFICATE: &[u8; 9usize] = b"2.5.4.36\0";
pub const szOID_CA_CERTIFICATE: &[u8; 9usize] = b"2.5.4.37\0";
pub const szOID_AUTHORITY_REVOCATION_LIST: &[u8; 9usize] = b"2.5.4.38\0";
pub const szOID_CERTIFICATE_REVOCATION_LIST: &[u8; 9usize] = b"2.5.4.39\0";
pub const szOID_CROSS_CERTIFICATE_PAIR: &[u8; 9usize] = b"2.5.4.40\0";
pub const szOID_GIVEN_NAME: &[u8; 9usize] = b"2.5.4.42\0";
pub const szOID_INITIALS: &[u8; 9usize] = b"2.5.4.43\0";
pub const szOID_DN_QUALIFIER: &[u8; 9usize] = b"2.5.4.46\0";
pub const szOID_DOMAIN_COMPONENT: &[u8; 27usize] = b"0.9.2342.19200300.100.1.25\0";
pub const szOID_PKCS_12_FRIENDLY_NAME_ATTR: &[u8; 22usize] = b"1.2.840.113549.1.9.20\0";
pub const szOID_PKCS_12_LOCAL_KEY_ID: &[u8; 22usize] = b"1.2.840.113549.1.9.21\0";
pub const szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR: &[u8; 21usize] = b"1.3.6.1.4.1.311.17.1\0";
pub const szOID_LOCAL_MACHINE_KEYSET: &[u8; 21usize] = b"1.3.6.1.4.1.311.17.2\0";
pub const szOID_PKCS_12_EXTENDED_ATTRIBUTES: &[u8; 21usize] = b"1.3.6.1.4.1.311.17.3\0";
pub const szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID: &[u8; 21usize] =
    b"1.3.6.1.4.1.311.17.4\0";
pub const szOID_KEYID_RDN: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.7.1\0";
pub const szOID_EV_RDN_LOCALE: &[u8; 25usize] = b"1.3.6.1.4.1.311.60.2.1.1\0";
pub const szOID_EV_RDN_STATE_OR_PROVINCE: &[u8; 25usize] = b"1.3.6.1.4.1.311.60.2.1.2\0";
pub const szOID_EV_RDN_COUNTRY: &[u8; 25usize] = b"1.3.6.1.4.1.311.60.2.1.3\0";
pub const CERT_RDN_ANY_TYPE: u32 = 0;
pub const CERT_RDN_ENCODED_BLOB: u32 = 1;
pub const CERT_RDN_OCTET_STRING: u32 = 2;
pub const CERT_RDN_NUMERIC_STRING: u32 = 3;
pub const CERT_RDN_PRINTABLE_STRING: u32 = 4;
pub const CERT_RDN_TELETEX_STRING: u32 = 5;
pub const CERT_RDN_T61_STRING: u32 = 5;
pub const CERT_RDN_VIDEOTEX_STRING: u32 = 6;
pub const CERT_RDN_IA5_STRING: u32 = 7;
pub const CERT_RDN_GRAPHIC_STRING: u32 = 8;
pub const CERT_RDN_VISIBLE_STRING: u32 = 9;
pub const CERT_RDN_ISO646_STRING: u32 = 9;
pub const CERT_RDN_GENERAL_STRING: u32 = 10;
pub const CERT_RDN_UNIVERSAL_STRING: u32 = 11;
pub const CERT_RDN_INT4_STRING: u32 = 11;
pub const CERT_RDN_BMP_STRING: u32 = 12;
pub const CERT_RDN_UNICODE_STRING: u32 = 12;
pub const CERT_RDN_UTF8_STRING: u32 = 13;
pub const CERT_RDN_TYPE_MASK: u32 = 255;
pub const CERT_RDN_FLAGS_MASK: u32 = 4278190080;
pub const CERT_RDN_ENABLE_T61_UNICODE_FLAG: u32 = 2147483648;
pub const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG: u32 = 536870912;
pub const CERT_RDN_FORCE_UTF8_UNICODE_FLAG: u32 = 268435456;
pub const CERT_RDN_DISABLE_CHECK_TYPE_FLAG: u32 = 1073741824;
pub const CERT_RDN_DISABLE_IE4_UTF8_FLAG: u32 = 16777216;
pub const CERT_RDN_ENABLE_PUNYCODE_FLAG: u32 = 33554432;
pub const CERT_RSA_PUBLIC_KEY_OBJID: &[u8; 21usize] = b"1.2.840.113549.1.1.1\0";
pub const CERT_DEFAULT_OID_PUBLIC_KEY_SIGN: &[u8; 21usize] = b"1.2.840.113549.1.1.1\0";
pub const CERT_DEFAULT_OID_PUBLIC_KEY_XCHG: &[u8; 21usize] = b"1.2.840.113549.1.1.1\0";
pub const CRYPT_ECC_PRIVATE_KEY_INFO_v1: u32 = 1;
pub const CERT_V1: u32 = 0;
pub const CERT_V2: u32 = 1;
pub const CERT_V3: u32 = 2;
pub const CERT_INFO_VERSION_FLAG: u32 = 1;
pub const CERT_INFO_SERIAL_NUMBER_FLAG: u32 = 2;
pub const CERT_INFO_SIGNATURE_ALGORITHM_FLAG: u32 = 3;
pub const CERT_INFO_ISSUER_FLAG: u32 = 4;
pub const CERT_INFO_NOT_BEFORE_FLAG: u32 = 5;
pub const CERT_INFO_NOT_AFTER_FLAG: u32 = 6;
pub const CERT_INFO_SUBJECT_FLAG: u32 = 7;
pub const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG: u32 = 8;
pub const CERT_INFO_ISSUER_UNIQUE_ID_FLAG: u32 = 9;
pub const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG: u32 = 10;
pub const CERT_INFO_EXTENSION_FLAG: u32 = 11;
pub const CRL_V1: u32 = 0;
pub const CRL_V2: u32 = 1;
pub const CERT_BUNDLE_CERTIFICATE: u32 = 0;
pub const CERT_BUNDLE_CRL: u32 = 1;
pub const CERT_REQUEST_V1: u32 = 0;
pub const CERT_KEYGEN_REQUEST_V1: u32 = 0;
pub const CTL_V1: u32 = 0;
pub const CERT_ENCODING_TYPE_MASK: u32 = 65535;
pub const CMSG_ENCODING_TYPE_MASK: u32 = 4294901760;
pub const CRYPT_ASN_ENCODING: u32 = 1;
pub const CRYPT_NDR_ENCODING: u32 = 2;
pub const X509_ASN_ENCODING: u32 = 1;
pub const X509_NDR_ENCODING: u32 = 2;
pub const PKCS_7_ASN_ENCODING: u32 = 65536;
pub const PKCS_7_NDR_ENCODING: u32 = 131072;
pub const CRYPT_FORMAT_STR_MULTI_LINE: u32 = 1;
pub const CRYPT_FORMAT_STR_NO_HEX: u32 = 16;
pub const CRYPT_FORMAT_SIMPLE: u32 = 1;
pub const CRYPT_FORMAT_X509: u32 = 2;
pub const CRYPT_FORMAT_OID: u32 = 4;
pub const CRYPT_FORMAT_RDN_SEMICOLON: u32 = 256;
pub const CRYPT_FORMAT_RDN_CRLF: u32 = 512;
pub const CRYPT_FORMAT_RDN_UNQUOTE: u32 = 1024;
pub const CRYPT_FORMAT_RDN_REVERSE: u32 = 2048;
pub const CRYPT_FORMAT_COMMA: u32 = 4096;
pub const CRYPT_FORMAT_SEMICOLON: u32 = 256;
pub const CRYPT_FORMAT_CRLF: u32 = 512;
pub const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG: u32 = 8;
pub const CRYPT_ENCODE_ALLOC_FLAG: u32 = 32768;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG: u32 = 2147483648;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG: u32 = 536870912;
pub const CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG: u32 = 268435456;
pub const CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG: u32 = 1073741824;
pub const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG: u32 = 65536;
pub const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG: u32 = 131072;
pub const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG: u32 = 262144;
pub const CRYPT_ENCODE_ENABLE_IA5CONVERSION_FLAG: u32 = 393216;
pub const CRYPT_DECODE_NOCOPY_FLAG: u32 = 1;
pub const CRYPT_DECODE_TO_BE_SIGNED_FLAG: u32 = 2;
pub const CRYPT_DECODE_SHARE_OID_STRING_FLAG: u32 = 4;
pub const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG: u32 = 8;
pub const CRYPT_DECODE_ALLOC_FLAG: u32 = 32768;
pub const CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG: u32 = 16777216;
pub const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG: u32 = 33554432;
pub const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG: u32 = 67108864;
pub const CRYPT_DECODE_ENABLE_IA5CONVERSION_FLAG: u32 = 100663296;
pub const CRYPT_ENCODE_DECODE_NONE: u32 = 0;
pub const szOID_AUTHORITY_KEY_IDENTIFIER: &[u8; 9usize] = b"2.5.29.1\0";
pub const szOID_KEY_ATTRIBUTES: &[u8; 9usize] = b"2.5.29.2\0";
pub const szOID_CERT_POLICIES_95: &[u8; 9usize] = b"2.5.29.3\0";
pub const szOID_KEY_USAGE_RESTRICTION: &[u8; 9usize] = b"2.5.29.4\0";
pub const szOID_SUBJECT_ALT_NAME: &[u8; 9usize] = b"2.5.29.7\0";
pub const szOID_ISSUER_ALT_NAME: &[u8; 9usize] = b"2.5.29.8\0";
pub const szOID_BASIC_CONSTRAINTS: &[u8; 10usize] = b"2.5.29.10\0";
pub const szOID_KEY_USAGE: &[u8; 10usize] = b"2.5.29.15\0";
pub const szOID_PRIVATEKEY_USAGE_PERIOD: &[u8; 10usize] = b"2.5.29.16\0";
pub const szOID_BASIC_CONSTRAINTS2: &[u8; 10usize] = b"2.5.29.19\0";
pub const szOID_CERT_POLICIES: &[u8; 10usize] = b"2.5.29.32\0";
pub const szOID_ANY_CERT_POLICY: &[u8; 12usize] = b"2.5.29.32.0\0";
pub const szOID_INHIBIT_ANY_POLICY: &[u8; 10usize] = b"2.5.29.54\0";
pub const szOID_AUTHORITY_KEY_IDENTIFIER2: &[u8; 10usize] = b"2.5.29.35\0";
pub const szOID_SUBJECT_KEY_IDENTIFIER: &[u8; 10usize] = b"2.5.29.14\0";
pub const szOID_SUBJECT_ALT_NAME2: &[u8; 10usize] = b"2.5.29.17\0";
pub const szOID_ISSUER_ALT_NAME2: &[u8; 10usize] = b"2.5.29.18\0";
pub const szOID_CRL_REASON_CODE: &[u8; 10usize] = b"2.5.29.21\0";
pub const szOID_REASON_CODE_HOLD: &[u8; 10usize] = b"2.5.29.23\0";
pub const szOID_CRL_DIST_POINTS: &[u8; 10usize] = b"2.5.29.31\0";
pub const szOID_ENHANCED_KEY_USAGE: &[u8; 10usize] = b"2.5.29.37\0";
pub const szOID_ANY_ENHANCED_KEY_USAGE: &[u8; 12usize] = b"2.5.29.37.0\0";
pub const szOID_CRL_NUMBER: &[u8; 10usize] = b"2.5.29.20\0";
pub const szOID_DELTA_CRL_INDICATOR: &[u8; 10usize] = b"2.5.29.27\0";
pub const szOID_ISSUING_DIST_POINT: &[u8; 10usize] = b"2.5.29.28\0";
pub const szOID_FRESHEST_CRL: &[u8; 10usize] = b"2.5.29.46\0";
pub const szOID_NAME_CONSTRAINTS: &[u8; 10usize] = b"2.5.29.30\0";
pub const szOID_POLICY_MAPPINGS: &[u8; 10usize] = b"2.5.29.33\0";
pub const szOID_LEGACY_POLICY_MAPPINGS: &[u8; 9usize] = b"2.5.29.5\0";
pub const szOID_POLICY_CONSTRAINTS: &[u8; 10usize] = b"2.5.29.36\0";
pub const szOID_RENEWAL_CERTIFICATE: &[u8; 21usize] = b"1.3.6.1.4.1.311.13.1\0";
pub const szOID_ENROLLMENT_NAME_VALUE_PAIR: &[u8; 23usize] = b"1.3.6.1.4.1.311.13.2.1\0";
pub const szOID_ENROLLMENT_CSP_PROVIDER: &[u8; 23usize] = b"1.3.6.1.4.1.311.13.2.2\0";
pub const szOID_OS_VERSION: &[u8; 23usize] = b"1.3.6.1.4.1.311.13.2.3\0";
pub const szOID_ENROLLMENT_AGENT: &[u8; 23usize] = b"1.3.6.1.4.1.311.20.2.1\0";
pub const szOID_PKIX: &[u8; 14usize] = b"1.3.6.1.5.5.7\0";
pub const szOID_PKIX_PE: &[u8; 16usize] = b"1.3.6.1.5.5.7.1\0";
pub const szOID_AUTHORITY_INFO_ACCESS: &[u8; 18usize] = b"1.3.6.1.5.5.7.1.1\0";
pub const szOID_SUBJECT_INFO_ACCESS: &[u8; 19usize] = b"1.3.6.1.5.5.7.1.11\0";
pub const szOID_BIOMETRIC_EXT: &[u8; 18usize] = b"1.3.6.1.5.5.7.1.2\0";
pub const szOID_QC_STATEMENTS_EXT: &[u8; 18usize] = b"1.3.6.1.5.5.7.1.3\0";
pub const szOID_LOGOTYPE_EXT: &[u8; 19usize] = b"1.3.6.1.5.5.7.1.12\0";
pub const szOID_TLS_FEATURES_EXT: &[u8; 19usize] = b"1.3.6.1.5.5.7.1.24\0";
pub const szOID_CERT_EXTENSIONS: &[u8; 23usize] = b"1.3.6.1.4.1.311.2.1.14\0";
pub const szOID_NEXT_UPDATE_LOCATION: &[u8; 21usize] = b"1.3.6.1.4.1.311.10.2\0";
pub const szOID_REMOVE_CERTIFICATE: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.8.1\0";
pub const szOID_CROSS_CERT_DIST_POINTS: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.9.1\0";
pub const szOID_CTL: &[u8; 21usize] = b"1.3.6.1.4.1.311.10.1\0";
pub const szOID_SORTED_CTL: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.1.1\0";
pub const szOID_SERIALIZED: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.3.3.1\0";
pub const szOID_NT_PRINCIPAL_NAME: &[u8; 23usize] = b"1.3.6.1.4.1.311.20.2.3\0";
pub const szOID_INTERNATIONALIZED_EMAIL_ADDRESS: &[u8; 23usize] = b"1.3.6.1.4.1.311.20.2.4\0";
pub const szOID_PRODUCT_UPDATE: &[u8; 21usize] = b"1.3.6.1.4.1.311.31.1\0";
pub const szOID_ANY_APPLICATION_POLICY: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.12.1\0";
pub const szOID_AUTO_ENROLL_CTL_USAGE: &[u8; 21usize] = b"1.3.6.1.4.1.311.20.1\0";
pub const szOID_ENROLL_CERTTYPE_EXTENSION: &[u8; 21usize] = b"1.3.6.1.4.1.311.20.2\0";
pub const szOID_CERT_MANIFOLD: &[u8; 21usize] = b"1.3.6.1.4.1.311.20.3\0";
pub const szOID_CERTSRV_CA_VERSION: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.1\0";
pub const szOID_CERTSRV_PREVIOUS_CERT_HASH: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.2\0";
pub const szOID_CRL_VIRTUAL_BASE: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.3\0";
pub const szOID_CRL_NEXT_PUBLISH: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.4\0";
pub const szOID_KP_CA_EXCHANGE: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.5\0";
pub const szOID_KP_PRIVACY_CA: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.36\0";
pub const szOID_KP_KEY_RECOVERY_AGENT: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.6\0";
pub const szOID_CERTIFICATE_TEMPLATE: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.7\0";
pub const szOID_ENTERPRISE_OID_ROOT: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.8\0";
pub const szOID_RDN_DUMMY_SIGNER: &[u8; 21usize] = b"1.3.6.1.4.1.311.21.9\0";
pub const szOID_APPLICATION_CERT_POLICIES: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.10\0";
pub const szOID_APPLICATION_POLICY_MAPPINGS: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.11\0";
pub const szOID_APPLICATION_POLICY_CONSTRAINTS: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.12\0";
pub const szOID_ARCHIVED_KEY_ATTR: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.13\0";
pub const szOID_CRL_SELF_CDP: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.14\0";
pub const szOID_REQUIRE_CERT_CHAIN_POLICY: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.15\0";
pub const szOID_ARCHIVED_KEY_CERT_HASH: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.16\0";
pub const szOID_ISSUED_CERT_HASH: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.17\0";
pub const szOID_DS_EMAIL_REPLICATION: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.19\0";
pub const szOID_REQUEST_CLIENT_INFO: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.20\0";
pub const szOID_ENCRYPTED_KEY_HASH: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.21\0";
pub const szOID_CERTSRV_CROSSCA_VERSION: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.22\0";
pub const szOID_NTDS_REPLICATION: &[u8; 21usize] = b"1.3.6.1.4.1.311.25.1\0";
pub const szOID_NTDS_CA_SECURITY_EXT: &[u8; 21usize] = b"1.3.6.1.4.1.311.25.2\0";
pub const szOID_NTDS_OBJECTSID: &[u8; 23usize] = b"1.3.6.1.4.1.311.25.2.1\0";
pub const szOID_SUBJECT_DIR_ATTRS: &[u8; 9usize] = b"2.5.29.9\0";
pub const szOID_PKIX_KP: &[u8; 16usize] = b"1.3.6.1.5.5.7.3\0";
pub const szOID_PKIX_KP_SERVER_AUTH: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.1\0";
pub const szOID_PKIX_KP_CLIENT_AUTH: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.2\0";
pub const szOID_PKIX_KP_CODE_SIGNING: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.3\0";
pub const szOID_PKIX_KP_EMAIL_PROTECTION: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.4\0";
pub const szOID_PKIX_KP_IPSEC_END_SYSTEM: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.5\0";
pub const szOID_PKIX_KP_IPSEC_TUNNEL: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.6\0";
pub const szOID_PKIX_KP_IPSEC_USER: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.7\0";
pub const szOID_PKIX_KP_TIMESTAMP_SIGNING: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.8\0";
pub const szOID_PKIX_KP_OCSP_SIGNING: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.9\0";
pub const szOID_PKIX_OCSP_NOCHECK: &[u8; 21usize] = b"1.3.6.1.5.5.7.48.1.5\0";
pub const szOID_PKIX_OCSP_NONCE: &[u8; 21usize] = b"1.3.6.1.5.5.7.48.1.2\0";
pub const szOID_IPSEC_KP_IKE_INTERMEDIATE: &[u8; 18usize] = b"1.3.6.1.5.5.8.2.2\0";
pub const szOID_PKINIT_KP_KDC: &[u8; 16usize] = b"1.3.6.1.5.2.3.5\0";
pub const szOID_KP_CTL_USAGE_SIGNING: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.1\0";
pub const szOID_KP_TIME_STAMP_SIGNING: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.2\0";
pub const szOID_SERVER_GATED_CRYPTO: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.3\0";
pub const szOID_SGC_NETSCAPE: &[u8; 22usize] = b"2.16.840.1.113730.4.1\0";
pub const szOID_KP_EFS: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.4\0";
pub const szOID_EFS_RECOVERY: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.3.4.1\0";
pub const szOID_WHQL_CRYPTO: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.5\0";
pub const szOID_ATTEST_WHQL_CRYPTO: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.3.5.1\0";
pub const szOID_NT5_CRYPTO: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.6\0";
pub const szOID_OEM_WHQL_CRYPTO: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.7\0";
pub const szOID_EMBEDDED_NT_CRYPTO: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.8\0";
pub const szOID_ROOT_LIST_SIGNER: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.3.9\0";
pub const szOID_KP_QUALIFIED_SUBORDINATION: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.10\0";
pub const szOID_KP_KEY_RECOVERY: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.11\0";
pub const szOID_KP_DOCUMENT_SIGNING: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.12\0";
pub const szOID_KP_LIFETIME_SIGNING: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.13\0";
pub const szOID_KP_MOBILE_DEVICE_SOFTWARE: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.14\0";
pub const szOID_KP_SMART_DISPLAY: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.15\0";
pub const szOID_KP_CSP_SIGNATURE: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.16\0";
pub const szOID_KP_FLIGHT_SIGNING: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.27\0";
pub const szOID_PLATFORM_MANIFEST_BINARY_ID: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.28\0";
pub const szOID_DRM: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.5.1\0";
pub const szOID_DRM_INDIVIDUALIZATION: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.5.2\0";
pub const szOID_LICENSES: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.6.1\0";
pub const szOID_LICENSE_SERVER: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.6.2\0";
pub const szOID_KP_SMARTCARD_LOGON: &[u8; 23usize] = b"1.3.6.1.4.1.311.20.2.2\0";
pub const szOID_KP_KERNEL_MODE_CODE_SIGNING: &[u8; 23usize] = b"1.3.6.1.4.1.311.61.1.1\0";
pub const szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING: &[u8; 23usize] = b"1.3.6.1.4.1.311.61.4.1\0";
pub const szOID_REVOKED_LIST_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.19\0";
pub const szOID_WINDOWS_KITS_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.20\0";
pub const szOID_WINDOWS_RT_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.21\0";
pub const szOID_PROTECTED_PROCESS_LIGHT_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.22\0";
pub const szOID_WINDOWS_TCB_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.23\0";
pub const szOID_PROTECTED_PROCESS_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.24\0";
pub const szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.25\0";
pub const szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.26\0";
pub const szOID_DISALLOWED_LIST: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.30\0";
pub const szOID_PIN_RULES_SIGNER: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.31\0";
pub const szOID_PIN_RULES_CTL: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.32\0";
pub const szOID_PIN_RULES_EXT: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.33\0";
pub const szOID_PIN_RULES_DOMAIN_NAME: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.34\0";
pub const szOID_PIN_RULES_LOG_END_DATE_EXT: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.35\0";
pub const szOID_IUM_SIGNING: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.37\0";
pub const szOID_EV_WHQL_CRYPTO: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.39\0";
pub const szOID_BIOMETRIC_SIGNING: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.41\0";
pub const szOID_ENCLAVE_SIGNING: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.42\0";
pub const szOID_SYNC_ROOT_CTL_EXT: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.50\0";
pub const szOID_HPKP_DOMAIN_NAME_CTL: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.60\0";
pub const szOID_HPKP_HEADER_VALUE_CTL: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.3.61\0";
pub const szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING: &[u8; 23usize] = b"1.3.6.1.4.1.311.61.5.1\0";
pub const szOID_WINDOWS_STORE_SIGNER: &[u8; 23usize] = b"1.3.6.1.4.1.311.76.3.1\0";
pub const szOID_DYNAMIC_CODE_GEN_SIGNER: &[u8; 23usize] = b"1.3.6.1.4.1.311.76.5.1\0";
pub const szOID_MICROSOFT_PUBLISHER_SIGNER: &[u8; 23usize] = b"1.3.6.1.4.1.311.76.8.1\0";
pub const szOID_YESNO_TRUST_ATTR: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.4.1\0";
pub const szOID_SITE_PIN_RULES_INDEX_ATTR: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.4.2\0";
pub const szOID_SITE_PIN_RULES_FLAGS_ATTR: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.4.3\0";
pub const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG: u32 = 1;
pub const szOID_PKIX_POLICY_QUALIFIER_CPS: &[u8; 18usize] = b"1.3.6.1.5.5.7.2.1\0";
pub const szOID_PKIX_POLICY_QUALIFIER_USERNOTICE: &[u8; 18usize] = b"1.3.6.1.5.5.7.2.2\0";
pub const szOID_ROOT_PROGRAM_FLAGS: &[u8; 23usize] = b"1.3.6.1.4.1.311.60.1.1\0";
pub const CERT_ROOT_PROGRAM_FLAG_ORG: u32 = 128;
pub const CERT_ROOT_PROGRAM_FLAG_LSC: u32 = 64;
pub const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO: u32 = 32;
pub const CERT_ROOT_PROGRAM_FLAG_OU: u32 = 16;
pub const CERT_ROOT_PROGRAM_FLAG_ADDRESS: u32 = 8;
pub const szOID_CERT_POLICIES_95_QUALIFIER1: &[u8; 26usize] = b"2.16.840.1.113733.1.7.1.1\0";
pub const szOID_RDN_TPM_MANUFACTURER: &[u8; 13usize] = b"2.23.133.2.1\0";
pub const szOID_RDN_TPM_MODEL: &[u8; 13usize] = b"2.23.133.2.2\0";
pub const szOID_RDN_TPM_VERSION: &[u8; 13usize] = b"2.23.133.2.3\0";
pub const szOID_RDN_TCG_PLATFORM_MANUFACTURER: &[u8; 13usize] = b"2.23.133.2.4\0";
pub const szOID_RDN_TCG_PLATFORM_MODEL: &[u8; 13usize] = b"2.23.133.2.5\0";
pub const szOID_RDN_TCG_PLATFORM_VERSION: &[u8; 13usize] = b"2.23.133.2.6\0";
pub const szOID_CT_CERT_SCTLIST: &[u8; 24usize] = b"1.3.6.1.4.1.11129.2.4.2\0";
pub const szOID_ENROLL_EK_INFO: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.23\0";
pub const szOID_ENROLL_AIK_INFO: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.39\0";
pub const szOID_ENROLL_ATTESTATION_STATEMENT: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.24\0";
pub const szOID_ENROLL_KSP_NAME: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.25\0";
pub const szOID_ENROLL_EKPUB_CHALLENGE: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.26\0";
pub const szOID_ENROLL_CAXCHGCERT_HASH: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.27\0";
pub const szOID_ENROLL_ATTESTATION_CHALLENGE: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.28\0";
pub const szOID_ENROLL_ENCRYPTION_ALGORITHM: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.29\0";
pub const szOID_KP_TPM_EK_CERTIFICATE: &[u8; 13usize] = b"2.23.133.8.1\0";
pub const szOID_KP_TPM_PLATFORM_CERTIFICATE: &[u8; 13usize] = b"2.23.133.8.2\0";
pub const szOID_KP_TPM_AIK_CERTIFICATE: &[u8; 13usize] = b"2.23.133.8.3\0";
pub const szOID_ENROLL_EKVERIFYKEY: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.30\0";
pub const szOID_ENROLL_EKVERIFYCERT: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.31\0";
pub const szOID_ENROLL_EKVERIFYCREDS: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.32\0";
pub const szOID_ENROLL_SCEP_ERROR: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.33\0";
pub const szOID_ENROLL_SCEP_SERVER_STATE: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.34\0";
pub const szOID_ENROLL_SCEP_CHALLENGE_ANSWER: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.35\0";
pub const szOID_ENROLL_SCEP_CLIENT_REQUEST: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.37\0";
pub const szOID_ENROLL_SCEP_SERVER_MESSAGE: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.38\0";
pub const szOID_ENROLL_SCEP_SERVER_SECRET: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.40\0";
pub const szOID_ENROLL_KEY_AFFINITY: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.41\0";
pub const szOID_ENROLL_SCEP_SIGNER_HASH: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.42\0";
pub const szOID_ENROLL_EK_CA_KEYID: &[u8; 22usize] = b"1.3.6.1.4.1.311.21.43\0";
pub const szOID_ATTR_SUPPORTED_ALGORITHMS: &[u8; 9usize] = b"2.5.4.52\0";
pub const szOID_ATTR_TPM_SPECIFICATION: &[u8; 14usize] = b"2.23.133.2.16\0";
pub const szOID_ATTR_PLATFORM_SPECIFICATION: &[u8; 14usize] = b"2.23.133.2.17\0";
pub const szOID_ATTR_TPM_SECURITY_ASSERTIONS: &[u8; 14usize] = b"2.23.133.2.18\0";
pub const CERT_UNICODE_RDN_ERR_INDEX_MASK: u32 = 1023;
pub const CERT_UNICODE_RDN_ERR_INDEX_SHIFT: u32 = 22;
pub const CERT_UNICODE_ATTR_ERR_INDEX_MASK: u32 = 63;
pub const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT: u32 = 16;
pub const CERT_UNICODE_VALUE_ERR_INDEX_MASK: u32 = 65535;
pub const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT: u32 = 0;
pub const CERT_DIGITAL_SIGNATURE_KEY_USAGE: u32 = 128;
pub const CERT_NON_REPUDIATION_KEY_USAGE: u32 = 64;
pub const CERT_KEY_ENCIPHERMENT_KEY_USAGE: u32 = 32;
pub const CERT_DATA_ENCIPHERMENT_KEY_USAGE: u32 = 16;
pub const CERT_KEY_AGREEMENT_KEY_USAGE: u32 = 8;
pub const CERT_KEY_CERT_SIGN_KEY_USAGE: u32 = 4;
pub const CERT_OFFLINE_CRL_SIGN_KEY_USAGE: u32 = 2;
pub const CERT_CRL_SIGN_KEY_USAGE: u32 = 2;
pub const CERT_ENCIPHER_ONLY_KEY_USAGE: u32 = 1;
pub const CERT_DECIPHER_ONLY_KEY_USAGE: u32 = 128;
pub const CERT_ALT_NAME_OTHER_NAME: u32 = 1;
pub const CERT_ALT_NAME_RFC822_NAME: u32 = 2;
pub const CERT_ALT_NAME_DNS_NAME: u32 = 3;
pub const CERT_ALT_NAME_X400_ADDRESS: u32 = 4;
pub const CERT_ALT_NAME_DIRECTORY_NAME: u32 = 5;
pub const CERT_ALT_NAME_EDI_PARTY_NAME: u32 = 6;
pub const CERT_ALT_NAME_URL: u32 = 7;
pub const CERT_ALT_NAME_IP_ADDRESS: u32 = 8;
pub const CERT_ALT_NAME_REGISTERED_ID: u32 = 9;
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK: u32 = 255;
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT: u32 = 16;
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK: u32 = 65535;
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT: u32 = 0;
pub const CERT_CA_SUBJECT_FLAG: u32 = 128;
pub const CERT_END_ENTITY_SUBJECT_FLAG: u32 = 64;
pub const szOID_PKIX_ACC_DESCR: &[u8; 17usize] = b"1.3.6.1.5.5.7.48\0";
pub const szOID_PKIX_OCSP: &[u8; 19usize] = b"1.3.6.1.5.5.7.48.1\0";
pub const szOID_PKIX_CA_ISSUERS: &[u8; 19usize] = b"1.3.6.1.5.5.7.48.2\0";
pub const szOID_PKIX_TIME_STAMPING: &[u8; 19usize] = b"1.3.6.1.5.5.7.48.3\0";
pub const szOID_PKIX_CA_REPOSITORY: &[u8; 19usize] = b"1.3.6.1.5.5.7.48.5\0";
pub const CRL_REASON_UNSPECIFIED: u32 = 0;
pub const CRL_REASON_KEY_COMPROMISE: u32 = 1;
pub const CRL_REASON_CA_COMPROMISE: u32 = 2;
pub const CRL_REASON_AFFILIATION_CHANGED: u32 = 3;
pub const CRL_REASON_SUPERSEDED: u32 = 4;
pub const CRL_REASON_CESSATION_OF_OPERATION: u32 = 5;
pub const CRL_REASON_CERTIFICATE_HOLD: u32 = 6;
pub const CRL_REASON_REMOVE_FROM_CRL: u32 = 8;
pub const CRL_REASON_PRIVILEGE_WITHDRAWN: u32 = 9;
pub const CRL_REASON_AA_COMPROMISE: u32 = 10;
pub const CRL_DIST_POINT_NO_NAME: u32 = 0;
pub const CRL_DIST_POINT_FULL_NAME: u32 = 1;
pub const CRL_DIST_POINT_ISSUER_RDN_NAME: u32 = 2;
pub const CRL_REASON_UNUSED_FLAG: u32 = 128;
pub const CRL_REASON_KEY_COMPROMISE_FLAG: u32 = 64;
pub const CRL_REASON_CA_COMPROMISE_FLAG: u32 = 32;
pub const CRL_REASON_AFFILIATION_CHANGED_FLAG: u32 = 16;
pub const CRL_REASON_SUPERSEDED_FLAG: u32 = 8;
pub const CRL_REASON_CESSATION_OF_OPERATION_FLAG: u32 = 4;
pub const CRL_REASON_CERTIFICATE_HOLD_FLAG: u32 = 2;
pub const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG: u32 = 1;
pub const CRL_REASON_AA_COMPROMISE_FLAG: u32 = 128;
pub const CRL_DIST_POINT_ERR_INDEX_MASK: u32 = 127;
pub const CRL_DIST_POINT_ERR_INDEX_SHIFT: u32 = 24;
pub const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT: u32 = 2147483648;
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK: u32 = 255;
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT: u32 = 24;
pub const CERT_EXCLUDED_SUBTREE_BIT: u32 = 2147483648;
pub const SORTED_CTL_EXT_FLAGS_OFFSET: u32 = 0;
pub const SORTED_CTL_EXT_COUNT_OFFSET: u32 = 4;
pub const SORTED_CTL_EXT_MAX_COLLISION_OFFSET: u32 = 8;
pub const SORTED_CTL_EXT_HASH_BUCKET_OFFSET: u32 = 12;
pub const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG: u32 = 1;
pub const CERT_DSS_R_LEN: u32 = 20;
pub const CERT_DSS_S_LEN: u32 = 20;
pub const CERT_DSS_SIGNATURE_LEN: u32 = 40;
pub const CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN: u32 = 48;
pub const CRYPT_X942_COUNTER_BYTE_LENGTH: u32 = 4;
pub const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH: u32 = 4;
pub const CRYPT_X942_PUB_INFO_BYTE_LENGTH: u32 = 64;
pub const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH: u32 = 4;
pub const CRYPT_RC2_40BIT_VERSION: u32 = 160;
pub const CRYPT_RC2_56BIT_VERSION: u32 = 52;
pub const CRYPT_RC2_64BIT_VERSION: u32 = 120;
pub const CRYPT_RC2_128BIT_VERSION: u32 = 58;
pub const szOID_QC_EU_COMPLIANCE: &[u8; 15usize] = b"0.4.0.1862.1.1\0";
pub const szOID_QC_SSCD: &[u8; 15usize] = b"0.4.0.1862.1.4\0";
pub const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC: u32 = 1;
pub const szOID_VERISIGN_PRIVATE_6_9: &[u8; 24usize] = b"2.16.840.1.113733.1.6.9\0";
pub const szOID_VERISIGN_ONSITE_JURISDICTION_HASH: &[u8; 25usize] = b"2.16.840.1.113733.1.6.11\0";
pub const szOID_VERISIGN_BITSTRING_6_13: &[u8; 25usize] = b"2.16.840.1.113733.1.6.13\0";
pub const szOID_VERISIGN_ISS_STRONG_CRYPTO: &[u8; 24usize] = b"2.16.840.1.113733.1.8.1\0";
pub const szOIDVerisign_MessageType: &[u8; 24usize] = b"2.16.840.1.113733.1.9.2\0";
pub const szOIDVerisign_PkiStatus: &[u8; 24usize] = b"2.16.840.1.113733.1.9.3\0";
pub const szOIDVerisign_FailInfo: &[u8; 24usize] = b"2.16.840.1.113733.1.9.4\0";
pub const szOIDVerisign_SenderNonce: &[u8; 24usize] = b"2.16.840.1.113733.1.9.5\0";
pub const szOIDVerisign_RecipientNonce: &[u8; 24usize] = b"2.16.840.1.113733.1.9.6\0";
pub const szOIDVerisign_TransactionID: &[u8; 24usize] = b"2.16.840.1.113733.1.9.7\0";
pub const szOID_NETSCAPE: &[u8; 18usize] = b"2.16.840.1.113730\0";
pub const szOID_NETSCAPE_CERT_EXTENSION: &[u8; 20usize] = b"2.16.840.1.113730.1\0";
pub const szOID_NETSCAPE_CERT_TYPE: &[u8; 22usize] = b"2.16.840.1.113730.1.1\0";
pub const szOID_NETSCAPE_BASE_URL: &[u8; 22usize] = b"2.16.840.1.113730.1.2\0";
pub const szOID_NETSCAPE_REVOCATION_URL: &[u8; 22usize] = b"2.16.840.1.113730.1.3\0";
pub const szOID_NETSCAPE_CA_REVOCATION_URL: &[u8; 22usize] = b"2.16.840.1.113730.1.4\0";
pub const szOID_NETSCAPE_CERT_RENEWAL_URL: &[u8; 22usize] = b"2.16.840.1.113730.1.7\0";
pub const szOID_NETSCAPE_CA_POLICY_URL: &[u8; 22usize] = b"2.16.840.1.113730.1.8\0";
pub const szOID_NETSCAPE_SSL_SERVER_NAME: &[u8; 23usize] = b"2.16.840.1.113730.1.12\0";
pub const szOID_NETSCAPE_COMMENT: &[u8; 23usize] = b"2.16.840.1.113730.1.13\0";
pub const szOID_NETSCAPE_DATA_TYPE: &[u8; 20usize] = b"2.16.840.1.113730.2\0";
pub const szOID_NETSCAPE_CERT_SEQUENCE: &[u8; 22usize] = b"2.16.840.1.113730.2.5\0";
pub const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE: u32 = 128;
pub const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE: u32 = 64;
pub const NETSCAPE_SMIME_CERT_TYPE: u32 = 32;
pub const NETSCAPE_SIGN_CERT_TYPE: u32 = 16;
pub const NETSCAPE_SSL_CA_CERT_TYPE: u32 = 4;
pub const NETSCAPE_SMIME_CA_CERT_TYPE: u32 = 2;
pub const NETSCAPE_SIGN_CA_CERT_TYPE: u32 = 1;
pub const szOID_CT_PKI_DATA: &[u8; 19usize] = b"1.3.6.1.5.5.7.12.2\0";
pub const szOID_CT_PKI_RESPONSE: &[u8; 19usize] = b"1.3.6.1.5.5.7.12.3\0";
pub const szOID_PKIX_NO_SIGNATURE: &[u8; 18usize] = b"1.3.6.1.5.5.7.6.2\0";
pub const szOID_CMC: &[u8; 16usize] = b"1.3.6.1.5.5.7.7\0";
pub const szOID_CMC_STATUS_INFO: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.1\0";
pub const szOID_CMC_IDENTIFICATION: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.2\0";
pub const szOID_CMC_IDENTITY_PROOF: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.3\0";
pub const szOID_CMC_DATA_RETURN: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.4\0";
pub const szOID_CMC_TRANSACTION_ID: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.5\0";
pub const szOID_CMC_SENDER_NONCE: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.6\0";
pub const szOID_CMC_RECIPIENT_NONCE: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.7\0";
pub const szOID_CMC_ADD_EXTENSIONS: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.8\0";
pub const szOID_CMC_ENCRYPTED_POP: &[u8; 18usize] = b"1.3.6.1.5.5.7.7.9\0";
pub const szOID_CMC_DECRYPTED_POP: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.10\0";
pub const szOID_CMC_LRA_POP_WITNESS: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.11\0";
pub const szOID_CMC_GET_CERT: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.15\0";
pub const szOID_CMC_GET_CRL: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.16\0";
pub const szOID_CMC_REVOKE_REQUEST: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.17\0";
pub const szOID_CMC_REG_INFO: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.18\0";
pub const szOID_CMC_RESPONSE_INFO: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.19\0";
pub const szOID_CMC_QUERY_PENDING: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.21\0";
pub const szOID_CMC_ID_POP_LINK_RANDOM: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.22\0";
pub const szOID_CMC_ID_POP_LINK_WITNESS: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.23\0";
pub const szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE: &[u8; 19usize] = b"1.3.6.1.5.5.7.7.24\0";
pub const szOID_CMC_ADD_ATTRIBUTES: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.10.1\0";
pub const CMC_TAGGED_CERT_REQUEST_CHOICE: u32 = 1;
pub const CMC_OTHER_INFO_NO_CHOICE: u32 = 0;
pub const CMC_OTHER_INFO_FAIL_CHOICE: u32 = 1;
pub const CMC_OTHER_INFO_PEND_CHOICE: u32 = 2;
pub const CMC_STATUS_SUCCESS: u32 = 0;
pub const CMC_STATUS_FAILED: u32 = 2;
pub const CMC_STATUS_PENDING: u32 = 3;
pub const CMC_STATUS_NO_SUPPORT: u32 = 4;
pub const CMC_STATUS_CONFIRM_REQUIRED: u32 = 5;
pub const CMC_FAIL_BAD_ALG: u32 = 0;
pub const CMC_FAIL_BAD_MESSAGE_CHECK: u32 = 1;
pub const CMC_FAIL_BAD_REQUEST: u32 = 2;
pub const CMC_FAIL_BAD_TIME: u32 = 3;
pub const CMC_FAIL_BAD_CERT_ID: u32 = 4;
pub const CMC_FAIL_UNSUPORTED_EXT: u32 = 5;
pub const CMC_FAIL_MUST_ARCHIVE_KEYS: u32 = 6;
pub const CMC_FAIL_BAD_IDENTITY: u32 = 7;
pub const CMC_FAIL_POP_REQUIRED: u32 = 8;
pub const CMC_FAIL_POP_FAILED: u32 = 9;
pub const CMC_FAIL_NO_KEY_REUSE: u32 = 10;
pub const CMC_FAIL_INTERNAL_CA_ERROR: u32 = 11;
pub const CMC_FAIL_TRY_LATER: u32 = 12;
pub const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE: u32 = 1;
pub const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE: u32 = 2;
pub const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE: u32 = 0;
pub const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE: u32 = 1;
pub const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE: u32 = 2;
pub const CERT_LOGOTYPE_DIRECT_INFO_CHOICE: u32 = 1;
pub const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE: u32 = 2;
pub const szOID_LOYALTY_OTHER_LOGOTYPE: &[u8; 19usize] = b"1.3.6.1.5.5.7.20.1\0";
pub const szOID_BACKGROUND_OTHER_LOGOTYPE: &[u8; 19usize] = b"1.3.6.1.5.5.7.20.2\0";
pub const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE: u32 = 1;
pub const CERT_BIOMETRIC_OID_DATA_CHOICE: u32 = 2;
pub const CERT_BIOMETRIC_PICTURE_TYPE: u32 = 0;
pub const CERT_BIOMETRIC_SIGNATURE_TYPE: u32 = 1;
pub const OCSP_REQUEST_V1: u32 = 0;
pub const OCSP_SUCCESSFUL_RESPONSE: u32 = 0;
pub const OCSP_MALFORMED_REQUEST_RESPONSE: u32 = 1;
pub const OCSP_INTERNAL_ERROR_RESPONSE: u32 = 2;
pub const OCSP_TRY_LATER_RESPONSE: u32 = 3;
pub const OCSP_SIG_REQUIRED_RESPONSE: u32 = 5;
pub const OCSP_UNAUTHORIZED_RESPONSE: u32 = 6;
pub const szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE: &[u8; 21usize] = b"1.3.6.1.5.5.7.48.1.1\0";
pub const OCSP_BASIC_GOOD_CERT_STATUS: u32 = 0;
pub const OCSP_BASIC_REVOKED_CERT_STATUS: u32 = 1;
pub const OCSP_BASIC_UNKNOWN_CERT_STATUS: u32 = 2;
pub const OCSP_BASIC_RESPONSE_V1: u32 = 0;
pub const OCSP_BASIC_BY_NAME_RESPONDER_ID: u32 = 1;
pub const OCSP_BASIC_BY_KEY_RESPONDER_ID: u32 = 2;
pub const CRYPT_OID_ENCODE_OBJECT_FUNC: &[u8; 21usize] = b"CryptDllEncodeObject\0";
pub const CRYPT_OID_DECODE_OBJECT_FUNC: &[u8; 21usize] = b"CryptDllDecodeObject\0";
pub const CRYPT_OID_ENCODE_OBJECT_EX_FUNC: &[u8; 23usize] = b"CryptDllEncodeObjectEx\0";
pub const CRYPT_OID_DECODE_OBJECT_EX_FUNC: &[u8; 23usize] = b"CryptDllDecodeObjectEx\0";
pub const CRYPT_OID_CREATE_COM_OBJECT_FUNC: &[u8; 24usize] = b"CryptDllCreateCOMObject\0";
pub const CRYPT_OID_VERIFY_REVOCATION_FUNC: &[u8; 24usize] = b"CertDllVerifyRevocation\0";
pub const CRYPT_OID_VERIFY_CTL_USAGE_FUNC: &[u8; 22usize] = b"CertDllVerifyCTLUsage\0";
pub const CRYPT_OID_FORMAT_OBJECT_FUNC: &[u8; 21usize] = b"CryptDllFormatObject\0";
pub const CRYPT_OID_FIND_OID_INFO_FUNC: &[u8; 20usize] = b"CryptDllFindOIDInfo\0";
pub const CRYPT_OID_FIND_LOCALIZED_NAME_FUNC: &[u8; 26usize] = b"CryptDllFindLocalizedName\0";
pub const CRYPT_OID_REGPATH: &[u8; 36usize] = b"Software\\Microsoft\\Cryptography\\OID\0";
pub const CRYPT_OID_REG_ENCODING_TYPE_PREFIX: &[u8; 14usize] = b"EncodingType \0";
pub const CRYPT_OID_REG_DLL_VALUE_NAME: &[u8; 4usize] = b"Dll\0";
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME: &[u8; 9usize] = b"FuncName\0";
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A: &[u8; 9usize] = b"FuncName\0";
pub const CRYPT_OID_REG_FLAGS_VALUE_NAME: &[u8; 11usize] = b"CryptFlags\0";
pub const CRYPT_DEFAULT_OID: &[u8; 8usize] = b"DEFAULT\0";
pub const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG: u32 = 1;
pub const CRYPT_GET_INSTALLED_OID_FUNC_FLAG: u32 = 1;
pub const CRYPT_REGISTER_FIRST_INDEX: u32 = 0;
pub const CRYPT_REGISTER_LAST_INDEX: u32 = 4294967295;
pub const CRYPT_MATCH_ANY_ENCODING_TYPE: u32 = 4294967295;
pub const CALG_OID_INFO_CNG_ONLY: u32 = 4294967295;
pub const CALG_OID_INFO_PARAMETERS: u32 = 4294967294;
pub const CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM: &[u8; 27usize] =
    b"CryptOIDInfoHashParameters\0";
pub const CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM: &[u8; 26usize] = b"CryptOIDInfoECCParameters\0";
pub const CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM: &[u8; 27usize] =
    b"CryptOIDInfoMgf1Parameters\0";
pub const CRYPT_OID_INFO_NO_SIGN_ALGORITHM: &[u8; 19usize] = b"CryptOIDInfoNoSign\0";
pub const CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM: &[u8; 27usize] =
    b"CryptOIDInfoOAEPParameters\0";
pub const CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM: &[u8; 30usize] =
    b"CryptOIDInfoECCWrapParameters\0";
pub const CRYPT_OID_INFO_NO_PARAMETERS_ALGORITHM: &[u8; 25usize] = b"CryptOIDInfoNoParameters\0";
pub const CRYPT_HASH_ALG_OID_GROUP_ID: u32 = 1;
pub const CRYPT_ENCRYPT_ALG_OID_GROUP_ID: u32 = 2;
pub const CRYPT_PUBKEY_ALG_OID_GROUP_ID: u32 = 3;
pub const CRYPT_SIGN_ALG_OID_GROUP_ID: u32 = 4;
pub const CRYPT_RDN_ATTR_OID_GROUP_ID: u32 = 5;
pub const CRYPT_EXT_OR_ATTR_OID_GROUP_ID: u32 = 6;
pub const CRYPT_ENHKEY_USAGE_OID_GROUP_ID: u32 = 7;
pub const CRYPT_POLICY_OID_GROUP_ID: u32 = 8;
pub const CRYPT_TEMPLATE_OID_GROUP_ID: u32 = 9;
pub const CRYPT_KDF_OID_GROUP_ID: u32 = 10;
pub const CRYPT_LAST_OID_GROUP_ID: u32 = 10;
pub const CRYPT_FIRST_ALG_OID_GROUP_ID: u32 = 1;
pub const CRYPT_LAST_ALG_OID_GROUP_ID: u32 = 4;
pub const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG: u32 = 1;
pub const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG: u32 = 2;
pub const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG: u32 = 4;
pub const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG: u32 = 2147483648;
pub const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG: u32 = 1073741824;
pub const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG: u32 = 536870912;
pub const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG: u32 = 268435456;
pub const CRYPT_OID_INFO_OID_KEY: u32 = 1;
pub const CRYPT_OID_INFO_NAME_KEY: u32 = 2;
pub const CRYPT_OID_INFO_ALGID_KEY: u32 = 3;
pub const CRYPT_OID_INFO_SIGN_KEY: u32 = 4;
pub const CRYPT_OID_INFO_CNG_ALGID_KEY: u32 = 5;
pub const CRYPT_OID_INFO_CNG_SIGN_KEY: u32 = 6;
pub const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK: u32 = 4294901760;
pub const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG: u32 = 2147483648;
pub const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG: u32 = 1073741824;
pub const CRYPT_OID_DISABLE_SEARCH_DS_FLAG: u32 = 2147483648;
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK: u32 = 268369920;
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT: u32 = 16;
pub const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG: u32 = 1;
pub const CRYPT_LOCALIZED_NAME_ENCODING_TYPE: u32 = 0;
pub const CRYPT_LOCALIZED_NAME_OID: &[u8; 15usize] = b"LocalizedNames\0";
pub const CERT_STRONG_SIGN_ECDSA_ALGORITHM: &[u8; 6usize] = b"ECDSA\0";
pub const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE: u32 = 1;
pub const CERT_STRONG_SIGN_OID_INFO_CHOICE: u32 = 2;
pub const CERT_STRONG_SIGN_ENABLE_CRL_CHECK: u32 = 1;
pub const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK: u32 = 2;
pub const szOID_CERT_STRONG_SIGN_OS_PREFIX: &[u8; 22usize] = b"1.3.6.1.4.1.311.72.1.\0";
pub const szOID_CERT_STRONG_SIGN_OS_1: &[u8; 23usize] = b"1.3.6.1.4.1.311.72.1.1\0";
pub const szOID_CERT_STRONG_SIGN_OS_CURRENT: &[u8; 23usize] = b"1.3.6.1.4.1.311.72.1.1\0";
pub const szOID_CERT_STRONG_KEY_OS_PREFIX: &[u8; 22usize] = b"1.3.6.1.4.1.311.72.2.\0";
pub const szOID_CERT_STRONG_KEY_OS_1: &[u8; 23usize] = b"1.3.6.1.4.1.311.72.2.1\0";
pub const szOID_CERT_STRONG_KEY_OS_CURRENT: &[u8; 23usize] = b"1.3.6.1.4.1.311.72.2.1\0";
pub const szOID_PKCS_7_DATA: &[u8; 21usize] = b"1.2.840.113549.1.7.1\0";
pub const szOID_PKCS_7_SIGNED: &[u8; 21usize] = b"1.2.840.113549.1.7.2\0";
pub const szOID_PKCS_7_ENVELOPED: &[u8; 21usize] = b"1.2.840.113549.1.7.3\0";
pub const szOID_PKCS_7_SIGNEDANDENVELOPED: &[u8; 21usize] = b"1.2.840.113549.1.7.4\0";
pub const szOID_PKCS_7_DIGESTED: &[u8; 21usize] = b"1.2.840.113549.1.7.5\0";
pub const szOID_PKCS_7_ENCRYPTED: &[u8; 21usize] = b"1.2.840.113549.1.7.6\0";
pub const szOID_PKCS_9_CONTENT_TYPE: &[u8; 21usize] = b"1.2.840.113549.1.9.3\0";
pub const szOID_PKCS_9_MESSAGE_DIGEST: &[u8; 21usize] = b"1.2.840.113549.1.9.4\0";
pub const CMSG_DATA: u32 = 1;
pub const CMSG_SIGNED: u32 = 2;
pub const CMSG_ENVELOPED: u32 = 3;
pub const CMSG_SIGNED_AND_ENVELOPED: u32 = 4;
pub const CMSG_HASHED: u32 = 5;
pub const CMSG_ENCRYPTED: u32 = 6;
pub const CMSG_ALL_FLAGS: i32 = -1;
pub const CMSG_DATA_FLAG: u32 = 2;
pub const CMSG_SIGNED_FLAG: u32 = 4;
pub const CMSG_ENVELOPED_FLAG: u32 = 8;
pub const CMSG_SIGNED_AND_ENVELOPED_FLAG: u32 = 16;
pub const CMSG_HASHED_FLAG: u32 = 32;
pub const CMSG_ENCRYPTED_FLAG: u32 = 64;
pub const CERT_ID_ISSUER_SERIAL_NUMBER: u32 = 1;
pub const CERT_ID_KEY_IDENTIFIER: u32 = 2;
pub const CERT_ID_SHA1_HASH: u32 = 3;
pub const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE: u32 = 1;
pub const CMSG_KEY_AGREE_STATIC_KEY_CHOICE: u32 = 2;
pub const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE: u32 = 1;
pub const CMSG_KEY_TRANS_RECIPIENT: u32 = 1;
pub const CMSG_KEY_AGREE_RECIPIENT: u32 = 2;
pub const CMSG_MAIL_LIST_RECIPIENT: u32 = 3;
pub const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG: u32 = 2147483648;
pub const CMSG_RC4_NO_SALT_FLAG: u32 = 1073741824;
pub const CMSG_INDEFINITE_LENGTH: u32 = 4294967295;
pub const CMSG_BARE_CONTENT_FLAG: u32 = 1;
pub const CMSG_LENGTH_ONLY_FLAG: u32 = 2;
pub const CMSG_DETACHED_FLAG: u32 = 4;
pub const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG: u32 = 8;
pub const CMSG_CONTENTS_OCTETS_FLAG: u32 = 16;
pub const CMSG_MAX_LENGTH_FLAG: u32 = 32;
pub const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG: u32 = 64;
pub const CMSG_SIGNED_DATA_NO_SIGN_FLAG: u32 = 128;
pub const CMSG_CRYPT_RELEASE_CONTEXT_FLAG: u32 = 32768;
pub const CMSG_TYPE_PARAM: u32 = 1;
pub const CMSG_CONTENT_PARAM: u32 = 2;
pub const CMSG_BARE_CONTENT_PARAM: u32 = 3;
pub const CMSG_INNER_CONTENT_TYPE_PARAM: u32 = 4;
pub const CMSG_SIGNER_COUNT_PARAM: u32 = 5;
pub const CMSG_SIGNER_INFO_PARAM: u32 = 6;
pub const CMSG_SIGNER_CERT_INFO_PARAM: u32 = 7;
pub const CMSG_SIGNER_HASH_ALGORITHM_PARAM: u32 = 8;
pub const CMSG_SIGNER_AUTH_ATTR_PARAM: u32 = 9;
pub const CMSG_SIGNER_UNAUTH_ATTR_PARAM: u32 = 10;
pub const CMSG_CERT_COUNT_PARAM: u32 = 11;
pub const CMSG_CERT_PARAM: u32 = 12;
pub const CMSG_CRL_COUNT_PARAM: u32 = 13;
pub const CMSG_CRL_PARAM: u32 = 14;
pub const CMSG_ENVELOPE_ALGORITHM_PARAM: u32 = 15;
pub const CMSG_RECIPIENT_COUNT_PARAM: u32 = 17;
pub const CMSG_RECIPIENT_INDEX_PARAM: u32 = 18;
pub const CMSG_RECIPIENT_INFO_PARAM: u32 = 19;
pub const CMSG_HASH_ALGORITHM_PARAM: u32 = 20;
pub const CMSG_HASH_DATA_PARAM: u32 = 21;
pub const CMSG_COMPUTED_HASH_PARAM: u32 = 22;
pub const CMSG_ENCRYPT_PARAM: u32 = 26;
pub const CMSG_ENCRYPTED_DIGEST: u32 = 27;
pub const CMSG_ENCODED_SIGNER: u32 = 28;
pub const CMSG_ENCODED_MESSAGE: u32 = 29;
pub const CMSG_VERSION_PARAM: u32 = 30;
pub const CMSG_ATTR_CERT_COUNT_PARAM: u32 = 31;
pub const CMSG_ATTR_CERT_PARAM: u32 = 32;
pub const CMSG_CMS_RECIPIENT_COUNT_PARAM: u32 = 33;
pub const CMSG_CMS_RECIPIENT_INDEX_PARAM: u32 = 34;
pub const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM: u32 = 35;
pub const CMSG_CMS_RECIPIENT_INFO_PARAM: u32 = 36;
pub const CMSG_UNPROTECTED_ATTR_PARAM: u32 = 37;
pub const CMSG_SIGNER_CERT_ID_PARAM: u32 = 38;
pub const CMSG_CMS_SIGNER_INFO_PARAM: u32 = 39;
pub const CMSG_SIGNED_DATA_V1: u32 = 1;
pub const CMSG_SIGNED_DATA_V3: u32 = 3;
pub const CMSG_SIGNED_DATA_PKCS_1_5_VERSION: u32 = 1;
pub const CMSG_SIGNED_DATA_CMS_VERSION: u32 = 3;
pub const CMSG_SIGNER_INFO_V1: u32 = 1;
pub const CMSG_SIGNER_INFO_V3: u32 = 3;
pub const CMSG_SIGNER_INFO_PKCS_1_5_VERSION: u32 = 1;
pub const CMSG_SIGNER_INFO_CMS_VERSION: u32 = 3;
pub const CMSG_HASHED_DATA_V0: u32 = 0;
pub const CMSG_HASHED_DATA_V2: u32 = 2;
pub const CMSG_HASHED_DATA_PKCS_1_5_VERSION: u32 = 0;
pub const CMSG_HASHED_DATA_CMS_VERSION: u32 = 2;
pub const CMSG_ENVELOPED_DATA_V0: u32 = 0;
pub const CMSG_ENVELOPED_DATA_V2: u32 = 2;
pub const CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION: u32 = 0;
pub const CMSG_ENVELOPED_DATA_CMS_VERSION: u32 = 2;
pub const CMSG_KEY_AGREE_ORIGINATOR_CERT: u32 = 1;
pub const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY: u32 = 2;
pub const CMSG_ENVELOPED_RECIPIENT_V0: u32 = 0;
pub const CMSG_ENVELOPED_RECIPIENT_V2: u32 = 2;
pub const CMSG_ENVELOPED_RECIPIENT_V3: u32 = 3;
pub const CMSG_ENVELOPED_RECIPIENT_V4: u32 = 4;
pub const CMSG_KEY_TRANS_PKCS_1_5_VERSION: u32 = 0;
pub const CMSG_KEY_TRANS_CMS_VERSION: u32 = 2;
pub const CMSG_KEY_AGREE_VERSION: u32 = 3;
pub const CMSG_MAIL_LIST_VERSION: u32 = 4;
pub const CMSG_CTRL_VERIFY_SIGNATURE: u32 = 1;
pub const CMSG_CTRL_DECRYPT: u32 = 2;
pub const CMSG_CTRL_VERIFY_HASH: u32 = 5;
pub const CMSG_CTRL_ADD_SIGNER: u32 = 6;
pub const CMSG_CTRL_DEL_SIGNER: u32 = 7;
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR: u32 = 8;
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR: u32 = 9;
pub const CMSG_CTRL_ADD_CERT: u32 = 10;
pub const CMSG_CTRL_DEL_CERT: u32 = 11;
pub const CMSG_CTRL_ADD_CRL: u32 = 12;
pub const CMSG_CTRL_DEL_CRL: u32 = 13;
pub const CMSG_CTRL_ADD_ATTR_CERT: u32 = 14;
pub const CMSG_CTRL_DEL_ATTR_CERT: u32 = 15;
pub const CMSG_CTRL_KEY_TRANS_DECRYPT: u32 = 16;
pub const CMSG_CTRL_KEY_AGREE_DECRYPT: u32 = 17;
pub const CMSG_CTRL_MAIL_LIST_DECRYPT: u32 = 18;
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX: u32 = 19;
pub const CMSG_CTRL_ADD_CMS_SIGNER_INFO: u32 = 20;
pub const CMSG_CTRL_ENABLE_STRONG_SIGNATURE: u32 = 21;
pub const CMSG_VERIFY_SIGNER_PUBKEY: u32 = 1;
pub const CMSG_VERIFY_SIGNER_CERT: u32 = 2;
pub const CMSG_VERIFY_SIGNER_CHAIN: u32 = 3;
pub const CMSG_VERIFY_SIGNER_NULL: u32 = 4;
pub const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG: u32 = 1;
pub const CMSG_OID_GEN_ENCRYPT_KEY_FUNC: &[u8; 25usize] = b"CryptMsgDllGenEncryptKey\0";
pub const CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC: &[u8; 28usize] = b"CryptMsgDllExportEncryptKey\0";
pub const CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC: &[u8; 28usize] = b"CryptMsgDllImportEncryptKey\0";
pub const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG: u32 = 1;
pub const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG: u32 = 1;
pub const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG: u32 = 2;
pub const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG: u32 = 32768;
pub const CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC: &[u8; 32usize] =
    b"CryptMsgDllGenContentEncryptKey\0";
pub const CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC: &[u8; 32usize] =
    b"CryptMsgDllGenContentEncryptKey\0";
pub const CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC: &[u8; 35usize] =
    b"CryptMsgDllCNGGenContentEncryptKey\0";
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG: u32 = 1;
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG: u32 = 2;
pub const CMSG_OID_EXPORT_KEY_TRANS_FUNC: &[u8; 26usize] = b"CryptMsgDllExportKeyTrans\0";
pub const CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC: &[u8; 26usize] = b"CryptMsgDllExportKeyTrans\0";
pub const CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC: &[u8; 29usize] = b"CryptMsgDllCNGExportKeyTrans\0";
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG: u32 = 1;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG: u32 = 2;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG: u32 = 4;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG: u32 = 8;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG: u32 = 16;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG: u32 = 32;
pub const CMSG_OID_EXPORT_KEY_AGREE_FUNC: &[u8; 26usize] = b"CryptMsgDllExportKeyAgree\0";
pub const CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC: &[u8; 26usize] = b"CryptMsgDllExportKeyAgree\0";
pub const CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC: &[u8; 29usize] = b"CryptMsgDllCNGExportKeyAgree\0";
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG: u32 = 1;
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG: u32 = 2;
pub const CMSG_OID_EXPORT_MAIL_LIST_FUNC: &[u8; 26usize] = b"CryptMsgDllExportMailList\0";
pub const CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC: &[u8; 26usize] = b"CryptMsgDllExportMailList\0";
pub const CMSG_OID_IMPORT_KEY_TRANS_FUNC: &[u8; 26usize] = b"CryptMsgDllImportKeyTrans\0";
pub const CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC: &[u8; 26usize] = b"CryptMsgDllImportKeyTrans\0";
pub const CMSG_OID_IMPORT_KEY_AGREE_FUNC: &[u8; 26usize] = b"CryptMsgDllImportKeyAgree\0";
pub const CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC: &[u8; 26usize] = b"CryptMsgDllImportKeyAgree\0";
pub const CMSG_OID_IMPORT_MAIL_LIST_FUNC: &[u8; 26usize] = b"CryptMsgDllImportMailList\0";
pub const CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC: &[u8; 26usize] = b"CryptMsgDllImportMailList\0";
pub const CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC: &[u8; 29usize] = b"CryptMsgDllCNGImportKeyTrans\0";
pub const CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC: &[u8; 29usize] = b"CryptMsgDllCNGImportKeyAgree\0";
pub const CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC: &[u8; 38usize] =
    b"CryptMsgDllCNGImportContentEncryptKey\0";
pub const CERT_KEY_PROV_HANDLE_PROP_ID: u32 = 1;
pub const CERT_KEY_PROV_INFO_PROP_ID: u32 = 2;
pub const CERT_SHA1_HASH_PROP_ID: u32 = 3;
pub const CERT_MD5_HASH_PROP_ID: u32 = 4;
pub const CERT_HASH_PROP_ID: u32 = 3;
pub const CERT_KEY_CONTEXT_PROP_ID: u32 = 5;
pub const CERT_KEY_SPEC_PROP_ID: u32 = 6;
pub const CERT_IE30_RESERVED_PROP_ID: u32 = 7;
pub const CERT_PUBKEY_HASH_RESERVED_PROP_ID: u32 = 8;
pub const CERT_ENHKEY_USAGE_PROP_ID: u32 = 9;
pub const CERT_CTL_USAGE_PROP_ID: u32 = 9;
pub const CERT_NEXT_UPDATE_LOCATION_PROP_ID: u32 = 10;
pub const CERT_FRIENDLY_NAME_PROP_ID: u32 = 11;
pub const CERT_PVK_FILE_PROP_ID: u32 = 12;
pub const CERT_DESCRIPTION_PROP_ID: u32 = 13;
pub const CERT_ACCESS_STATE_PROP_ID: u32 = 14;
pub const CERT_SIGNATURE_HASH_PROP_ID: u32 = 15;
pub const CERT_SMART_CARD_DATA_PROP_ID: u32 = 16;
pub const CERT_EFS_PROP_ID: u32 = 17;
pub const CERT_FORTEZZA_DATA_PROP_ID: u32 = 18;
pub const CERT_ARCHIVED_PROP_ID: u32 = 19;
pub const CERT_KEY_IDENTIFIER_PROP_ID: u32 = 20;
pub const CERT_AUTO_ENROLL_PROP_ID: u32 = 21;
pub const CERT_PUBKEY_ALG_PARA_PROP_ID: u32 = 22;
pub const CERT_CROSS_CERT_DIST_POINTS_PROP_ID: u32 = 23;
pub const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID: u32 = 24;
pub const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID: u32 = 25;
pub const CERT_ENROLLMENT_PROP_ID: u32 = 26;
pub const CERT_DATE_STAMP_PROP_ID: u32 = 27;
pub const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID: u32 = 28;
pub const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID: u32 = 29;
pub const CERT_EXTENDED_ERROR_INFO_PROP_ID: u32 = 30;
pub const CERT_RENEWAL_PROP_ID: u32 = 64;
pub const CERT_ARCHIVED_KEY_HASH_PROP_ID: u32 = 65;
pub const CERT_AUTO_ENROLL_RETRY_PROP_ID: u32 = 66;
pub const CERT_AIA_URL_RETRIEVED_PROP_ID: u32 = 67;
pub const CERT_AUTHORITY_INFO_ACCESS_PROP_ID: u32 = 68;
pub const CERT_BACKED_UP_PROP_ID: u32 = 69;
pub const CERT_OCSP_RESPONSE_PROP_ID: u32 = 70;
pub const CERT_REQUEST_ORIGINATOR_PROP_ID: u32 = 71;
pub const CERT_SOURCE_LOCATION_PROP_ID: u32 = 72;
pub const CERT_SOURCE_URL_PROP_ID: u32 = 73;
pub const CERT_NEW_KEY_PROP_ID: u32 = 74;
pub const CERT_OCSP_CACHE_PREFIX_PROP_ID: u32 = 75;
pub const CERT_SMART_CARD_ROOT_INFO_PROP_ID: u32 = 76;
pub const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID: u32 = 77;
pub const CERT_NCRYPT_KEY_HANDLE_PROP_ID: u32 = 78;
pub const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID: u32 = 79;
pub const CERT_SUBJECT_INFO_ACCESS_PROP_ID: u32 = 80;
pub const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID: u32 = 81;
pub const CERT_CA_DISABLE_CRL_PROP_ID: u32 = 82;
pub const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID: u32 = 83;
pub const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID: u32 = 84;
pub const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID: u32 = 85;
pub const CERT_SUBJECT_DISABLE_CRL_PROP_ID: u32 = 86;
pub const CERT_CEP_PROP_ID: u32 = 87;
pub const CERT_SIGN_HASH_CNG_ALG_PROP_ID: u32 = 89;
pub const CERT_SCARD_PIN_ID_PROP_ID: u32 = 90;
pub const CERT_SCARD_PIN_INFO_PROP_ID: u32 = 91;
pub const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID: u32 = 92;
pub const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID: u32 = 93;
pub const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID: u32 = 94;
pub const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID: u32 = 95;
pub const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID: u32 = 96;
pub const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID: u32 = 97;
pub const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID: u32 = 98;
pub const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID: u32 = 99;
pub const CERT_HCRYPTPROV_TRANSFER_PROP_ID: u32 = 100;
pub const CERT_SMART_CARD_READER_PROP_ID: u32 = 101;
pub const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID: u32 = 102;
pub const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID: u32 = 103;
pub const CERT_DISALLOWED_FILETIME_PROP_ID: u32 = 104;
pub const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID: u32 = 105;
pub const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID: u32 = 106;
pub const CERT_SHA256_HASH_PROP_ID: u32 = 107;
pub const CERT_SCEP_SERVER_CERTS_PROP_ID: u32 = 108;
pub const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID: u32 = 109;
pub const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID: u32 = 110;
pub const CERT_SCEP_CA_CERT_PROP_ID: u32 = 111;
pub const CERT_SCEP_SIGNER_CERT_PROP_ID: u32 = 112;
pub const CERT_SCEP_NONCE_PROP_ID: u32 = 113;
pub const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID: u32 = 114;
pub const CERT_SCEP_FLAGS_PROP_ID: u32 = 115;
pub const CERT_SCEP_GUID_PROP_ID: u32 = 116;
pub const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID: u32 = 117;
pub const CERT_ISOLATED_KEY_PROP_ID: u32 = 118;
pub const CERT_SERIAL_CHAIN_PROP_ID: u32 = 119;
pub const CERT_KEY_CLASSIFICATION_PROP_ID: u32 = 120;
pub const CERT_OCSP_MUST_STAPLE_PROP_ID: u32 = 121;
pub const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID: u32 = 122;
pub const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID: u32 = 123;
pub const CERT_PIN_SHA256_HASH_PROP_ID: u32 = 124;
pub const CERT_CLR_DELETE_KEY_PROP_ID: u32 = 125;
pub const CERT_NOT_BEFORE_FILETIME_PROP_ID: u32 = 126;
pub const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID: u32 = 127;
pub const CERT_DISALLOWED_CA_FILETIME_PROP_ID: u32 = 128;
pub const CERT_FIRST_RESERVED_PROP_ID: u32 = 129;
pub const CERT_LAST_RESERVED_PROP_ID: u32 = 32767;
pub const CERT_FIRST_USER_PROP_ID: u32 = 32768;
pub const CERT_LAST_USER_PROP_ID: u32 = 65535;
pub const szOID_CERT_PROP_ID_PREFIX: &[u8; 23usize] = b"1.3.6.1.4.1.311.10.11.\0";
pub const szOID_CERT_KEY_IDENTIFIER_PROP_ID: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.11.20\0";
pub const szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID: &[u8; 25usize] =
    b"1.3.6.1.4.1.311.10.11.28\0";
pub const szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.11.29\0";
pub const szOID_CERT_MD5_HASH_PROP_ID: &[u8; 24usize] = b"1.3.6.1.4.1.311.10.11.4\0";
pub const szOID_CERT_SIGNATURE_HASH_PROP_ID: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.11.15\0";
pub const szOID_DISALLOWED_HASH: &[u8; 25usize] = b"1.3.6.1.4.1.311.10.11.15\0";
pub const szOID_CERT_DISALLOWED_FILETIME_PROP_ID: &[u8; 26usize] = b"1.3.6.1.4.1.311.10.11.104\0";
pub const szOID_CERT_DISALLOWED_CA_FILETIME_PROP_ID: &[u8; 26usize] =
    b"1.3.6.1.4.1.311.10.11.128\0";
pub const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG: u32 = 1;
pub const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG: u32 = 2;
pub const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG: u32 = 4;
pub const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG: u32 = 8;
pub const CERT_ACCESS_STATE_SHARED_USER_FLAG: u32 = 16;
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION: &[u8; 23usize] =
    b"1.3.6.1.4.1.311.60.3.1\0";
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION: &[u8; 23usize] =
    b"1.3.6.1.4.1.311.60.3.2\0";
pub const szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL: &[u8; 23usize] = b"1.3.6.1.4.1.311.60.3.3\0";
pub const CERT_SET_KEY_PROV_HANDLE_PROP_ID: u32 = 1;
pub const CERT_SET_KEY_CONTEXT_PROP_ID: u32 = 1;
pub const CERT_NCRYPT_KEY_SPEC: u32 = 4294967295;
pub const sz_CERT_STORE_PROV_MEMORY: &[u8; 7usize] = b"Memory\0";
pub const sz_CERT_STORE_PROV_FILENAME_W: &[u8; 5usize] = b"File\0";
pub const sz_CERT_STORE_PROV_FILENAME: &[u8; 5usize] = b"File\0";
pub const sz_CERT_STORE_PROV_SYSTEM_W: &[u8; 7usize] = b"System\0";
pub const sz_CERT_STORE_PROV_SYSTEM: &[u8; 7usize] = b"System\0";
pub const sz_CERT_STORE_PROV_PKCS7: &[u8; 6usize] = b"PKCS7\0";
pub const sz_CERT_STORE_PROV_PKCS12: &[u8; 7usize] = b"PKCS12\0";
pub const sz_CERT_STORE_PROV_SERIALIZED: &[u8; 11usize] = b"Serialized\0";
pub const sz_CERT_STORE_PROV_COLLECTION: &[u8; 11usize] = b"Collection\0";
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W: &[u8; 15usize] = b"SystemRegistry\0";
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY: &[u8; 15usize] = b"SystemRegistry\0";
pub const sz_CERT_STORE_PROV_PHYSICAL_W: &[u8; 9usize] = b"Physical\0";
pub const sz_CERT_STORE_PROV_PHYSICAL: &[u8; 9usize] = b"Physical\0";
pub const sz_CERT_STORE_PROV_SMART_CARD_W: &[u8; 10usize] = b"SmartCard\0";
pub const sz_CERT_STORE_PROV_SMART_CARD: &[u8; 10usize] = b"SmartCard\0";
pub const sz_CERT_STORE_PROV_LDAP_W: &[u8; 5usize] = b"Ldap\0";
pub const sz_CERT_STORE_PROV_LDAP: &[u8; 5usize] = b"Ldap\0";
pub const CERT_STORE_SIGNATURE_FLAG: u32 = 1;
pub const CERT_STORE_TIME_VALIDITY_FLAG: u32 = 2;
pub const CERT_STORE_REVOCATION_FLAG: u32 = 4;
pub const CERT_STORE_NO_CRL_FLAG: u32 = 65536;
pub const CERT_STORE_NO_ISSUER_FLAG: u32 = 131072;
pub const CERT_STORE_BASE_CRL_FLAG: u32 = 256;
pub const CERT_STORE_DELTA_CRL_FLAG: u32 = 512;
pub const CERT_STORE_NO_CRYPT_RELEASE_FLAG: u32 = 1;
pub const CERT_STORE_SET_LOCALIZED_NAME_FLAG: u32 = 2;
pub const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG: u32 = 4;
pub const CERT_STORE_DELETE_FLAG: u32 = 16;
pub const CERT_STORE_UNSAFE_PHYSICAL_FLAG: u32 = 32;
pub const CERT_STORE_SHARE_STORE_FLAG: u32 = 64;
pub const CERT_STORE_SHARE_CONTEXT_FLAG: u32 = 128;
pub const CERT_STORE_MANIFOLD_FLAG: u32 = 256;
pub const CERT_STORE_ENUM_ARCHIVED_FLAG: u32 = 512;
pub const CERT_STORE_UPDATE_KEYID_FLAG: u32 = 1024;
pub const CERT_STORE_BACKUP_RESTORE_FLAG: u32 = 2048;
pub const CERT_STORE_READONLY_FLAG: u32 = 32768;
pub const CERT_STORE_OPEN_EXISTING_FLAG: u32 = 16384;
pub const CERT_STORE_CREATE_NEW_FLAG: u32 = 8192;
pub const CERT_STORE_MAXIMUM_ALLOWED_FLAG: u32 = 4096;
pub const CERT_SYSTEM_STORE_MASK: u32 = 4294901760;
pub const CERT_SYSTEM_STORE_RELOCATE_FLAG: u32 = 2147483648;
pub const CERT_SYSTEM_STORE_UNPROTECTED_FLAG: u32 = 1073741824;
pub const CERT_SYSTEM_STORE_DEFER_READ_FLAG: u32 = 536870912;
pub const CERT_SYSTEM_STORE_LOCATION_MASK: u32 = 16711680;
pub const CERT_SYSTEM_STORE_LOCATION_SHIFT: u32 = 16;
pub const CERT_SYSTEM_STORE_CURRENT_USER_ID: u32 = 1;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID: u32 = 2;
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID: u32 = 4;
pub const CERT_SYSTEM_STORE_SERVICES_ID: u32 = 5;
pub const CERT_SYSTEM_STORE_USERS_ID: u32 = 6;
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID: u32 = 7;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID: u32 = 8;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID: u32 = 9;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID: u32 = 10;
pub const CERT_SYSTEM_STORE_CURRENT_USER: u32 = 65536;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE: u32 = 131072;
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE: u32 = 262144;
pub const CERT_SYSTEM_STORE_SERVICES: u32 = 327680;
pub const CERT_SYSTEM_STORE_USERS: u32 = 393216;
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY: u32 = 458752;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY: u32 = 524288;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE: u32 = 589824;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS: u32 = 655360;
pub const CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH: &[u8; 47usize] =
    b"Software\\Policies\\Microsoft\\SystemCertificates\0";
pub const CERT_EFSBLOB_REGPATH: &[u8; 51usize] =
    b"Software\\Policies\\Microsoft\\SystemCertificates\\EFS\0";
pub const CERT_EFSBLOB_VALUE_NAME: &[u8; 8usize] = b"EFSBlob\0";
pub const CERT_PROT_ROOT_FLAGS_REGPATH: &[u8; 67usize] =
    b"Software\\Policies\\Microsoft\\SystemCertificates\\Root\\ProtectedRoots\0";
pub const CERT_PROT_ROOT_FLAGS_VALUE_NAME: &[u8; 6usize] = b"Flags\0";
pub const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG: u32 = 1;
pub const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG: u32 = 2;
pub const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG: u32 = 4;
pub const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG: u32 = 8;
pub const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG: u32 = 8;
pub const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG: u32 = 16;
pub const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG: u32 = 32;
pub const CERT_PROT_ROOT_DISABLE_PEER_TRUST: u32 = 65536;
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME: &[u8; 11usize] = b"PeerUsages\0";
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A: &[u8; 11usize] = b"PeerUsages\0";
pub const CERT_PROT_ROOT_PEER_USAGES_DEFAULT_A: &[u8; 60usize] =
    b"1.3.6.1.5.5.7.3.2\01.3.6.1.5.5.7.3.4\01.3.6.1.4.1.311.10.3.4\0\0";
pub const CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH: &[u8; 70usize] =
    b"Software\\Policies\\Microsoft\\SystemCertificates\\TrustedPublisher\\Safer\0";
pub const CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH: &[u8; 38usize] =
    b"Software\\Microsoft\\SystemCertificates\0";
pub const CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH: &[u8; 61usize] =
    b"Software\\Microsoft\\SystemCertificates\\TrustedPublisher\\Safer\0";
pub const CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME: &[u8; 18usize] = b"AuthenticodeFlags\0";
pub const CERT_TRUST_PUB_ALLOW_TRUST_MASK: u32 = 3;
pub const CERT_TRUST_PUB_ALLOW_END_USER_TRUST: u32 = 0;
pub const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST: u32 = 1;
pub const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST: u32 = 2;
pub const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG: u32 = 256;
pub const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG: u32 = 512;
pub const CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH: &[u8; 73usize] =
    b"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents\0";
pub const CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME: &[u8; 15usize] = b"RootAutoUpdate\0";
pub const CERT_DISABLE_ROOT_AUTO_UPDATE_REGPATH: &[u8; 56usize] =
    b"Software\\Policies\\Microsoft\\SystemCertificates\\AuthRoot\0";
pub const CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME: &[u8; 22usize] = b"DisableRootAutoUpdate\0";
pub const CERT_ENABLE_DISALLOWED_CERT_AUTO_UPDATE_VALUE_NAME: &[u8; 31usize] =
    b"EnableDisallowedCertAutoUpdate\0";
pub const CERT_DISABLE_PIN_RULES_AUTO_UPDATE_VALUE_NAME: &[u8; 26usize] =
    b"DisablePinRulesAutoUpdate\0";
pub const CERT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH: &[u8; 58usize] =
    b"Software\\Microsoft\\SystemCertificates\\AuthRoot\\AutoUpdate\0";
pub const CERT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME: &[u8; 11usize] = b"RootDirUrl\0";
pub const CERT_AUTO_UPDATE_SYNC_FROM_DIR_URL_VALUE_NAME: &[u8; 15usize] = b"SyncFromDirUrl\0";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH: &[u8; 58usize] =
    b"Software\\Microsoft\\SystemCertificates\\AuthRoot\\AutoUpdate\0";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME: &[u8; 11usize] = b"RootDirUrl\0";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME: &[u8; 14usize] =
    b"SyncDeltaTime\0";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME: &[u8; 6usize] = b"Flags\0";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG: u32 = 1;
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG: u32 = 2;
pub const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG: u32 = 4;
pub const CERT_AUTH_ROOT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME: &[u8; 13usize] = b"LastSyncTime\0";
pub const CERT_AUTH_ROOT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME: &[u8; 11usize] = b"EncodedCtl\0";
pub const CERT_AUTH_ROOT_CTL_FILENAME: &[u8; 13usize] = b"authroot.stl\0";
pub const CERT_AUTH_ROOT_CTL_FILENAME_A: &[u8; 13usize] = b"authroot.stl\0";
pub const CERT_AUTH_ROOT_CAB_FILENAME: &[u8; 16usize] = b"authrootstl.cab\0";
pub const CERT_AUTH_ROOT_SEQ_FILENAME: &[u8; 16usize] = b"authrootseq.txt\0";
pub const CERT_AUTH_ROOT_CERT_EXT: &[u8; 5usize] = b".crt\0";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME: &[u8; 28usize] =
    b"DisallowedCertSyncDeltaTime\0";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME: &[u8; 27usize] =
    b"DisallowedCertLastSyncTime\0";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME: &[u8; 25usize] =
    b"DisallowedCertEncodedCtl\0";
pub const CERT_DISALLOWED_CERT_CTL_FILENAME: &[u8; 19usize] = b"disallowedcert.stl\0";
pub const CERT_DISALLOWED_CERT_CTL_FILENAME_A: &[u8; 19usize] = b"disallowedcert.stl\0";
pub const CERT_DISALLOWED_CERT_CAB_FILENAME: &[u8; 22usize] = b"disallowedcertstl.cab\0";
pub const CERT_DISALLOWED_CERT_AUTO_UPDATE_LIST_IDENTIFIER: &[u8; 28usize] =
    b"DisallowedCert_AutoUpdate_1\0";
pub const CERT_PIN_RULES_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME: &[u8; 22usize] =
    b"PinRulesSyncDeltaTime\0";
pub const CERT_PIN_RULES_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME: &[u8; 21usize] =
    b"PinRulesLastSyncTime\0";
pub const CERT_PIN_RULES_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME: &[u8; 19usize] =
    b"PinRulesEncodedCtl\0";
pub const CERT_PIN_RULES_CTL_FILENAME: &[u8; 13usize] = b"pinrules.stl\0";
pub const CERT_PIN_RULES_CTL_FILENAME_A: &[u8; 13usize] = b"pinrules.stl\0";
pub const CERT_PIN_RULES_CAB_FILENAME: &[u8; 16usize] = b"pinrulesstl.cab\0";
pub const CERT_PIN_RULES_AUTO_UPDATE_LIST_IDENTIFIER: &[u8; 22usize] = b"PinRules_AutoUpdate_1\0";
pub const CERT_REGISTRY_STORE_REMOTE_FLAG: u32 = 65536;
pub const CERT_REGISTRY_STORE_SERIALIZED_FLAG: u32 = 131072;
pub const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG: u32 = 2147483648;
pub const CERT_REGISTRY_STORE_LM_GPT_FLAG: u32 = 16777216;
pub const CERT_REGISTRY_STORE_ROAMING_FLAG: u32 = 262144;
pub const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG: u32 = 524288;
pub const CERT_REGISTRY_STORE_EXTERNAL_FLAG: u32 = 1048576;
pub const CERT_IE_DIRTY_FLAGS_REGPATH: &[u8; 45usize] =
    b"Software\\Microsoft\\Cryptography\\IEDirtyFlags\0";
pub const CERT_FILE_STORE_COMMIT_ENABLE_FLAG: u32 = 65536;
pub const CERT_LDAP_STORE_SIGN_FLAG: u32 = 65536;
pub const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG: u32 = 131072;
pub const CERT_LDAP_STORE_OPENED_FLAG: u32 = 262144;
pub const CERT_LDAP_STORE_UNBIND_FLAG: u32 = 524288;
pub const CRYPT_OID_OPEN_STORE_PROV_FUNC: &[u8; 21usize] = b"CertDllOpenStoreProv\0";
pub const CERT_STORE_PROV_EXTERNAL_FLAG: u32 = 1;
pub const CERT_STORE_PROV_DELETED_FLAG: u32 = 2;
pub const CERT_STORE_PROV_NO_PERSIST_FLAG: u32 = 4;
pub const CERT_STORE_PROV_SYSTEM_STORE_FLAG: u32 = 8;
pub const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG: u32 = 16;
pub const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG: u32 = 32;
pub const CERT_STORE_PROV_SHARED_USER_FLAG: u32 = 64;
pub const CERT_STORE_PROV_CLOSE_FUNC: u32 = 0;
pub const CERT_STORE_PROV_READ_CERT_FUNC: u32 = 1;
pub const CERT_STORE_PROV_WRITE_CERT_FUNC: u32 = 2;
pub const CERT_STORE_PROV_DELETE_CERT_FUNC: u32 = 3;
pub const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC: u32 = 4;
pub const CERT_STORE_PROV_READ_CRL_FUNC: u32 = 5;
pub const CERT_STORE_PROV_WRITE_CRL_FUNC: u32 = 6;
pub const CERT_STORE_PROV_DELETE_CRL_FUNC: u32 = 7;
pub const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC: u32 = 8;
pub const CERT_STORE_PROV_READ_CTL_FUNC: u32 = 9;
pub const CERT_STORE_PROV_WRITE_CTL_FUNC: u32 = 10;
pub const CERT_STORE_PROV_DELETE_CTL_FUNC: u32 = 11;
pub const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC: u32 = 12;
pub const CERT_STORE_PROV_CONTROL_FUNC: u32 = 13;
pub const CERT_STORE_PROV_FIND_CERT_FUNC: u32 = 14;
pub const CERT_STORE_PROV_FREE_FIND_CERT_FUNC: u32 = 15;
pub const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC: u32 = 16;
pub const CERT_STORE_PROV_FIND_CRL_FUNC: u32 = 17;
pub const CERT_STORE_PROV_FREE_FIND_CRL_FUNC: u32 = 18;
pub const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC: u32 = 19;
pub const CERT_STORE_PROV_FIND_CTL_FUNC: u32 = 20;
pub const CERT_STORE_PROV_FREE_FIND_CTL_FUNC: u32 = 21;
pub const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC: u32 = 22;
pub const CERT_STORE_PROV_WRITE_ADD_FLAG: u32 = 1;
pub const CERT_STORE_SAVE_AS_STORE: u32 = 1;
pub const CERT_STORE_SAVE_AS_PKCS7: u32 = 2;
pub const CERT_STORE_SAVE_AS_PKCS12: u32 = 3;
pub const CERT_STORE_SAVE_TO_FILE: u32 = 1;
pub const CERT_STORE_SAVE_TO_MEMORY: u32 = 2;
pub const CERT_STORE_SAVE_TO_FILENAME_A: u32 = 3;
pub const CERT_STORE_SAVE_TO_FILENAME_W: u32 = 4;
pub const CERT_STORE_SAVE_TO_FILENAME: u32 = 4;
pub const CERT_CLOSE_STORE_FORCE_FLAG: u32 = 1;
pub const CERT_CLOSE_STORE_CHECK_FLAG: u32 = 2;
pub const CERT_COMPARE_MASK: u32 = 65535;
pub const CERT_COMPARE_SHIFT: u32 = 16;
pub const CERT_COMPARE_ANY: u32 = 0;
pub const CERT_COMPARE_SHA1_HASH: u32 = 1;
pub const CERT_COMPARE_NAME: u32 = 2;
pub const CERT_COMPARE_ATTR: u32 = 3;
pub const CERT_COMPARE_MD5_HASH: u32 = 4;
pub const CERT_COMPARE_PROPERTY: u32 = 5;
pub const CERT_COMPARE_PUBLIC_KEY: u32 = 6;
pub const CERT_COMPARE_HASH: u32 = 1;
pub const CERT_COMPARE_NAME_STR_A: u32 = 7;
pub const CERT_COMPARE_NAME_STR_W: u32 = 8;
pub const CERT_COMPARE_KEY_SPEC: u32 = 9;
pub const CERT_COMPARE_ENHKEY_USAGE: u32 = 10;
pub const CERT_COMPARE_CTL_USAGE: u32 = 10;
pub const CERT_COMPARE_SUBJECT_CERT: u32 = 11;
pub const CERT_COMPARE_ISSUER_OF: u32 = 12;
pub const CERT_COMPARE_EXISTING: u32 = 13;
pub const CERT_COMPARE_SIGNATURE_HASH: u32 = 14;
pub const CERT_COMPARE_KEY_IDENTIFIER: u32 = 15;
pub const CERT_COMPARE_CERT_ID: u32 = 16;
pub const CERT_COMPARE_CROSS_CERT_DIST_POINTS: u32 = 17;
pub const CERT_COMPARE_PUBKEY_MD5_HASH: u32 = 18;
pub const CERT_COMPARE_SUBJECT_INFO_ACCESS: u32 = 19;
pub const CERT_COMPARE_HASH_STR: u32 = 20;
pub const CERT_COMPARE_HAS_PRIVATE_KEY: u32 = 21;
pub const CERT_FIND_ANY: u32 = 0;
pub const CERT_FIND_SHA1_HASH: u32 = 65536;
pub const CERT_FIND_MD5_HASH: u32 = 262144;
pub const CERT_FIND_SIGNATURE_HASH: u32 = 917504;
pub const CERT_FIND_KEY_IDENTIFIER: u32 = 983040;
pub const CERT_FIND_HASH: u32 = 65536;
pub const CERT_FIND_PROPERTY: u32 = 327680;
pub const CERT_FIND_PUBLIC_KEY: u32 = 393216;
pub const CERT_FIND_SUBJECT_NAME: u32 = 131079;
pub const CERT_FIND_SUBJECT_ATTR: u32 = 196615;
pub const CERT_FIND_ISSUER_NAME: u32 = 131076;
pub const CERT_FIND_ISSUER_ATTR: u32 = 196612;
pub const CERT_FIND_SUBJECT_STR_A: u32 = 458759;
pub const CERT_FIND_SUBJECT_STR_W: u32 = 524295;
pub const CERT_FIND_SUBJECT_STR: u32 = 524295;
pub const CERT_FIND_ISSUER_STR_A: u32 = 458756;
pub const CERT_FIND_ISSUER_STR_W: u32 = 524292;
pub const CERT_FIND_ISSUER_STR: u32 = 524292;
pub const CERT_FIND_KEY_SPEC: u32 = 589824;
pub const CERT_FIND_ENHKEY_USAGE: u32 = 655360;
pub const CERT_FIND_CTL_USAGE: u32 = 655360;
pub const CERT_FIND_SUBJECT_CERT: u32 = 720896;
pub const CERT_FIND_ISSUER_OF: u32 = 786432;
pub const CERT_FIND_EXISTING: u32 = 851968;
pub const CERT_FIND_CERT_ID: u32 = 1048576;
pub const CERT_FIND_CROSS_CERT_DIST_POINTS: u32 = 1114112;
pub const CERT_FIND_PUBKEY_MD5_HASH: u32 = 1179648;
pub const CERT_FIND_SUBJECT_INFO_ACCESS: u32 = 1245184;
pub const CERT_FIND_HASH_STR: u32 = 1310720;
pub const CERT_FIND_HAS_PRIVATE_KEY: u32 = 1376256;
pub const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG: u32 = 1;
pub const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG: u32 = 2;
pub const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG: u32 = 4;
pub const CERT_FIND_NO_ENHKEY_USAGE_FLAG: u32 = 8;
pub const CERT_FIND_OR_ENHKEY_USAGE_FLAG: u32 = 16;
pub const CERT_FIND_VALID_ENHKEY_USAGE_FLAG: u32 = 32;
pub const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG: u32 = 1;
pub const CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG: u32 = 2;
pub const CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG: u32 = 4;
pub const CERT_FIND_NO_CTL_USAGE_FLAG: u32 = 8;
pub const CERT_FIND_OR_CTL_USAGE_FLAG: u32 = 16;
pub const CERT_FIND_VALID_CTL_USAGE_FLAG: u32 = 32;
pub const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG: u32 = 2147483648;
pub const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG: u32 = 1073741824;
pub const CTL_ENTRY_FROM_PROP_CHAIN_FLAG: u32 = 1;
pub const CRL_FIND_ANY: u32 = 0;
pub const CRL_FIND_ISSUED_BY: u32 = 1;
pub const CRL_FIND_EXISTING: u32 = 2;
pub const CRL_FIND_ISSUED_FOR: u32 = 3;
pub const CRL_FIND_ISSUED_BY_AKI_FLAG: u32 = 1;
pub const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG: u32 = 2;
pub const CRL_FIND_ISSUED_BY_DELTA_FLAG: u32 = 4;
pub const CRL_FIND_ISSUED_BY_BASE_FLAG: u32 = 8;
pub const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG: u32 = 16;
pub const CERT_STORE_ADD_NEW: u32 = 1;
pub const CERT_STORE_ADD_USE_EXISTING: u32 = 2;
pub const CERT_STORE_ADD_REPLACE_EXISTING: u32 = 3;
pub const CERT_STORE_ADD_ALWAYS: u32 = 4;
pub const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES: u32 = 5;
pub const CERT_STORE_ADD_NEWER: u32 = 6;
pub const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES: u32 = 7;
pub const CERT_STORE_CERTIFICATE_CONTEXT: u32 = 1;
pub const CERT_STORE_CRL_CONTEXT: u32 = 2;
pub const CERT_STORE_CTL_CONTEXT: u32 = 3;
pub const CERT_STORE_ALL_CONTEXT_FLAG: i32 = -1;
pub const CERT_STORE_CERTIFICATE_CONTEXT_FLAG: u32 = 2;
pub const CERT_STORE_CRL_CONTEXT_FLAG: u32 = 4;
pub const CERT_STORE_CTL_CONTEXT_FLAG: u32 = 8;
pub const CTL_ANY_SUBJECT_TYPE: u32 = 1;
pub const CTL_CERT_SUBJECT_TYPE: u32 = 2;
pub const CTL_FIND_ANY: u32 = 0;
pub const CTL_FIND_SHA1_HASH: u32 = 1;
pub const CTL_FIND_MD5_HASH: u32 = 2;
pub const CTL_FIND_USAGE: u32 = 3;
pub const CTL_FIND_SUBJECT: u32 = 4;
pub const CTL_FIND_EXISTING: u32 = 5;
pub const CTL_FIND_NO_LIST_ID_CBDATA: u32 = 4294967295;
pub const CTL_FIND_SAME_USAGE_FLAG: u32 = 1;
pub const CERT_STORE_CTRL_RESYNC: u32 = 1;
pub const CERT_STORE_CTRL_NOTIFY_CHANGE: u32 = 2;
pub const CERT_STORE_CTRL_COMMIT: u32 = 3;
pub const CERT_STORE_CTRL_AUTO_RESYNC: u32 = 4;
pub const CERT_STORE_CTRL_CANCEL_NOTIFY: u32 = 5;
pub const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG: u32 = 1;
pub const CERT_STORE_CTRL_COMMIT_FORCE_FLAG: u32 = 1;
pub const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG: u32 = 2;
pub const CERT_STORE_LOCALIZED_NAME_PROP_ID: u32 = 4096;
pub const CERT_CREATE_CONTEXT_NOCOPY_FLAG: u32 = 1;
pub const CERT_CREATE_CONTEXT_SORTED_FLAG: u32 = 2;
pub const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG: u32 = 4;
pub const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG: u32 = 8;
pub const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG: u32 = 1;
pub const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG: u32 = 2;
pub const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG: u32 = 4;
pub const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG: u32 = 8;
pub const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG: u32 = 1;
pub const CERT_PHYSICAL_STORE_DEFAULT_NAME: &[u8; 9usize] = b".Default\0";
pub const CERT_PHYSICAL_STORE_GROUP_POLICY_NAME: &[u8; 13usize] = b".GroupPolicy\0";
pub const CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME: &[u8; 14usize] = b".LocalMachine\0";
pub const CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME: &[u8; 17usize] = b".UserCertificate\0";
pub const CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME: &[u8; 25usize] =
    b".LocalMachineGroupPolicy\0";
pub const CERT_PHYSICAL_STORE_ENTERPRISE_NAME: &[u8; 12usize] = b".Enterprise\0";
pub const CERT_PHYSICAL_STORE_AUTH_ROOT_NAME: &[u8; 10usize] = b".AuthRoot\0";
pub const CERT_PHYSICAL_STORE_SMART_CARD_NAME: &[u8; 11usize] = b".SmartCard\0";
pub const CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC: &[u8; 27usize] = b"CertDllOpenSystemStoreProv\0";
pub const CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC: &[u8; 27usize] = b"CertDllRegisterSystemStore\0";
pub const CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC: &[u8; 29usize] =
    b"CertDllUnregisterSystemStore\0";
pub const CRYPT_OID_ENUM_SYSTEM_STORE_FUNC: &[u8; 23usize] = b"CertDllEnumSystemStore\0";
pub const CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC: &[u8; 29usize] =
    b"CertDllRegisterPhysicalStore\0";
pub const CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC: &[u8; 31usize] =
    b"CertDllUnregisterPhysicalStore\0";
pub const CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC: &[u8; 25usize] = b"CertDllEnumPhysicalStore\0";
pub const CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME: &[u8; 20usize] = b"SystemStoreLocation\0";
pub const CMSG_TRUSTED_SIGNER_FLAG: u32 = 1;
pub const CMSG_SIGNER_ONLY_FLAG: u32 = 2;
pub const CMSG_USE_SIGNER_INDEX_FLAG: u32 = 4;
pub const CMSG_CMS_ENCAPSULATED_CTL_FLAG: u32 = 32768;
pub const CMSG_ENCODE_SORTED_CTL_FLAG: u32 = 1;
pub const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG: u32 = 2;
pub const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG: u32 = 1;
pub const CERT_VERIFY_TRUSTED_SIGNERS_FLAG: u32 = 2;
pub const CERT_VERIFY_NO_TIME_CHECK_FLAG: u32 = 4;
pub const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG: u32 = 8;
pub const CERT_VERIFY_UPDATED_CTL_FLAG: u32 = 1;
pub const CERT_CONTEXT_REVOCATION_TYPE: u32 = 1;
pub const CERT_VERIFY_REV_CHAIN_FLAG: u32 = 1;
pub const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION: u32 = 2;
pub const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG: u32 = 4;
pub const CERT_VERIFY_REV_SERVER_OCSP_FLAG: u32 = 8;
pub const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG: u32 = 16;
pub const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG: u32 = 32;
pub const CERT_UNICODE_IS_RDN_ATTRS_FLAG: u32 = 1;
pub const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG: u32 = 2;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB: u32 = 1;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT: u32 = 2;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL: u32 = 3;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE: u32 = 4;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY: u32 = 1;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT: u32 = 2;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN: u32 = 3;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL: u32 = 4;
pub const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG: u32 = 1;
pub const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG: u32 = 2;
pub const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG: u32 = 4;
pub const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG: u32 = 8;
pub const CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC: &[u8; 42usize] =
    b"CryptDllExtractEncodedSignatureParameters\0";
pub const CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC: &[u8; 26usize] = b"CryptDllSignAndEncodeHash\0";
pub const CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC: &[u8; 31usize] =
    b"CryptDllVerifyEncodedSignature\0";
pub const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG: u32 = 1;
pub const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG: u32 = 2;
pub const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID: u32 = 1;
pub const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID: u32 = 2;
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC: &[u8; 30usize] =
    b"CryptDllExportPublicKeyInfoEx\0";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC: &[u8; 31usize] =
    b"CryptDllExportPublicKeyInfoEx2\0";
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC: &[u8; 47usize] =
    b"CryptDllExportPublicKeyInfoFromBCryptKeyHandle\0";
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC: &[u8; 30usize] =
    b"CryptDllImportPublicKeyInfoEx\0";
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC: &[u8; 31usize] =
    b"CryptDllImportPublicKeyInfoEx2\0";
pub const CRYPT_ACQUIRE_CACHE_FLAG: u32 = 1;
pub const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG: u32 = 2;
pub const CRYPT_ACQUIRE_COMPARE_KEY_FLAG: u32 = 4;
pub const CRYPT_ACQUIRE_NO_HEALING: u32 = 8;
pub const CRYPT_ACQUIRE_SILENT_FLAG: u32 = 64;
pub const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG: u32 = 128;
pub const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK: u32 = 458752;
pub const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG: u32 = 65536;
pub const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG: u32 = 131072;
pub const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG: u32 = 262144;
pub const CRYPT_FIND_USER_KEYSET_FLAG: u32 = 1;
pub const CRYPT_FIND_MACHINE_KEYSET_FLAG: u32 = 2;
pub const CRYPT_FIND_SILENT_KEYSET_FLAG: u32 = 64;
pub const CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC: &[u8; 31usize] =
    b"CryptDllImportPrivateKeyInfoEx\0";
pub const CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC: &[u8; 31usize] =
    b"CryptDllExportPrivateKeyInfoEx\0";
pub const CRYPT_DELETE_KEYSET: u32 = 16;
pub const CERT_SIMPLE_NAME_STR: u32 = 1;
pub const CERT_OID_NAME_STR: u32 = 2;
pub const CERT_X500_NAME_STR: u32 = 3;
pub const CERT_XML_NAME_STR: u32 = 4;
pub const CERT_NAME_STR_SEMICOLON_FLAG: u32 = 1073741824;
pub const CERT_NAME_STR_NO_PLUS_FLAG: u32 = 536870912;
pub const CERT_NAME_STR_NO_QUOTING_FLAG: u32 = 268435456;
pub const CERT_NAME_STR_CRLF_FLAG: u32 = 134217728;
pub const CERT_NAME_STR_COMMA_FLAG: u32 = 67108864;
pub const CERT_NAME_STR_REVERSE_FLAG: u32 = 33554432;
pub const CERT_NAME_STR_FORWARD_FLAG: u32 = 16777216;
pub const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG: u32 = 65536;
pub const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG: u32 = 131072;
pub const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG: u32 = 262144;
pub const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG: u32 = 524288;
pub const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG: u32 = 1048576;
pub const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG: u32 = 2097152;
pub const CERT_NAME_EMAIL_TYPE: u32 = 1;
pub const CERT_NAME_RDN_TYPE: u32 = 2;
pub const CERT_NAME_ATTR_TYPE: u32 = 3;
pub const CERT_NAME_SIMPLE_DISPLAY_TYPE: u32 = 4;
pub const CERT_NAME_FRIENDLY_DISPLAY_TYPE: u32 = 5;
pub const CERT_NAME_DNS_TYPE: u32 = 6;
pub const CERT_NAME_URL_TYPE: u32 = 7;
pub const CERT_NAME_UPN_TYPE: u32 = 8;
pub const CERT_NAME_ISSUER_FLAG: u32 = 1;
pub const CERT_NAME_DISABLE_IE4_UTF8_FLAG: u32 = 65536;
pub const CERT_NAME_SEARCH_ALL_NAMES_FLAG: u32 = 2;
pub const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG: u32 = 1;
pub const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG: u32 = 2;
pub const CRYPT_MESSAGE_KEYID_SIGNER_FLAG: u32 = 4;
pub const CRYPT_MESSAGE_SILENT_KEYSET_FLAG: u32 = 64;
pub const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG: u32 = 4;
pub const CERT_QUERY_OBJECT_FILE: u32 = 1;
pub const CERT_QUERY_OBJECT_BLOB: u32 = 2;
pub const CERT_QUERY_CONTENT_CERT: u32 = 1;
pub const CERT_QUERY_CONTENT_CTL: u32 = 2;
pub const CERT_QUERY_CONTENT_CRL: u32 = 3;
pub const CERT_QUERY_CONTENT_SERIALIZED_STORE: u32 = 4;
pub const CERT_QUERY_CONTENT_SERIALIZED_CERT: u32 = 5;
pub const CERT_QUERY_CONTENT_SERIALIZED_CTL: u32 = 6;
pub const CERT_QUERY_CONTENT_SERIALIZED_CRL: u32 = 7;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED: u32 = 8;
pub const CERT_QUERY_CONTENT_PKCS7_UNSIGNED: u32 = 9;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED: u32 = 10;
pub const CERT_QUERY_CONTENT_PKCS10: u32 = 11;
pub const CERT_QUERY_CONTENT_PFX: u32 = 12;
pub const CERT_QUERY_CONTENT_CERT_PAIR: u32 = 13;
pub const CERT_QUERY_CONTENT_PFX_AND_LOAD: u32 = 14;
pub const CERT_QUERY_CONTENT_FLAG_CERT: u32 = 2;
pub const CERT_QUERY_CONTENT_FLAG_CTL: u32 = 4;
pub const CERT_QUERY_CONTENT_FLAG_CRL: u32 = 8;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE: u32 = 16;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT: u32 = 32;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL: u32 = 64;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL: u32 = 128;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED: u32 = 256;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED: u32 = 512;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED: u32 = 1024;
pub const CERT_QUERY_CONTENT_FLAG_PKCS10: u32 = 2048;
pub const CERT_QUERY_CONTENT_FLAG_PFX: u32 = 4096;
pub const CERT_QUERY_CONTENT_FLAG_CERT_PAIR: u32 = 8192;
pub const CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD: u32 = 16384;
pub const CERT_QUERY_CONTENT_FLAG_ALL: u32 = 16382;
pub const CERT_QUERY_CONTENT_FLAG_ALL_ISSUER_CERT: u32 = 818;
pub const CERT_QUERY_FORMAT_BINARY: u32 = 1;
pub const CERT_QUERY_FORMAT_BASE64_ENCODED: u32 = 2;
pub const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED: u32 = 3;
pub const CERT_QUERY_FORMAT_FLAG_BINARY: u32 = 2;
pub const CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED: u32 = 4;
pub const CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED: u32 = 8;
pub const CERT_QUERY_FORMAT_FLAG_ALL: u32 = 14;
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC: &[u8; 31usize] =
    b"SchemeDllRetrieveEncodedObject\0";
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC: &[u8; 32usize] =
    b"SchemeDllRetrieveEncodedObjectW\0";
pub const CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC: &[u8; 30usize] =
    b"ContextDllCreateObjectContext\0";
pub const CRYPT_RETRIEVE_MULTIPLE_OBJECTS: u32 = 1;
pub const CRYPT_CACHE_ONLY_RETRIEVAL: u32 = 2;
pub const CRYPT_WIRE_ONLY_RETRIEVAL: u32 = 4;
pub const CRYPT_DONT_CACHE_RESULT: u32 = 8;
pub const CRYPT_ASYNC_RETRIEVAL: u32 = 16;
pub const CRYPT_STICKY_CACHE_RETRIEVAL: u32 = 4096;
pub const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL: u32 = 8192;
pub const CRYPT_OFFLINE_CHECK_RETRIEVAL: u32 = 16384;
pub const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE: u32 = 32768;
pub const CRYPT_LDAP_SIGN_RETRIEVAL: u32 = 65536;
pub const CRYPT_NO_AUTH_RETRIEVAL: u32 = 131072;
pub const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL: u32 = 262144;
pub const CRYPT_AIA_RETRIEVAL: u32 = 524288;
pub const CRYPT_HTTP_POST_RETRIEVAL: u32 = 1048576;
pub const CRYPT_PROXY_CACHE_RETRIEVAL: u32 = 2097152;
pub const CRYPT_NOT_MODIFIED_RETRIEVAL: u32 = 4194304;
pub const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL: u32 = 8388608;
pub const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL: u32 = 67108864;
pub const CRYPT_ENABLE_FILE_RETRIEVAL: u32 = 134217728;
pub const CRYPT_CREATE_NEW_FLUSH_ENTRY: u32 = 268435456;
pub const CRYPT_VERIFY_CONTEXT_SIGNATURE: u32 = 32;
pub const CRYPT_VERIFY_DATA_HASH: u32 = 64;
pub const CRYPT_KEEP_TIME_VALID: u32 = 128;
pub const CRYPT_DONT_VERIFY_SIGNATURE: u32 = 256;
pub const CRYPT_DONT_CHECK_TIME_VALIDITY: u32 = 512;
pub const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY: u32 = 1024;
pub const CRYPT_ACCUMULATIVE_TIMEOUT: u32 = 2048;
pub const CRYPT_OCSP_ONLY_RETRIEVAL: u32 = 16777216;
pub const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL: u32 = 33554432;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_NONE: u32 = 0;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB: u32 = 1;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_CRL: u32 = 2;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP: u32 = 3;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB: u32 = 5;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB: u32 = 6;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB: u32 = 7;
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH: u32 = 0;
pub const CRYPTNET_URL_CACHE_DISABLE_FLUSH: u32 = 4294967295;
pub const CRYPTNET_URL_CACHE_RESPONSE_NONE: u32 = 0;
pub const CRYPTNET_URL_CACHE_RESPONSE_HTTP: u32 = 1;
pub const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED: u32 = 32768;
pub const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH: u32 = 4096;
pub const CRYPT_GET_URL_FROM_PROPERTY: u32 = 1;
pub const CRYPT_GET_URL_FROM_EXTENSION: u32 = 2;
pub const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE: u32 = 4;
pub const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE: u32 = 8;
pub const URL_OID_GET_OBJECT_URL_FUNC: &[u8; 19usize] = b"UrlDllGetObjectUrl\0";
pub const TIME_VALID_OID_GET_OBJECT_FUNC: &[u8; 22usize] = b"TimeValidDllGetObject\0";
pub const TIME_VALID_OID_FLUSH_OBJECT_FUNC: &[u8; 24usize] = b"TimeValidDllFlushObject\0";
pub const CERT_CREATE_SELFSIGN_NO_SIGN: u32 = 1;
pub const CERT_CREATE_SELFSIGN_NO_KEY_INFO: u32 = 2;
pub const CRYPT_KEYID_MACHINE_FLAG: u32 = 32;
pub const CRYPT_KEYID_ALLOC_FLAG: u32 = 32768;
pub const CRYPT_KEYID_DELETE_FLAG: u32 = 16;
pub const CRYPT_KEYID_SET_NEW_FLAG: u32 = 8192;
pub const CERT_CHAIN_CONFIG_REGPATH : & [u8 ; 94usize] = b"Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\CertDllCreateCertificateChainEngine\\Config\0" ;
pub const CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME: &[u8; 25usize] =
    b"MaxUrlRetrievalByteCount\0";
pub const CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_DEFAULT: u32 = 104857600;
pub const CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME: &[u8; 25usize] =
    b"ChainCacheResyncFiletime\0";
pub const CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME: &[u8; 33usize] =
    b"DisableMandatoryBasicConstraints\0";
pub const CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME: &[u8; 25usize] =
    b"DisableCANameConstraints\0";
pub const CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME: &[u8; 37usize] =
    b"DisableUnsupportedCriticalExtensions\0";
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME: &[u8; 21usize] =
    b"MaxAIAUrlCountInCert\0";
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT: u32 = 5;
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME: &[u8; 32usize] =
    b"MaxAIAUrlRetrievalCountPerChain\0";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT: u32 = 3;
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME: &[u8; 28usize] =
    b"MaxAIAUrlRetrievalByteCount\0";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT: u32 = 100000;
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME: &[u8; 28usize] =
    b"MaxAIAUrlRetrievalCertCount\0";
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT: u32 = 10;
pub const CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME: &[u8; 20usize] = b"OcspValiditySeconds\0";
pub const CERT_CHAIN_OCSP_VALIDITY_SECONDS_DEFAULT: u32 = 43200;
pub const CERT_CHAIN_DISABLE_SERIAL_CHAIN_VALUE_NAME: &[u8; 19usize] = b"DisableSerialChain\0";
pub const CERT_CHAIN_SERIAL_CHAIN_LOG_FILE_NAME_VALUE_NAME: &[u8; 23usize] =
    b"SerialChainLogFileName\0";
pub const CERT_CHAIN_DISABLE_SYNC_WITH_SSL_TIME_VALUE_NAME: &[u8; 23usize] =
    b"DisableSyncWithSslTime\0";
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_VALUE_NAME: &[u8; 28usize] =
    b"MaxSslTimeUpdatedEventCount\0";
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT: u32 = 5;
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE: u32 = 4294967295;
pub const CERT_CHAIN_SSL_HANDSHAKE_LOG_FILE_NAME_VALUE_NAME: &[u8; 24usize] =
    b"SslHandshakeLogFileName\0";
pub const CERT_CHAIN_ENABLE_WEAK_SIGNATURE_FLAGS_VALUE_NAME: &[u8; 25usize] =
    b"EnableWeakSignatureFlags\0";
pub const CERT_CHAIN_ENABLE_MD2_MD4_FLAG: u32 = 1;
pub const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG: u32 = 2;
pub const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG: u32 = 4;
pub const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG: u32 = 8;
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME: &[u8; 22usize] =
    b"MinRsaPubKeyBitLength\0";
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT: u32 = 1023;
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE: u32 = 4294967295;
pub const CERT_CHAIN_WEAK_RSA_PUB_KEY_TIME_VALUE_NAME: &[u8; 18usize] = b"WeakRsaPubKeyTime\0";
pub const CERT_CHAIN_WEAK_SIGNATURE_LOG_DIR_VALUE_NAME: &[u8; 20usize] = b"WeakSignatureLogDir\0";
pub const CERT_CHAIN_DEFAULT_CONFIG_SUBDIR: &[u8; 8usize] = b"Default\0";
pub const CERT_CHAIN_WEAK_PREFIX_NAME: &[u8; 5usize] = b"Weak\0";
pub const CERT_CHAIN_WEAK_THIRD_PARTY_CONFIG_NAME: &[u8; 11usize] = b"ThirdParty\0";
pub const CERT_CHAIN_WEAK_ALL_CONFIG_NAME: &[u8; 4usize] = b"All\0";
pub const CERT_CHAIN_WEAK_FLAGS_NAME: &[u8; 6usize] = b"Flags\0";
pub const CERT_CHAIN_WEAK_HYGIENE_NAME: &[u8; 8usize] = b"Hygiene\0";
pub const CERT_CHAIN_WEAK_AFTER_TIME_NAME: &[u8; 10usize] = b"AfterTime\0";
pub const CERT_CHAIN_WEAK_FILE_HASH_AFTER_TIME_NAME: &[u8; 18usize] = b"FileHashAfterTime\0";
pub const CERT_CHAIN_WEAK_TIMESTAMP_HASH_AFTER_TIME_NAME: &[u8; 23usize] =
    b"TimestampHashAfterTime\0";
pub const CERT_CHAIN_WEAK_MIN_BIT_LENGTH_NAME: &[u8; 13usize] = b"MinBitLength\0";
pub const CERT_CHAIN_WEAK_SHA256_ALLOW_NAME: &[u8; 12usize] = b"Sha256Allow\0";
pub const CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE: u32 = 4294967295;
pub const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG: u32 = 2147483648;
pub const CERT_CHAIN_DISABLE_ECC_PARA_FLAG: u32 = 16;
pub const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG: u32 = 65536;
pub const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG: u32 = 131072;
pub const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG: u32 = 262144;
pub const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG: u32 = 1048576;
pub const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG: u32 = 2097152;
pub const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG: u32 = 4194304;
pub const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG: u32 = 8388608;
pub const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG: u32 = 16777216;
pub const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG: u32 = 33554432;
pub const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG: u32 = 67108864;
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG: u32 = 134217728;
pub const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG: u32 = 268435456;
pub const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG: u32 = 536870912;
pub const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG: u32 = 1073741824;
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG: u32 = 4096;
pub const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG: u32 = 8192;
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG: u32 = 16384;
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG: u32 = 32768;
pub const CERT_CHAIN_DISABLE_WEAK_FLAGS: u32 = 215285776;
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAGS: u32 = 12288;
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAGS: u32 = 49152;
pub const CERT_CHAIN_ENABLE_HYGIENE_FLAGS: u32 = 857866240;
pub const CERT_CHAIN_MOTW_WEAK_FLAGS: u32 = 1786773504;
pub const CERT_CHAIN_OPT_IN_WEAK_FLAGS: u32 = 262144;
pub const CERT_CHAIN_AUTO_CURRENT_USER: u32 = 1;
pub const CERT_CHAIN_AUTO_LOCAL_MACHINE: u32 = 2;
pub const CERT_CHAIN_AUTO_IMPERSONATED: u32 = 3;
pub const CERT_CHAIN_AUTO_PROCESS_INFO: u32 = 4;
pub const CERT_CHAIN_AUTO_PINRULE_INFO: u32 = 5;
pub const CERT_CHAIN_AUTO_NETWORK_INFO: u32 = 6;
pub const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE: u32 = 7;
pub const CERT_CHAIN_AUTO_HPKP_RULE_INFO: u32 = 8;
pub const CERT_CHAIN_AUTO_FLAGS_VALUE_NAME: &[u8; 10usize] = b"AutoFlags\0";
pub const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG: u32 = 1;
pub const CERT_CHAIN_AUTO_LOG_CREATE_FLAG: u32 = 2;
pub const CERT_CHAIN_AUTO_LOG_FREE_FLAG: u32 = 4;
pub const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG: u32 = 8;
pub const CERT_CHAIN_AUTO_LOG_FLAGS: u32 = 14;
pub const CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_VALUE_NAME: &[u8; 27usize] =
    b"AutoFlushFirstDeltaSeconds\0";
pub const CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_DEFAULT: u32 = 300;
pub const CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_VALUE_NAME: &[u8; 26usize] =
    b"AutoFlushNextDeltaSeconds\0";
pub const CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_DEFAULT: u32 = 1800;
pub const CERT_CHAIN_AUTO_LOG_FILE_NAME_VALUE_NAME: &[u8; 16usize] = b"AutoLogFileName\0";
pub const CERT_CHAIN_DISABLE_AUTO_FLUSH_PROCESS_NAME_LIST_VALUE_NAME: &[u8; 32usize] =
    b"DisableAutoFlushProcessNameList\0";
pub const CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME: &[u8; 30usize] =
    b"SrvOcspRespMinValiditySeconds\0";
pub const CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_DEFAULT: u32 = 600;
pub const CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME: &[u8; 43usize] =
    b"SrvOcspRespUrlRetrievalTimeoutMilliseconds\0";
pub const CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT: u32 = 15000;
pub const CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME: &[u8; 38usize] =
    b"SrvOcspRespMaxBeforeNextUpdateSeconds\0";
pub const CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT: u32 = 14400;
pub const CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME: &[u8; 38usize] =
    b"SrvOcspRespMinBeforeNextUpdateSeconds\0";
pub const CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT: u32 = 120;
pub const CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME: &[u8; 37usize] =
    b"SrvOcspRespMinAfterNextUpdateSeconds\0";
pub const CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_DEFAULT: u32 = 60;
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_VALUE_NAME: &[u8; 34usize] =
    b"SrvOcspRespMinSyncCertFileSeconds\0";
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT: u32 = 5;
pub const CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_VALUE_NAME: &[u8; 34usize] =
    b"SrvOcspRespMaxSyncCertFileSeconds\0";
pub const CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_DEFAULT: u32 = 3600;
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME: &[u8; 33usize] =
    b"CryptnetMaxCachedOcspPerCrlCount\0";
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT: u32 = 500;
pub const CRYPTNET_OCSP_AFTER_CRL_DISABLE: u32 = 4294967295;
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME: &[u8; 34usize] =
    b"CryptnetDefaultFlushExemptSeconds\0";
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_DEFAULT: u32 = 2419200;
pub const CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME: &[u8; 33usize] =
    b"CryptnetPreFetchMinMaxAgeSeconds\0";
pub const CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_DEFAULT: u32 = 3600;
pub const CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME: &[u8; 33usize] =
    b"CryptnetPreFetchMaxMaxAgeSeconds\0";
pub const CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_DEFAULT: u32 = 1209600;
pub const CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_VALUE_NAME: &[u8; 45usize] =
    b"CryptnetPreFetchMinOcspValidityPeriodSeconds\0";
pub const CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_DEFAULT: u32 = 1209600;
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME: &[u8; 44usize] =
    b"CryptnetPreFetchAfterPublishPreFetchDivisor\0";
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT: u32 = 10;
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME: &[u8; 48usize] =
    b"CryptnetPreFetchBeforeNextUpdatePreFetchDivisor\0";
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT: u32 = 20;
pub const CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME:
    &[u8; 51usize] = b"CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds\0";
pub const CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_DEFAULT: u32 = 3600;
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME:
    &[u8; 61usize] = b"CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor\0";
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT: u32 = 10;
pub const CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME:
    &[u8; 56usize] = b"CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds\0";
pub const CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_DEFAULT: u32 = 14400;
pub const CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME:
    &[u8; 56usize] = b"CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds\0";
pub const CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_DEFAULT: u32 = 1800;
pub const CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME: &[u8;
     54usize] = b"CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds\0";
pub const CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_DEFAULT: u32 = 1800;
pub const CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME: &[u8; 37usize] =
    b"CryptnetPreFetchTriggerPeriodSeconds\0";
pub const CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_DEFAULT: u32 = 600;
pub const CRYPTNET_PRE_FETCH_TRIGGER_DISABLE: u32 = 4294967295;
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME: &[u8; 45usize] =
    b"CryptnetPreFetchScanAfterTriggerDelaySeconds\0";
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT: u32 = 60;
pub const CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME: &[u8; 40usize] =
    b"CryptnetPreFetchRetrievalTimeoutSeconds\0";
pub const CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_DEFAULT: u32 = 300;
pub const CRYPTNET_CRL_PRE_FETCH_CONFIG_REGPATH : & [u8 ; 106usize] = b"Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\CertDllCreateCertificateChainEngine\\Config\\CrlPreFetch\0" ;
pub const CRYPTNET_CRL_PRE_FETCH_PROCESS_NAME_LIST_VALUE_NAME: &[u8; 16usize] =
    b"ProcessNameList\0";
pub const CRYPTNET_CRL_PRE_FETCH_URL_LIST_VALUE_NAME: &[u8; 16usize] = b"PreFetchUrlList\0";
pub const CRYPTNET_CRL_PRE_FETCH_DISABLE_INFORMATION_EVENTS_VALUE_NAME: &[u8; 25usize] =
    b"DisableInformationEvents\0";
pub const CRYPTNET_CRL_PRE_FETCH_LOG_FILE_NAME_VALUE_NAME: &[u8; 12usize] = b"LogFileName\0";
pub const CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_VALUE_NAME: &[u8; 15usize] = b"TimeoutSeconds\0";
pub const CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_DEFAULT: u32 = 300;
pub const CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_VALUE_NAME: &[u8; 14usize] = b"MaxAgeSeconds\0";
pub const CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_DEFAULT: u32 = 7200;
pub const CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_MIN: u32 = 300;
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME: &[u8; 31usize] =
    b"PublishBeforeNextUpdateSeconds\0";
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT: u32 = 3600;
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_VALUE_NAME: &[u8; 29usize] =
    b"PublishRandomIntervalSeconds\0";
pub const CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_DEFAULT: u32 = 300;
pub const CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME: &[u8; 27usize] =
    b"MinBeforeNextUpdateSeconds\0";
pub const CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT: u32 = 300;
pub const CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME: &[u8; 26usize] =
    b"MinAfterNextUpdateSeconds\0";
pub const CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_DEFAULT: u32 = 300;
pub const CERT_GROUP_POLICY_CHAIN_CONFIG_REGPATH: &[u8; 66usize] =
    b"Software\\Policies\\Microsoft\\SystemCertificates\\ChainEngine\\Config\0";
pub const CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME: &[u8; 37usize] =
    b"ChainUrlRetrievalTimeoutMilliseconds\0";
pub const CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT: u32 = 15000;
pub const CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME: &[u8;
     52usize] = b"ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds\0";
pub const CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT: u32 = 20000;
pub const CERT_RETR_BEHAVIOR_INET_AUTH_VALUE_NAME: &[u8; 22usize] = b"EnableInetUnknownAuth\0";
pub const CERT_RETR_BEHAVIOR_INET_STATUS_VALUE_NAME: &[u8; 16usize] = b"EnableInetLocal\0";
pub const CERT_RETR_BEHAVIOR_FILE_VALUE_NAME: &[u8; 19usize] = b"AllowFileUrlScheme\0";
pub const CERT_RETR_BEHAVIOR_LDAP_VALUE_NAME: &[u8; 26usize] = b"DisableLDAPSignAndEncrypt\0";
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME: &[u8; 35usize] =
    b"CryptnetCachedOcspSwitchToCrlCount\0";
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT: u32 = 50;
pub const CRYPTNET_CRL_BEFORE_OCSP_ENABLE: u32 = 4294967295;
pub const CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME: &[u8; 23usize] =
    b"DisableAIAUrlRetrieval\0";
pub const CERT_CHAIN_OPTIONS_VALUE_NAME: &[u8; 8usize] = b"Options\0";
pub const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL: u32 = 2;
pub const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL: u32 = 4;
pub const CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME: &[u8; 31usize] =
    b"CrossCertDownloadIntervalHours\0";
pub const CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_DEFAULT: u32 = 168;
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME: &[u8; 27usize] =
    b"CRLValidityExtensionPeriod\0";
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT: u32 = 12;
pub const CERT_CHAIN_CACHE_END_CERT: u32 = 1;
pub const CERT_CHAIN_THREAD_STORE_SYNC: u32 = 2;
pub const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL: u32 = 4;
pub const CERT_CHAIN_USE_LOCAL_MACHINE_STORE: u32 = 8;
pub const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE: u32 = 16;
pub const CERT_CHAIN_ENABLE_SHARE_STORE: u32 = 32;
pub const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG: u32 = 1;
pub const CERT_TRUST_NO_ERROR: u32 = 0;
pub const CERT_TRUST_IS_NOT_TIME_VALID: u32 = 1;
pub const CERT_TRUST_IS_NOT_TIME_NESTED: u32 = 2;
pub const CERT_TRUST_IS_REVOKED: u32 = 4;
pub const CERT_TRUST_IS_NOT_SIGNATURE_VALID: u32 = 8;
pub const CERT_TRUST_IS_NOT_VALID_FOR_USAGE: u32 = 16;
pub const CERT_TRUST_IS_UNTRUSTED_ROOT: u32 = 32;
pub const CERT_TRUST_REVOCATION_STATUS_UNKNOWN: u32 = 64;
pub const CERT_TRUST_IS_CYCLIC: u32 = 128;
pub const CERT_TRUST_INVALID_EXTENSION: u32 = 256;
pub const CERT_TRUST_INVALID_POLICY_CONSTRAINTS: u32 = 512;
pub const CERT_TRUST_INVALID_BASIC_CONSTRAINTS: u32 = 1024;
pub const CERT_TRUST_INVALID_NAME_CONSTRAINTS: u32 = 2048;
pub const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT: u32 = 4096;
pub const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT: u32 = 8192;
pub const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT: u32 = 16384;
pub const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT: u32 = 32768;
pub const CERT_TRUST_IS_OFFLINE_REVOCATION: u32 = 16777216;
pub const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY: u32 = 33554432;
pub const CERT_TRUST_IS_EXPLICIT_DISTRUST: u32 = 67108864;
pub const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT: u32 = 134217728;
pub const CERT_TRUST_HAS_WEAK_SIGNATURE: u32 = 1048576;
pub const CERT_TRUST_HAS_WEAK_HYGIENE: u32 = 2097152;
pub const CERT_TRUST_IS_PARTIAL_CHAIN: u32 = 65536;
pub const CERT_TRUST_CTL_IS_NOT_TIME_VALID: u32 = 131072;
pub const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID: u32 = 262144;
pub const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE: u32 = 524288;
pub const CERT_TRUST_HAS_EXACT_MATCH_ISSUER: u32 = 1;
pub const CERT_TRUST_HAS_KEY_MATCH_ISSUER: u32 = 2;
pub const CERT_TRUST_HAS_NAME_MATCH_ISSUER: u32 = 4;
pub const CERT_TRUST_IS_SELF_SIGNED: u32 = 8;
pub const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION: u32 = 16;
pub const CERT_TRUST_AUTO_UPDATE_END_REVOCATION: u32 = 32;
pub const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL: u32 = 64;
pub const CERT_TRUST_IS_KEY_ROLLOVER: u32 = 128;
pub const CERT_TRUST_SSL_HANDSHAKE_OCSP: u32 = 262144;
pub const CERT_TRUST_SSL_TIME_VALID_OCSP: u32 = 524288;
pub const CERT_TRUST_SSL_RECONNECT_OCSP: u32 = 1048576;
pub const CERT_TRUST_HAS_PREFERRED_ISSUER: u32 = 256;
pub const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY: u32 = 512;
pub const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS: u32 = 1024;
pub const CERT_TRUST_IS_PEER_TRUSTED: u32 = 2048;
pub const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED: u32 = 4096;
pub const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE: u32 = 8192;
pub const CERT_TRUST_IS_CA_TRUSTED: u32 = 16384;
pub const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE: u32 = 32768;
pub const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE: u32 = 131072;
pub const CERT_TRUST_BEFORE_DISALLOWED_CA_FILETIME: u32 = 2097152;
pub const CERT_TRUST_IS_COMPLEX_CHAIN: u32 = 65536;
pub const CERT_TRUST_SSL_TIME_VALID: u32 = 16777216;
pub const CERT_TRUST_NO_TIME_CHECK: u32 = 33554432;
pub const USAGE_MATCH_TYPE_AND: u32 = 0;
pub const USAGE_MATCH_TYPE_OR: u32 = 1;
pub const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG: u32 = 1;
pub const CERT_CHAIN_REVOCATION_CHECK_END_CERT: u32 = 268435456;
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN: u32 = 536870912;
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT: u32 = 1073741824;
pub const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY: u32 = 2147483648;
pub const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT: u32 = 134217728;
pub const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT: u32 = 67108864;
pub const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING: u32 = 64;
pub const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS: u32 = 128;
pub const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE: u32 = 256;
pub const CERT_CHAIN_TIMESTAMP_TIME: u32 = 512;
pub const CERT_CHAIN_ENABLE_PEER_TRUST: u32 = 1024;
pub const CERT_CHAIN_DISABLE_MY_PEER_TRUST: u32 = 2048;
pub const CERT_CHAIN_DISABLE_MD2_MD4: u32 = 4096;
pub const CERT_CHAIN_DISABLE_AIA: u32 = 8192;
pub const CERT_CHAIN_HAS_MOTW: u32 = 16384;
pub const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT: u32 = 32768;
pub const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE: u32 = 65536;
pub const CERT_CHAIN_ENABLE_DISALLOWED_CA: u32 = 131072;
pub const CERT_CHAIN_FIND_BY_ISSUER: u32 = 1;
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG: u32 = 1;
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG: u32 = 2;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG: u32 = 4;
pub const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG: u32 = 8;
pub const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG: u32 = 16384;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG: u32 = 32768;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG: u32 = 1;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG: u32 = 2;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG: u32 = 4;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG: u32 = 8;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS: u32 = 7;
pub const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG: u32 = 16;
pub const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG: u32 = 32;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG: u32 = 64;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG: u32 = 128;
pub const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG: u32 = 256;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG: u32 = 512;
pub const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG: u32 = 1024;
pub const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG: u32 = 2048;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS: u32 = 3840;
pub const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG: u32 = 32768;
pub const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG: u32 = 16384;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG: u32 = 8192;
pub const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG: u32 = 4096;
pub const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG: u32 = 134217728;
pub const CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC: &[u8; 36usize] =
    b"CertDllVerifyCertificateChainPolicy\0";
pub const AUTHTYPE_CLIENT: u32 = 1;
pub const AUTHTYPE_SERVER: u32 = 2;
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG: u32 = 2147483648;
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG: u32 = 1073741824;
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG: u32 = 65536;
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG: u32 = 131072;
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG: u32 = 262144;
pub const SSL_F12_ERROR_TEXT_LENGTH: u32 = 256;
pub const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL: u32 = 0;
pub const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL: u32 = 1;
pub const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL: u32 = 2;
pub const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY: u32 = 0;
pub const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY: u32 = 1;
pub const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY: u32 = 2;
pub const SSL_HPKP_PKP_HEADER_INDEX: u32 = 0;
pub const SSL_HPKP_PKP_RO_HEADER_INDEX: u32 = 1;
pub const SSL_HPKP_HEADER_COUNT: u32 = 2;
pub const SSL_KEY_PIN_ERROR_TEXT_LENGTH: u32 = 512;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR: i32 = -2;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR: i32 = -1;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS: u32 = 0;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING: u32 = 1;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING: u32 = 2;
pub const CRYPT_STRING_BASE64HEADER: u32 = 0;
pub const CRYPT_STRING_BASE64: u32 = 1;
pub const CRYPT_STRING_BINARY: u32 = 2;
pub const CRYPT_STRING_BASE64REQUESTHEADER: u32 = 3;
pub const CRYPT_STRING_HEX: u32 = 4;
pub const CRYPT_STRING_HEXASCII: u32 = 5;
pub const CRYPT_STRING_BASE64_ANY: u32 = 6;
pub const CRYPT_STRING_ANY: u32 = 7;
pub const CRYPT_STRING_HEX_ANY: u32 = 8;
pub const CRYPT_STRING_BASE64X509CRLHEADER: u32 = 9;
pub const CRYPT_STRING_HEXADDR: u32 = 10;
pub const CRYPT_STRING_HEXASCIIADDR: u32 = 11;
pub const CRYPT_STRING_HEXRAW: u32 = 12;
pub const CRYPT_STRING_BASE64URI: u32 = 13;
pub const CRYPT_STRING_ENCODEMASK: u32 = 255;
pub const CRYPT_STRING_RESERVED100: u32 = 256;
pub const CRYPT_STRING_RESERVED200: u32 = 512;
pub const CRYPT_STRING_PERCENTESCAPE: u32 = 134217728;
pub const CRYPT_STRING_HASHDATA: u32 = 268435456;
pub const CRYPT_STRING_STRICT: u32 = 536870912;
pub const CRYPT_STRING_NOCRLF: u32 = 1073741824;
pub const CRYPT_STRING_NOCR: u32 = 2147483648;
pub const szOID_PKCS_12_PbeIds: &[u8; 22usize] = b"1.2.840.113549.1.12.1\0";
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC4: &[u8; 24usize] = b"1.2.840.113549.1.12.1.1\0";
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC4: &[u8; 24usize] = b"1.2.840.113549.1.12.1.2\0";
pub const szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES: &[u8; 24usize] = b"1.2.840.113549.1.12.1.3\0";
pub const szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES: &[u8; 24usize] = b"1.2.840.113549.1.12.1.4\0";
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC2: &[u8; 24usize] = b"1.2.840.113549.1.12.1.5\0";
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC2: &[u8; 24usize] = b"1.2.840.113549.1.12.1.6\0";
pub const szOID_PKCS_5_PBKDF2: &[u8; 22usize] = b"1.2.840.113549.1.5.12\0";
pub const szOID_PKCS_5_PBES2: &[u8; 22usize] = b"1.2.840.113549.1.5.13\0";
pub const PKCS12_IMPORT_SILENT: u32 = 64;
pub const CRYPT_USER_KEYSET: u32 = 4096;
pub const PKCS12_PREFER_CNG_KSP: u32 = 256;
pub const PKCS12_ALWAYS_CNG_KSP: u32 = 512;
pub const PKCS12_ONLY_CERTIFICATES: u32 = 1024;
pub const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES: u32 = 2048;
pub const PKCS12_ALLOW_OVERWRITE_KEY: u32 = 16384;
pub const PKCS12_NO_PERSIST_KEY: u32 = 32768;
pub const PKCS12_VIRTUAL_ISOLATION_KEY: u32 = 65536;
pub const PKCS12_IMPORT_RESERVED_MASK: u32 = 4294901760;
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE: u32 = 0;
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_NAME: &[u8; 12usize] = b"PfxProvider\0";
pub const PKCS12_ONLY_CERTIFICATES_CONTAINER_NAME: &[u8; 13usize] = b"PfxContainer\0";
pub const REPORT_NO_PRIVATE_KEY: u32 = 1;
pub const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY: u32 = 2;
pub const EXPORT_PRIVATE_KEYS: u32 = 4;
pub const PKCS12_INCLUDE_EXTENDED_PROPERTIES: u32 = 16;
pub const PKCS12_PROTECT_TO_DOMAIN_SIDS: u32 = 32;
pub const PKCS12_EXPORT_SILENT: u32 = 64;
pub const PKCS12_EXPORT_PBES2_PARAMS: u32 = 128;
pub const PKCS12_DISABLE_ENCRYPT_CERTIFICATES: u32 = 256;
pub const PKCS12_ENCRYPT_CERTIFICATES: u32 = 512;
pub const PKCS12_EXPORT_ECC_CURVE_PARAMETERS: u32 = 4096;
pub const PKCS12_EXPORT_ECC_CURVE_OID: u32 = 8192;
pub const PKCS12_EXPORT_RESERVED_MASK: u32 = 4294901760;
pub const PKCS12_PBKDF2_ID_HMAC_SHA1: &[u8; 19usize] = b"1.2.840.113549.2.7\0";
pub const PKCS12_PBKDF2_ID_HMAC_SHA256: &[u8; 19usize] = b"1.2.840.113549.2.9\0";
pub const PKCS12_PBKDF2_ID_HMAC_SHA384: &[u8; 20usize] = b"1.2.840.113549.2.10\0";
pub const PKCS12_PBKDF2_ID_HMAC_SHA512: &[u8; 20usize] = b"1.2.840.113549.2.11\0";
pub const PKCS12_PBES2_ALG_AES256_SHA256: &[u8; 14usize] = b"AES256-SHA256\0";
pub const PKCS12_CONFIG_REGPATH: &[u8; 46usize] =
    b"Software\\Microsoft\\Windows\\CurrentVersion\\PFX\0";
pub const PKCS12_ENCRYPT_CERTIFICATES_VALUE_NAME: &[u8; 20usize] = b"EncryptCertificates\0";
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG: u32 = 1;
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG: u32 = 2;
pub const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG: u32 = 1;
pub const CERT_SELECT_MAX_PARA: u32 = 500;
pub const CERT_SELECT_BY_ENHKEY_USAGE: u32 = 1;
pub const CERT_SELECT_BY_KEY_USAGE: u32 = 2;
pub const CERT_SELECT_BY_POLICY_OID: u32 = 3;
pub const CERT_SELECT_BY_PROV_NAME: u32 = 4;
pub const CERT_SELECT_BY_EXTENSION: u32 = 5;
pub const CERT_SELECT_BY_SUBJECT_HOST_NAME: u32 = 6;
pub const CERT_SELECT_BY_ISSUER_ATTR: u32 = 7;
pub const CERT_SELECT_BY_SUBJECT_ATTR: u32 = 8;
pub const CERT_SELECT_BY_ISSUER_NAME: u32 = 9;
pub const CERT_SELECT_BY_PUBLIC_KEY: u32 = 10;
pub const CERT_SELECT_BY_TLS_SIGNATURES: u32 = 11;
pub const CERT_SELECT_BY_ISSUER_DISPLAYNAME: u32 = 12;
pub const CERT_SELECT_BY_FRIENDLYNAME: u32 = 13;
pub const CERT_SELECT_BY_THUMBPRINT: u32 = 14;
pub const CERT_SELECT_LAST: u32 = 11;
pub const CERT_SELECT_MAX: u32 = 33;
pub const CERT_SELECT_ALLOW_EXPIRED: u32 = 1;
pub const CERT_SELECT_TRUSTED_ROOT: u32 = 2;
pub const CERT_SELECT_DISALLOW_SELFSIGNED: u32 = 4;
pub const CERT_SELECT_HAS_PRIVATE_KEY: u32 = 8;
pub const CERT_SELECT_HAS_KEY_FOR_SIGNATURE: u32 = 16;
pub const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE: u32 = 32;
pub const CERT_SELECT_HARDWARE_ONLY: u32 = 64;
pub const CERT_SELECT_ALLOW_DUPLICATES: u32 = 128;
pub const CERT_SELECT_IGNORE_AUTOSELECT: u32 = 256;
pub const TIMESTAMP_VERSION: u32 = 1;
pub const TIMESTAMP_STATUS_GRANTED: u32 = 0;
pub const TIMESTAMP_STATUS_GRANTED_WITH_MODS: u32 = 1;
pub const TIMESTAMP_STATUS_REJECTED: u32 = 2;
pub const TIMESTAMP_STATUS_WAITING: u32 = 3;
pub const TIMESTAMP_STATUS_REVOCATION_WARNING: u32 = 4;
pub const TIMESTAMP_STATUS_REVOKED: u32 = 5;
pub const TIMESTAMP_FAILURE_BAD_ALG: u32 = 0;
pub const TIMESTAMP_FAILURE_BAD_REQUEST: u32 = 2;
pub const TIMESTAMP_FAILURE_BAD_FORMAT: u32 = 5;
pub const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE: u32 = 14;
pub const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED: u32 = 15;
pub const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED: u32 = 16;
pub const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE: u32 = 17;
pub const TIMESTAMP_FAILURE_SYSTEM_FAILURE: u32 = 25;
pub const TIMESTAMP_DONT_HASH_DATA: u32 = 1;
pub const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE: u32 = 32;
pub const TIMESTAMP_NO_AUTH_RETRIEVAL: u32 = 131072;
pub const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE: u32 = 1;
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE: u32 = 32;
pub const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE: u32 = 33;
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE: u32 = 65535;
pub const SSL_OBJECT_LOCATOR_PFX_FUNC: &[u8; 30usize] = b"SslObjectLocatorInitializePfx\0";
pub const SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC: &[u8; 37usize] =
    b"SslObjectLocatorInitializeIssuerList\0";
pub const SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC: &[u8; 47usize] =
    b"SslObjectLocatorInitializeCertValidationConfig\0";
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN: u32 = 1;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP: u32 = 2;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT: u32 = 3;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD: u32 = 4;
pub const CERT_FILE_HASH_USE_TYPE: u32 = 1;
pub const CERT_TIMESTAMP_HASH_USE_TYPE: u32 = 2;
pub const szFORCE_KEY_PROTECTION: &[u8; 19usize] = b"ForceKeyProtection\0";
pub const dwFORCE_KEY_PROTECTION_DISABLED: u32 = 0;
pub const dwFORCE_KEY_PROTECTION_USER_SELECT: u32 = 1;
pub const dwFORCE_KEY_PROTECTION_HIGH: u32 = 2;
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT: u32 = 1;
pub const CRYPTPROTECT_PROMPT_ON_PROTECT: u32 = 2;
pub const CRYPTPROTECT_PROMPT_RESERVED: u32 = 4;
pub const CRYPTPROTECT_PROMPT_STRONG: u32 = 8;
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG: u32 = 16;
pub const CRYPTPROTECT_UI_FORBIDDEN: u32 = 1;
pub const CRYPTPROTECT_LOCAL_MACHINE: u32 = 4;
pub const CRYPTPROTECT_CRED_SYNC: u32 = 8;
pub const CRYPTPROTECT_AUDIT: u32 = 16;
pub const CRYPTPROTECT_NO_RECOVERY: u32 = 32;
pub const CRYPTPROTECT_VERIFY_PROTECTION: u32 = 64;
pub const CRYPTPROTECT_CRED_REGENERATE: u32 = 128;
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL: u32 = 268435455;
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL: u32 = 4294967295;
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE: u32 = 16;
pub const CRYPTPROTECTMEMORY_SAME_PROCESS: u32 = 0;
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS: u32 = 1;
pub const CRYPTPROTECTMEMORY_SAME_LOGON: u32 = 2;
pub const WINEFS_SETUSERKEY_SET_CAPABILITIES: u32 = 1;
pub const EFS_COMPATIBILITY_VERSION_NCRYPT_PROTECTOR: u32 = 5;
pub const EFS_COMPATIBILITY_VERSION_PFILE_PROTECTOR: u32 = 6;
pub const EFS_SUBVER_UNKNOWN: u32 = 0;
pub const EFS_EFS_SUBVER_EFS_CERT: u32 = 1;
pub const EFS_PFILE_SUBVER_RMS: u32 = 2;
pub const EFS_PFILE_SUBVER_APPX: u32 = 3;
pub const MAX_SID_SIZE: u32 = 256;
pub const EFS_METADATA_ADD_USER: u32 = 1;
pub const EFS_METADATA_REMOVE_USER: u32 = 2;
pub const EFS_METADATA_REPLACE_USER: u32 = 4;
pub const EFS_METADATA_GENERAL_OP: u32 = 8;
pub const __REQUIRED_RPCNDR_H_VERSION__: u32 = 501;
pub const __REQUIRED_RPCSAL_H_VERSION__: u32 = 100;
pub const __RPCNDR_H_VERSION__: u32 = 501;
pub const __RPCSAL_H_VERSION__: u32 = 100;
pub const TARGET_IS_NT1012_OR_LATER: u32 = 1;
pub const TARGET_IS_NT102_OR_LATER: u32 = 1;
pub const TARGET_IS_NT100_OR_LATER: u32 = 1;
pub const TARGET_IS_NT63_OR_LATER: u32 = 1;
pub const TARGET_IS_NT62_OR_LATER: u32 = 1;
pub const TARGET_IS_NT61_OR_LATER: u32 = 1;
pub const TARGET_IS_NT60_OR_LATER: u32 = 1;
pub const TARGET_IS_NT51_OR_LATER: u32 = 1;
pub const TARGET_IS_NT50_OR_LATER: u32 = 1;
pub const TARGET_IS_NT40_OR_LATER: u32 = 1;
pub const TARGET_IS_NT351_OR_WIN95_OR_LATER: u32 = 1;
pub const cbNDRContext: u32 = 20;
pub const USER_CALL_IS_ASYNC: u32 = 256;
pub const USER_CALL_NEW_CORRELATION_DESC: u32 = 512;
pub const USER_MARSHAL_FC_BYTE: u32 = 1;
pub const USER_MARSHAL_FC_CHAR: u32 = 2;
pub const USER_MARSHAL_FC_SMALL: u32 = 3;
pub const USER_MARSHAL_FC_USMALL: u32 = 4;
pub const USER_MARSHAL_FC_WCHAR: u32 = 5;
pub const USER_MARSHAL_FC_SHORT: u32 = 6;
pub const USER_MARSHAL_FC_USHORT: u32 = 7;
pub const USER_MARSHAL_FC_LONG: u32 = 8;
pub const USER_MARSHAL_FC_ULONG: u32 = 9;
pub const USER_MARSHAL_FC_FLOAT: u32 = 10;
pub const USER_MARSHAL_FC_HYPER: u32 = 11;
pub const USER_MARSHAL_FC_DOUBLE: u32 = 12;
pub const ROTREGFLAGS_ALLOWANYCLIENT: u32 = 1;
pub const APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP: u32 = 1;
pub const APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND: u32 = 2;
pub const APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY: u32 = 4;
pub const APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN: u32 = 8;
pub const APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION: u32 = 16;
pub const APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY: u32 = 32;
pub const APPIDREGFLAGS_RESERVED1: u32 = 64;
pub const APPIDREGFLAGS_RESERVED2: u32 = 128;
pub const APPIDREGFLAGS_RESERVED3: u32 = 256;
pub const APPIDREGFLAGS_RESERVED4: u32 = 512;
pub const APPIDREGFLAGS_RESERVED5: u32 = 1024;
pub const APPIDREGFLAGS_AAA_NO_IMPLICIT_ACTIVATE_AS_IU: u32 = 2048;
pub const APPIDREGFLAGS_RESERVED7: u32 = 4096;
pub const APPIDREGFLAGS_RESERVED8: u32 = 8192;
pub const APPIDREGFLAGS_RESERVED9: u32 = 16384;
pub const DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES: u32 = 1;
pub const DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL: u32 = 2;
pub const DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES: u32 = 4;
pub const DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL: u32 = 8;
pub const DCOMSCM_PING_USE_MID_AUTHNSERVICE: u32 = 16;
pub const DCOMSCM_PING_DISALLOW_UNSECURE_CALL: u32 = 32;
pub const ROTFLAGS_REGISTRATIONKEEPSALIVE: u32 = 1;
pub const ROTFLAGS_ALLOWANYCLIENT: u32 = 2;
pub const ROT_COMPARE_MAX: u32 = 2048;
pub const WDT_INPROC_CALL: u32 = 1215587415;
pub const WDT_REMOTE_CALL: u32 = 1383359575;
pub const WDT_INPROC64_CALL: u32 = 1349805143;
pub const FILE_DEVICE_BEEP: u32 = 1;
pub const FILE_DEVICE_CD_ROM: u32 = 2;
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: u32 = 3;
pub const FILE_DEVICE_CONTROLLER: u32 = 4;
pub const FILE_DEVICE_DATALINK: u32 = 5;
pub const FILE_DEVICE_DFS: u32 = 6;
pub const FILE_DEVICE_DISK: u32 = 7;
pub const FILE_DEVICE_DISK_FILE_SYSTEM: u32 = 8;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9;
pub const FILE_DEVICE_INPORT_PORT: u32 = 10;
pub const FILE_DEVICE_KEYBOARD: u32 = 11;
pub const FILE_DEVICE_MAILSLOT: u32 = 12;
pub const FILE_DEVICE_MIDI_IN: u32 = 13;
pub const FILE_DEVICE_MIDI_OUT: u32 = 14;
pub const FILE_DEVICE_MOUSE: u32 = 15;
pub const FILE_DEVICE_MULTI_UNC_PROVIDER: u32 = 16;
pub const FILE_DEVICE_NAMED_PIPE: u32 = 17;
pub const FILE_DEVICE_NETWORK: u32 = 18;
pub const FILE_DEVICE_NETWORK_BROWSER: u32 = 19;
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: u32 = 20;
pub const FILE_DEVICE_NULL: u32 = 21;
pub const FILE_DEVICE_PARALLEL_PORT: u32 = 22;
pub const FILE_DEVICE_PHYSICAL_NETCARD: u32 = 23;
pub const FILE_DEVICE_PRINTER: u32 = 24;
pub const FILE_DEVICE_SCANNER: u32 = 25;
pub const FILE_DEVICE_SERIAL_MOUSE_PORT: u32 = 26;
pub const FILE_DEVICE_SERIAL_PORT: u32 = 27;
pub const FILE_DEVICE_SCREEN: u32 = 28;
pub const FILE_DEVICE_SOUND: u32 = 29;
pub const FILE_DEVICE_STREAMS: u32 = 30;
pub const FILE_DEVICE_TAPE: u32 = 31;
pub const FILE_DEVICE_TAPE_FILE_SYSTEM: u32 = 32;
pub const FILE_DEVICE_TRANSPORT: u32 = 33;
pub const FILE_DEVICE_UNKNOWN: u32 = 34;
pub const FILE_DEVICE_VIDEO: u32 = 35;
pub const FILE_DEVICE_VIRTUAL_DISK: u32 = 36;
pub const FILE_DEVICE_WAVE_IN: u32 = 37;
pub const FILE_DEVICE_WAVE_OUT: u32 = 38;
pub const FILE_DEVICE_8042_PORT: u32 = 39;
pub const FILE_DEVICE_NETWORK_REDIRECTOR: u32 = 40;
pub const FILE_DEVICE_BATTERY: u32 = 41;
pub const FILE_DEVICE_BUS_EXTENDER: u32 = 42;
pub const FILE_DEVICE_MODEM: u32 = 43;
pub const FILE_DEVICE_VDM: u32 = 44;
pub const FILE_DEVICE_MASS_STORAGE: u32 = 45;
pub const FILE_DEVICE_SMB: u32 = 46;
pub const FILE_DEVICE_KS: u32 = 47;
pub const FILE_DEVICE_CHANGER: u32 = 48;
pub const FILE_DEVICE_SMARTCARD: u32 = 49;
pub const FILE_DEVICE_ACPI: u32 = 50;
pub const FILE_DEVICE_DVD: u32 = 51;
pub const FILE_DEVICE_FULLSCREEN_VIDEO: u32 = 52;
pub const FILE_DEVICE_DFS_FILE_SYSTEM: u32 = 53;
pub const FILE_DEVICE_DFS_VOLUME: u32 = 54;
pub const FILE_DEVICE_SERENUM: u32 = 55;
pub const FILE_DEVICE_TERMSRV: u32 = 56;
pub const FILE_DEVICE_KSEC: u32 = 57;
pub const FILE_DEVICE_FIPS: u32 = 58;
pub const FILE_DEVICE_INFINIBAND: u32 = 59;
pub const FILE_DEVICE_VMBUS: u32 = 62;
pub const FILE_DEVICE_CRYPT_PROVIDER: u32 = 63;
pub const FILE_DEVICE_WPD: u32 = 64;
pub const FILE_DEVICE_BLUETOOTH: u32 = 65;
pub const FILE_DEVICE_MT_COMPOSITE: u32 = 66;
pub const FILE_DEVICE_MT_TRANSPORT: u32 = 67;
pub const FILE_DEVICE_BIOMETRIC: u32 = 68;
pub const FILE_DEVICE_PMI: u32 = 69;
pub const FILE_DEVICE_EHSTOR: u32 = 70;
pub const FILE_DEVICE_DEVAPI: u32 = 71;
pub const FILE_DEVICE_GPIO: u32 = 72;
pub const FILE_DEVICE_USBEX: u32 = 73;
pub const FILE_DEVICE_CONSOLE: u32 = 80;
pub const FILE_DEVICE_NFP: u32 = 81;
pub const FILE_DEVICE_SYSENV: u32 = 82;
pub const FILE_DEVICE_VIRTUAL_BLOCK: u32 = 83;
pub const FILE_DEVICE_POINT_OF_SERVICE: u32 = 84;
pub const FILE_DEVICE_STORAGE_REPLICATION: u32 = 85;
pub const FILE_DEVICE_TRUST_ENV: u32 = 86;
pub const FILE_DEVICE_UCM: u32 = 87;
pub const FILE_DEVICE_UCMTCPCI: u32 = 88;
pub const FILE_DEVICE_PERSISTENT_MEMORY: u32 = 89;
pub const FILE_DEVICE_NVDIMM: u32 = 90;
pub const FILE_DEVICE_HOLOGRAPHIC: u32 = 91;
pub const FILE_DEVICE_SDFXHCI: u32 = 92;
pub const FILE_DEVICE_UCMUCSI: u32 = 93;
pub const FILE_DEVICE_PRM: u32 = 94;
pub const FILE_DEVICE_EVENT_COLLECTOR: u32 = 95;
pub const FILE_DEVICE_USB4: u32 = 96;
pub const FILE_DEVICE_SOUNDWIRE: u32 = 97;
pub const METHOD_BUFFERED: u32 = 0;
pub const METHOD_IN_DIRECT: u32 = 1;
pub const METHOD_OUT_DIRECT: u32 = 2;
pub const METHOD_NEITHER: u32 = 3;
pub const METHOD_DIRECT_TO_HARDWARE: u32 = 1;
pub const METHOD_DIRECT_FROM_HARDWARE: u32 = 2;
pub const FILE_ANY_ACCESS: u32 = 0;
pub const FILE_SPECIAL_ACCESS: u32 = 0;
pub const FILE_READ_ACCESS: u32 = 1;
pub const FILE_WRITE_ACCESS: u32 = 2;
pub const IOCTL_STORAGE_BASE: u32 = 45;
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_CONFLICT: u32 = 1;
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_NOHWID: u32 = 2;
pub const STORAGE_DEVICE_FLAGS_PAGE_83_DEVICEGUID: u32 = 4;
pub const RECOVERED_WRITES_VALID: u32 = 1;
pub const UNRECOVERED_WRITES_VALID: u32 = 2;
pub const RECOVERED_READS_VALID: u32 = 4;
pub const UNRECOVERED_READS_VALID: u32 = 8;
pub const WRITE_COMPRESSION_INFO_VALID: u32 = 16;
pub const READ_COMPRESSION_INFO_VALID: u32 = 32;
pub const TAPE_RETURN_STATISTICS: u32 = 0;
pub const TAPE_RETURN_ENV_INFO: u32 = 1;
pub const TAPE_RESET_STATISTICS: u32 = 2;
pub const MEDIA_ERASEABLE: u32 = 1;
pub const MEDIA_WRITE_ONCE: u32 = 2;
pub const MEDIA_READ_ONLY: u32 = 4;
pub const MEDIA_READ_WRITE: u32 = 8;
pub const MEDIA_WRITE_PROTECTED: u32 = 256;
pub const MEDIA_CURRENTLY_MOUNTED: u32 = 2147483648;
pub const STORAGE_FAILURE_PREDICTION_CONFIG_V1: u32 = 1;
pub const SRB_TYPE_SCSI_REQUEST_BLOCK: u32 = 0;
pub const SRB_TYPE_STORAGE_REQUEST_BLOCK: u32 = 1;
pub const STORAGE_ADDRESS_TYPE_BTL8: u32 = 0;
pub const STORAGE_RPMB_DESCRIPTOR_VERSION_1: u32 = 1;
pub const STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE: u32 = 512;
pub const STORAGE_CRYPTO_CAPABILITY_VERSION_1: u32 = 1;
pub const STORAGE_CRYPTO_DESCRIPTOR_VERSION_1: u32 = 1;
pub const STORAGE_TIER_NAME_LENGTH: u32 = 256;
pub const STORAGE_TIER_DESCRIPTION_LENGTH: u32 = 512;
pub const STORAGE_TIER_FLAG_NO_SEEK_PENALTY: u32 = 131072;
pub const STORAGE_TIER_FLAG_WRITE_BACK_CACHE: u32 = 2097152;
pub const STORAGE_TIER_FLAG_READ_CACHE: u32 = 4194304;
pub const STORAGE_TIER_FLAG_PARITY: u32 = 8388608;
pub const STORAGE_TIER_FLAG_SMR: u32 = 16777216;
pub const STORAGE_TEMPERATURE_VALUE_NOT_REPORTED: u32 = 32768;
pub const STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST: u32 = 1;
pub const STORAGE_COMPONENT_ROLE_CACHE: u32 = 1;
pub const STORAGE_COMPONENT_ROLE_TIERING: u32 = 2;
pub const STORAGE_COMPONENT_ROLE_DATA: u32 = 4;
pub const STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO: u32 = 1;
pub const STORAGE_ATTRIBUTE_BLOCK_IO: u32 = 2;
pub const STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE: u32 = 4;
pub const STORAGE_ATTRIBUTE_VOLATILE: u32 = 8;
pub const STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION: u32 = 16;
pub const STORAGE_ATTRIBUTE_PERF_SIZE_INDEPENDENT: u32 = 32;
pub const STORAGE_DEVICE_MAX_OPERATIONAL_STATUS: u32 = 16;
pub const STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH: u32 = 128;
pub const STORAGE_DEVICE_NUMA_NODE_UNKNOWN: u32 = 4294967295;
pub const DeviceDsmActionFlag_NonDestructive: u32 = 2147483648;
pub const DeviceDsmAction_None: u32 = 0;
pub const DeviceDsmAction_Trim: u32 = 1;
pub const DeviceDsmAction_Notification: u32 = 2147483650;
pub const DeviceDsmAction_OffloadRead: u32 = 2147483651;
pub const DeviceDsmAction_OffloadWrite: u32 = 4;
pub const DeviceDsmAction_Allocation: u32 = 2147483653;
pub const DeviceDsmAction_Repair: u32 = 2147483654;
pub const DeviceDsmAction_Scrub: u32 = 2147483655;
pub const DeviceDsmAction_DrtQuery: u32 = 2147483656;
pub const DeviceDsmAction_DrtClear: u32 = 2147483657;
pub const DeviceDsmAction_DrtDisable: u32 = 2147483658;
pub const DeviceDsmAction_TieringQuery: u32 = 2147483659;
pub const DeviceDsmAction_Map: u32 = 2147483660;
pub const DeviceDsmAction_RegenerateParity: u32 = 2147483661;
pub const DeviceDsmAction_NvCache_Change_Priority: u32 = 2147483662;
pub const DeviceDsmAction_NvCache_Evict: u32 = 2147483663;
pub const DeviceDsmAction_TopologyIdQuery: u32 = 2147483664;
pub const DeviceDsmAction_GetPhysicalAddresses: u32 = 2147483665;
pub const DeviceDsmAction_ScopeRegen: u32 = 2147483666;
pub const DeviceDsmAction_ReportZones: u32 = 2147483667;
pub const DeviceDsmAction_OpenZone: u32 = 2147483668;
pub const DeviceDsmAction_FinishZone: u32 = 2147483669;
pub const DeviceDsmAction_CloseZone: u32 = 2147483670;
pub const DeviceDsmAction_ResetWritePointer: u32 = 23;
pub const DeviceDsmAction_GetRangeErrorInfo: u32 = 2147483672;
pub const DeviceDsmAction_WriteZeroes: u32 = 25;
pub const DeviceDsmAction_LostQuery: u32 = 2147483674;
pub const DeviceDsmAction_GetFreeSpace: u32 = 2147483675;
pub const DeviceDsmAction_ConversionQuery: u32 = 2147483676;
pub const DeviceDsmAction_VdtSet: u32 = 29;
pub const DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE: u32 = 1;
pub const DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED: u32 = 2147483648;
pub const DEVICE_DSM_FLAG_TRIM_BYPASS_RZAT: u32 = 1073741824;
pub const DEVICE_DSM_NOTIFY_FLAG_BEGIN: u32 = 1;
pub const DEVICE_DSM_NOTIFY_FLAG_END: u32 = 2;
pub const STORAGE_OFFLOAD_MAX_TOKEN_LENGTH: u32 = 512;
pub const STORAGE_OFFLOAD_TOKEN_ID_LENGTH: u32 = 504;
pub const STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA: u32 = 4294901761;
pub const STORAGE_OFFLOAD_READ_RANGE_TRUNCATED: u32 = 1;
pub const STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED: u32 = 1;
pub const STORAGE_OFFLOAD_TOKEN_INVALID: u32 = 2;
pub const DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY: u32 = 1073741824;
pub const DEVICE_DSM_PARAMETERS_V1: u32 = 1;
pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS_VERSION_V1: u32 = 1;
pub const DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT: u32 = 1073741824;
pub const DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT: u32 = 536870912;
pub const DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC: u32 = 268435456;
pub const DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT: u32 = 536870912;
pub const DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES: u32 = 268435456;
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1: u32 = 1;
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_VERSION_V1: u32 = 1;
pub const DEVICE_STORAGE_NO_ERRORS: u32 = 1;
pub const DEVICE_DSM_RANGE_ERROR_OUTPUT_V1: u32 = 1;
pub const DEVICE_DSM_RANGE_ERROR_INFO_VERSION_V1: u32 = 1;
pub const IOCTL_STORAGE_BC_VERSION: u32 = 1;
pub const STORAGE_PRIORITY_HINT_SUPPORTED: u32 = 1;
pub const STORAGE_DIAGNOSTIC_FLAG_ADAPTER_REQUEST: u32 = 1;
pub const ERROR_HISTORY_DIRECTORY_ENTRY_DEFAULT_COUNT: u32 = 8;
pub const DEVICEDUMP_STRUCTURE_VERSION_V1: u32 = 1;
pub const DEVICEDUMP_MAX_IDSTRING: u32 = 32;
pub const MAX_FW_BUCKET_ID_LENGTH: u32 = 132;
pub const STORAGE_CRASH_TELEMETRY_REGKEY: &[u8; 81usize] =
    b"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl\\StorageTelemetry\0";
pub const STORAGE_DEVICE_TELEMETRY_REGKEY: &[u8; 76usize] =
    b"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Storage\\StorageTelemetry\0";
pub const DDUMP_FLAG_DATA_READ_FROM_DEVICE: u32 = 1;
pub const FW_ISSUEID_NO_ISSUE: u32 = 0;
pub const FW_ISSUEID_UNKNOWN: u32 = 4294967295;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_SMART: u32 = 1;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG: u32 = 2;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX: u32 = 16;
pub const TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH: u32 = 16;
pub const TC_PUBLIC_DATA_TYPE_ATAGP: &[u8; 14usize] = b"ATAGPLogPages\0";
pub const TC_PUBLIC_DATA_TYPE_ATASMART: &[u8; 14usize] = b"ATASMARTPages\0";
pub const CDB_SIZE: u32 = 16;
pub const TELEMETRY_COMMAND_SIZE: u32 = 16;
pub const DEVICEDUMP_CAP_PRIVATE_SECTION: u32 = 1;
pub const DEVICEDUMP_CAP_RESTRICTED_SECTION: u32 = 2;
pub const STORAGE_IDLE_POWERUP_REASON_VERSION_V1: u32 = 1;
pub const STORAGE_DEVICE_POWER_CAP_VERSION_V1: u32 = 1;
pub const STORAGE_EVENT_NOTIFICATION_VERSION_V1: u32 = 1;
pub const STORAGE_EVENT_MEDIA_STATUS: u32 = 1;
pub const STORAGE_EVENT_DEVICE_STATUS: u32 = 2;
pub const STORAGE_EVENT_DEVICE_OPERATION: u32 = 4;
pub const STORAGE_EVENT_ALL: u32 = 7;
pub const READ_COPY_NUMBER_KEY: u32 = 1380142592;
pub const READ_COPY_NUMBER_BYPASS_CACHE_FLAG: u32 = 256;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER: u32 = 1;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT: u32 = 2;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_FIRST_SEGMENT: u32 = 4;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_REPLACE_EXISTING_IMAGE: u32 = 1073741824;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE: u32 = 2147483648;
pub const STORAGE_HW_FIRMWARE_INVALID_SLOT: u32 = 255;
pub const STORAGE_HW_FIRMWARE_REVISION_LENGTH: u32 = 16;
pub const STORAGE_PROTOCOL_STRUCTURE_VERSION: u32 = 1;
pub const STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST: u32 = 2147483648;
pub const STORAGE_PROTOCOL_STATUS_PENDING: u32 = 0;
pub const STORAGE_PROTOCOL_STATUS_SUCCESS: u32 = 1;
pub const STORAGE_PROTOCOL_STATUS_ERROR: u32 = 2;
pub const STORAGE_PROTOCOL_STATUS_INVALID_REQUEST: u32 = 3;
pub const STORAGE_PROTOCOL_STATUS_NO_DEVICE: u32 = 4;
pub const STORAGE_PROTOCOL_STATUS_BUSY: u32 = 5;
pub const STORAGE_PROTOCOL_STATUS_DATA_OVERRUN: u32 = 6;
pub const STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES: u32 = 7;
pub const STORAGE_PROTOCOL_STATUS_THROTTLED_REQUEST: u32 = 8;
pub const STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED: u32 = 255;
pub const STORAGE_PROTOCOL_COMMAND_LENGTH_NVME: u32 = 64;
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND: u32 = 1;
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND: u32 = 2;
pub const STORATTRIBUTE_NONE: u32 = 0;
pub const STORATTRIBUTE_MANAGEMENT_STATE: u32 = 1;
pub const IOCTL_SCMBUS_BASE: u32 = 89;
pub const IOCTL_SCMBUS_DEVICE_FUNCTION_BASE: u32 = 0;
pub const IOCTL_SCM_LOGICAL_DEVICE_FUNCTION_BASE: u32 = 768;
pub const IOCTL_SCM_PHYSICAL_DEVICE_FUNCTION_BASE: u32 = 1536;
pub const SCM_MAX_SYMLINK_LEN_IN_CHARS: u32 = 256;
pub const MAX_INTERFACE_CODES: u32 = 8;
pub const SCM_PD_FIRMWARE_REVISION_LENGTH_BYTES: u32 = 32;
pub const SCM_PD_PROPERTY_NAME_LENGTH_IN_CHARS: u32 = 128;
pub const SCM_PD_MAX_OPERATIONAL_STATUS: u32 = 16;
pub const SCM_PD_FIRMWARE_LAST_DOWNLOAD: u32 = 1;
pub const IOCTL_DISK_BASE: u32 = 7;
pub const PARTITION_ENTRY_UNUSED: u32 = 0;
pub const PARTITION_FAT_12: u32 = 1;
pub const PARTITION_XENIX_1: u32 = 2;
pub const PARTITION_XENIX_2: u32 = 3;
pub const PARTITION_FAT_16: u32 = 4;
pub const PARTITION_EXTENDED: u32 = 5;
pub const PARTITION_HUGE: u32 = 6;
pub const PARTITION_IFS: u32 = 7;
pub const PARTITION_OS2BOOTMGR: u32 = 10;
pub const PARTITION_FAT32: u32 = 11;
pub const PARTITION_FAT32_XINT13: u32 = 12;
pub const PARTITION_XINT13: u32 = 14;
pub const PARTITION_XINT13_EXTENDED: u32 = 15;
pub const PARTITION_MSFT_RECOVERY: u32 = 39;
pub const PARTITION_MAIN_OS: u32 = 40;
pub const PARTIITON_OS_DATA: u32 = 41;
pub const PARTITION_PRE_INSTALLED: u32 = 42;
pub const PARTITION_BSP: u32 = 43;
pub const PARTITION_DPP: u32 = 44;
pub const PARTITION_WINDOWS_SYSTEM: u32 = 45;
pub const PARTITION_PREP: u32 = 65;
pub const PARTITION_LDM: u32 = 66;
pub const PARTITION_DM: u32 = 84;
pub const PARTITION_EZDRIVE: u32 = 85;
pub const PARTITION_UNIX: u32 = 99;
pub const PARTITION_SPACES_DATA: u32 = 215;
pub const PARTITION_SPACES: u32 = 231;
pub const PARTITION_GPT: u32 = 238;
pub const PARTITION_SYSTEM: u32 = 239;
pub const VALID_NTFT: u32 = 192;
pub const PARTITION_NTFT: u32 = 128;
pub const GPT_ATTRIBUTE_PLATFORM_REQUIRED: u32 = 1;
pub const GPT_ATTRIBUTE_NO_BLOCK_IO_PROTOCOL: u32 = 2;
pub const GPT_ATTRIBUTE_LEGACY_BIOS_BOOTABLE: u32 = 4;
pub const GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER: i64 = -9223372036854775808;
pub const GPT_BASIC_DATA_ATTRIBUTE_HIDDEN: u64 = 4611686018427387904;
pub const GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY: u64 = 2305843009213693952;
pub const GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY: u64 = 1152921504606846976;
pub const GPT_BASIC_DATA_ATTRIBUTE_OFFLINE: u64 = 576460752303423488;
pub const GPT_BASIC_DATA_ATTRIBUTE_DAX: u64 = 288230376151711744;
pub const GPT_BASIC_DATA_ATTRIBUTE_SERVICE: u64 = 144115188075855872;
pub const GPT_SPACES_ATTRIBUTE_NO_METADATA: i64 = -9223372036854775808;
pub const HIST_NO_OF_BUCKETS: u32 = 24;
pub const DISK_LOGGING_START: u32 = 0;
pub const DISK_LOGGING_STOP: u32 = 1;
pub const DISK_LOGGING_DUMP: u32 = 2;
pub const DISK_BINNING: u32 = 3;
pub const CAP_ATA_ID_CMD: u32 = 1;
pub const CAP_ATAPI_ID_CMD: u32 = 2;
pub const CAP_SMART_CMD: u32 = 4;
pub const ATAPI_ID_CMD: u32 = 161;
pub const ID_CMD: u32 = 236;
pub const SMART_CMD: u32 = 176;
pub const SMART_CYL_LOW: u32 = 79;
pub const SMART_CYL_HI: u32 = 194;
pub const SMART_NO_ERROR: u32 = 0;
pub const SMART_IDE_ERROR: u32 = 1;
pub const SMART_INVALID_FLAG: u32 = 2;
pub const SMART_INVALID_COMMAND: u32 = 3;
pub const SMART_INVALID_BUFFER: u32 = 4;
pub const SMART_INVALID_DRIVE: u32 = 5;
pub const SMART_INVALID_IOCTL: u32 = 6;
pub const SMART_ERROR_NO_MEM: u32 = 7;
pub const SMART_INVALID_REGISTER: u32 = 8;
pub const SMART_NOT_SUPPORTED: u32 = 9;
pub const SMART_NO_IDE_DEVICE: u32 = 10;
pub const SMART_OFFLINE_ROUTINE_OFFLINE: u32 = 0;
pub const SMART_SHORT_SELFTEST_OFFLINE: u32 = 1;
pub const SMART_EXTENDED_SELFTEST_OFFLINE: u32 = 2;
pub const SMART_ABORT_OFFLINE_SELFTEST: u32 = 127;
pub const SMART_SHORT_SELFTEST_CAPTIVE: u32 = 129;
pub const SMART_EXTENDED_SELFTEST_CAPTIVE: u32 = 130;
pub const READ_ATTRIBUTE_BUFFER_SIZE: u32 = 512;
pub const IDENTIFY_BUFFER_SIZE: u32 = 512;
pub const READ_THRESHOLD_BUFFER_SIZE: u32 = 512;
pub const SMART_LOG_SECTOR_SIZE: u32 = 512;
pub const READ_ATTRIBUTES: u32 = 208;
pub const READ_THRESHOLDS: u32 = 209;
pub const ENABLE_DISABLE_AUTOSAVE: u32 = 210;
pub const SAVE_ATTRIBUTE_VALUES: u32 = 211;
pub const EXECUTE_OFFLINE_DIAGS: u32 = 212;
pub const SMART_READ_LOG: u32 = 213;
pub const SMART_WRITE_LOG: u32 = 214;
pub const ENABLE_SMART: u32 = 216;
pub const DISABLE_SMART: u32 = 217;
pub const RETURN_SMART_STATUS: u32 = 218;
pub const ENABLE_DISABLE_AUTO_OFFLINE: u32 = 219;
pub const DISK_ATTRIBUTE_OFFLINE: u32 = 1;
pub const DISK_ATTRIBUTE_READ_ONLY: u32 = 2;
pub const IOCTL_CHANGER_BASE: u32 = 48;
pub const MAX_VOLUME_ID_SIZE: u32 = 36;
pub const MAX_VOLUME_TEMPLATE_SIZE: u32 = 40;
pub const VENDOR_ID_LENGTH: u32 = 8;
pub const PRODUCT_ID_LENGTH: u32 = 16;
pub const REVISION_LENGTH: u32 = 4;
pub const SERIAL_NUMBER_LENGTH: u32 = 32;
pub const CHANGER_BAR_CODE_SCANNER_INSTALLED: u32 = 1;
pub const CHANGER_INIT_ELEM_STAT_WITH_RANGE: u32 = 2;
pub const CHANGER_CLOSE_IEPORT: u32 = 4;
pub const CHANGER_OPEN_IEPORT: u32 = 8;
pub const CHANGER_STATUS_NON_VOLATILE: u32 = 16;
pub const CHANGER_EXCHANGE_MEDIA: u32 = 32;
pub const CHANGER_CLEANER_SLOT: u32 = 64;
pub const CHANGER_LOCK_UNLOCK: u32 = 128;
pub const CHANGER_CARTRIDGE_MAGAZINE: u32 = 256;
pub const CHANGER_MEDIUM_FLIP: u32 = 512;
pub const CHANGER_POSITION_TO_ELEMENT: u32 = 1024;
pub const CHANGER_REPORT_IEPORT_STATE: u32 = 2048;
pub const CHANGER_STORAGE_DRIVE: u32 = 4096;
pub const CHANGER_STORAGE_IEPORT: u32 = 8192;
pub const CHANGER_STORAGE_SLOT: u32 = 16384;
pub const CHANGER_STORAGE_TRANSPORT: u32 = 32768;
pub const CHANGER_DRIVE_CLEANING_REQUIRED: u32 = 65536;
pub const CHANGER_PREDISMOUNT_EJECT_REQUIRED: u32 = 131072;
pub const CHANGER_CLEANER_ACCESS_NOT_VALID: u32 = 262144;
pub const CHANGER_PREMOUNT_EJECT_REQUIRED: u32 = 524288;
pub const CHANGER_VOLUME_IDENTIFICATION: u32 = 1048576;
pub const CHANGER_VOLUME_SEARCH: u32 = 2097152;
pub const CHANGER_VOLUME_ASSERT: u32 = 4194304;
pub const CHANGER_VOLUME_REPLACE: u32 = 8388608;
pub const CHANGER_VOLUME_UNDEFINE: u32 = 16777216;
pub const CHANGER_SERIAL_NUMBER_VALID: u32 = 67108864;
pub const CHANGER_DEVICE_REINITIALIZE_CAPABLE: u32 = 134217728;
pub const CHANGER_KEYPAD_ENABLE_DISABLE: u32 = 268435456;
pub const CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS: u32 = 536870912;
pub const CHANGER_RESERVED_BIT: u32 = 2147483648;
pub const CHANGER_PREDISMOUNT_ALIGN_TO_SLOT: u32 = 2147483649;
pub const CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE: u32 = 2147483650;
pub const CHANGER_CLEANER_AUTODISMOUNT: u32 = 2147483652;
pub const CHANGER_TRUE_EXCHANGE_CAPABLE: u32 = 2147483656;
pub const CHANGER_SLOTS_USE_TRAYS: u32 = 2147483664;
pub const CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR: u32 = 2147483680;
pub const CHANGER_CLEANER_OPS_NOT_SUPPORTED: u32 = 2147483712;
pub const CHANGER_IEPORT_USER_CONTROL_OPEN: u32 = 2147483776;
pub const CHANGER_IEPORT_USER_CONTROL_CLOSE: u32 = 2147483904;
pub const CHANGER_MOVE_EXTENDS_IEPORT: u32 = 2147484160;
pub const CHANGER_MOVE_RETRACTS_IEPORT: u32 = 2147484672;
pub const CHANGER_TO_TRANSPORT: u32 = 1;
pub const CHANGER_TO_SLOT: u32 = 2;
pub const CHANGER_TO_IEPORT: u32 = 4;
pub const CHANGER_TO_DRIVE: u32 = 8;
pub const LOCK_UNLOCK_IEPORT: u32 = 1;
pub const LOCK_UNLOCK_DOOR: u32 = 2;
pub const LOCK_UNLOCK_KEYPAD: u32 = 4;
pub const LOCK_ELEMENT: u32 = 0;
pub const UNLOCK_ELEMENT: u32 = 1;
pub const EXTEND_IEPORT: u32 = 2;
pub const RETRACT_IEPORT: u32 = 3;
pub const ELEMENT_STATUS_FULL: u32 = 1;
pub const ELEMENT_STATUS_IMPEXP: u32 = 2;
pub const ELEMENT_STATUS_EXCEPT: u32 = 4;
pub const ELEMENT_STATUS_ACCESS: u32 = 8;
pub const ELEMENT_STATUS_EXENAB: u32 = 16;
pub const ELEMENT_STATUS_INENAB: u32 = 32;
pub const ELEMENT_STATUS_PRODUCT_DATA: u32 = 64;
pub const ELEMENT_STATUS_LUN_VALID: u32 = 4096;
pub const ELEMENT_STATUS_ID_VALID: u32 = 8192;
pub const ELEMENT_STATUS_NOT_BUS: u32 = 32768;
pub const ELEMENT_STATUS_INVERT: u32 = 4194304;
pub const ELEMENT_STATUS_SVALID: u32 = 8388608;
pub const ELEMENT_STATUS_PVOLTAG: u32 = 268435456;
pub const ELEMENT_STATUS_AVOLTAG: u32 = 536870912;
pub const ERROR_LABEL_UNREADABLE: u32 = 1;
pub const ERROR_LABEL_QUESTIONABLE: u32 = 2;
pub const ERROR_SLOT_NOT_PRESENT: u32 = 4;
pub const ERROR_DRIVE_NOT_INSTALLED: u32 = 8;
pub const ERROR_TRAY_MALFUNCTION: u32 = 16;
pub const ERROR_INIT_STATUS_NEEDED: u32 = 17;
pub const ERROR_UNHANDLED_ERROR: u32 = 4294967295;
pub const SEARCH_ALL: u32 = 0;
pub const SEARCH_PRIMARY: u32 = 1;
pub const SEARCH_ALTERNATE: u32 = 2;
pub const SEARCH_ALL_NO_SEQ: u32 = 4;
pub const SEARCH_PRI_NO_SEQ: u32 = 5;
pub const SEARCH_ALT_NO_SEQ: u32 = 6;
pub const ASSERT_PRIMARY: u32 = 8;
pub const ASSERT_ALTERNATE: u32 = 9;
pub const REPLACE_PRIMARY: u32 = 10;
pub const REPLACE_ALTERNATE: u32 = 11;
pub const UNDEFINE_PRIMARY: u32 = 12;
pub const UNDEFINE_ALTERNATE: u32 = 13;
pub const GET_VOLUME_BITMAP_FLAG_MASK_METADATA: u32 = 1;
pub const FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE: u32 = 1;
pub const USN_PAGE_SIZE: u32 = 4096;
pub const USN_REASON_DATA_OVERWRITE: u32 = 1;
pub const USN_REASON_DATA_EXTEND: u32 = 2;
pub const USN_REASON_DATA_TRUNCATION: u32 = 4;
pub const USN_REASON_NAMED_DATA_OVERWRITE: u32 = 16;
pub const USN_REASON_NAMED_DATA_EXTEND: u32 = 32;
pub const USN_REASON_NAMED_DATA_TRUNCATION: u32 = 64;
pub const USN_REASON_FILE_CREATE: u32 = 256;
pub const USN_REASON_FILE_DELETE: u32 = 512;
pub const USN_REASON_EA_CHANGE: u32 = 1024;
pub const USN_REASON_SECURITY_CHANGE: u32 = 2048;
pub const USN_REASON_RENAME_OLD_NAME: u32 = 4096;
pub const USN_REASON_RENAME_NEW_NAME: u32 = 8192;
pub const USN_REASON_INDEXABLE_CHANGE: u32 = 16384;
pub const USN_REASON_BASIC_INFO_CHANGE: u32 = 32768;
pub const USN_REASON_HARD_LINK_CHANGE: u32 = 65536;
pub const USN_REASON_COMPRESSION_CHANGE: u32 = 131072;
pub const USN_REASON_ENCRYPTION_CHANGE: u32 = 262144;
pub const USN_REASON_OBJECT_ID_CHANGE: u32 = 524288;
pub const USN_REASON_REPARSE_POINT_CHANGE: u32 = 1048576;
pub const USN_REASON_STREAM_CHANGE: u32 = 2097152;
pub const USN_REASON_TRANSACTED_CHANGE: u32 = 4194304;
pub const USN_REASON_INTEGRITY_CHANGE: u32 = 8388608;
pub const USN_REASON_DESIRED_STORAGE_CLASS_CHANGE: u32 = 16777216;
pub const USN_REASON_CLOSE: u32 = 2147483648;
pub const USN_DELETE_FLAG_DELETE: u32 = 1;
pub const USN_DELETE_FLAG_NOTIFY: u32 = 2;
pub const USN_DELETE_VALID_FLAGS: u32 = 3;
pub const USN_SOURCE_DATA_MANAGEMENT: u32 = 1;
pub const USN_SOURCE_AUXILIARY_DATA: u32 = 2;
pub const USN_SOURCE_REPLICATION_MANAGEMENT: u32 = 4;
pub const USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT: u32 = 8;
pub const USN_SOURCE_VALID_FLAGS: u32 = 15;
pub const MARK_HANDLE_PROTECT_CLUSTERS: u32 = 1;
pub const MARK_HANDLE_TXF_SYSTEM_LOG: u32 = 4;
pub const MARK_HANDLE_NOT_TXF_SYSTEM_LOG: u32 = 8;
pub const MARK_HANDLE_REALTIME: u32 = 32;
pub const MARK_HANDLE_NOT_REALTIME: u32 = 64;
pub const MARK_HANDLE_CLOUD_SYNC: u32 = 2048;
pub const MARK_HANDLE_READ_COPY: u32 = 128;
pub const MARK_HANDLE_NOT_READ_COPY: u32 = 256;
pub const MARK_HANDLE_FILTER_METADATA: u32 = 512;
pub const MARK_HANDLE_RETURN_PURGE_FAILURE: u32 = 1024;
pub const MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION: u32 = 4096;
pub const MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO: u32 = 8192;
pub const MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES: u32 = 16384;
pub const MARK_HANDLE_SUPPRESS_VOLUME_OPEN_FLUSH: u32 = 32768;
pub const MARK_HANDLE_ENABLE_CPU_CACHE: u32 = 268435456;
pub const VOLUME_IS_DIRTY: u32 = 1;
pub const VOLUME_UPGRADE_SCHEDULED: u32 = 2;
pub const VOLUME_SESSION_OPEN: u32 = 4;
pub const FILE_PREFETCH_TYPE_FOR_CREATE: u32 = 1;
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM: u32 = 2;
pub const FILE_PREFETCH_TYPE_FOR_CREATE_EX: u32 = 3;
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM_EX: u32 = 4;
pub const FILE_PREFETCH_TYPE_MAX: u32 = 4;
pub const FILESYSTEM_STATISTICS_TYPE_NTFS: u32 = 1;
pub const FILESYSTEM_STATISTICS_TYPE_FAT: u32 = 2;
pub const FILESYSTEM_STATISTICS_TYPE_EXFAT: u32 = 3;
pub const FILESYSTEM_STATISTICS_TYPE_REFS: u32 = 4;
pub const FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA: u32 = 1;
pub const FILE_SET_ENCRYPTION: u32 = 1;
pub const FILE_CLEAR_ENCRYPTION: u32 = 2;
pub const STREAM_SET_ENCRYPTION: u32 = 3;
pub const STREAM_CLEAR_ENCRYPTION: u32 = 4;
pub const MAXIMUM_ENCRYPTION_VALUE: u32 = 4;
pub const ENCRYPTION_FORMAT_DEFAULT: u32 = 1;
pub const ENCRYPTED_DATA_INFO_SPARSE_FILE: u32 = 1;
pub const COPYFILE_SIS_LINK: u32 = 1;
pub const COPYFILE_SIS_REPLACE: u32 = 2;
pub const COPYFILE_SIS_FLAGS: u32 = 3;
pub const SET_REPAIR_ENABLED: u32 = 1;
pub const SET_REPAIR_WARN_ABOUT_DATA_LOSS: u32 = 8;
pub const SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT: u32 = 16;
pub const SET_REPAIR_VALID_MASK: u32 = 25;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE: u32 = 1;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED: u32 = 2;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST: u32 = 4;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD: u32 = 8;
pub const FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE: u32 = 16;
pub const FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED: u32 = 32;
pub const FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR: u32 = 64;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED: u32 = 128;
pub const FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED: u32 = 256;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED: u32 = 512;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIRED: u32 = 1024;
pub const FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG: u32 = 2048;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND: u32 = 4096;
pub const FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK: u32 = 8192;
pub const FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION: u32 = 16384;
pub const FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE: u32 = 32768;
pub const FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST: u32 = 65536;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH: u32 = 131072;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN: u32 = 262144;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD: u32 = 524288;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT: u32 = 1048576;
pub const FILE_INITIATE_REPAIR_HINT1_SID_VALID: u32 = 2097152;
pub const FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH: u32 = 4194304;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT: u32 = 8388608;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE: u32 = 16777216;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED: u32 = 33554432;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST: u32 = 67108864;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD: u32 = 134217728;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX: u32 = 268435456;
pub const FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY: u32 = 536870912;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES: u32 = 1073741824;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE: u32 = 2147483648;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_LCN: u64 = 4294967296;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_VCN: u64 = 8589934592;
pub const FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT: u64 = 17179869184;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN: u64 = 34359738368;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL: u64 = 68719476736;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT: u64 = 137438953472;
pub const FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG: u64 = 274877906944;
pub const FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID: u64 = 549755813888;
pub const FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH: u64 = 1099511627776;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME: u64 = 2199023255552;
pub const FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES: u64 = 4398046511104;
pub const TXFS_RM_FLAG_LOGGING_MODE: u32 = 1;
pub const TXFS_RM_FLAG_RENAME_RM: u32 = 2;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 4;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 8;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 16;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 32;
pub const TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 64;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 128;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 256;
pub const TXFS_RM_FLAG_GROW_LOG: u32 = 1024;
pub const TXFS_RM_FLAG_SHRINK_LOG: u32 = 2048;
pub const TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE: u32 = 4096;
pub const TXFS_RM_FLAG_PRESERVE_CHANGES: u32 = 8192;
pub const TXFS_RM_FLAG_RESET_RM_AT_NEXT_START: u32 = 16384;
pub const TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START: u32 = 32768;
pub const TXFS_RM_FLAG_PREFER_CONSISTENCY: u32 = 65536;
pub const TXFS_RM_FLAG_PREFER_AVAILABILITY: u32 = 131072;
pub const TXFS_LOGGING_MODE_SIMPLE: u32 = 1;
pub const TXFS_LOGGING_MODE_FULL: u32 = 2;
pub const TXFS_TRANSACTION_STATE_NONE: u32 = 0;
pub const TXFS_TRANSACTION_STATE_ACTIVE: u32 = 1;
pub const TXFS_TRANSACTION_STATE_PREPARED: u32 = 2;
pub const TXFS_TRANSACTION_STATE_NOTACTIVE: u32 = 3;
pub const TXFS_MODIFY_RM_VALID_FLAGS: u32 = 261631;
pub const TXFS_RM_STATE_NOT_STARTED: u32 = 0;
pub const TXFS_RM_STATE_STARTING: u32 = 1;
pub const TXFS_RM_STATE_ACTIVE: u32 = 2;
pub const TXFS_RM_STATE_SHUTTING_DOWN: u32 = 3;
pub const TXFS_QUERY_RM_INFORMATION_VALID_FLAGS: u32 = 246192;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN: u32 = 1;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK: u32 = 2;
pub const TXFS_ROLLFORWARD_REDO_VALID_FLAGS: u32 = 3;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 1;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 2;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE: u32 = 4;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 8;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 16;
pub const TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 32;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 64;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 128;
pub const TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT: u32 = 512;
pub const TXFS_START_RM_FLAG_LOGGING_MODE: u32 = 1024;
pub const TXFS_START_RM_FLAG_PRESERVE_CHANGES: u32 = 2048;
pub const TXFS_START_RM_FLAG_PREFER_CONSISTENCY: u32 = 4096;
pub const TXFS_START_RM_FLAG_PREFER_AVAILABILITY: u32 = 8192;
pub const TXFS_START_RM_VALID_FLAGS: u32 = 15999;
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED: u32 = 1;
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED: u32 = 2;
pub const TXFS_TRANSACTED_VERSION_NONTRANSACTED: u32 = 4294967294;
pub const TXFS_TRANSACTED_VERSION_UNCOMMITTED: u32 = 4294967295;
pub const TXFS_SAVEPOINT_SET: u32 = 1;
pub const TXFS_SAVEPOINT_ROLLBACK: u32 = 2;
pub const TXFS_SAVEPOINT_CLEAR: u32 = 4;
pub const TXFS_SAVEPOINT_CLEAR_ALL: u32 = 16;
pub const PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED: u32 = 1;
pub const PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED: u32 = 2;
pub const PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY: u32 = 4;
pub const PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY: u32 = 8;
pub const PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING: u32 = 16;
pub const PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM: u32 = 32;
pub const PERSISTENT_VOLUME_STATE_BACKED_BY_WIM: u32 = 64;
pub const PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING: u32 = 128;
pub const PERSISTENT_VOLUME_STATE_TXF_DISABLED: u32 = 256;
pub const PERSISTENT_VOLUME_STATE_REALLOCATE_ALL_DATA_WRITES: u32 = 512;
pub const PERSISTENT_VOLUME_STATE_CHKDSK_RAN_ONCE: u32 = 1024;
pub const PERSISTENT_VOLUME_STATE_MODIFIED_BY_CHKDSK: u32 = 2048;
pub const PERSISTENT_VOLUME_STATE_DAX_FORMATTED: u32 = 4096;
pub const OPLOCK_LEVEL_CACHE_READ: u32 = 1;
pub const OPLOCK_LEVEL_CACHE_HANDLE: u32 = 2;
pub const OPLOCK_LEVEL_CACHE_WRITE: u32 = 4;
pub const REQUEST_OPLOCK_INPUT_FLAG_REQUEST: u32 = 1;
pub const REQUEST_OPLOCK_INPUT_FLAG_ACK: u32 = 2;
pub const REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE: u32 = 4;
pub const REQUEST_OPLOCK_CURRENT_VERSION: u32 = 1;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED: u32 = 1;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED: u32 = 2;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES: u32 = 1;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES: u32 = 2;
pub const SD_GLOBAL_CHANGE_TYPE_MACHINE_SID: u32 = 1;
pub const SD_GLOBAL_CHANGE_TYPE_QUERY_STATS: u32 = 65536;
pub const SD_GLOBAL_CHANGE_TYPE_ENUM_SDS: u32 = 131072;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE: u32 = 1;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET: u32 = 2;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE: u32 = 4;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE: u32 = 8;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK: u32 = 4278190080;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA: u32 = 16777216;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX: u32 = 33554432;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM: u32 = 50331648;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN: u32 = 1;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_END: u32 = 2;
pub const CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED: u32 = 1;
pub const CSV_INVALID_DEVICE_NUMBER: u32 = 4294967295;
pub const CSV_QUERY_MDS_PATH_V2_VERSION_1: u32 = 1;
pub const CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED: u32 = 1;
pub const CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED: u32 = 2;
pub const CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED: u32 = 4;
pub const QUERY_FILE_LAYOUT_RESTART: u32 = 1;
pub const QUERY_FILE_LAYOUT_INCLUDE_NAMES: u32 = 2;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS: u32 = 4;
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTENTS: u32 = 8;
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO: u32 = 16;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED: u32 = 32;
pub const QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES: u32 = 64;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION: u32 = 128;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE: u32 = 256;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE: u32 = 512;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE: u32 = 1024;
pub const QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES: u32 = 2048;
pub const QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE: u32 = 4096;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DATA_ATTRIBUTE: u32 = 8192;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_REPARSE_ATTRIBUTE: u32 = 16384;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EA_ATTRIBUTE: u32 = 32768;
pub const QUERY_FILE_LAYOUT_SINGLE_INSTANCED: u32 = 1;
pub const FILE_LAYOUT_NAME_ENTRY_PRIMARY: u32 = 1;
pub const FILE_LAYOUT_NAME_ENTRY_DOS: u32 = 2;
pub const STREAM_LAYOUT_ENTRY_IMMOVABLE: u32 = 1;
pub const STREAM_LAYOUT_ENTRY_PINNED: u32 = 2;
pub const STREAM_LAYOUT_ENTRY_RESIDENT: u32 = 4;
pub const STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED: u32 = 8;
pub const STREAM_LAYOUT_ENTRY_HAS_INFORMATION: u32 = 16;
pub const STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS: u32 = 1;
pub const STREAM_EXTENT_ENTRY_ALL_EXTENTS: u32 = 2;
pub const CHECKSUM_TYPE_UNCHANGED: i32 = -1;
pub const CHECKSUM_TYPE_NONE: u32 = 0;
pub const CHECKSUM_TYPE_CRC32: u32 = 1;
pub const CHECKSUM_TYPE_CRC64: u32 = 2;
pub const CHECKSUM_TYPE_ECC: u32 = 3;
pub const CHECKSUM_TYPE_FIRST_UNUSED_TYPE: u32 = 4;
pub const FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF: u32 = 1;
pub const OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE: u32 = 1;
pub const SET_PURGE_FAILURE_MODE_ENABLED: u32 = 1;
pub const SET_PURGE_FAILURE_MODE_DISABLED: u32 = 2;
pub const FILE_REGION_USAGE_VALID_CACHED_DATA: u32 = 1;
pub const FILE_REGION_USAGE_VALID_NONCACHED_DATA: u32 = 2;
pub const FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT: u32 = 4;
pub const FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT: u32 = 8;
pub const FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT: u32 = 16;
pub const FILE_REGION_USAGE_QUERY_ALIGNMENT: u32 = 24;
pub const VALID_WRITE_USN_REASON_MASK: u32 = 2147483649;
pub const FILE_STORAGE_TIER_NAME_LENGTH: u32 = 256;
pub const FILE_STORAGE_TIER_DESCRIPTION_LENGTH: u32 = 512;
pub const FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY: u32 = 131072;
pub const FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE: u32 = 2097152;
pub const FILE_STORAGE_TIER_FLAG_READ_CACHE: u32 = 4194304;
pub const FILE_STORAGE_TIER_FLAG_PARITY: u32 = 8388608;
pub const FILE_STORAGE_TIER_FLAG_SMR: u32 = 16777216;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE: u32 = 2147483648;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ: u32 = 1073741824;
pub const QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME: u32 = 536870912;
pub const QUERY_FILE_LAYOUT_REPARSE_DATA_INVALID: u32 = 1;
pub const QUERY_FILE_LAYOUT_REPARSE_TAG_INVALID: u32 = 2;
pub const DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC: u32 = 1;
pub const DUPLICATE_EXTENTS_DATA_EX_ASYNC: u32 = 2;
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V0: u32 = 0;
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1: u32 = 1;
pub const REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1: u32 = 1;
pub const STREAMS_INVALID_ID: u32 = 0;
pub const STREAMS_MAX_ID: u32 = 65535;
pub const STREAMS_ASSOCIATE_ID_CLEAR: u32 = 1;
pub const STREAMS_ASSOCIATE_ID_SET: u32 = 2;
pub const DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY: u32 = 1;
pub const DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED: u32 = 2;
pub const WOF_CURRENT_VERSION: u32 = 1;
pub const WOF_PROVIDER_WIM: u32 = 1;
pub const WOF_PROVIDER_FILE: u32 = 2;
pub const WOF_PROVIDER_CLOUD: u32 = 3;
pub const WIM_PROVIDER_HASH_SIZE: u32 = 20;
pub const WIM_PROVIDER_CURRENT_VERSION: u32 = 1;
pub const WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE: u32 = 1;
pub const WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED: u32 = 2;
pub const WIM_BOOT_OS_WIM: u32 = 1;
pub const WIM_BOOT_NOT_OS_WIM: u32 = 0;
pub const FILE_PROVIDER_CURRENT_VERSION: u32 = 1;
pub const FILE_PROVIDER_SINGLE_FILE: u32 = 1;
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K: u32 = 0;
pub const FILE_PROVIDER_COMPRESSION_LZX: u32 = 1;
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K: u32 = 2;
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K: u32 = 3;
pub const FILE_PROVIDER_COMPRESSION_MAXIMUM: u32 = 4;
pub const FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE: u32 = 1;
pub const CONTAINER_VOLUME_STATE_HOSTING_CONTAINER: u32 = 1;
pub const CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT: u32 = 1;
pub const CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT: u32 = 2;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT: u32 = 4;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT: u32 = 8;
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT: u32 = 16;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_ROOT: u32 = 32;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT: u32 = 64;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT: u32 = 128;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME: u32 = 256;
pub const CONTAINER_ROOT_INFO_FLAG_UNION_LAYER_ROOT: u32 = 512;
pub const CONTAINER_ROOT_INFO_VALID_FLAGS: u32 = 1023;
pub const PROJFS_PROTOCOL_VERSION: u32 = 3;
pub const IOCTL_VOLUME_BASE: u32 = 86;
pub const EFS_TRACKED_OFFSET_HEADER_FLAG: u32 = 1;
pub const SPACES_TRACKED_OFFSET_HEADER_FLAG: u32 = 2;
pub const SCARD_ATR_LENGTH: u32 = 33;
pub const SCARD_PROTOCOL_UNDEFINED: u32 = 0;
pub const SCARD_PROTOCOL_T0: u32 = 1;
pub const SCARD_PROTOCOL_T1: u32 = 2;
pub const SCARD_PROTOCOL_RAW: u32 = 65536;
pub const SCARD_PROTOCOL_Tx: u32 = 3;
pub const SCARD_PROTOCOL_DEFAULT: u32 = 2147483648;
pub const SCARD_PROTOCOL_OPTIMAL: u32 = 0;
pub const SCARD_POWER_DOWN: u32 = 0;
pub const SCARD_COLD_RESET: u32 = 1;
pub const SCARD_WARM_RESET: u32 = 2;
pub const MAXIMUM_ATTR_STRING_LENGTH: u32 = 32;
pub const MAXIMUM_SMARTCARD_READERS: u32 = 10;
pub const SCARD_CLASS_VENDOR_INFO: u32 = 1;
pub const SCARD_CLASS_COMMUNICATIONS: u32 = 2;
pub const SCARD_CLASS_PROTOCOL: u32 = 3;
pub const SCARD_CLASS_POWER_MGMT: u32 = 4;
pub const SCARD_CLASS_SECURITY: u32 = 5;
pub const SCARD_CLASS_MECHANICAL: u32 = 6;
pub const SCARD_CLASS_VENDOR_DEFINED: u32 = 7;
pub const SCARD_CLASS_IFD_PROTOCOL: u32 = 8;
pub const SCARD_CLASS_ICC_STATE: u32 = 9;
pub const SCARD_CLASS_PERF: u32 = 32766;
pub const SCARD_CLASS_SYSTEM: u32 = 32767;
pub const SCARD_T0_HEADER_LENGTH: u32 = 7;
pub const SCARD_T0_CMD_LENGTH: u32 = 5;
pub const SCARD_T1_PROLOGUE_LENGTH: u32 = 3;
pub const SCARD_T1_EPILOGUE_LENGTH: u32 = 2;
pub const SCARD_T1_EPILOGUE_LENGTH_LRC: u32 = 1;
pub const SCARD_T1_MAX_IFS: u32 = 254;
pub const SCARD_UNKNOWN: u32 = 0;
pub const SCARD_ABSENT: u32 = 1;
pub const SCARD_PRESENT: u32 = 2;
pub const SCARD_SWALLOWED: u32 = 3;
pub const SCARD_POWERED: u32 = 4;
pub const SCARD_NEGOTIABLE: u32 = 5;
pub const SCARD_SPECIFIC: u32 = 6;
pub const SCARD_READER_SWALLOWS: u32 = 1;
pub const SCARD_READER_EJECTS: u32 = 2;
pub const SCARD_READER_CONFISCATES: u32 = 4;
pub const SCARD_READER_CONTACTLESS: u32 = 8;
pub const SCARD_READER_TYPE_SERIAL: u32 = 1;
pub const SCARD_READER_TYPE_PARALELL: u32 = 2;
pub const SCARD_READER_TYPE_KEYBOARD: u32 = 4;
pub const SCARD_READER_TYPE_SCSI: u32 = 8;
pub const SCARD_READER_TYPE_IDE: u32 = 16;
pub const SCARD_READER_TYPE_USB: u32 = 32;
pub const SCARD_READER_TYPE_PCMCIA: u32 = 64;
pub const SCARD_READER_TYPE_TPM: u32 = 128;
pub const SCARD_READER_TYPE_NFC: u32 = 256;
pub const SCARD_READER_TYPE_UICC: u32 = 512;
pub const SCARD_READER_TYPE_NGC: u32 = 1024;
pub const SCARD_READER_TYPE_EMBEDDEDSE: u32 = 2048;
pub const SCARD_READER_TYPE_VENDOR: u32 = 240;
pub const SCARD_SCOPE_USER: u32 = 0;
pub const SCARD_SCOPE_TERMINAL: u32 = 1;
pub const SCARD_SCOPE_SYSTEM: u32 = 2;
pub const SCARD_PROVIDER_PRIMARY: u32 = 1;
pub const SCARD_PROVIDER_CSP: u32 = 2;
pub const SCARD_PROVIDER_KSP: u32 = 3;
pub const SCARD_STATE_UNAWARE: u32 = 0;
pub const SCARD_STATE_IGNORE: u32 = 1;
pub const SCARD_STATE_CHANGED: u32 = 2;
pub const SCARD_STATE_UNKNOWN: u32 = 4;
pub const SCARD_STATE_UNAVAILABLE: u32 = 8;
pub const SCARD_STATE_EMPTY: u32 = 16;
pub const SCARD_STATE_PRESENT: u32 = 32;
pub const SCARD_STATE_ATRMATCH: u32 = 64;
pub const SCARD_STATE_EXCLUSIVE: u32 = 128;
pub const SCARD_STATE_INUSE: u32 = 256;
pub const SCARD_STATE_MUTE: u32 = 512;
pub const SCARD_STATE_UNPOWERED: u32 = 1024;
pub const SCARD_SHARE_EXCLUSIVE: u32 = 1;
pub const SCARD_SHARE_SHARED: u32 = 2;
pub const SCARD_SHARE_DIRECT: u32 = 3;
pub const SCARD_LEAVE_CARD: u32 = 0;
pub const SCARD_RESET_CARD: u32 = 1;
pub const SCARD_UNPOWER_CARD: u32 = 2;
pub const SCARD_EJECT_CARD: u32 = 3;
pub const SC_DLG_MINIMAL_UI: u32 = 1;
pub const SC_DLG_NO_UI: u32 = 2;
pub const SC_DLG_FORCE_UI: u32 = 4;
pub const SCERR_NOCARDNAME: u32 = 16384;
pub const SCERR_NOGUIDS: u32 = 32768;
pub const SCARD_AUDIT_CHV_FAILURE: u32 = 0;
pub const SCARD_AUDIT_CHV_SUCCESS: u32 = 1;
pub const MAXPROPPAGES: u32 = 100;
pub const PSP_DEFAULT: u32 = 0;
pub const PSP_DLGINDIRECT: u32 = 1;
pub const PSP_USEHICON: u32 = 2;
pub const PSP_USEICONID: u32 = 4;
pub const PSP_USETITLE: u32 = 8;
pub const PSP_RTLREADING: u32 = 16;
pub const PSP_HASHELP: u32 = 32;
pub const PSP_USEREFPARENT: u32 = 64;
pub const PSP_USECALLBACK: u32 = 128;
pub const PSP_PREMATURE: u32 = 1024;
pub const PSP_HIDEHEADER: u32 = 2048;
pub const PSP_USEHEADERTITLE: u32 = 4096;
pub const PSP_USEHEADERSUBTITLE: u32 = 8192;
pub const PSP_USEFUSIONCONTEXT: u32 = 16384;
pub const PSPCB_ADDREF: u32 = 0;
pub const PSPCB_RELEASE: u32 = 1;
pub const PSPCB_CREATE: u32 = 2;
pub const PSH_DEFAULT: u32 = 0;
pub const PSH_PROPTITLE: u32 = 1;
pub const PSH_USEHICON: u32 = 2;
pub const PSH_USEICONID: u32 = 4;
pub const PSH_PROPSHEETPAGE: u32 = 8;
pub const PSH_WIZARDHASFINISH: u32 = 16;
pub const PSH_WIZARD: u32 = 32;
pub const PSH_USEPSTARTPAGE: u32 = 64;
pub const PSH_NOAPPLYNOW: u32 = 128;
pub const PSH_USECALLBACK: u32 = 256;
pub const PSH_HASHELP: u32 = 512;
pub const PSH_MODELESS: u32 = 1024;
pub const PSH_RTLREADING: u32 = 2048;
pub const PSH_WIZARDCONTEXTHELP: u32 = 4096;
pub const PSH_WIZARD97: u32 = 16777216;
pub const PSH_WATERMARK: u32 = 32768;
pub const PSH_USEHBMWATERMARK: u32 = 65536;
pub const PSH_USEHPLWATERMARK: u32 = 131072;
pub const PSH_STRETCHWATERMARK: u32 = 262144;
pub const PSH_HEADER: u32 = 524288;
pub const PSH_USEHBMHEADER: u32 = 1048576;
pub const PSH_USEPAGELANG: u32 = 2097152;
pub const PSH_WIZARD_LITE: u32 = 4194304;
pub const PSH_NOCONTEXTHELP: u32 = 33554432;
pub const PSH_AEROWIZARD: u32 = 16384;
pub const PSH_RESIZABLE: u32 = 67108864;
pub const PSH_HEADERBITMAP: u32 = 134217728;
pub const PSH_NOMARGIN: u32 = 268435456;
pub const PSCB_INITIALIZED: u32 = 1;
pub const PSCB_PRECREATE: u32 = 2;
pub const PSCB_BUTTONPRESSED: u32 = 3;
pub const PSN_FIRST: i32 = -200;
pub const PSN_LAST: i32 = -299;
pub const PSN_SETACTIVE: i32 = -200;
pub const PSN_KILLACTIVE: i32 = -201;
pub const PSN_APPLY: i32 = -202;
pub const PSN_RESET: i32 = -203;
pub const PSN_HELP: i32 = -205;
pub const PSN_WIZBACK: i32 = -206;
pub const PSN_WIZNEXT: i32 = -207;
pub const PSN_WIZFINISH: i32 = -208;
pub const PSN_QUERYCANCEL: i32 = -209;
pub const PSN_GETOBJECT: i32 = -210;
pub const PSN_TRANSLATEACCELERATOR: i32 = -212;
pub const PSN_QUERYINITIALFOCUS: i32 = -213;
pub const PSNRET_NOERROR: u32 = 0;
pub const PSNRET_INVALID: u32 = 1;
pub const PSNRET_INVALID_NOCHANGEPAGE: u32 = 2;
pub const PSNRET_MESSAGEHANDLED: u32 = 3;
pub const PSM_SETCURSEL: u32 = 1125;
pub const PSM_REMOVEPAGE: u32 = 1126;
pub const PSM_ADDPAGE: u32 = 1127;
pub const PSM_CHANGED: u32 = 1128;
pub const PSM_RESTARTWINDOWS: u32 = 1129;
pub const PSM_REBOOTSYSTEM: u32 = 1130;
pub const PSM_CANCELTOCLOSE: u32 = 1131;
pub const PSM_QUERYSIBLINGS: u32 = 1132;
pub const PSM_UNCHANGED: u32 = 1133;
pub const PSM_APPLY: u32 = 1134;
pub const PSM_SETTITLEA: u32 = 1135;
pub const PSM_SETTITLEW: u32 = 1144;
pub const PSM_SETTITLE: u32 = 1135;
pub const PSM_SETWIZBUTTONS: u32 = 1136;
pub const PSWIZB_BACK: u32 = 1;
pub const PSWIZB_NEXT: u32 = 2;
pub const PSWIZB_FINISH: u32 = 4;
pub const PSWIZB_DISABLEDFINISH: u32 = 8;
pub const PSWIZBF_ELEVATIONREQUIRED: u32 = 1;
pub const PSWIZB_CANCEL: u32 = 16;
pub const PSM_PRESSBUTTON: u32 = 1137;
pub const PSBTN_BACK: u32 = 0;
pub const PSBTN_NEXT: u32 = 1;
pub const PSBTN_FINISH: u32 = 2;
pub const PSBTN_OK: u32 = 3;
pub const PSBTN_APPLYNOW: u32 = 4;
pub const PSBTN_CANCEL: u32 = 5;
pub const PSBTN_HELP: u32 = 6;
pub const PSBTN_MAX: u32 = 6;
pub const PSM_SETCURSELID: u32 = 1138;
pub const PSM_SETFINISHTEXTA: u32 = 1139;
pub const PSM_SETFINISHTEXTW: u32 = 1145;
pub const PSM_SETFINISHTEXT: u32 = 1139;
pub const PSM_GETTABCONTROL: u32 = 1140;
pub const PSM_ISDIALOGMESSAGE: u32 = 1141;
pub const PSM_GETCURRENTPAGEHWND: u32 = 1142;
pub const PSM_INSERTPAGE: u32 = 1143;
pub const PSM_SETHEADERTITLEA: u32 = 1149;
pub const PSM_SETHEADERTITLEW: u32 = 1150;
pub const PSM_SETHEADERTITLE: u32 = 1149;
pub const PSM_SETHEADERSUBTITLEA: u32 = 1151;
pub const PSM_SETHEADERSUBTITLEW: u32 = 1152;
pub const PSM_SETHEADERSUBTITLE: u32 = 1151;
pub const PSM_HWNDTOINDEX: u32 = 1153;
pub const PSM_INDEXTOHWND: u32 = 1154;
pub const PSM_PAGETOINDEX: u32 = 1155;
pub const PSM_INDEXTOPAGE: u32 = 1156;
pub const PSM_IDTOINDEX: u32 = 1157;
pub const PSM_INDEXTOID: u32 = 1158;
pub const PSM_GETRESULT: u32 = 1159;
pub const PSM_RECALCPAGESIZES: u32 = 1160;
pub const PSM_SETNEXTTEXTW: u32 = 1161;
pub const PSM_SETNEXTTEXT: u32 = 1161;
pub const PSWIZB_SHOW: u32 = 0;
pub const PSWIZB_RESTORE: u32 = 1;
pub const PSM_SHOWWIZBUTTONS: u32 = 1162;
pub const PSM_ENABLEWIZBUTTONS: u32 = 1163;
pub const PSM_SETBUTTONTEXTW: u32 = 1164;
pub const PSM_SETBUTTONTEXT: u32 = 1164;
pub const ID_PSRESTARTWINDOWS: u32 = 2;
pub const ID_PSREBOOTSYSTEM: u32 = 3;
pub const WIZ_CXDLG: u32 = 276;
pub const WIZ_CYDLG: u32 = 140;
pub const WIZ_CXBMP: u32 = 80;
pub const WIZ_BODYX: u32 = 92;
pub const WIZ_BODYCX: u32 = 184;
pub const PROP_SM_CXDLG: u32 = 212;
pub const PROP_SM_CYDLG: u32 = 188;
pub const PROP_MED_CXDLG: u32 = 227;
pub const PROP_MED_CYDLG: u32 = 215;
pub const PROP_LG_CXDLG: u32 = 252;
pub const PROP_LG_CYDLG: u32 = 218;
pub const DSPRINT_PUBLISH: u32 = 1;
pub const DSPRINT_UPDATE: u32 = 2;
pub const DSPRINT_UNPUBLISH: u32 = 4;
pub const DSPRINT_REPUBLISH: u32 = 8;
pub const DSPRINT_PENDING: u32 = 2147483648;
pub const PRINTER_CONTROL_PAUSE: u32 = 1;
pub const PRINTER_CONTROL_RESUME: u32 = 2;
pub const PRINTER_CONTROL_PURGE: u32 = 3;
pub const PRINTER_CONTROL_SET_STATUS: u32 = 4;
pub const PRINTER_STATUS_PAUSED: u32 = 1;
pub const PRINTER_STATUS_ERROR: u32 = 2;
pub const PRINTER_STATUS_PENDING_DELETION: u32 = 4;
pub const PRINTER_STATUS_PAPER_JAM: u32 = 8;
pub const PRINTER_STATUS_PAPER_OUT: u32 = 16;
pub const PRINTER_STATUS_MANUAL_FEED: u32 = 32;
pub const PRINTER_STATUS_PAPER_PROBLEM: u32 = 64;
pub const PRINTER_STATUS_OFFLINE: u32 = 128;
pub const PRINTER_STATUS_IO_ACTIVE: u32 = 256;
pub const PRINTER_STATUS_BUSY: u32 = 512;
pub const PRINTER_STATUS_PRINTING: u32 = 1024;
pub const PRINTER_STATUS_OUTPUT_BIN_FULL: u32 = 2048;
pub const PRINTER_STATUS_NOT_AVAILABLE: u32 = 4096;
pub const PRINTER_STATUS_WAITING: u32 = 8192;
pub const PRINTER_STATUS_PROCESSING: u32 = 16384;
pub const PRINTER_STATUS_INITIALIZING: u32 = 32768;
pub const PRINTER_STATUS_WARMING_UP: u32 = 65536;
pub const PRINTER_STATUS_TONER_LOW: u32 = 131072;
pub const PRINTER_STATUS_NO_TONER: u32 = 262144;
pub const PRINTER_STATUS_PAGE_PUNT: u32 = 524288;
pub const PRINTER_STATUS_USER_INTERVENTION: u32 = 1048576;
pub const PRINTER_STATUS_OUT_OF_MEMORY: u32 = 2097152;
pub const PRINTER_STATUS_DOOR_OPEN: u32 = 4194304;
pub const PRINTER_STATUS_SERVER_UNKNOWN: u32 = 8388608;
pub const PRINTER_STATUS_POWER_SAVE: u32 = 16777216;
pub const PRINTER_STATUS_SERVER_OFFLINE: u32 = 33554432;
pub const PRINTER_STATUS_DRIVER_UPDATE_NEEDED: u32 = 67108864;
pub const PRINTER_ATTRIBUTE_QUEUED: u32 = 1;
pub const PRINTER_ATTRIBUTE_DIRECT: u32 = 2;
pub const PRINTER_ATTRIBUTE_DEFAULT: u32 = 4;
pub const PRINTER_ATTRIBUTE_SHARED: u32 = 8;
pub const PRINTER_ATTRIBUTE_NETWORK: u32 = 16;
pub const PRINTER_ATTRIBUTE_HIDDEN: u32 = 32;
pub const PRINTER_ATTRIBUTE_LOCAL: u32 = 64;
pub const PRINTER_ATTRIBUTE_ENABLE_DEVQ: u32 = 128;
pub const PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS: u32 = 256;
pub const PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST: u32 = 512;
pub const PRINTER_ATTRIBUTE_WORK_OFFLINE: u32 = 1024;
pub const PRINTER_ATTRIBUTE_ENABLE_BIDI: u32 = 2048;
pub const PRINTER_ATTRIBUTE_RAW_ONLY: u32 = 4096;
pub const PRINTER_ATTRIBUTE_PUBLISHED: u32 = 8192;
pub const PRINTER_ATTRIBUTE_FAX: u32 = 16384;
pub const PRINTER_ATTRIBUTE_TS: u32 = 32768;
pub const PRINTER_ATTRIBUTE_PUSHED_USER: u32 = 131072;
pub const PRINTER_ATTRIBUTE_PUSHED_MACHINE: u32 = 262144;
pub const PRINTER_ATTRIBUTE_MACHINE: u32 = 524288;
pub const PRINTER_ATTRIBUTE_FRIENDLY_NAME: u32 = 1048576;
pub const PRINTER_ATTRIBUTE_TS_GENERIC_DRIVER: u32 = 2097152;
pub const PRINTER_ATTRIBUTE_PER_USER: u32 = 4194304;
pub const PRINTER_ATTRIBUTE_ENTERPRISE_CLOUD: u32 = 8388608;
pub const NO_PRIORITY: u32 = 0;
pub const MAX_PRIORITY: u32 = 99;
pub const MIN_PRIORITY: u32 = 1;
pub const DEF_PRIORITY: u32 = 1;
pub const JOB_CONTROL_PAUSE: u32 = 1;
pub const JOB_CONTROL_RESUME: u32 = 2;
pub const JOB_CONTROL_CANCEL: u32 = 3;
pub const JOB_CONTROL_RESTART: u32 = 4;
pub const JOB_CONTROL_DELETE: u32 = 5;
pub const JOB_CONTROL_SENT_TO_PRINTER: u32 = 6;
pub const JOB_CONTROL_LAST_PAGE_EJECTED: u32 = 7;
pub const JOB_CONTROL_RETAIN: u32 = 8;
pub const JOB_CONTROL_RELEASE: u32 = 9;
pub const JOB_CONTROL_SEND_TOAST: u32 = 10;
pub const JOB_STATUS_PAUSED: u32 = 1;
pub const JOB_STATUS_ERROR: u32 = 2;
pub const JOB_STATUS_DELETING: u32 = 4;
pub const JOB_STATUS_SPOOLING: u32 = 8;
pub const JOB_STATUS_PRINTING: u32 = 16;
pub const JOB_STATUS_OFFLINE: u32 = 32;
pub const JOB_STATUS_PAPEROUT: u32 = 64;
pub const JOB_STATUS_PRINTED: u32 = 128;
pub const JOB_STATUS_DELETED: u32 = 256;
pub const JOB_STATUS_BLOCKED_DEVQ: u32 = 512;
pub const JOB_STATUS_USER_INTERVENTION: u32 = 1024;
pub const JOB_STATUS_RESTART: u32 = 2048;
pub const JOB_STATUS_COMPLETE: u32 = 4096;
pub const JOB_STATUS_RETAINED: u32 = 8192;
pub const JOB_STATUS_RENDERING_LOCALLY: u32 = 16384;
pub const JOB_POSITION_UNSPECIFIED: u32 = 0;
pub const PRINTER_DRIVER_PACKAGE_AWARE: u32 = 1;
pub const PRINTER_DRIVER_XPS: u32 = 2;
pub const PRINTER_DRIVER_SANDBOX_ENABLED: u32 = 4;
pub const PRINTER_DRIVER_CLASS: u32 = 8;
pub const PRINTER_DRIVER_DERIVED: u32 = 16;
pub const PRINTER_DRIVER_NOT_SHAREABLE: u32 = 32;
pub const PRINTER_DRIVER_CATEGORY_FAX: u32 = 64;
pub const PRINTER_DRIVER_CATEGORY_FILE: u32 = 128;
pub const PRINTER_DRIVER_CATEGORY_VIRTUAL: u32 = 256;
pub const PRINTER_DRIVER_CATEGORY_SERVICE: u32 = 512;
pub const PRINTER_DRIVER_SOFT_RESET_REQUIRED: u32 = 1024;
pub const PRINTER_DRIVER_SANDBOX_DISABLED: u32 = 2048;
pub const PRINTER_DRIVER_CATEGORY_3D: u32 = 4096;
pub const PRINTER_DRIVER_CATEGORY_CLOUD: u32 = 8192;
pub const DRIVER_KERNELMODE: u32 = 1;
pub const DRIVER_USERMODE: u32 = 2;
pub const DPD_DELETE_UNUSED_FILES: u32 = 1;
pub const DPD_DELETE_SPECIFIC_VERSION: u32 = 2;
pub const DPD_DELETE_ALL_FILES: u32 = 4;
pub const APD_STRICT_UPGRADE: u32 = 1;
pub const APD_STRICT_DOWNGRADE: u32 = 2;
pub const APD_COPY_ALL_FILES: u32 = 4;
pub const APD_COPY_NEW_FILES: u32 = 8;
pub const APD_COPY_FROM_DIRECTORY: u32 = 16;
pub const STRING_NONE: u32 = 1;
pub const STRING_MUIDLL: u32 = 2;
pub const STRING_LANGPAIR: u32 = 4;
pub const MAX_FORM_KEYWORD_LENGTH: u32 = 64;
pub const DI_CHANNEL: u32 = 1;
pub const DI_READ_SPOOL_JOB: u32 = 3;
pub const DI_MEMORYMAP_WRITE: u32 = 1;
pub const FORM_USER: u32 = 0;
pub const FORM_BUILTIN: u32 = 1;
pub const FORM_PRINTER: u32 = 2;
pub const NORMAL_PRINT: u32 = 0;
pub const REVERSE_PRINT: u32 = 1;
pub const PPCAPS_RIGHT_THEN_DOWN: u32 = 1;
pub const PPCAPS_DOWN_THEN_RIGHT: u32 = 2;
pub const PPCAPS_LEFT_THEN_DOWN: u32 = 4;
pub const PPCAPS_DOWN_THEN_LEFT: u32 = 8;
pub const PPCAPS_BORDER_PRINT: u32 = 1;
pub const PPCAPS_BOOKLET_EDGE: u32 = 1;
pub const PPCAPS_REVERSE_PAGES_FOR_REVERSE_DUPLEX: u32 = 1;
pub const PPCAPS_DONT_SEND_EXTRA_PAGES_FOR_DUPLEX: u32 = 2;
pub const PPCAPS_SQUARE_SCALING: u32 = 1;
pub const PORT_TYPE_WRITE: u32 = 1;
pub const PORT_TYPE_READ: u32 = 2;
pub const PORT_TYPE_REDIRECTED: u32 = 4;
pub const PORT_TYPE_NET_ATTACHED: u32 = 8;
pub const PORT_STATUS_TYPE_ERROR: u32 = 1;
pub const PORT_STATUS_TYPE_WARNING: u32 = 2;
pub const PORT_STATUS_TYPE_INFO: u32 = 3;
pub const PORT_STATUS_OFFLINE: u32 = 1;
pub const PORT_STATUS_PAPER_JAM: u32 = 2;
pub const PORT_STATUS_PAPER_OUT: u32 = 3;
pub const PORT_STATUS_OUTPUT_BIN_FULL: u32 = 4;
pub const PORT_STATUS_PAPER_PROBLEM: u32 = 5;
pub const PORT_STATUS_NO_TONER: u32 = 6;
pub const PORT_STATUS_DOOR_OPEN: u32 = 7;
pub const PORT_STATUS_USER_INTERVENTION: u32 = 8;
pub const PORT_STATUS_OUT_OF_MEMORY: u32 = 9;
pub const PORT_STATUS_TONER_LOW: u32 = 10;
pub const PORT_STATUS_WARMING_UP: u32 = 11;
pub const PORT_STATUS_POWER_SAVE: u32 = 12;
pub const PRINTER_ENUM_DEFAULT: u32 = 1;
pub const PRINTER_ENUM_LOCAL: u32 = 2;
pub const PRINTER_ENUM_CONNECTIONS: u32 = 4;
pub const PRINTER_ENUM_FAVORITE: u32 = 4;
pub const PRINTER_ENUM_NAME: u32 = 8;
pub const PRINTER_ENUM_REMOTE: u32 = 16;
pub const PRINTER_ENUM_SHARED: u32 = 32;
pub const PRINTER_ENUM_NETWORK: u32 = 64;
pub const PRINTER_ENUM_EXPAND: u32 = 16384;
pub const PRINTER_ENUM_CONTAINER: u32 = 32768;
pub const PRINTER_ENUM_ICONMASK: u32 = 16711680;
pub const PRINTER_ENUM_ICON1: u32 = 65536;
pub const PRINTER_ENUM_ICON2: u32 = 131072;
pub const PRINTER_ENUM_ICON3: u32 = 262144;
pub const PRINTER_ENUM_ICON4: u32 = 524288;
pub const PRINTER_ENUM_ICON5: u32 = 1048576;
pub const PRINTER_ENUM_ICON6: u32 = 2097152;
pub const PRINTER_ENUM_ICON7: u32 = 4194304;
pub const PRINTER_ENUM_ICON8: u32 = 8388608;
pub const PRINTER_ENUM_HIDE: u32 = 16777216;
pub const PRINTER_ENUM_CATEGORY_ALL: u32 = 33554432;
pub const PRINTER_ENUM_CATEGORY_3D: u32 = 67108864;
pub const SPOOL_FILE_PERSISTENT: u32 = 1;
pub const SPOOL_FILE_TEMPORARY: u32 = 2;
pub const PRINTER_NOTIFY_TYPE: u32 = 0;
pub const JOB_NOTIFY_TYPE: u32 = 1;
pub const SERVER_NOTIFY_TYPE: u32 = 2;
pub const PRINTER_NOTIFY_FIELD_SERVER_NAME: u32 = 0;
pub const PRINTER_NOTIFY_FIELD_PRINTER_NAME: u32 = 1;
pub const PRINTER_NOTIFY_FIELD_SHARE_NAME: u32 = 2;
pub const PRINTER_NOTIFY_FIELD_PORT_NAME: u32 = 3;
pub const PRINTER_NOTIFY_FIELD_DRIVER_NAME: u32 = 4;
pub const PRINTER_NOTIFY_FIELD_COMMENT: u32 = 5;
pub const PRINTER_NOTIFY_FIELD_LOCATION: u32 = 6;
pub const PRINTER_NOTIFY_FIELD_DEVMODE: u32 = 7;
pub const PRINTER_NOTIFY_FIELD_SEPFILE: u32 = 8;
pub const PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR: u32 = 9;
pub const PRINTER_NOTIFY_FIELD_PARAMETERS: u32 = 10;
pub const PRINTER_NOTIFY_FIELD_DATATYPE: u32 = 11;
pub const PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR: u32 = 12;
pub const PRINTER_NOTIFY_FIELD_ATTRIBUTES: u32 = 13;
pub const PRINTER_NOTIFY_FIELD_PRIORITY: u32 = 14;
pub const PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY: u32 = 15;
pub const PRINTER_NOTIFY_FIELD_START_TIME: u32 = 16;
pub const PRINTER_NOTIFY_FIELD_UNTIL_TIME: u32 = 17;
pub const PRINTER_NOTIFY_FIELD_STATUS: u32 = 18;
pub const PRINTER_NOTIFY_FIELD_STATUS_STRING: u32 = 19;
pub const PRINTER_NOTIFY_FIELD_CJOBS: u32 = 20;
pub const PRINTER_NOTIFY_FIELD_AVERAGE_PPM: u32 = 21;
pub const PRINTER_NOTIFY_FIELD_TOTAL_PAGES: u32 = 22;
pub const PRINTER_NOTIFY_FIELD_PAGES_PRINTED: u32 = 23;
pub const PRINTER_NOTIFY_FIELD_TOTAL_BYTES: u32 = 24;
pub const PRINTER_NOTIFY_FIELD_BYTES_PRINTED: u32 = 25;
pub const PRINTER_NOTIFY_FIELD_OBJECT_GUID: u32 = 26;
pub const PRINTER_NOTIFY_FIELD_FRIENDLY_NAME: u32 = 27;
pub const PRINTER_NOTIFY_FIELD_BRANCH_OFFICE_PRINTING: u32 = 28;
pub const JOB_NOTIFY_FIELD_PRINTER_NAME: u32 = 0;
pub const JOB_NOTIFY_FIELD_MACHINE_NAME: u32 = 1;
pub const JOB_NOTIFY_FIELD_PORT_NAME: u32 = 2;
pub const JOB_NOTIFY_FIELD_USER_NAME: u32 = 3;
pub const JOB_NOTIFY_FIELD_NOTIFY_NAME: u32 = 4;
pub const JOB_NOTIFY_FIELD_DATATYPE: u32 = 5;
pub const JOB_NOTIFY_FIELD_PRINT_PROCESSOR: u32 = 6;
pub const JOB_NOTIFY_FIELD_PARAMETERS: u32 = 7;
pub const JOB_NOTIFY_FIELD_DRIVER_NAME: u32 = 8;
pub const JOB_NOTIFY_FIELD_DEVMODE: u32 = 9;
pub const JOB_NOTIFY_FIELD_STATUS: u32 = 10;
pub const JOB_NOTIFY_FIELD_STATUS_STRING: u32 = 11;
pub const JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR: u32 = 12;
pub const JOB_NOTIFY_FIELD_DOCUMENT: u32 = 13;
pub const JOB_NOTIFY_FIELD_PRIORITY: u32 = 14;
pub const JOB_NOTIFY_FIELD_POSITION: u32 = 15;
pub const JOB_NOTIFY_FIELD_SUBMITTED: u32 = 16;
pub const JOB_NOTIFY_FIELD_START_TIME: u32 = 17;
pub const JOB_NOTIFY_FIELD_UNTIL_TIME: u32 = 18;
pub const JOB_NOTIFY_FIELD_TIME: u32 = 19;
pub const JOB_NOTIFY_FIELD_TOTAL_PAGES: u32 = 20;
pub const JOB_NOTIFY_FIELD_PAGES_PRINTED: u32 = 21;
pub const JOB_NOTIFY_FIELD_TOTAL_BYTES: u32 = 22;
pub const JOB_NOTIFY_FIELD_BYTES_PRINTED: u32 = 23;
pub const JOB_NOTIFY_FIELD_REMOTE_JOB_ID: u32 = 24;
pub const SERVER_NOTIFY_FIELD_PRINT_DRIVER_ISOLATION_GROUP: u32 = 0;
pub const PRINTER_NOTIFY_CATEGORY_ALL: u32 = 4096;
pub const PRINTER_NOTIFY_CATEGORY_3D: u32 = 8192;
pub const PRINTER_NOTIFY_OPTIONS_REFRESH: u32 = 1;
pub const PRINTER_NOTIFY_INFO_DISCARDED: u32 = 1;
pub const BIDI_ACTION_ENUM_SCHEMA: &[u8; 11usize] = b"EnumSchema\0";
pub const BIDI_ACTION_GET: &[u8; 4usize] = b"Get\0";
pub const BIDI_ACTION_SET: &[u8; 4usize] = b"Set\0";
pub const BIDI_ACTION_GET_ALL: &[u8; 7usize] = b"GetAll\0";
pub const BIDI_ACTION_GET_WITH_ARGUMENT: &[u8; 16usize] = b"GetWithArgument\0";
pub const BIDI_ACCESS_ADMINISTRATOR: u32 = 1;
pub const BIDI_ACCESS_USER: u32 = 2;
pub const ERROR_BIDI_STATUS_OK: u32 = 0;
pub const ERROR_BIDI_NOT_SUPPORTED: u32 = 50;
pub const ERROR_BIDI_ERROR_BASE: u32 = 13000;
pub const ERROR_BIDI_STATUS_WARNING: u32 = 13001;
pub const ERROR_BIDI_SCHEMA_READ_ONLY: u32 = 13002;
pub const ERROR_BIDI_SERVER_OFFLINE: u32 = 13003;
pub const ERROR_BIDI_DEVICE_OFFLINE: u32 = 13004;
pub const ERROR_BIDI_SCHEMA_NOT_SUPPORTED: u32 = 13005;
pub const ERROR_BIDI_SET_DIFFERENT_TYPE: u32 = 13006;
pub const ERROR_BIDI_SET_MULTIPLE_SCHEMAPATH: u32 = 13007;
pub const ERROR_BIDI_SET_INVALID_SCHEMAPATH: u32 = 13008;
pub const ERROR_BIDI_SET_UNKNOWN_FAILURE: u32 = 13009;
pub const ERROR_BIDI_SCHEMA_WRITE_ONLY: u32 = 13010;
pub const ERROR_BIDI_GET_REQUIRES_ARGUMENT: u32 = 13011;
pub const ERROR_BIDI_GET_ARGUMENT_NOT_SUPPORTED: u32 = 13012;
pub const ERROR_BIDI_GET_MISSING_ARGUMENT: u32 = 13013;
pub const ERROR_BIDI_DEVICE_CONFIG_UNCHANGED: u32 = 13014;
pub const ERROR_BIDI_NO_LOCALIZED_RESOURCES: u32 = 13015;
pub const ERROR_BIDI_NO_BIDI_SCHEMA_EXTENSIONS: u32 = 13016;
pub const ERROR_BIDI_UNSUPPORTED_CLIENT_LANGUAGE: u32 = 13017;
pub const ERROR_BIDI_UNSUPPORTED_RESOURCE_FORMAT: u32 = 13018;
pub const PRINTER_CHANGE_ADD_PRINTER: u32 = 1;
pub const PRINTER_CHANGE_SET_PRINTER: u32 = 2;
pub const PRINTER_CHANGE_DELETE_PRINTER: u32 = 4;
pub const PRINTER_CHANGE_FAILED_CONNECTION_PRINTER: u32 = 8;
pub const PRINTER_CHANGE_PRINTER: u32 = 255;
pub const PRINTER_CHANGE_ADD_JOB: u32 = 256;
pub const PRINTER_CHANGE_SET_JOB: u32 = 512;
pub const PRINTER_CHANGE_DELETE_JOB: u32 = 1024;
pub const PRINTER_CHANGE_WRITE_JOB: u32 = 2048;
pub const PRINTER_CHANGE_JOB: u32 = 65280;
pub const PRINTER_CHANGE_ADD_FORM: u32 = 65536;
pub const PRINTER_CHANGE_SET_FORM: u32 = 131072;
pub const PRINTER_CHANGE_DELETE_FORM: u32 = 262144;
pub const PRINTER_CHANGE_FORM: u32 = 458752;
pub const PRINTER_CHANGE_ADD_PORT: u32 = 1048576;
pub const PRINTER_CHANGE_CONFIGURE_PORT: u32 = 2097152;
pub const PRINTER_CHANGE_DELETE_PORT: u32 = 4194304;
pub const PRINTER_CHANGE_PORT: u32 = 7340032;
pub const PRINTER_CHANGE_ADD_PRINT_PROCESSOR: u32 = 16777216;
pub const PRINTER_CHANGE_DELETE_PRINT_PROCESSOR: u32 = 67108864;
pub const PRINTER_CHANGE_PRINT_PROCESSOR: u32 = 117440512;
pub const PRINTER_CHANGE_SERVER: u32 = 134217728;
pub const PRINTER_CHANGE_ADD_PRINTER_DRIVER: u32 = 268435456;
pub const PRINTER_CHANGE_SET_PRINTER_DRIVER: u32 = 536870912;
pub const PRINTER_CHANGE_DELETE_PRINTER_DRIVER: u32 = 1073741824;
pub const PRINTER_CHANGE_PRINTER_DRIVER: u32 = 1879048192;
pub const PRINTER_CHANGE_TIMEOUT: u32 = 2147483648;
pub const PRINTER_CHANGE_ALL: u32 = 2138570751;
pub const PRINTER_ERROR_INFORMATION: u32 = 2147483648;
pub const PRINTER_ERROR_WARNING: u32 = 1073741824;
pub const PRINTER_ERROR_SEVERE: u32 = 536870912;
pub const PRINTER_ERROR_OUTOFPAPER: u32 = 1;
pub const PRINTER_ERROR_JAM: u32 = 2;
pub const PRINTER_ERROR_OUTOFTONER: u32 = 4;
pub const SPLREG_PRINT_DRIVER_ISOLATION_GROUPS_SEPARATOR: u8 = 92u8;
pub const SERVER_ACCESS_ADMINISTER: u32 = 1;
pub const SERVER_ACCESS_ENUMERATE: u32 = 2;
pub const PRINTER_ACCESS_ADMINISTER: u32 = 4;
pub const PRINTER_ACCESS_USE: u32 = 8;
pub const JOB_ACCESS_ADMINISTER: u32 = 16;
pub const JOB_ACCESS_READ: u32 = 32;
pub const PRINTER_ACCESS_MANAGE_LIMITED: u32 = 64;
pub const SERVER_ALL_ACCESS: u32 = 983043;
pub const SERVER_READ: u32 = 131074;
pub const SERVER_WRITE: u32 = 131075;
pub const SERVER_EXECUTE: u32 = 131074;
pub const PRINTER_ALL_ACCESS: u32 = 983052;
pub const PRINTER_READ: u32 = 131080;
pub const PRINTER_WRITE: u32 = 131080;
pub const PRINTER_EXECUTE: u32 = 131080;
pub const JOB_ALL_ACCESS: u32 = 983088;
pub const JOB_READ: u32 = 131104;
pub const JOB_WRITE: u32 = 131088;
pub const JOB_EXECUTE: u32 = 131088;
pub const PRINTER_CONNECTION_MISMATCH: u32 = 32;
pub const PRINTER_CONNECTION_NO_UI: u32 = 64;
pub const IPDFP_COPY_ALL_FILES: u32 = 1;
pub const UPDP_SILENT_UPLOAD: u32 = 1;
pub const UPDP_UPLOAD_ALWAYS: u32 = 2;
pub const UPDP_CHECK_DRIVERSTORE: u32 = 4;
pub const MS_PRINT_JOB_OUTPUT_FILE: &[u8; 21usize] = b"MsPrintJobOutputFile\0";
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _CRT_INTERNAL_COMBASE_SYMBOL_PREFIX: &[u8; 1usize] = b"\0";
pub const COM_RIGHTS_EXECUTE: u32 = 1;
pub const COM_RIGHTS_EXECUTE_LOCAL: u32 = 2;
pub const COM_RIGHTS_EXECUTE_REMOTE: u32 = 4;
pub const COM_RIGHTS_ACTIVATE_LOCAL: u32 = 8;
pub const COM_RIGHTS_ACTIVATE_REMOTE: u32 = 16;
pub const COM_RIGHTS_RESERVED1: u32 = 32;
pub const COM_RIGHTS_RESERVED2: u32 = 64;
pub const CWMO_MAX_HANDLES: u32 = 56;
pub const FADF_AUTO: u32 = 1;
pub const FADF_STATIC: u32 = 2;
pub const FADF_EMBEDDED: u32 = 4;
pub const FADF_FIXEDSIZE: u32 = 16;
pub const FADF_RECORD: u32 = 32;
pub const FADF_HAVEIID: u32 = 64;
pub const FADF_HAVEVARTYPE: u32 = 128;
pub const FADF_BSTR: u32 = 256;
pub const FADF_UNKNOWN: u32 = 512;
pub const FADF_DISPATCH: u32 = 1024;
pub const FADF_VARIANT: u32 = 2048;
pub const FADF_RESERVED: u32 = 61448;
pub const PARAMFLAG_NONE: u32 = 0;
pub const PARAMFLAG_FIN: u32 = 1;
pub const PARAMFLAG_FOUT: u32 = 2;
pub const PARAMFLAG_FLCID: u32 = 4;
pub const PARAMFLAG_FRETVAL: u32 = 8;
pub const PARAMFLAG_FOPT: u32 = 16;
pub const PARAMFLAG_FHASDEFAULT: u32 = 32;
pub const PARAMFLAG_FHASCUSTDATA: u32 = 64;
pub const IDLFLAG_NONE: u32 = 0;
pub const IDLFLAG_FIN: u32 = 1;
pub const IDLFLAG_FOUT: u32 = 2;
pub const IDLFLAG_FLCID: u32 = 4;
pub const IDLFLAG_FRETVAL: u32 = 8;
pub const IMPLTYPEFLAG_FDEFAULT: u32 = 1;
pub const IMPLTYPEFLAG_FSOURCE: u32 = 2;
pub const IMPLTYPEFLAG_FRESTRICTED: u32 = 4;
pub const IMPLTYPEFLAG_FDEFAULTVTABLE: u32 = 8;
pub const DISPID_UNKNOWN: i32 = -1;
pub const DISPID_VALUE: u32 = 0;
pub const DISPID_PROPERTYPUT: i32 = -3;
pub const DISPID_NEWENUM: i32 = -4;
pub const DISPID_EVALUATE: i32 = -5;
pub const DISPID_CONSTRUCTOR: i32 = -6;
pub const DISPID_DESTRUCTOR: i32 = -7;
pub const DISPID_COLLECT: i32 = -8;
pub const PROPSETFLAG_DEFAULT: u32 = 0;
pub const PROPSETFLAG_NONSIMPLE: u32 = 1;
pub const PROPSETFLAG_ANSI: u32 = 2;
pub const PROPSETFLAG_UNBUFFERED: u32 = 4;
pub const PROPSETFLAG_CASE_SENSITIVE: u32 = 8;
pub const PROPSET_BEHAVIOR_CASE_SENSITIVE: u32 = 1;
pub const PID_DICTIONARY: u32 = 0;
pub const PID_CODEPAGE: u32 = 1;
pub const PID_FIRST_USABLE: u32 = 2;
pub const PID_FIRST_NAME_DEFAULT: u32 = 4095;
pub const PID_LOCALE: u32 = 2147483648;
pub const PID_MODIFY_TIME: u32 = 2147483649;
pub const PID_SECURITY: u32 = 2147483650;
pub const PID_BEHAVIOR: u32 = 2147483651;
pub const PID_ILLEGAL: u32 = 4294967295;
pub const PID_MIN_READONLY: u32 = 2147483648;
pub const PID_MAX_READONLY: u32 = 3221225471;
pub const PRSPEC_INVALID: u32 = 4294967295;
pub const PRSPEC_LPWSTR: u32 = 0;
pub const PRSPEC_PROPID: u32 = 1;
pub const PROPSETHDR_OSVERSION_UNKNOWN: u32 = 4294967295;
pub const CWCSTORAGENAME: u32 = 32;
pub const STGM_DIRECT: u32 = 0;
pub const STGM_TRANSACTED: u32 = 65536;
pub const STGM_SIMPLE: u32 = 134217728;
pub const STGM_READ: u32 = 0;
pub const STGM_WRITE: u32 = 1;
pub const STGM_READWRITE: u32 = 2;
pub const STGM_SHARE_DENY_NONE: u32 = 64;
pub const STGM_SHARE_DENY_READ: u32 = 48;
pub const STGM_SHARE_DENY_WRITE: u32 = 32;
pub const STGM_SHARE_EXCLUSIVE: u32 = 16;
pub const STGM_PRIORITY: u32 = 262144;
pub const STGM_DELETEONRELEASE: u32 = 67108864;
pub const STGM_NOSCRATCH: u32 = 1048576;
pub const STGM_CREATE: u32 = 4096;
pub const STGM_CONVERT: u32 = 131072;
pub const STGM_FAILIFTHERE: u32 = 0;
pub const STGM_NOSNAPSHOT: u32 = 2097152;
pub const STGM_DIRECT_SWMR: u32 = 4194304;
pub const STGFMT_STORAGE: u32 = 0;
pub const STGFMT_NATIVE: u32 = 1;
pub const STGFMT_FILE: u32 = 3;
pub const STGFMT_ANY: u32 = 4;
pub const STGFMT_DOCFILE: u32 = 5;
pub const STGFMT_DOCUMENT: u32 = 0;
pub const STGOPTIONS_VERSION: u32 = 2;
pub const CCH_MAX_PROPSTG_NAME: u32 = 31;
pub const MARSHALINTERFACE_MIN: u32 = 500;
pub const ASYNC_MODE_COMPATIBILITY: u32 = 1;
pub const ASYNC_MODE_DEFAULT: u32 = 0;
pub const STGTY_REPEAT: u32 = 256;
pub const STG_TOEND: u32 = 4294967295;
pub const STG_LAYOUT_SEQUENTIAL: u32 = 0;
pub const STG_LAYOUT_INTERLEAVED: u32 = 1;
pub const UPDFCACHE_NODATACACHE: u32 = 1;
pub const UPDFCACHE_ONSAVECACHE: u32 = 2;
pub const UPDFCACHE_ONSTOPCACHE: u32 = 4;
pub const UPDFCACHE_NORMALCACHE: u32 = 8;
pub const UPDFCACHE_IFBLANK: u32 = 16;
pub const UPDFCACHE_ONLYIFBLANK: u32 = 2147483648;
pub const UPDFCACHE_IFBLANKORONSAVECACHE: u32 = 18;
pub const MK_ALT: u32 = 32;
pub const DROPEFFECT_NONE: u32 = 0;
pub const DROPEFFECT_COPY: u32 = 1;
pub const DROPEFFECT_MOVE: u32 = 2;
pub const DROPEFFECT_LINK: u32 = 4;
pub const DROPEFFECT_SCROLL: u32 = 2147483648;
pub const DD_DEFSCROLLINSET: u32 = 11;
pub const DD_DEFSCROLLDELAY: u32 = 50;
pub const DD_DEFSCROLLINTERVAL: u32 = 50;
pub const DD_DEFDRAGDELAY: u32 = 200;
pub const DD_DEFDRAGMINDIST: u32 = 2;
pub const MKSYS_URLMONIKER: u32 = 6;
pub const URL_MK_LEGACY: u32 = 0;
pub const URL_MK_UNIFORM: u32 = 1;
pub const URL_MK_NO_CANONICALIZE: u32 = 2;
pub const FIEF_FLAG_FORCE_JITUI: u32 = 1;
pub const FIEF_FLAG_PEEK: u32 = 2;
pub const FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK: u32 = 4;
pub const FIEF_FLAG_RESERVED_0: u32 = 8;
pub const FMFD_DEFAULT: u32 = 0;
pub const FMFD_URLASFILENAME: u32 = 1;
pub const FMFD_ENABLEMIMESNIFFING: u32 = 2;
pub const FMFD_IGNOREMIMETEXTPLAIN: u32 = 4;
pub const FMFD_SERVERMIME: u32 = 8;
pub const FMFD_RESPECTTEXTPLAIN: u32 = 16;
pub const FMFD_RETURNUPDATEDIMGMIMES: u32 = 32;
pub const FMFD_RESERVED_1: u32 = 64;
pub const FMFD_RESERVED_2: u32 = 128;
pub const UAS_EXACTLEGACY: u32 = 4096;
pub const URLMON_OPTION_USERAGENT: u32 = 268435457;
pub const URLMON_OPTION_USERAGENT_REFRESH: u32 = 268435458;
pub const URLMON_OPTION_URL_ENCODING: u32 = 268435460;
pub const URLMON_OPTION_USE_BINDSTRINGCREDS: u32 = 268435464;
pub const URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS: u32 = 268435472;
pub const CF_NULL: u32 = 0;
pub const CFSTR_MIME_NULL: u32 = 0;
pub const Uri_CREATE_ALLOW_RELATIVE: u32 = 1;
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME: u32 = 2;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME: u32 = 4;
pub const Uri_CREATE_NOFRAG: u32 = 8;
pub const Uri_CREATE_NO_CANONICALIZE: u32 = 16;
pub const Uri_CREATE_CANONICALIZE: u32 = 256;
pub const Uri_CREATE_FILE_USE_DOS_PATH: u32 = 32;
pub const Uri_CREATE_DECODE_EXTRA_INFO: u32 = 64;
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO: u32 = 128;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES: u32 = 512;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES: u32 = 1024;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI: u32 = 2048;
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI: u32 = 4096;
pub const Uri_CREATE_IE_SETTINGS: u32 = 8192;
pub const Uri_CREATE_NO_IE_SETTINGS: u32 = 16384;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS: u32 = 32768;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS: u32 = 65536;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE: u32 = 131072;
pub const Uri_DISPLAY_NO_FRAGMENT: u32 = 1;
pub const Uri_PUNYCODE_IDN_HOST: u32 = 2;
pub const Uri_DISPLAY_IDN_HOST: u32 = 4;
pub const Uri_DISPLAY_NO_PUNYCODE: u32 = 8;
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8: u32 = 1;
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_CP: u32 = 2;
pub const Uri_ENCODING_HOST_IS_IDN: u32 = 4;
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8: u32 = 8;
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP: u32 = 16;
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8: u32 = 32;
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP: u32 = 64;
pub const Uri_ENCODING_RFC: u32 = 41;
pub const UriBuilder_USE_ORIGINAL_FLAGS: u32 = 1;
pub const WININETINFO_OPTION_LOCK_HANDLE: u32 = 65534;
pub const URLOSTRM_USECACHEDCOPY_ONLY: u32 = 1;
pub const URLOSTRM_USECACHEDCOPY: u32 = 2;
pub const URLOSTRM_GETNEWESTVERSION: u32 = 3;
pub const SET_FEATURE_ON_THREAD: u32 = 1;
pub const SET_FEATURE_ON_PROCESS: u32 = 2;
pub const SET_FEATURE_IN_REGISTRY: u32 = 4;
pub const SET_FEATURE_ON_THREAD_LOCALMACHINE: u32 = 8;
pub const SET_FEATURE_ON_THREAD_INTRANET: u32 = 16;
pub const SET_FEATURE_ON_THREAD_TRUSTED: u32 = 32;
pub const SET_FEATURE_ON_THREAD_INTERNET: u32 = 64;
pub const SET_FEATURE_ON_THREAD_RESTRICTED: u32 = 128;
pub const GET_FEATURE_FROM_THREAD: u32 = 1;
pub const GET_FEATURE_FROM_PROCESS: u32 = 2;
pub const GET_FEATURE_FROM_REGISTRY: u32 = 4;
pub const GET_FEATURE_FROM_THREAD_LOCALMACHINE: u32 = 8;
pub const GET_FEATURE_FROM_THREAD_INTRANET: u32 = 16;
pub const GET_FEATURE_FROM_THREAD_TRUSTED: u32 = 32;
pub const GET_FEATURE_FROM_THREAD_INTERNET: u32 = 64;
pub const GET_FEATURE_FROM_THREAD_RESTRICTED: u32 = 128;
pub const PROTOCOLFLAG_NO_PICS_CHECK: u32 = 1;
pub const MUTZ_NOSAVEDFILECHECK: u32 = 1;
pub const MUTZ_ISFILE: u32 = 2;
pub const MUTZ_ACCEPT_WILDCARD_SCHEME: u32 = 128;
pub const MUTZ_ENFORCERESTRICTED: u32 = 256;
pub const MUTZ_RESERVED: u32 = 512;
pub const MUTZ_REQUIRESAVEDFILECHECK: u32 = 1024;
pub const MUTZ_DONT_UNESCAPE: u32 = 2048;
pub const MUTZ_DONT_USE_CACHE: u32 = 4096;
pub const MUTZ_FORCE_INTRANET_FLAGS: u32 = 8192;
pub const MUTZ_IGNORE_ZONE_MAPPINGS: u32 = 16384;
pub const MAX_SIZE_SECURITY_ID: u32 = 512;
pub const URLACTION_MIN: u32 = 4096;
pub const URLACTION_DOWNLOAD_MIN: u32 = 4096;
pub const URLACTION_DOWNLOAD_SIGNED_ACTIVEX: u32 = 4097;
pub const URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX: u32 = 4100;
pub const URLACTION_DOWNLOAD_CURR_MAX: u32 = 4100;
pub const URLACTION_DOWNLOAD_MAX: u32 = 4607;
pub const URLACTION_ACTIVEX_MIN: u32 = 4608;
pub const URLACTION_ACTIVEX_RUN: u32 = 4608;
pub const URLPOLICY_ACTIVEX_CHECK_LIST: u32 = 65536;
pub const URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY: u32 = 4609;
pub const URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY: u32 = 4610;
pub const URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY: u32 = 4611;
pub const URLACTION_SCRIPT_OVERRIDE_SAFETY: u32 = 5121;
pub const URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY: u32 = 4612;
pub const URLACTION_ACTIVEX_TREATASUNTRUSTED: u32 = 4613;
pub const URLACTION_ACTIVEX_NO_WEBOC_SCRIPT: u32 = 4614;
pub const URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION: u32 = 4615;
pub const URLACTION_ACTIVEX_OVERRIDE_OPTIN: u32 = 4616;
pub const URLACTION_ACTIVEX_SCRIPTLET_RUN: u32 = 4617;
pub const URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION: u32 = 4618;
pub const URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST: u32 = 4619;
pub const URLACTION_ACTIVEX_ALLOW_TDC: u32 = 4620;
pub const URLACTION_ACTIVEX_CURR_MAX: u32 = 4620;
pub const URLACTION_ACTIVEX_MAX: u32 = 5119;
pub const URLACTION_SCRIPT_MIN: u32 = 5120;
pub const URLACTION_SCRIPT_RUN: u32 = 5120;
pub const URLACTION_SCRIPT_JAVA_USE: u32 = 5122;
pub const URLACTION_SCRIPT_SAFE_ACTIVEX: u32 = 5125;
pub const URLACTION_CROSS_DOMAIN_DATA: u32 = 5126;
pub const URLACTION_SCRIPT_PASTE: u32 = 5127;
pub const URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE: u32 = 5128;
pub const URLACTION_SCRIPT_XSSFILTER: u32 = 5129;
pub const URLACTION_SCRIPT_NAVIGATE: u32 = 5130;
pub const URLACTION_PLUGGABLE_PROTOCOL_XHR: u32 = 5131;
pub const URLACTION_ALLOW_VBSCRIPT_IE: u32 = 5132;
pub const URLACTION_ALLOW_JSCRIPT_IE: u32 = 5133;
pub const URLACTION_SCRIPT_CURR_MAX: u32 = 5133;
pub const URLACTION_SCRIPT_MAX: u32 = 5631;
pub const URLACTION_HTML_MIN: u32 = 5632;
pub const URLACTION_HTML_SUBMIT_FORMS: u32 = 5633;
pub const URLACTION_HTML_SUBMIT_FORMS_FROM: u32 = 5634;
pub const URLACTION_HTML_SUBMIT_FORMS_TO: u32 = 5635;
pub const URLACTION_HTML_FONT_DOWNLOAD: u32 = 5636;
pub const URLACTION_HTML_JAVA_RUN: u32 = 5637;
pub const URLACTION_HTML_USERDATA_SAVE: u32 = 5638;
pub const URLACTION_HTML_SUBFRAME_NAVIGATE: u32 = 5639;
pub const URLACTION_HTML_META_REFRESH: u32 = 5640;
pub const URLACTION_HTML_MIXED_CONTENT: u32 = 5641;
pub const URLACTION_HTML_INCLUDE_FILE_PATH: u32 = 5642;
pub const URLACTION_HTML_ALLOW_INJECTED_DYNAMIC_HTML: u32 = 5643;
pub const URLACTION_HTML_REQUIRE_UTF8_DOCUMENT_CODEPAGE: u32 = 5644;
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_CANVAS: u32 = 5645;
pub const URLACTION_HTML_ALLOW_WINDOW_CLOSE: u32 = 5646;
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_WEBWORKER: u32 = 5647;
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_TEXTTRACK: u32 = 5648;
pub const URLACTION_HTML_ALLOW_INDEXEDDB: u32 = 5649;
pub const URLACTION_HTML_MAX: u32 = 6143;
pub const URLACTION_SHELL_MIN: u32 = 6144;
pub const URLACTION_SHELL_INSTALL_DTITEMS: u32 = 6144;
pub const URLACTION_SHELL_MOVE_OR_COPY: u32 = 6146;
pub const URLACTION_SHELL_FILE_DOWNLOAD: u32 = 6147;
pub const URLACTION_SHELL_VERB: u32 = 6148;
pub const URLACTION_SHELL_WEBVIEW_VERB: u32 = 6149;
pub const URLACTION_SHELL_SHELLEXECUTE: u32 = 6150;
pub const URLACTION_SHELL_EXECUTE_HIGHRISK: u32 = 6150;
pub const URLACTION_SHELL_EXECUTE_MODRISK: u32 = 6151;
pub const URLACTION_SHELL_EXECUTE_LOWRISK: u32 = 6152;
pub const URLACTION_SHELL_POPUPMGR: u32 = 6153;
pub const URLACTION_SHELL_RTF_OBJECTS_LOAD: u32 = 6154;
pub const URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY: u32 = 6155;
pub const URLACTION_SHELL_EXTENSIONSECURITY: u32 = 6156;
pub const URLACTION_SHELL_SECURE_DRAGSOURCE: u32 = 6157;
pub const URLACTION_SHELL_REMOTEQUERY: u32 = 6158;
pub const URLACTION_SHELL_PREVIEW: u32 = 6159;
pub const URLACTION_SHELL_SHARE: u32 = 6160;
pub const URLACTION_SHELL_ALLOW_CROSS_SITE_SHARE: u32 = 6161;
pub const URLACTION_SHELL_TOCTOU_RISK: u32 = 6162;
pub const URLACTION_SHELL_CURR_MAX: u32 = 6162;
pub const URLACTION_SHELL_MAX: u32 = 6655;
pub const URLACTION_NETWORK_MIN: u32 = 6656;
pub const URLACTION_CREDENTIALS_USE: u32 = 6656;
pub const URLPOLICY_CREDENTIALS_SILENT_LOGON_OK: u32 = 0;
pub const URLPOLICY_CREDENTIALS_MUST_PROMPT_USER: u32 = 65536;
pub const URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT: u32 = 131072;
pub const URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY: u32 = 196608;
pub const URLACTION_AUTHENTICATE_CLIENT: u32 = 6657;
pub const URLPOLICY_AUTHENTICATE_CLEARTEXT_OK: u32 = 0;
pub const URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE: u32 = 65536;
pub const URLPOLICY_AUTHENTICATE_MUTUAL_ONLY: u32 = 196608;
pub const URLACTION_COOKIES: u32 = 6658;
pub const URLACTION_COOKIES_SESSION: u32 = 6659;
pub const URLACTION_CLIENT_CERT_PROMPT: u32 = 6660;
pub const URLACTION_COOKIES_THIRD_PARTY: u32 = 6661;
pub const URLACTION_COOKIES_SESSION_THIRD_PARTY: u32 = 6662;
pub const URLACTION_COOKIES_ENABLED: u32 = 6672;
pub const URLACTION_NETWORK_CURR_MAX: u32 = 6672;
pub const URLACTION_NETWORK_MAX: u32 = 7167;
pub const URLACTION_JAVA_MIN: u32 = 7168;
pub const URLACTION_JAVA_PERMISSIONS: u32 = 7168;
pub const URLPOLICY_JAVA_PROHIBIT: u32 = 0;
pub const URLPOLICY_JAVA_HIGH: u32 = 65536;
pub const URLPOLICY_JAVA_MEDIUM: u32 = 131072;
pub const URLPOLICY_JAVA_LOW: u32 = 196608;
pub const URLPOLICY_JAVA_CUSTOM: u32 = 8388608;
pub const URLACTION_JAVA_CURR_MAX: u32 = 7168;
pub const URLACTION_JAVA_MAX: u32 = 7423;
pub const URLACTION_INFODELIVERY_MIN: u32 = 7424;
pub const URLACTION_INFODELIVERY_NO_ADDING_CHANNELS: u32 = 7424;
pub const URLACTION_INFODELIVERY_NO_EDITING_CHANNELS: u32 = 7425;
pub const URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS: u32 = 7426;
pub const URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS: u32 = 7427;
pub const URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS: u32 = 7428;
pub const URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS: u32 = 7429;
pub const URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING: u32 = 7430;
pub const URLACTION_INFODELIVERY_CURR_MAX: u32 = 7430;
pub const URLACTION_INFODELIVERY_MAX: u32 = 7679;
pub const URLACTION_CHANNEL_SOFTDIST_MIN: u32 = 7680;
pub const URLACTION_CHANNEL_SOFTDIST_PERMISSIONS: u32 = 7685;
pub const URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT: u32 = 65536;
pub const URLPOLICY_CHANNEL_SOFTDIST_PRECACHE: u32 = 131072;
pub const URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL: u32 = 196608;
pub const URLACTION_CHANNEL_SOFTDIST_MAX: u32 = 7935;
pub const URLACTION_DOTNET_USERCONTROLS: u32 = 8197;
pub const URLACTION_BEHAVIOR_MIN: u32 = 8192;
pub const URLACTION_BEHAVIOR_RUN: u32 = 8192;
pub const URLPOLICY_BEHAVIOR_CHECK_LIST: u32 = 65536;
pub const URLACTION_FEATURE_MIN: u32 = 8448;
pub const URLACTION_FEATURE_MIME_SNIFFING: u32 = 8448;
pub const URLACTION_FEATURE_ZONE_ELEVATION: u32 = 8449;
pub const URLACTION_FEATURE_WINDOW_RESTRICTIONS: u32 = 8450;
pub const URLACTION_FEATURE_SCRIPT_STATUS_BAR: u32 = 8451;
pub const URLACTION_FEATURE_FORCE_ADDR_AND_STATUS: u32 = 8452;
pub const URLACTION_FEATURE_BLOCK_INPUT_PROMPTS: u32 = 8453;
pub const URLACTION_FEATURE_DATA_BINDING: u32 = 8454;
pub const URLACTION_FEATURE_CROSSDOMAIN_FOCUS_CHANGE: u32 = 8455;
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN: u32 = 8704;
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI: u32 = 8704;
pub const URLACTION_AUTOMATIC_ACTIVEX_UI: u32 = 8705;
pub const URLACTION_ALLOW_RESTRICTEDPROTOCOLS: u32 = 8960;
pub const URLACTION_ALLOW_APEVALUATION: u32 = 8961;
pub const URLACTION_ALLOW_XHR_EVALUATION: u32 = 8962;
pub const URLACTION_WINDOWS_BROWSER_APPLICATIONS: u32 = 9216;
pub const URLACTION_XPS_DOCUMENTS: u32 = 9217;
pub const URLACTION_LOOSE_XAML: u32 = 9218;
pub const URLACTION_LOWRIGHTS: u32 = 9472;
pub const URLACTION_WINFX_SETUP: u32 = 9728;
pub const URLACTION_INPRIVATE_BLOCKING: u32 = 9984;
pub const URLACTION_ALLOW_AUDIO_VIDEO: u32 = 9985;
pub const URLACTION_ALLOW_ACTIVEX_FILTERING: u32 = 9986;
pub const URLACTION_ALLOW_STRUCTURED_STORAGE_SNIFFING: u32 = 9987;
pub const URLACTION_ALLOW_AUDIO_VIDEO_PLUGINS: u32 = 9988;
pub const URLACTION_ALLOW_ZONE_ELEVATION_VIA_OPT_OUT: u32 = 9989;
pub const URLACTION_ALLOW_ZONE_ELEVATION_OPT_OUT_ADDITION: u32 = 9990;
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_WITHIN_WINDOW: u32 = 9992;
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_ACROSS_WINDOWS: u32 = 9993;
pub const URLACTION_ALLOW_CROSSDOMAIN_APPCACHE_MANIFEST: u32 = 9994;
pub const URLACTION_ALLOW_RENDER_LEGACY_DXTFILTERS: u32 = 9995;
pub const URLACTION_ALLOW_ANTIMALWARE_SCANNING_OF_ACTIVEX: u32 = 9996;
pub const URLACTION_ALLOW_CSS_EXPRESSIONS: u32 = 9997;
pub const URLPOLICY_ALLOW: u32 = 0;
pub const URLPOLICY_QUERY: u32 = 1;
pub const URLPOLICY_DISALLOW: u32 = 3;
pub const URLPOLICY_NOTIFY_ON_ALLOW: u32 = 16;
pub const URLPOLICY_NOTIFY_ON_DISALLOW: u32 = 32;
pub const URLPOLICY_LOG_ON_ALLOW: u32 = 64;
pub const URLPOLICY_LOG_ON_DISALLOW: u32 = 128;
pub const URLPOLICY_MASK_PERMISSIONS: u32 = 15;
pub const URLPOLICY_DONTCHECKDLGBOX: u32 = 256;
pub const URLZONE_ESC_FLAG: u32 = 256;
pub const SECURITY_IE_STATE_GREEN: u32 = 0;
pub const SECURITY_IE_STATE_RED: u32 = 1;
pub const SOFTDIST_FLAG_USAGE_EMAIL: u32 = 1;
pub const SOFTDIST_FLAG_USAGE_PRECACHE: u32 = 2;
pub const SOFTDIST_FLAG_USAGE_AUTOINSTALL: u32 = 4;
pub const SOFTDIST_FLAG_DELETE_SUBSCRIPTION: u32 = 8;
pub const SOFTDIST_ADSTATE_NONE: u32 = 0;
pub const SOFTDIST_ADSTATE_AVAILABLE: u32 = 1;
pub const SOFTDIST_ADSTATE_DOWNLOADED: u32 = 2;
pub const SOFTDIST_ADSTATE_INSTALLED: u32 = 3;
pub const CONFIRMSAFETYACTION_LOADOBJECT: u32 = 1;
pub const PIDDI_THUMBNAIL: u32 = 2;
pub const PIDSI_TITLE: u32 = 2;
pub const PIDSI_SUBJECT: u32 = 3;
pub const PIDSI_AUTHOR: u32 = 4;
pub const PIDSI_KEYWORDS: u32 = 5;
pub const PIDSI_COMMENTS: u32 = 6;
pub const PIDSI_TEMPLATE: u32 = 7;
pub const PIDSI_LASTAUTHOR: u32 = 8;
pub const PIDSI_REVNUMBER: u32 = 9;
pub const PIDSI_EDITTIME: u32 = 10;
pub const PIDSI_LASTPRINTED: u32 = 11;
pub const PIDSI_CREATE_DTM: u32 = 12;
pub const PIDSI_LASTSAVE_DTM: u32 = 13;
pub const PIDSI_PAGECOUNT: u32 = 14;
pub const PIDSI_WORDCOUNT: u32 = 15;
pub const PIDSI_CHARCOUNT: u32 = 16;
pub const PIDSI_THUMBNAIL: u32 = 17;
pub const PIDSI_APPNAME: u32 = 18;
pub const PIDSI_DOC_SECURITY: u32 = 19;
pub const PIDDSI_CATEGORY: u32 = 2;
pub const PIDDSI_PRESFORMAT: u32 = 3;
pub const PIDDSI_BYTECOUNT: u32 = 4;
pub const PIDDSI_LINECOUNT: u32 = 5;
pub const PIDDSI_PARCOUNT: u32 = 6;
pub const PIDDSI_SLIDECOUNT: u32 = 7;
pub const PIDDSI_NOTECOUNT: u32 = 8;
pub const PIDDSI_HIDDENCOUNT: u32 = 9;
pub const PIDDSI_MMCLIPCOUNT: u32 = 10;
pub const PIDDSI_SCALE: u32 = 11;
pub const PIDDSI_HEADINGPAIR: u32 = 12;
pub const PIDDSI_DOCPARTS: u32 = 13;
pub const PIDDSI_MANAGER: u32 = 14;
pub const PIDDSI_COMPANY: u32 = 15;
pub const PIDDSI_LINKSDIRTY: u32 = 16;
pub const PIDMSI_EDITOR: u32 = 2;
pub const PIDMSI_SUPPLIER: u32 = 3;
pub const PIDMSI_SOURCE: u32 = 4;
pub const PIDMSI_SEQUENCE_NO: u32 = 5;
pub const PIDMSI_PROJECT: u32 = 6;
pub const PIDMSI_STATUS: u32 = 7;
pub const PIDMSI_OWNER: u32 = 8;
pub const PIDMSI_RATING: u32 = 9;
pub const PIDMSI_PRODUCTION: u32 = 10;
pub const PIDMSI_COPYRIGHT: u32 = 11;
pub const STDOLE_MAJORVERNUM: u32 = 1;
pub const STDOLE_MINORVERNUM: u32 = 0;
pub const STDOLE_LCID: u32 = 0;
pub const STDOLE2_MAJORVERNUM: u32 = 2;
pub const STDOLE2_MINORVERNUM: u32 = 0;
pub const STDOLE2_LCID: u32 = 0;
pub const VARIANT_NOVALUEPROP: u32 = 1;
pub const VARIANT_ALPHABOOL: u32 = 2;
pub const VARIANT_NOUSEROVERRIDE: u32 = 4;
pub const VARIANT_CALENDAR_HIJRI: u32 = 8;
pub const VARIANT_LOCALBOOL: u32 = 16;
pub const VARIANT_CALENDAR_THAI: u32 = 32;
pub const VARIANT_CALENDAR_GREGORIAN: u32 = 64;
pub const VARIANT_USE_NLS: u32 = 128;
pub const LOCALE_USE_NLS: u32 = 268435456;
pub const VTDATEGRE_MAX: u32 = 2958465;
pub const VTDATEGRE_MIN: i32 = -657434;
pub const NUMPRS_LEADING_WHITE: u32 = 1;
pub const NUMPRS_TRAILING_WHITE: u32 = 2;
pub const NUMPRS_LEADING_PLUS: u32 = 4;
pub const NUMPRS_TRAILING_PLUS: u32 = 8;
pub const NUMPRS_LEADING_MINUS: u32 = 16;
pub const NUMPRS_TRAILING_MINUS: u32 = 32;
pub const NUMPRS_HEX_OCT: u32 = 64;
pub const NUMPRS_PARENS: u32 = 128;
pub const NUMPRS_DECIMAL: u32 = 256;
pub const NUMPRS_THOUSANDS: u32 = 512;
pub const NUMPRS_CURRENCY: u32 = 1024;
pub const NUMPRS_EXPONENT: u32 = 2048;
pub const NUMPRS_USE_ALL: u32 = 4096;
pub const NUMPRS_STD: u32 = 8191;
pub const NUMPRS_NEG: u32 = 65536;
pub const NUMPRS_INEXACT: u32 = 131072;
pub const VARCMP_LT: u32 = 0;
pub const VARCMP_EQ: u32 = 1;
pub const VARCMP_GT: u32 = 2;
pub const VARCMP_NULL: u32 = 3;
pub const MEMBERID_NIL: i32 = -1;
pub const ID_DEFAULTINST: i32 = -2;
pub const DISPATCH_METHOD: u32 = 1;
pub const DISPATCH_PROPERTYGET: u32 = 2;
pub const DISPATCH_PROPERTYPUT: u32 = 4;
pub const DISPATCH_PROPERTYPUTREF: u32 = 8;
pub const LOAD_TLB_AS_32BIT: u32 = 32;
pub const LOAD_TLB_AS_64BIT: u32 = 64;
pub const MASK_TO_RESET_TLB_BITS: i32 = -97;
pub const ACTIVEOBJECT_STRONG: u32 = 0;
pub const ACTIVEOBJECT_WEAK: u32 = 1;
pub const OLEIVERB_PRIMARY: u32 = 0;
pub const OLEIVERB_SHOW: i32 = -1;
pub const OLEIVERB_OPEN: i32 = -2;
pub const OLEIVERB_HIDE: i32 = -3;
pub const OLEIVERB_UIACTIVATE: i32 = -4;
pub const OLEIVERB_INPLACEACTIVATE: i32 = -5;
pub const OLEIVERB_DISCARDUNDOSTATE: i32 = -6;
pub const EMBDHLP_INPROC_HANDLER: u32 = 0;
pub const EMBDHLP_INPROC_SERVER: u32 = 1;
pub const EMBDHLP_CREATENOW: u32 = 0;
pub const EMBDHLP_DELAYCREATE: u32 = 65536;
pub const OLECREATE_LEAVERUNNING: u32 = 1;
pub const OFN_READONLY: u32 = 1;
pub const OFN_OVERWRITEPROMPT: u32 = 2;
pub const OFN_HIDEREADONLY: u32 = 4;
pub const OFN_NOCHANGEDIR: u32 = 8;
pub const OFN_SHOWHELP: u32 = 16;
pub const OFN_ENABLEHOOK: u32 = 32;
pub const OFN_ENABLETEMPLATE: u32 = 64;
pub const OFN_ENABLETEMPLATEHANDLE: u32 = 128;
pub const OFN_NOVALIDATE: u32 = 256;
pub const OFN_ALLOWMULTISELECT: u32 = 512;
pub const OFN_EXTENSIONDIFFERENT: u32 = 1024;
pub const OFN_PATHMUSTEXIST: u32 = 2048;
pub const OFN_FILEMUSTEXIST: u32 = 4096;
pub const OFN_CREATEPROMPT: u32 = 8192;
pub const OFN_SHAREAWARE: u32 = 16384;
pub const OFN_NOREADONLYRETURN: u32 = 32768;
pub const OFN_NOTESTFILECREATE: u32 = 65536;
pub const OFN_NONETWORKBUTTON: u32 = 131072;
pub const OFN_NOLONGNAMES: u32 = 262144;
pub const OFN_EXPLORER: u32 = 524288;
pub const OFN_NODEREFERENCELINKS: u32 = 1048576;
pub const OFN_LONGNAMES: u32 = 2097152;
pub const OFN_ENABLEINCLUDENOTIFY: u32 = 4194304;
pub const OFN_ENABLESIZING: u32 = 8388608;
pub const OFN_DONTADDTORECENT: u32 = 33554432;
pub const OFN_FORCESHOWHIDDEN: u32 = 268435456;
pub const OFN_EX_NOPLACESBAR: u32 = 1;
pub const OFN_SHAREFALLTHROUGH: u32 = 2;
pub const OFN_SHARENOWARN: u32 = 1;
pub const OFN_SHAREWARN: u32 = 0;
pub const CDN_FIRST: i32 = -601;
pub const CDN_LAST: i32 = -699;
pub const CDN_INITDONE: i32 = -601;
pub const CDN_SELCHANGE: i32 = -602;
pub const CDN_FOLDERCHANGE: i32 = -603;
pub const CDN_SHAREVIOLATION: i32 = -604;
pub const CDN_HELP: i32 = -605;
pub const CDN_FILEOK: i32 = -606;
pub const CDN_TYPECHANGE: i32 = -607;
pub const CDN_INCLUDEITEM: i32 = -608;
pub const CDM_FIRST: u32 = 1124;
pub const CDM_LAST: u32 = 1224;
pub const CDM_GETSPEC: u32 = 1124;
pub const CDM_GETFILEPATH: u32 = 1125;
pub const CDM_GETFOLDERPATH: u32 = 1126;
pub const CDM_GETFOLDERIDLIST: u32 = 1127;
pub const CDM_SETCONTROLTEXT: u32 = 1128;
pub const CDM_HIDECONTROL: u32 = 1129;
pub const CDM_SETDEFEXT: u32 = 1130;
pub const CC_RGBINIT: u32 = 1;
pub const CC_FULLOPEN: u32 = 2;
pub const CC_PREVENTFULLOPEN: u32 = 4;
pub const CC_SHOWHELP: u32 = 8;
pub const CC_ENABLEHOOK: u32 = 16;
pub const CC_ENABLETEMPLATE: u32 = 32;
pub const CC_ENABLETEMPLATEHANDLE: u32 = 64;
pub const CC_SOLIDCOLOR: u32 = 128;
pub const CC_ANYCOLOR: u32 = 256;
pub const FR_DOWN: u32 = 1;
pub const FR_WHOLEWORD: u32 = 2;
pub const FR_MATCHCASE: u32 = 4;
pub const FR_FINDNEXT: u32 = 8;
pub const FR_REPLACE: u32 = 16;
pub const FR_REPLACEALL: u32 = 32;
pub const FR_DIALOGTERM: u32 = 64;
pub const FR_SHOWHELP: u32 = 128;
pub const FR_ENABLEHOOK: u32 = 256;
pub const FR_ENABLETEMPLATE: u32 = 512;
pub const FR_NOUPDOWN: u32 = 1024;
pub const FR_NOMATCHCASE: u32 = 2048;
pub const FR_NOWHOLEWORD: u32 = 4096;
pub const FR_ENABLETEMPLATEHANDLE: u32 = 8192;
pub const FR_HIDEUPDOWN: u32 = 16384;
pub const FR_HIDEMATCHCASE: u32 = 32768;
pub const FR_HIDEWHOLEWORD: u32 = 65536;
pub const FR_RAW: u32 = 131072;
pub const FR_SHOWWRAPAROUND: u32 = 262144;
pub const FR_NOWRAPAROUND: u32 = 524288;
pub const FR_WRAPAROUND: u32 = 1048576;
pub const FR_MATCHDIAC: u32 = 536870912;
pub const FR_MATCHKASHIDA: u32 = 1073741824;
pub const FR_MATCHALEFHAMZA: u32 = 2147483648;
pub const FRM_FIRST: u32 = 1124;
pub const FRM_LAST: u32 = 1224;
pub const FRM_SETOPERATIONRESULT: u32 = 1124;
pub const FRM_SETOPERATIONRESULTTEXT: u32 = 1125;
pub const CF_SCREENFONTS: u32 = 1;
pub const CF_PRINTERFONTS: u32 = 2;
pub const CF_BOTH: u32 = 3;
pub const CF_SHOWHELP: u32 = 4;
pub const CF_ENABLEHOOK: u32 = 8;
pub const CF_ENABLETEMPLATE: u32 = 16;
pub const CF_ENABLETEMPLATEHANDLE: u32 = 32;
pub const CF_INITTOLOGFONTSTRUCT: u32 = 64;
pub const CF_USESTYLE: u32 = 128;
pub const CF_EFFECTS: u32 = 256;
pub const CF_APPLY: u32 = 512;
pub const CF_ANSIONLY: u32 = 1024;
pub const CF_SCRIPTSONLY: u32 = 1024;
pub const CF_NOVECTORFONTS: u32 = 2048;
pub const CF_NOOEMFONTS: u32 = 2048;
pub const CF_NOSIMULATIONS: u32 = 4096;
pub const CF_LIMITSIZE: u32 = 8192;
pub const CF_FIXEDPITCHONLY: u32 = 16384;
pub const CF_WYSIWYG: u32 = 32768;
pub const CF_FORCEFONTEXIST: u32 = 65536;
pub const CF_SCALABLEONLY: u32 = 131072;
pub const CF_TTONLY: u32 = 262144;
pub const CF_NOFACESEL: u32 = 524288;
pub const CF_NOSTYLESEL: u32 = 1048576;
pub const CF_NOSIZESEL: u32 = 2097152;
pub const CF_SELECTSCRIPT: u32 = 4194304;
pub const CF_NOSCRIPTSEL: u32 = 8388608;
pub const CF_NOVERTFONTS: u32 = 16777216;
pub const CF_INACTIVEFONTS: u32 = 33554432;
pub const SIMULATED_FONTTYPE: u32 = 32768;
pub const PRINTER_FONTTYPE: u32 = 16384;
pub const SCREEN_FONTTYPE: u32 = 8192;
pub const BOLD_FONTTYPE: u32 = 256;
pub const ITALIC_FONTTYPE: u32 = 512;
pub const REGULAR_FONTTYPE: u32 = 1024;
pub const PS_OPENTYPE_FONTTYPE: u32 = 65536;
pub const TT_OPENTYPE_FONTTYPE: u32 = 131072;
pub const TYPE1_FONTTYPE: u32 = 262144;
pub const SYMBOL_FONTTYPE: u32 = 524288;
pub const WM_CHOOSEFONT_GETLOGFONT: u32 = 1025;
pub const WM_CHOOSEFONT_SETLOGFONT: u32 = 1125;
pub const WM_CHOOSEFONT_SETFLAGS: u32 = 1126;
pub const LBSELCHSTRINGA: &[u8; 27usize] = b"commdlg_LBSelChangedNotify\0";
pub const SHAREVISTRINGA: &[u8; 23usize] = b"commdlg_ShareViolation\0";
pub const FILEOKSTRINGA: &[u8; 19usize] = b"commdlg_FileNameOK\0";
pub const COLOROKSTRINGA: &[u8; 16usize] = b"commdlg_ColorOK\0";
pub const SETRGBSTRINGA: &[u8; 20usize] = b"commdlg_SetRGBColor\0";
pub const HELPMSGSTRINGA: &[u8; 13usize] = b"commdlg_help\0";
pub const FINDMSGSTRINGA: &[u8; 20usize] = b"commdlg_FindReplace\0";
pub const LBSELCHSTRINGW: &[u8; 27usize] = b"commdlg_LBSelChangedNotify\0";
pub const SHAREVISTRINGW: &[u8; 23usize] = b"commdlg_ShareViolation\0";
pub const FILEOKSTRINGW: &[u8; 19usize] = b"commdlg_FileNameOK\0";
pub const COLOROKSTRINGW: &[u8; 16usize] = b"commdlg_ColorOK\0";
pub const SETRGBSTRINGW: &[u8; 20usize] = b"commdlg_SetRGBColor\0";
pub const HELPMSGSTRINGW: &[u8; 13usize] = b"commdlg_help\0";
pub const FINDMSGSTRINGW: &[u8; 20usize] = b"commdlg_FindReplace\0";
pub const LBSELCHSTRING: &[u8; 27usize] = b"commdlg_LBSelChangedNotify\0";
pub const SHAREVISTRING: &[u8; 23usize] = b"commdlg_ShareViolation\0";
pub const FILEOKSTRING: &[u8; 19usize] = b"commdlg_FileNameOK\0";
pub const COLOROKSTRING: &[u8; 16usize] = b"commdlg_ColorOK\0";
pub const SETRGBSTRING: &[u8; 20usize] = b"commdlg_SetRGBColor\0";
pub const HELPMSGSTRING: &[u8; 13usize] = b"commdlg_help\0";
pub const FINDMSGSTRING: &[u8; 20usize] = b"commdlg_FindReplace\0";
pub const CD_LBSELNOITEMS: i32 = -1;
pub const CD_LBSELCHANGE: u32 = 0;
pub const CD_LBSELSUB: u32 = 1;
pub const CD_LBSELADD: u32 = 2;
pub const PD_ALLPAGES: u32 = 0;
pub const PD_SELECTION: u32 = 1;
pub const PD_PAGENUMS: u32 = 2;
pub const PD_NOSELECTION: u32 = 4;
pub const PD_NOPAGENUMS: u32 = 8;
pub const PD_COLLATE: u32 = 16;
pub const PD_PRINTTOFILE: u32 = 32;
pub const PD_PRINTSETUP: u32 = 64;
pub const PD_NOWARNING: u32 = 128;
pub const PD_RETURNDC: u32 = 256;
pub const PD_RETURNIC: u32 = 512;
pub const PD_RETURNDEFAULT: u32 = 1024;
pub const PD_SHOWHELP: u32 = 2048;
pub const PD_ENABLEPRINTHOOK: u32 = 4096;
pub const PD_ENABLESETUPHOOK: u32 = 8192;
pub const PD_ENABLEPRINTTEMPLATE: u32 = 16384;
pub const PD_ENABLESETUPTEMPLATE: u32 = 32768;
pub const PD_ENABLEPRINTTEMPLATEHANDLE: u32 = 65536;
pub const PD_ENABLESETUPTEMPLATEHANDLE: u32 = 131072;
pub const PD_USEDEVMODECOPIES: u32 = 262144;
pub const PD_USEDEVMODECOPIESANDCOLLATE: u32 = 262144;
pub const PD_DISABLEPRINTTOFILE: u32 = 524288;
pub const PD_HIDEPRINTTOFILE: u32 = 1048576;
pub const PD_NONETWORKBUTTON: u32 = 2097152;
pub const PD_CURRENTPAGE: u32 = 4194304;
pub const PD_NOCURRENTPAGE: u32 = 8388608;
pub const PD_EXCLUSIONFLAGS: u32 = 16777216;
pub const PD_USELARGETEMPLATE: u32 = 268435456;
pub const PD_EXCL_COPIESANDCOLLATE: u32 = 33024;
pub const START_PAGE_GENERAL: u32 = 4294967295;
pub const PD_RESULT_CANCEL: u32 = 0;
pub const PD_RESULT_PRINT: u32 = 1;
pub const PD_RESULT_APPLY: u32 = 2;
pub const DN_DEFAULTPRN: u32 = 1;
pub const WM_PSD_PAGESETUPDLG: u32 = 1024;
pub const WM_PSD_FULLPAGERECT: u32 = 1025;
pub const WM_PSD_MINMARGINRECT: u32 = 1026;
pub const WM_PSD_MARGINRECT: u32 = 1027;
pub const WM_PSD_GREEKTEXTRECT: u32 = 1028;
pub const WM_PSD_ENVSTAMPRECT: u32 = 1029;
pub const WM_PSD_YAFULLPAGERECT: u32 = 1030;
pub const PSD_DEFAULTMINMARGINS: u32 = 0;
pub const PSD_INWININIINTLMEASURE: u32 = 0;
pub const PSD_MINMARGINS: u32 = 1;
pub const PSD_MARGINS: u32 = 2;
pub const PSD_INTHOUSANDTHSOFINCHES: u32 = 4;
pub const PSD_INHUNDREDTHSOFMILLIMETERS: u32 = 8;
pub const PSD_DISABLEMARGINS: u32 = 16;
pub const PSD_DISABLEPRINTER: u32 = 32;
pub const PSD_NOWARNING: u32 = 128;
pub const PSD_DISABLEORIENTATION: u32 = 256;
pub const PSD_RETURNDEFAULT: u32 = 1024;
pub const PSD_DISABLEPAPER: u32 = 512;
pub const PSD_SHOWHELP: u32 = 2048;
pub const PSD_ENABLEPAGESETUPHOOK: u32 = 8192;
pub const PSD_ENABLEPAGESETUPTEMPLATE: u32 = 32768;
pub const PSD_ENABLEPAGESETUPTEMPLATEHANDLE: u32 = 131072;
pub const PSD_ENABLEPAGEPAINTHOOK: u32 = 262144;
pub const PSD_DISABLEPAGEPAINTING: u32 = 524288;
pub const PSD_NONETWORKBUTTON: u32 = 2097152;
pub const _STRALIGN_USE_SECURE_CRT: u32 = 1;
pub const SERVICES_ACTIVE_DATABASEW: &[u8; 15usize] = b"ServicesActive\0";
pub const SERVICES_FAILED_DATABASEW: &[u8; 15usize] = b"ServicesFailed\0";
pub const SERVICES_ACTIVE_DATABASEA: &[u8; 15usize] = b"ServicesActive\0";
pub const SERVICES_FAILED_DATABASEA: &[u8; 15usize] = b"ServicesFailed\0";
pub const SC_GROUP_IDENTIFIERW: u8 = 43u8;
pub const SC_GROUP_IDENTIFIERA: u8 = 43u8;
pub const SERVICES_ACTIVE_DATABASE: &[u8; 15usize] = b"ServicesActive\0";
pub const SERVICES_FAILED_DATABASE: &[u8; 15usize] = b"ServicesFailed\0";
pub const SC_GROUP_IDENTIFIER: u8 = 43u8;
pub const SERVICE_NO_CHANGE: u32 = 4294967295;
pub const SERVICE_ACTIVE: u32 = 1;
pub const SERVICE_INACTIVE: u32 = 2;
pub const SERVICE_STATE_ALL: u32 = 3;
pub const SERVICE_CONTROL_STOP: u32 = 1;
pub const SERVICE_CONTROL_PAUSE: u32 = 2;
pub const SERVICE_CONTROL_CONTINUE: u32 = 3;
pub const SERVICE_CONTROL_INTERROGATE: u32 = 4;
pub const SERVICE_CONTROL_SHUTDOWN: u32 = 5;
pub const SERVICE_CONTROL_PARAMCHANGE: u32 = 6;
pub const SERVICE_CONTROL_NETBINDADD: u32 = 7;
pub const SERVICE_CONTROL_NETBINDREMOVE: u32 = 8;
pub const SERVICE_CONTROL_NETBINDENABLE: u32 = 9;
pub const SERVICE_CONTROL_NETBINDDISABLE: u32 = 10;
pub const SERVICE_CONTROL_DEVICEEVENT: u32 = 11;
pub const SERVICE_CONTROL_HARDWAREPROFILECHANGE: u32 = 12;
pub const SERVICE_CONTROL_POWEREVENT: u32 = 13;
pub const SERVICE_CONTROL_SESSIONCHANGE: u32 = 14;
pub const SERVICE_CONTROL_PRESHUTDOWN: u32 = 15;
pub const SERVICE_CONTROL_TIMECHANGE: u32 = 16;
pub const SERVICE_CONTROL_TRIGGEREVENT: u32 = 32;
pub const SERVICE_CONTROL_LOWRESOURCES: u32 = 96;
pub const SERVICE_CONTROL_SYSTEMLOWRESOURCES: u32 = 97;
pub const SERVICE_STOPPED: u32 = 1;
pub const SERVICE_START_PENDING: u32 = 2;
pub const SERVICE_STOP_PENDING: u32 = 3;
pub const SERVICE_RUNNING: u32 = 4;
pub const SERVICE_CONTINUE_PENDING: u32 = 5;
pub const SERVICE_PAUSE_PENDING: u32 = 6;
pub const SERVICE_PAUSED: u32 = 7;
pub const SERVICE_ACCEPT_STOP: u32 = 1;
pub const SERVICE_ACCEPT_PAUSE_CONTINUE: u32 = 2;
pub const SERVICE_ACCEPT_SHUTDOWN: u32 = 4;
pub const SERVICE_ACCEPT_PARAMCHANGE: u32 = 8;
pub const SERVICE_ACCEPT_NETBINDCHANGE: u32 = 16;
pub const SERVICE_ACCEPT_HARDWAREPROFILECHANGE: u32 = 32;
pub const SERVICE_ACCEPT_POWEREVENT: u32 = 64;
pub const SERVICE_ACCEPT_SESSIONCHANGE: u32 = 128;
pub const SERVICE_ACCEPT_PRESHUTDOWN: u32 = 256;
pub const SERVICE_ACCEPT_TIMECHANGE: u32 = 512;
pub const SERVICE_ACCEPT_TRIGGEREVENT: u32 = 1024;
pub const SERVICE_ACCEPT_USER_LOGOFF: u32 = 2048;
pub const SERVICE_ACCEPT_LOWRESOURCES: u32 = 8192;
pub const SERVICE_ACCEPT_SYSTEMLOWRESOURCES: u32 = 16384;
pub const SC_MANAGER_CONNECT: u32 = 1;
pub const SC_MANAGER_CREATE_SERVICE: u32 = 2;
pub const SC_MANAGER_ENUMERATE_SERVICE: u32 = 4;
pub const SC_MANAGER_LOCK: u32 = 8;
pub const SC_MANAGER_QUERY_LOCK_STATUS: u32 = 16;
pub const SC_MANAGER_MODIFY_BOOT_CONFIG: u32 = 32;
pub const SC_MANAGER_ALL_ACCESS: u32 = 983103;
pub const SERVICE_QUERY_CONFIG: u32 = 1;
pub const SERVICE_CHANGE_CONFIG: u32 = 2;
pub const SERVICE_QUERY_STATUS: u32 = 4;
pub const SERVICE_ENUMERATE_DEPENDENTS: u32 = 8;
pub const SERVICE_START: u32 = 16;
pub const SERVICE_STOP: u32 = 32;
pub const SERVICE_PAUSE_CONTINUE: u32 = 64;
pub const SERVICE_INTERROGATE: u32 = 128;
pub const SERVICE_USER_DEFINED_CONTROL: u32 = 256;
pub const SERVICE_ALL_ACCESS: u32 = 983551;
pub const SERVICE_RUNS_IN_SYSTEM_PROCESS: u32 = 1;
pub const SERVICE_CONFIG_DESCRIPTION: u32 = 1;
pub const SERVICE_CONFIG_FAILURE_ACTIONS: u32 = 2;
pub const SERVICE_CONFIG_DELAYED_AUTO_START_INFO: u32 = 3;
pub const SERVICE_CONFIG_FAILURE_ACTIONS_FLAG: u32 = 4;
pub const SERVICE_CONFIG_SERVICE_SID_INFO: u32 = 5;
pub const SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO: u32 = 6;
pub const SERVICE_CONFIG_PRESHUTDOWN_INFO: u32 = 7;
pub const SERVICE_CONFIG_TRIGGER_INFO: u32 = 8;
pub const SERVICE_CONFIG_PREFERRED_NODE: u32 = 9;
pub const SERVICE_CONFIG_LAUNCH_PROTECTED: u32 = 12;
pub const SERVICE_NOTIFY_STATUS_CHANGE_1: u32 = 1;
pub const SERVICE_NOTIFY_STATUS_CHANGE_2: u32 = 2;
pub const SERVICE_NOTIFY_STATUS_CHANGE: u32 = 2;
pub const SERVICE_NOTIFY_STOPPED: u32 = 1;
pub const SERVICE_NOTIFY_START_PENDING: u32 = 2;
pub const SERVICE_NOTIFY_STOP_PENDING: u32 = 4;
pub const SERVICE_NOTIFY_RUNNING: u32 = 8;
pub const SERVICE_NOTIFY_CONTINUE_PENDING: u32 = 16;
pub const SERVICE_NOTIFY_PAUSE_PENDING: u32 = 32;
pub const SERVICE_NOTIFY_PAUSED: u32 = 64;
pub const SERVICE_NOTIFY_CREATED: u32 = 128;
pub const SERVICE_NOTIFY_DELETED: u32 = 256;
pub const SERVICE_NOTIFY_DELETE_PENDING: u32 = 512;
pub const SERVICE_STOP_REASON_FLAG_MIN: u32 = 0;
pub const SERVICE_STOP_REASON_FLAG_UNPLANNED: u32 = 268435456;
pub const SERVICE_STOP_REASON_FLAG_CUSTOM: u32 = 536870912;
pub const SERVICE_STOP_REASON_FLAG_PLANNED: u32 = 1073741824;
pub const SERVICE_STOP_REASON_FLAG_MAX: u32 = 2147483648;
pub const SERVICE_STOP_REASON_MAJOR_MIN: u32 = 0;
pub const SERVICE_STOP_REASON_MAJOR_OTHER: u32 = 65536;
pub const SERVICE_STOP_REASON_MAJOR_HARDWARE: u32 = 131072;
pub const SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM: u32 = 196608;
pub const SERVICE_STOP_REASON_MAJOR_SOFTWARE: u32 = 262144;
pub const SERVICE_STOP_REASON_MAJOR_APPLICATION: u32 = 327680;
pub const SERVICE_STOP_REASON_MAJOR_NONE: u32 = 393216;
pub const SERVICE_STOP_REASON_MAJOR_MAX: u32 = 458752;
pub const SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM: u32 = 4194304;
pub const SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM: u32 = 16711680;
pub const SERVICE_STOP_REASON_MINOR_MIN: u32 = 0;
pub const SERVICE_STOP_REASON_MINOR_OTHER: u32 = 1;
pub const SERVICE_STOP_REASON_MINOR_MAINTENANCE: u32 = 2;
pub const SERVICE_STOP_REASON_MINOR_INSTALLATION: u32 = 3;
pub const SERVICE_STOP_REASON_MINOR_UPGRADE: u32 = 4;
pub const SERVICE_STOP_REASON_MINOR_RECONFIG: u32 = 5;
pub const SERVICE_STOP_REASON_MINOR_HUNG: u32 = 6;
pub const SERVICE_STOP_REASON_MINOR_UNSTABLE: u32 = 7;
pub const SERVICE_STOP_REASON_MINOR_DISK: u32 = 8;
pub const SERVICE_STOP_REASON_MINOR_NETWORKCARD: u32 = 9;
pub const SERVICE_STOP_REASON_MINOR_ENVIRONMENT: u32 = 10;
pub const SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER: u32 = 11;
pub const SERVICE_STOP_REASON_MINOR_OTHERDRIVER: u32 = 12;
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK: u32 = 13;
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE: u32 = 14;
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX: u32 = 15;
pub const SERVICE_STOP_REASON_MINOR_SECURITY: u32 = 16;
pub const SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY: u32 = 17;
pub const SERVICE_STOP_REASON_MINOR_WMI: u32 = 18;
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL: u32 = 19;
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL: u32 = 20;
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL: u32 = 21;
pub const SERVICE_STOP_REASON_MINOR_MMC: u32 = 22;
pub const SERVICE_STOP_REASON_MINOR_NONE: u32 = 23;
pub const SERVICE_STOP_REASON_MINOR_MEMOTYLIMIT: u32 = 24;
pub const SERVICE_STOP_REASON_MINOR_MAX: u32 = 25;
pub const SERVICE_STOP_REASON_MINOR_MIN_CUSTOM: u32 = 256;
pub const SERVICE_STOP_REASON_MINOR_MAX_CUSTOM: u32 = 65535;
pub const SERVICE_CONTROL_STATUS_REASON_INFO: u32 = 1;
pub const SERVICE_SID_TYPE_NONE: u32 = 0;
pub const SERVICE_SID_TYPE_UNRESTRICTED: u32 = 1;
pub const SERVICE_SID_TYPE_RESTRICTED: u32 = 3;
pub const SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL: u32 = 1;
pub const SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY: u32 = 2;
pub const SERVICE_TRIGGER_TYPE_DOMAIN_JOIN: u32 = 3;
pub const SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT: u32 = 4;
pub const SERVICE_TRIGGER_TYPE_GROUP_POLICY: u32 = 5;
pub const SERVICE_TRIGGER_TYPE_NETWORK_ENDPOINT: u32 = 6;
pub const SERVICE_TRIGGER_TYPE_CUSTOM_SYSTEM_STATE_CHANGE: u32 = 7;
pub const SERVICE_TRIGGER_TYPE_CUSTOM: u32 = 20;
pub const SERVICE_TRIGGER_TYPE_AGGREGATE: u32 = 30;
pub const SERVICE_TRIGGER_DATA_TYPE_BINARY: u32 = 1;
pub const SERVICE_TRIGGER_DATA_TYPE_STRING: u32 = 2;
pub const SERVICE_TRIGGER_DATA_TYPE_LEVEL: u32 = 3;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ANY: u32 = 4;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ALL: u32 = 5;
pub const SERVICE_START_REASON_DEMAND: u32 = 1;
pub const SERVICE_START_REASON_AUTO: u32 = 2;
pub const SERVICE_START_REASON_TRIGGER: u32 = 4;
pub const SERVICE_START_REASON_RESTART_ON_FAILURE: u32 = 8;
pub const SERVICE_START_REASON_DELAYEDAUTO: u32 = 16;
pub const SERVICE_DYNAMIC_INFORMATION_LEVEL_START_REASON: u32 = 1;
pub const SERVICE_LAUNCH_PROTECTED_NONE: u32 = 0;
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS: u32 = 1;
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS_LIGHT: u32 = 2;
pub const SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT: u32 = 3;
pub const SERVICE_TRIGGER_ACTION_SERVICE_START: u32 = 1;
pub const SERVICE_TRIGGER_ACTION_SERVICE_STOP: u32 = 2;
pub const SERVICE_TRIGGER_STARTED_ARGUMENT: &[u8; 15usize] = b"TriggerStarted\0";
pub const SC_AGGREGATE_STORAGE_KEY: &[u8; 57usize] =
    b"System\\CurrentControlSet\\Control\\ServiceAggregatedEvents\0";
pub const DIALOPTION_BILLING: u32 = 64;
pub const DIALOPTION_QUIET: u32 = 128;
pub const DIALOPTION_DIALTONE: u32 = 256;
pub const MDMVOLFLAG_LOW: u32 = 1;
pub const MDMVOLFLAG_MEDIUM: u32 = 2;
pub const MDMVOLFLAG_HIGH: u32 = 4;
pub const MDMVOL_LOW: u32 = 0;
pub const MDMVOL_MEDIUM: u32 = 1;
pub const MDMVOL_HIGH: u32 = 2;
pub const MDMSPKRFLAG_OFF: u32 = 1;
pub const MDMSPKRFLAG_DIAL: u32 = 2;
pub const MDMSPKRFLAG_ON: u32 = 4;
pub const MDMSPKRFLAG_CALLSETUP: u32 = 8;
pub const MDMSPKR_OFF: u32 = 0;
pub const MDMSPKR_DIAL: u32 = 1;
pub const MDMSPKR_ON: u32 = 2;
pub const MDMSPKR_CALLSETUP: u32 = 3;
pub const MDM_COMPRESSION: u32 = 1;
pub const MDM_ERROR_CONTROL: u32 = 2;
pub const MDM_FORCED_EC: u32 = 4;
pub const MDM_CELLULAR: u32 = 8;
pub const MDM_FLOWCONTROL_HARD: u32 = 16;
pub const MDM_FLOWCONTROL_SOFT: u32 = 32;
pub const MDM_CCITT_OVERRIDE: u32 = 64;
pub const MDM_SPEED_ADJUST: u32 = 128;
pub const MDM_TONE_DIAL: u32 = 256;
pub const MDM_BLIND_DIAL: u32 = 512;
pub const MDM_V23_OVERRIDE: u32 = 1024;
pub const MDM_DIAGNOSTICS: u32 = 2048;
pub const MDM_MASK_BEARERMODE: u32 = 61440;
pub const MDM_SHIFT_BEARERMODE: u32 = 12;
pub const MDM_MASK_PROTOCOLID: u32 = 983040;
pub const MDM_SHIFT_PROTOCOLID: u32 = 16;
pub const MDM_MASK_PROTOCOLDATA: u32 = 267386880;
pub const MDM_SHIFT_PROTOCOLDATA: u32 = 20;
pub const MDM_MASK_PROTOCOLINFO: u32 = 268369920;
pub const MDM_SHIFT_PROTOCOLINFO: u32 = 16;
pub const MDM_MASK_EXTENDEDINFO: u32 = 268431360;
pub const MDM_SHIFT_EXTENDEDINFO: u32 = 12;
pub const MDM_BEARERMODE_ANALOG: u32 = 0;
pub const MDM_BEARERMODE_ISDN: u32 = 1;
pub const MDM_BEARERMODE_GSM: u32 = 2;
pub const MDM_PROTOCOLID_DEFAULT: u32 = 0;
pub const MDM_PROTOCOLID_HDLCPPP: u32 = 1;
pub const MDM_PROTOCOLID_V128: u32 = 2;
pub const MDM_PROTOCOLID_X75: u32 = 3;
pub const MDM_PROTOCOLID_V110: u32 = 4;
pub const MDM_PROTOCOLID_V120: u32 = 5;
pub const MDM_PROTOCOLID_AUTO: u32 = 6;
pub const MDM_PROTOCOLID_ANALOG: u32 = 7;
pub const MDM_PROTOCOLID_GPRS: u32 = 8;
pub const MDM_PROTOCOLID_PIAFS: u32 = 9;
pub const MDM_SHIFT_HDLCPPP_SPEED: u32 = 0;
pub const MDM_MASK_HDLCPPP_SPEED: u32 = 7;
pub const MDM_HDLCPPP_SPEED_DEFAULT: u32 = 0;
pub const MDM_HDLCPPP_SPEED_64K: u32 = 1;
pub const MDM_HDLCPPP_SPEED_56K: u32 = 2;
pub const MDM_SHIFT_HDLCPPP_AUTH: u32 = 3;
pub const MDM_MASK_HDLCPPP_AUTH: u32 = 56;
pub const MDM_HDLCPPP_AUTH_DEFAULT: u32 = 0;
pub const MDM_HDLCPPP_AUTH_NONE: u32 = 1;
pub const MDM_HDLCPPP_AUTH_PAP: u32 = 2;
pub const MDM_HDLCPPP_AUTH_CHAP: u32 = 3;
pub const MDM_HDLCPPP_AUTH_MSCHAP: u32 = 4;
pub const MDM_SHIFT_HDLCPPP_ML: u32 = 6;
pub const MDM_MASK_HDLCPPP_ML: u32 = 192;
pub const MDM_HDLCPPP_ML_DEFAULT: u32 = 0;
pub const MDM_HDLCPPP_ML_NONE: u32 = 1;
pub const MDM_HDLCPPP_ML_2: u32 = 2;
pub const MDM_SHIFT_V120_SPEED: u32 = 0;
pub const MDM_MASK_V120_SPEED: u32 = 7;
pub const MDM_V120_SPEED_DEFAULT: u32 = 0;
pub const MDM_V120_SPEED_64K: u32 = 1;
pub const MDM_V120_SPEED_56K: u32 = 2;
pub const MDM_SHIFT_V120_ML: u32 = 6;
pub const MDM_MASK_V120_ML: u32 = 192;
pub const MDM_V120_ML_DEFAULT: u32 = 0;
pub const MDM_V120_ML_NONE: u32 = 1;
pub const MDM_V120_ML_2: u32 = 2;
pub const MDM_SHIFT_X75_DATA: u32 = 0;
pub const MDM_MASK_X75_DATA: u32 = 7;
pub const MDM_X75_DATA_DEFAULT: u32 = 0;
pub const MDM_X75_DATA_64K: u32 = 1;
pub const MDM_X75_DATA_128K: u32 = 2;
pub const MDM_X75_DATA_T_70: u32 = 3;
pub const MDM_X75_DATA_BTX: u32 = 4;
pub const MDM_SHIFT_V110_SPEED: u32 = 0;
pub const MDM_MASK_V110_SPEED: u32 = 15;
pub const MDM_V110_SPEED_DEFAULT: u32 = 0;
pub const MDM_V110_SPEED_1DOT2K: u32 = 1;
pub const MDM_V110_SPEED_2DOT4K: u32 = 2;
pub const MDM_V110_SPEED_4DOT8K: u32 = 3;
pub const MDM_V110_SPEED_9DOT6K: u32 = 4;
pub const MDM_V110_SPEED_12DOT0K: u32 = 5;
pub const MDM_V110_SPEED_14DOT4K: u32 = 6;
pub const MDM_V110_SPEED_19DOT2K: u32 = 7;
pub const MDM_V110_SPEED_28DOT8K: u32 = 8;
pub const MDM_V110_SPEED_38DOT4K: u32 = 9;
pub const MDM_V110_SPEED_57DOT6K: u32 = 10;
pub const MDM_SHIFT_AUTO_SPEED: u32 = 0;
pub const MDM_MASK_AUTO_SPEED: u32 = 7;
pub const MDM_AUTO_SPEED_DEFAULT: u32 = 0;
pub const MDM_SHIFT_AUTO_ML: u32 = 6;
pub const MDM_MASK_AUTO_ML: u32 = 192;
pub const MDM_AUTO_ML_DEFAULT: u32 = 0;
pub const MDM_AUTO_ML_NONE: u32 = 1;
pub const MDM_AUTO_ML_2: u32 = 2;
pub const MDM_ANALOG_RLP_ON: u32 = 0;
pub const MDM_ANALOG_RLP_OFF: u32 = 1;
pub const MDM_ANALOG_V34: u32 = 2;
pub const MDM_PIAFS_INCOMING: u32 = 0;
pub const MDM_PIAFS_OUTGOING: u32 = 1;
pub const STYLE_DESCRIPTION_SIZE: u32 = 32;
pub const IMEMENUITEM_STRING_SIZE: u32 = 80;
pub const IMC_GETCANDIDATEPOS: u32 = 7;
pub const IMC_SETCANDIDATEPOS: u32 = 8;
pub const IMC_GETCOMPOSITIONFONT: u32 = 9;
pub const IMC_SETCOMPOSITIONFONT: u32 = 10;
pub const IMC_GETCOMPOSITIONWINDOW: u32 = 11;
pub const IMC_SETCOMPOSITIONWINDOW: u32 = 12;
pub const IMC_GETSTATUSWINDOWPOS: u32 = 15;
pub const IMC_SETSTATUSWINDOWPOS: u32 = 16;
pub const IMC_CLOSESTATUSWINDOW: u32 = 33;
pub const IMC_OPENSTATUSWINDOW: u32 = 34;
pub const NI_OPENCANDIDATE: u32 = 16;
pub const NI_CLOSECANDIDATE: u32 = 17;
pub const NI_SELECTCANDIDATESTR: u32 = 18;
pub const NI_CHANGECANDIDATELIST: u32 = 19;
pub const NI_FINALIZECONVERSIONRESULT: u32 = 20;
pub const NI_COMPOSITIONSTR: u32 = 21;
pub const NI_SETCANDIDATE_PAGESTART: u32 = 22;
pub const NI_SETCANDIDATE_PAGESIZE: u32 = 23;
pub const NI_IMEMENUSELECTED: u32 = 24;
pub const ISC_SHOWUICANDIDATEWINDOW: u32 = 1;
pub const ISC_SHOWUICOMPOSITIONWINDOW: u32 = 2147483648;
pub const ISC_SHOWUIGUIDELINE: u32 = 1073741824;
pub const ISC_SHOWUIALLCANDIDATEWINDOW: u32 = 15;
pub const ISC_SHOWUIALL: u32 = 3221225487;
pub const CPS_COMPLETE: u32 = 1;
pub const CPS_CONVERT: u32 = 2;
pub const CPS_REVERT: u32 = 3;
pub const CPS_CANCEL: u32 = 4;
pub const MOD_LEFT: u32 = 32768;
pub const MOD_RIGHT: u32 = 16384;
pub const MOD_ON_KEYUP: u32 = 2048;
pub const MOD_IGNORE_ALL_MODIFIER: u32 = 1024;
pub const IME_CHOTKEY_IME_NONIME_TOGGLE: u32 = 16;
pub const IME_CHOTKEY_SHAPE_TOGGLE: u32 = 17;
pub const IME_CHOTKEY_SYMBOL_TOGGLE: u32 = 18;
pub const IME_JHOTKEY_CLOSE_OPEN: u32 = 48;
pub const IME_KHOTKEY_SHAPE_TOGGLE: u32 = 80;
pub const IME_KHOTKEY_HANJACONVERT: u32 = 81;
pub const IME_KHOTKEY_ENGLISH: u32 = 82;
pub const IME_THOTKEY_IME_NONIME_TOGGLE: u32 = 112;
pub const IME_THOTKEY_SHAPE_TOGGLE: u32 = 113;
pub const IME_THOTKEY_SYMBOL_TOGGLE: u32 = 114;
pub const IME_HOTKEY_DSWITCH_FIRST: u32 = 256;
pub const IME_HOTKEY_DSWITCH_LAST: u32 = 287;
pub const IME_HOTKEY_PRIVATE_FIRST: u32 = 512;
pub const IME_ITHOTKEY_RESEND_RESULTSTR: u32 = 512;
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION: u32 = 513;
pub const IME_ITHOTKEY_UISTYLE_TOGGLE: u32 = 514;
pub const IME_ITHOTKEY_RECONVERTSTRING: u32 = 515;
pub const IME_HOTKEY_PRIVATE_LAST: u32 = 543;
pub const GCS_COMPREADSTR: u32 = 1;
pub const GCS_COMPREADATTR: u32 = 2;
pub const GCS_COMPREADCLAUSE: u32 = 4;
pub const GCS_COMPSTR: u32 = 8;
pub const GCS_COMPATTR: u32 = 16;
pub const GCS_COMPCLAUSE: u32 = 32;
pub const GCS_CURSORPOS: u32 = 128;
pub const GCS_DELTASTART: u32 = 256;
pub const GCS_RESULTREADSTR: u32 = 512;
pub const GCS_RESULTREADCLAUSE: u32 = 1024;
pub const GCS_RESULTSTR: u32 = 2048;
pub const GCS_RESULTCLAUSE: u32 = 4096;
pub const CS_INSERTCHAR: u32 = 8192;
pub const CS_NOMOVECARET: u32 = 16384;
pub const IMEVER_0310: u32 = 196618;
pub const IMEVER_0400: u32 = 262144;
pub const IME_PROP_AT_CARET: u32 = 65536;
pub const IME_PROP_SPECIAL_UI: u32 = 131072;
pub const IME_PROP_CANDLIST_START_FROM_1: u32 = 262144;
pub const IME_PROP_UNICODE: u32 = 524288;
pub const IME_PROP_COMPLETE_ON_UNSELECT: u32 = 1048576;
pub const UI_CAP_2700: u32 = 1;
pub const UI_CAP_ROT90: u32 = 2;
pub const UI_CAP_ROTANY: u32 = 4;
pub const SCS_CAP_COMPSTR: u32 = 1;
pub const SCS_CAP_MAKEREAD: u32 = 2;
pub const SCS_CAP_SETRECONVERTSTRING: u32 = 4;
pub const SELECT_CAP_CONVERSION: u32 = 1;
pub const SELECT_CAP_SENTENCE: u32 = 2;
pub const GGL_LEVEL: u32 = 1;
pub const GGL_INDEX: u32 = 2;
pub const GGL_STRING: u32 = 3;
pub const GGL_PRIVATE: u32 = 4;
pub const GL_LEVEL_NOGUIDELINE: u32 = 0;
pub const GL_LEVEL_FATAL: u32 = 1;
pub const GL_LEVEL_ERROR: u32 = 2;
pub const GL_LEVEL_WARNING: u32 = 3;
pub const GL_LEVEL_INFORMATION: u32 = 4;
pub const GL_ID_UNKNOWN: u32 = 0;
pub const GL_ID_NOMODULE: u32 = 1;
pub const GL_ID_NODICTIONARY: u32 = 16;
pub const GL_ID_CANNOTSAVE: u32 = 17;
pub const GL_ID_NOCONVERT: u32 = 32;
pub const GL_ID_TYPINGERROR: u32 = 33;
pub const GL_ID_TOOMANYSTROKE: u32 = 34;
pub const GL_ID_READINGCONFLICT: u32 = 35;
pub const GL_ID_INPUTREADING: u32 = 36;
pub const GL_ID_INPUTRADICAL: u32 = 37;
pub const GL_ID_INPUTCODE: u32 = 38;
pub const GL_ID_INPUTSYMBOL: u32 = 39;
pub const GL_ID_CHOOSECANDIDATE: u32 = 40;
pub const GL_ID_REVERSECONVERSION: u32 = 41;
pub const GL_ID_PRIVATE_FIRST: u32 = 32768;
pub const GL_ID_PRIVATE_LAST: u32 = 65535;
pub const IGP_PROPERTY: u32 = 4;
pub const IGP_CONVERSION: u32 = 8;
pub const IGP_SENTENCE: u32 = 12;
pub const IGP_UI: u32 = 16;
pub const IGP_SETCOMPSTR: u32 = 20;
pub const IGP_SELECT: u32 = 24;
pub const SCS_SETSTR: u32 = 9;
pub const SCS_CHANGEATTR: u32 = 18;
pub const SCS_CHANGECLAUSE: u32 = 36;
pub const SCS_SETRECONVERTSTRING: u32 = 65536;
pub const SCS_QUERYRECONVERTSTRING: u32 = 131072;
pub const ATTR_INPUT: u32 = 0;
pub const ATTR_TARGET_CONVERTED: u32 = 1;
pub const ATTR_CONVERTED: u32 = 2;
pub const ATTR_TARGET_NOTCONVERTED: u32 = 3;
pub const ATTR_INPUT_ERROR: u32 = 4;
pub const ATTR_FIXEDCONVERTED: u32 = 5;
pub const CFS_DEFAULT: u32 = 0;
pub const CFS_RECT: u32 = 1;
pub const CFS_POINT: u32 = 2;
pub const CFS_FORCE_POSITION: u32 = 32;
pub const CFS_CANDIDATEPOS: u32 = 64;
pub const CFS_EXCLUDE: u32 = 128;
pub const GCL_CONVERSION: u32 = 1;
pub const GCL_REVERSECONVERSION: u32 = 2;
pub const GCL_REVERSE_LENGTH: u32 = 3;
pub const IME_CMODE_ALPHANUMERIC: u32 = 0;
pub const IME_CMODE_NATIVE: u32 = 1;
pub const IME_CMODE_CHINESE: u32 = 1;
pub const IME_CMODE_HANGUL: u32 = 1;
pub const IME_CMODE_JAPANESE: u32 = 1;
pub const IME_CMODE_KATAKANA: u32 = 2;
pub const IME_CMODE_LANGUAGE: u32 = 3;
pub const IME_CMODE_FULLSHAPE: u32 = 8;
pub const IME_CMODE_ROMAN: u32 = 16;
pub const IME_CMODE_CHARCODE: u32 = 32;
pub const IME_CMODE_HANJACONVERT: u32 = 64;
pub const IME_CMODE_NATIVESYMBOL: u32 = 128;
pub const IME_CMODE_HANGEUL: u32 = 1;
pub const IME_CMODE_SOFTKBD: u32 = 128;
pub const IME_CMODE_NOCONVERSION: u32 = 256;
pub const IME_CMODE_EUDC: u32 = 512;
pub const IME_CMODE_SYMBOL: u32 = 1024;
pub const IME_CMODE_FIXED: u32 = 2048;
pub const IME_CMODE_RESERVED: u32 = 4026531840;
pub const IME_SMODE_NONE: u32 = 0;
pub const IME_SMODE_PLAURALCLAUSE: u32 = 1;
pub const IME_SMODE_SINGLECONVERT: u32 = 2;
pub const IME_SMODE_AUTOMATIC: u32 = 4;
pub const IME_SMODE_PHRASEPREDICT: u32 = 8;
pub const IME_SMODE_CONVERSATION: u32 = 16;
pub const IME_SMODE_RESERVED: u32 = 61440;
pub const IME_CAND_UNKNOWN: u32 = 0;
pub const IME_CAND_READ: u32 = 1;
pub const IME_CAND_CODE: u32 = 2;
pub const IME_CAND_MEANING: u32 = 3;
pub const IME_CAND_RADICAL: u32 = 4;
pub const IME_CAND_STROKE: u32 = 5;
pub const IMN_CLOSESTATUSWINDOW: u32 = 1;
pub const IMN_OPENSTATUSWINDOW: u32 = 2;
pub const IMN_CHANGECANDIDATE: u32 = 3;
pub const IMN_CLOSECANDIDATE: u32 = 4;
pub const IMN_OPENCANDIDATE: u32 = 5;
pub const IMN_SETCONVERSIONMODE: u32 = 6;
pub const IMN_SETSENTENCEMODE: u32 = 7;
pub const IMN_SETOPENSTATUS: u32 = 8;
pub const IMN_SETCANDIDATEPOS: u32 = 9;
pub const IMN_SETCOMPOSITIONFONT: u32 = 10;
pub const IMN_SETCOMPOSITIONWINDOW: u32 = 11;
pub const IMN_SETSTATUSWINDOWPOS: u32 = 12;
pub const IMN_GUIDELINE: u32 = 13;
pub const IMN_PRIVATE: u32 = 14;
pub const IMR_COMPOSITIONWINDOW: u32 = 1;
pub const IMR_CANDIDATEWINDOW: u32 = 2;
pub const IMR_COMPOSITIONFONT: u32 = 3;
pub const IMR_RECONVERTSTRING: u32 = 4;
pub const IMR_CONFIRMRECONVERTSTRING: u32 = 5;
pub const IMR_QUERYCHARPOSITION: u32 = 6;
pub const IMR_DOCUMENTFEED: u32 = 7;
pub const IMM_ERROR_NODATA: i32 = -1;
pub const IMM_ERROR_GENERAL: i32 = -2;
pub const IME_CONFIG_GENERAL: u32 = 1;
pub const IME_CONFIG_REGISTERWORD: u32 = 2;
pub const IME_CONFIG_SELECTDICTIONARY: u32 = 3;
pub const IME_ESC_QUERY_SUPPORT: u32 = 3;
pub const IME_ESC_RESERVED_FIRST: u32 = 4;
pub const IME_ESC_RESERVED_LAST: u32 = 2047;
pub const IME_ESC_PRIVATE_FIRST: u32 = 2048;
pub const IME_ESC_PRIVATE_LAST: u32 = 4095;
pub const IME_ESC_SEQUENCE_TO_INTERNAL: u32 = 4097;
pub const IME_ESC_GET_EUDC_DICTIONARY: u32 = 4099;
pub const IME_ESC_SET_EUDC_DICTIONARY: u32 = 4100;
pub const IME_ESC_MAX_KEY: u32 = 4101;
pub const IME_ESC_IME_NAME: u32 = 4102;
pub const IME_ESC_SYNC_HOTKEY: u32 = 4103;
pub const IME_ESC_HANJA_MODE: u32 = 4104;
pub const IME_ESC_AUTOMATA: u32 = 4105;
pub const IME_ESC_PRIVATE_HOTKEY: u32 = 4106;
pub const IME_ESC_GETHELPFILENAME: u32 = 4107;
pub const IME_REGWORD_STYLE_EUDC: u32 = 1;
pub const IME_REGWORD_STYLE_USER_FIRST: u32 = 2147483648;
pub const IME_REGWORD_STYLE_USER_LAST: u32 = 4294967295;
pub const IACE_CHILDREN: u32 = 1;
pub const IACE_DEFAULT: u32 = 16;
pub const IACE_IGNORENOCONTEXT: u32 = 32;
pub const IGIMIF_RIGHTMENU: u32 = 1;
pub const IGIMII_CMODE: u32 = 1;
pub const IGIMII_SMODE: u32 = 2;
pub const IGIMII_CONFIGURE: u32 = 4;
pub const IGIMII_TOOLS: u32 = 8;
pub const IGIMII_HELP: u32 = 16;
pub const IGIMII_OTHER: u32 = 32;
pub const IGIMII_INPUTTOOLS: u32 = 64;
pub const IMFT_RADIOCHECK: u32 = 1;
pub const IMFT_SEPARATOR: u32 = 2;
pub const IMFT_SUBMENU: u32 = 4;
pub const IMFS_GRAYED: u32 = 3;
pub const IMFS_DISABLED: u32 = 3;
pub const IMFS_CHECKED: u32 = 8;
pub const IMFS_HILITE: u32 = 128;
pub const IMFS_ENABLED: u32 = 0;
pub const IMFS_UNCHECKED: u32 = 0;
pub const IMFS_UNHILITE: u32 = 0;
pub const IMFS_DEFAULT: u32 = 4096;
pub const SOFTKEYBOARD_TYPE_T1: u32 = 1;
pub const SOFTKEYBOARD_TYPE_C1: u32 = 2;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIdFAST16: &[u8; 2usize] = b"d\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIdMAX: &[u8; 4usize] = b"lld\0";
pub const PRIdPTR: &[u8; 4usize] = b"lld\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIiFAST16: &[u8; 2usize] = b"i\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIiMAX: &[u8; 4usize] = b"lli\0";
pub const PRIiPTR: &[u8; 4usize] = b"lli\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIoFAST16: &[u8; 2usize] = b"o\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIoMAX: &[u8; 4usize] = b"llo\0";
pub const PRIoPTR: &[u8; 4usize] = b"llo\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIuFAST16: &[u8; 2usize] = b"u\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIuMAX: &[u8; 4usize] = b"llu\0";
pub const PRIuPTR: &[u8; 4usize] = b"llu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIxFAST16: &[u8; 2usize] = b"x\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIxMAX: &[u8; 4usize] = b"llx\0";
pub const PRIxPTR: &[u8; 4usize] = b"llx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIXFAST16: &[u8; 2usize] = b"X\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIXMAX: &[u8; 4usize] = b"llX\0";
pub const PRIXPTR: &[u8; 4usize] = b"llX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2usize] = b"d\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNdMAX: &[u8; 4usize] = b"lld\0";
pub const SCNdPTR: &[u8; 4usize] = b"lld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2usize] = b"i\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNiMAX: &[u8; 4usize] = b"lli\0";
pub const SCNiPTR: &[u8; 4usize] = b"lli\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 2usize] = b"o\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNoMAX: &[u8; 4usize] = b"llo\0";
pub const SCNoPTR: &[u8; 4usize] = b"llo\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2usize] = b"u\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNuMAX: &[u8; 4usize] = b"llu\0";
pub const SCNuPTR: &[u8; 4usize] = b"llu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2usize] = b"x\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNxMAX: &[u8; 4usize] = b"llx\0";
pub const SCNxPTR: &[u8; 4usize] = b"llx\0";
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 1;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 57;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 37;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_E: f64 = 2.718281828459045;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: u32 = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: u32 = 8;
pub const LIBAVCODEC_VERSION_MAJOR: u32 = 59;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: u32 = 1;
pub const AV_CODEC_CAP_DR1: u32 = 2;
pub const AV_CODEC_CAP_TRUNCATED: u32 = 8;
pub const AV_CODEC_CAP_DELAY: u32 = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: u32 = 64;
pub const AV_CODEC_CAP_SUBFRAMES: u32 = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: u32 = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: u32 = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: u32 = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: u32 = 16384;
pub const AV_CODEC_CAP_OTHER_THREADS: u32 = 32768;
pub const AV_CODEC_CAP_AUTO_THREADS: u32 = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: u32 = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: u32 = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: u32 = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: u32 = 2147483648;
pub const AV_CODEC_CAP_HARDWARE: u32 = 262144;
pub const AV_CODEC_CAP_HYBRID: u32 = 524288;
pub const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE: u32 = 1048576;
pub const AV_CODEC_CAP_ENCODER_FLUSH: u32 = 2097152;
pub const AV_CODEC_CAP_ENCODER_RECON_FRAME: u32 = 4194304;
pub const AV_CODEC_PROP_INTRA_ONLY: u32 = 1;
pub const AV_CODEC_PROP_LOSSY: u32 = 2;
pub const AV_CODEC_PROP_LOSSLESS: u32 = 4;
pub const AV_CODEC_PROP_REORDER: u32 = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: u32 = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: u32 = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: u32 = 64;
pub const AV_EF_CRCCHECK: u32 = 1;
pub const AV_EF_BITSTREAM: u32 = 2;
pub const AV_EF_BUFFER: u32 = 4;
pub const AV_EF_EXPLODE: u32 = 8;
pub const AV_EF_IGNORE_ERR: u32 = 32768;
pub const AV_EF_CAREFUL: u32 = 65536;
pub const AV_EF_COMPLIANT: u32 = 131072;
pub const AV_EF_AGGRESSIVE: u32 = 262144;
pub const FF_COMPLIANCE_VERY_STRICT: u32 = 2;
pub const FF_COMPLIANCE_STRICT: u32 = 1;
pub const FF_COMPLIANCE_NORMAL: u32 = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: i32 = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: i32 = -2;
pub const AV_PKT_FLAG_KEY: u32 = 1;
pub const AV_PKT_FLAG_CORRUPT: u32 = 2;
pub const AV_PKT_FLAG_DISCARD: u32 = 4;
pub const AV_PKT_FLAG_TRUSTED: u32 = 8;
pub const AV_PKT_FLAG_DISPOSABLE: u32 = 16;
pub const LIBAVCODEC_VERSION_MINOR: u32 = 48;
pub const LIBAVCODEC_VERSION_MICRO: u32 = 100;
pub const AV_INPUT_BUFFER_MIN_SIZE: u32 = 16384;
pub const AV_CODEC_FLAG_UNALIGNED: u32 = 1;
pub const AV_CODEC_FLAG_QSCALE: u32 = 2;
pub const AV_CODEC_FLAG_4MV: u32 = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: u32 = 8;
pub const AV_CODEC_FLAG_QPEL: u32 = 16;
pub const AV_CODEC_FLAG_DROPCHANGED: u32 = 32;
pub const AV_CODEC_FLAG_RECON_FRAME: u32 = 64;
pub const AV_CODEC_FLAG_PASS1: u32 = 512;
pub const AV_CODEC_FLAG_PASS2: u32 = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: u32 = 2048;
pub const AV_CODEC_FLAG_GRAY: u32 = 8192;
pub const AV_CODEC_FLAG_PSNR: u32 = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: u32 = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: u32 = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: u32 = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: u32 = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: u32 = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: u32 = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: u32 = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: u32 = 2147483648;
pub const AV_CODEC_FLAG2_FAST: u32 = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: u32 = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: u32 = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: u32 = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: u32 = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: u32 = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: u32 = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: u32 = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: u32 = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: u32 = 1073741824;
pub const AV_CODEC_FLAG2_ICC_PROFILES: u32 = 2147483648;
pub const AV_CODEC_EXPORT_DATA_MVS: u32 = 1;
pub const AV_CODEC_EXPORT_DATA_PRFT: u32 = 2;
pub const AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS: u32 = 4;
pub const AV_CODEC_EXPORT_DATA_FILM_GRAIN: u32 = 8;
pub const AV_GET_BUFFER_FLAG_REF: u32 = 1;
pub const AV_GET_ENCODE_BUFFER_FLAG_REF: u32 = 1;
pub const FF_COMPRESSION_DEFAULT: i32 = -1;
pub const FF_CMP_SAD: u32 = 0;
pub const FF_CMP_SSE: u32 = 1;
pub const FF_CMP_SATD: u32 = 2;
pub const FF_CMP_DCT: u32 = 3;
pub const FF_CMP_PSNR: u32 = 4;
pub const FF_CMP_BIT: u32 = 5;
pub const FF_CMP_RD: u32 = 6;
pub const FF_CMP_ZERO: u32 = 7;
pub const FF_CMP_VSAD: u32 = 8;
pub const FF_CMP_VSSE: u32 = 9;
pub const FF_CMP_NSSE: u32 = 10;
pub const FF_CMP_W53: u32 = 11;
pub const FF_CMP_W97: u32 = 12;
pub const FF_CMP_DCTMAX: u32 = 13;
pub const FF_CMP_DCT264: u32 = 14;
pub const FF_CMP_MEDIAN_SAD: u32 = 15;
pub const FF_CMP_CHROMA: u32 = 256;
pub const SLICE_FLAG_CODED_ORDER: u32 = 1;
pub const SLICE_FLAG_ALLOW_FIELD: u32 = 2;
pub const SLICE_FLAG_ALLOW_PLANE: u32 = 4;
pub const FF_MB_DECISION_SIMPLE: u32 = 0;
pub const FF_MB_DECISION_BITS: u32 = 1;
pub const FF_MB_DECISION_RD: u32 = 2;
pub const FF_BUG_AUTODETECT: u32 = 1;
pub const FF_BUG_XVID_ILACE: u32 = 4;
pub const FF_BUG_UMP4: u32 = 8;
pub const FF_BUG_NO_PADDING: u32 = 16;
pub const FF_BUG_AMV: u32 = 32;
pub const FF_BUG_QPEL_CHROMA: u32 = 64;
pub const FF_BUG_STD_QPEL: u32 = 128;
pub const FF_BUG_QPEL_CHROMA2: u32 = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: u32 = 512;
pub const FF_BUG_EDGE: u32 = 1024;
pub const FF_BUG_HPEL_CHROMA: u32 = 2048;
pub const FF_BUG_DC_CLIP: u32 = 4096;
pub const FF_BUG_MS: u32 = 8192;
pub const FF_BUG_TRUNCATED: u32 = 16384;
pub const FF_BUG_IEDGE: u32 = 32768;
pub const FF_EC_GUESS_MVS: u32 = 1;
pub const FF_EC_DEBLOCK: u32 = 2;
pub const FF_EC_FAVOR_INTER: u32 = 256;
pub const FF_DEBUG_PICT_INFO: u32 = 1;
pub const FF_DEBUG_RC: u32 = 2;
pub const FF_DEBUG_BITSTREAM: u32 = 4;
pub const FF_DEBUG_MB_TYPE: u32 = 8;
pub const FF_DEBUG_QP: u32 = 16;
pub const FF_DEBUG_DCT_COEFF: u32 = 64;
pub const FF_DEBUG_SKIP: u32 = 128;
pub const FF_DEBUG_STARTCODE: u32 = 256;
pub const FF_DEBUG_ER: u32 = 1024;
pub const FF_DEBUG_MMCO: u32 = 2048;
pub const FF_DEBUG_BUGS: u32 = 4096;
pub const FF_DEBUG_BUFFERS: u32 = 32768;
pub const FF_DEBUG_THREADS: u32 = 65536;
pub const FF_DEBUG_GREEN_MD: u32 = 8388608;
pub const FF_DEBUG_NOMC: u32 = 16777216;
pub const FF_DCT_AUTO: u32 = 0;
pub const FF_DCT_FASTINT: u32 = 1;
pub const FF_DCT_INT: u32 = 2;
pub const FF_DCT_MMX: u32 = 3;
pub const FF_DCT_ALTIVEC: u32 = 5;
pub const FF_DCT_FAAN: u32 = 6;
pub const FF_IDCT_AUTO: u32 = 0;
pub const FF_IDCT_INT: u32 = 1;
pub const FF_IDCT_SIMPLE: u32 = 2;
pub const FF_IDCT_SIMPLEMMX: u32 = 3;
pub const FF_IDCT_ARM: u32 = 7;
pub const FF_IDCT_ALTIVEC: u32 = 8;
pub const FF_IDCT_SIMPLEARM: u32 = 10;
pub const FF_IDCT_XVID: u32 = 14;
pub const FF_IDCT_SIMPLEARMV5TE: u32 = 16;
pub const FF_IDCT_SIMPLEARMV6: u32 = 17;
pub const FF_IDCT_FAAN: u32 = 20;
pub const FF_IDCT_SIMPLENEON: u32 = 22;
pub const FF_IDCT_NONE: u32 = 24;
pub const FF_IDCT_SIMPLEAUTO: u32 = 128;
pub const FF_THREAD_FRAME: u32 = 1;
pub const FF_THREAD_SLICE: u32 = 2;
pub const FF_PROFILE_UNKNOWN: i32 = -99;
pub const FF_PROFILE_RESERVED: i32 = -100;
pub const FF_PROFILE_AAC_MAIN: u32 = 0;
pub const FF_PROFILE_AAC_LOW: u32 = 1;
pub const FF_PROFILE_AAC_SSR: u32 = 2;
pub const FF_PROFILE_AAC_LTP: u32 = 3;
pub const FF_PROFILE_AAC_HE: u32 = 4;
pub const FF_PROFILE_AAC_HE_V2: u32 = 28;
pub const FF_PROFILE_AAC_LD: u32 = 22;
pub const FF_PROFILE_AAC_ELD: u32 = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: u32 = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: u32 = 131;
pub const FF_PROFILE_DNXHD: u32 = 0;
pub const FF_PROFILE_DNXHR_LB: u32 = 1;
pub const FF_PROFILE_DNXHR_SQ: u32 = 2;
pub const FF_PROFILE_DNXHR_HQ: u32 = 3;
pub const FF_PROFILE_DNXHR_HQX: u32 = 4;
pub const FF_PROFILE_DNXHR_444: u32 = 5;
pub const FF_PROFILE_DTS: u32 = 20;
pub const FF_PROFILE_DTS_ES: u32 = 30;
pub const FF_PROFILE_DTS_96_24: u32 = 40;
pub const FF_PROFILE_DTS_HD_HRA: u32 = 50;
pub const FF_PROFILE_DTS_HD_MA: u32 = 60;
pub const FF_PROFILE_DTS_EXPRESS: u32 = 70;
pub const FF_PROFILE_MPEG2_422: u32 = 0;
pub const FF_PROFILE_MPEG2_HIGH: u32 = 1;
pub const FF_PROFILE_MPEG2_SS: u32 = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: u32 = 3;
pub const FF_PROFILE_MPEG2_MAIN: u32 = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: u32 = 5;
pub const FF_PROFILE_H264_CONSTRAINED: u32 = 512;
pub const FF_PROFILE_H264_INTRA: u32 = 2048;
pub const FF_PROFILE_H264_BASELINE: u32 = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: u32 = 578;
pub const FF_PROFILE_H264_MAIN: u32 = 77;
pub const FF_PROFILE_H264_EXTENDED: u32 = 88;
pub const FF_PROFILE_H264_HIGH: u32 = 100;
pub const FF_PROFILE_H264_HIGH_10: u32 = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: u32 = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: u32 = 118;
pub const FF_PROFILE_H264_HIGH_422: u32 = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: u32 = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: u32 = 128;
pub const FF_PROFILE_H264_HIGH_444: u32 = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: u32 = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: u32 = 2292;
pub const FF_PROFILE_H264_CAVLC_444: u32 = 44;
pub const FF_PROFILE_VC1_SIMPLE: u32 = 0;
pub const FF_PROFILE_VC1_MAIN: u32 = 1;
pub const FF_PROFILE_VC1_COMPLEX: u32 = 2;
pub const FF_PROFILE_VC1_ADVANCED: u32 = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: u32 = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: u32 = 1;
pub const FF_PROFILE_MPEG4_CORE: u32 = 2;
pub const FF_PROFILE_MPEG4_MAIN: u32 = 3;
pub const FF_PROFILE_MPEG4_N_BIT: u32 = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: u32 = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: u32 = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: u32 = 7;
pub const FF_PROFILE_MPEG4_HYBRID: u32 = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: u32 = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: u32 = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: u32 = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: u32 = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: u32 = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: u32 = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: u32 = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: u32 = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: u32 = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: u32 = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: u32 = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: u32 = 4;
pub const FF_PROFILE_VP9_0: u32 = 0;
pub const FF_PROFILE_VP9_1: u32 = 1;
pub const FF_PROFILE_VP9_2: u32 = 2;
pub const FF_PROFILE_VP9_3: u32 = 3;
pub const FF_PROFILE_HEVC_MAIN: u32 = 1;
pub const FF_PROFILE_HEVC_MAIN_10: u32 = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: u32 = 3;
pub const FF_PROFILE_HEVC_REXT: u32 = 4;
pub const FF_PROFILE_VVC_MAIN_10: u32 = 1;
pub const FF_PROFILE_VVC_MAIN_10_444: u32 = 33;
pub const FF_PROFILE_AV1_MAIN: u32 = 0;
pub const FF_PROFILE_AV1_HIGH: u32 = 1;
pub const FF_PROFILE_AV1_PROFESSIONAL: u32 = 2;
pub const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT: u32 = 192;
pub const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT: u32 = 193;
pub const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT: u32 = 194;
pub const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS: u32 = 195;
pub const FF_PROFILE_MJPEG_JPEG_LS: u32 = 247;
pub const FF_PROFILE_SBC_MSBC: u32 = 1;
pub const FF_PROFILE_PRORES_PROXY: u32 = 0;
pub const FF_PROFILE_PRORES_LT: u32 = 1;
pub const FF_PROFILE_PRORES_STANDARD: u32 = 2;
pub const FF_PROFILE_PRORES_HQ: u32 = 3;
pub const FF_PROFILE_PRORES_4444: u32 = 4;
pub const FF_PROFILE_PRORES_XQ: u32 = 5;
pub const FF_PROFILE_ARIB_PROFILE_A: u32 = 0;
pub const FF_PROFILE_ARIB_PROFILE_C: u32 = 1;
pub const FF_PROFILE_KLVA_SYNC: u32 = 0;
pub const FF_PROFILE_KLVA_ASYNC: u32 = 1;
pub const FF_LEVEL_UNKNOWN: i32 = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: i32 = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: u32 = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: u32 = 1;
pub const FF_SUB_CHARENC_MODE_IGNORE: u32 = 2;
pub const FF_DEBUG_VIS_MV_P_FOR: u32 = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: u32 = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: u32 = 4;
pub const FF_CODEC_PROPERTY_LOSSLESS: u32 = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: u32 = 2;
pub const FF_CODEC_PROPERTY_FILM_GRAIN: u32 = 4;
pub const FF_SUB_TEXT_FMT_ASS: u32 = 0;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: u32 = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: u32 = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: u32 = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: u32 = 4;
pub const AV_SUBTITLE_FLAG_FORCED: u32 = 1;
pub const AV_PARSER_PTS_NB: u32 = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: u32 = 1;
pub const PARSER_FLAG_ONCE: u32 = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: u32 = 4;
pub const PARSER_FLAG_USE_CODEC_TS: u32 = 4096;
pub const _CRT_USE_CONFORMING_ANNEX_K_TIME: u32 = 0;
pub const TIME_UTC: u32 = 1;
pub const LIBAVFORMAT_VERSION_MAJOR: u32 = 59;
pub const FF_API_R_FRAME_RATE: u32 = 1;
pub const AVIO_SEEKABLE_NORMAL: u32 = 1;
pub const AVIO_SEEKABLE_TIME: u32 = 2;
pub const AVSEEK_SIZE: u32 = 65536;
pub const AVSEEK_FORCE: u32 = 131072;
pub const AVIO_FLAG_READ: u32 = 1;
pub const AVIO_FLAG_WRITE: u32 = 2;
pub const AVIO_FLAG_READ_WRITE: u32 = 3;
pub const AVIO_FLAG_NONBLOCK: u32 = 8;
pub const AVIO_FLAG_DIRECT: u32 = 32768;
pub const LIBAVFORMAT_VERSION_MINOR: u32 = 33;
pub const LIBAVFORMAT_VERSION_MICRO: u32 = 100;
pub const AVPROBE_SCORE_EXTENSION: u32 = 50;
pub const AVPROBE_SCORE_MIME: u32 = 75;
pub const AVPROBE_SCORE_MAX: u32 = 100;
pub const AVPROBE_PADDING_SIZE: u32 = 32;
pub const AVFMT_NOFILE: u32 = 1;
pub const AVFMT_NEEDNUMBER: u32 = 2;
pub const AVFMT_EXPERIMENTAL: u32 = 4;
pub const AVFMT_SHOW_IDS: u32 = 8;
pub const AVFMT_GLOBALHEADER: u32 = 64;
pub const AVFMT_NOTIMESTAMPS: u32 = 128;
pub const AVFMT_GENERIC_INDEX: u32 = 256;
pub const AVFMT_TS_DISCONT: u32 = 512;
pub const AVFMT_VARIABLE_FPS: u32 = 1024;
pub const AVFMT_NODIMENSIONS: u32 = 2048;
pub const AVFMT_NOSTREAMS: u32 = 4096;
pub const AVFMT_NOBINSEARCH: u32 = 8192;
pub const AVFMT_NOGENSEARCH: u32 = 16384;
pub const AVFMT_NO_BYTE_SEEK: u32 = 32768;
pub const AVFMT_ALLOW_FLUSH: u32 = 65536;
pub const AVFMT_TS_NONSTRICT: u32 = 131072;
pub const AVFMT_TS_NEGATIVE: u32 = 262144;
pub const AVFMT_SEEK_TO_PTS: u32 = 67108864;
pub const AVINDEX_KEYFRAME: u32 = 1;
pub const AVINDEX_DISCARD_FRAME: u32 = 2;
pub const AV_DISPOSITION_DEFAULT: u32 = 1;
pub const AV_DISPOSITION_DUB: u32 = 2;
pub const AV_DISPOSITION_ORIGINAL: u32 = 4;
pub const AV_DISPOSITION_COMMENT: u32 = 8;
pub const AV_DISPOSITION_LYRICS: u32 = 16;
pub const AV_DISPOSITION_KARAOKE: u32 = 32;
pub const AV_DISPOSITION_FORCED: u32 = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: u32 = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: u32 = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: u32 = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: u32 = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: u32 = 2048;
pub const AV_DISPOSITION_NON_DIEGETIC: u32 = 4096;
pub const AV_DISPOSITION_CAPTIONS: u32 = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: u32 = 131072;
pub const AV_DISPOSITION_METADATA: u32 = 262144;
pub const AV_DISPOSITION_DEPENDENT: u32 = 524288;
pub const AV_DISPOSITION_STILL_IMAGE: u32 = 1048576;
pub const AV_PTS_WRAP_IGNORE: u32 = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: u32 = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: i32 = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const AVSTREAM_EVENT_FLAG_NEW_PACKETS: u32 = 2;
pub const AV_PROGRAM_RUNNING: u32 = 1;
pub const AVFMTCTX_NOHEADER: u32 = 1;
pub const AVFMTCTX_UNSEEKABLE: u32 = 2;
pub const AVFMT_FLAG_GENPTS: u32 = 1;
pub const AVFMT_FLAG_IGNIDX: u32 = 2;
pub const AVFMT_FLAG_NONBLOCK: u32 = 4;
pub const AVFMT_FLAG_IGNDTS: u32 = 8;
pub const AVFMT_FLAG_NOFILLIN: u32 = 16;
pub const AVFMT_FLAG_NOPARSE: u32 = 32;
pub const AVFMT_FLAG_NOBUFFER: u32 = 64;
pub const AVFMT_FLAG_CUSTOM_IO: u32 = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: u32 = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: u32 = 512;
pub const AVFMT_FLAG_BITEXACT: u32 = 1024;
pub const AVFMT_FLAG_SORT_DTS: u32 = 65536;
pub const AVFMT_FLAG_PRIV_OPT: u32 = 131072;
pub const AVFMT_FLAG_FAST_SEEK: u32 = 524288;
pub const AVFMT_FLAG_SHORTEST: u32 = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: u32 = 2097152;
pub const FF_FDEBUG_TS: u32 = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: i32 = -1;
pub const AVFMT_AVOID_NEG_TS_DISABLED: u32 = 0;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: u32 = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: u32 = 2;
pub const AVSEEK_FLAG_BACKWARD: u32 = 1;
pub const AVSEEK_FLAG_BYTE: u32 = 2;
pub const AVSEEK_FLAG_ANY: u32 = 4;
pub const AVSEEK_FLAG_FRAME: u32 = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: u32 = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: u32 = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: u32 = 1;
pub const AV_PIX_FMT_FLAG_BE: u32 = 1;
pub const AV_PIX_FMT_FLAG_PAL: u32 = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: u32 = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: u32 = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: u32 = 16;
pub const AV_PIX_FMT_FLAG_RGB: u32 = 32;
pub const AV_PIX_FMT_FLAG_ALPHA: u32 = 128;
pub const AV_PIX_FMT_FLAG_BAYER: u32 = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: u32 = 512;
pub const FF_LOSS_RESOLUTION: u32 = 1;
pub const FF_LOSS_DEPTH: u32 = 2;
pub const FF_LOSS_COLORSPACE: u32 = 4;
pub const FF_LOSS_ALPHA: u32 = 8;
pub const FF_LOSS_COLORQUANT: u32 = 16;
pub const FF_LOSS_CHROMA: u32 = 32;
pub const FF_LOSS_EXCESS_RESOLUTION: u32 = 64;
pub const FF_LOSS_EXCESS_DEPTH: u32 = 128;
pub const AV_OPT_FLAG_ENCODING_PARAM: u32 = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: u32 = 2;
pub const AV_OPT_FLAG_AUDIO_PARAM: u32 = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: u32 = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: u32 = 32;
pub const AV_OPT_FLAG_EXPORT: u32 = 64;
pub const AV_OPT_FLAG_READONLY: u32 = 128;
pub const AV_OPT_FLAG_BSF_PARAM: u32 = 256;
pub const AV_OPT_FLAG_RUNTIME_PARAM: u32 = 32768;
pub const AV_OPT_FLAG_FILTERING_PARAM: u32 = 65536;
pub const AV_OPT_FLAG_DEPRECATED: u32 = 131072;
pub const AV_OPT_FLAG_CHILD_CONSTS: u32 = 262144;
pub const AV_OPT_SEARCH_CHILDREN: u32 = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: u32 = 2;
pub const AV_OPT_ALLOW_NULL: u32 = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: u32 = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: u32 = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: u32 = 2;
pub const LIBSWSCALE_VERSION_MAJOR: u32 = 6;
pub const LIBSWSCALE_VERSION_MINOR: u32 = 8;
pub const LIBSWSCALE_VERSION_MICRO: u32 = 112;
pub const SWS_FAST_BILINEAR: u32 = 1;
pub const SWS_BILINEAR: u32 = 2;
pub const SWS_BICUBIC: u32 = 4;
pub const SWS_X: u32 = 8;
pub const SWS_POINT: u32 = 16;
pub const SWS_AREA: u32 = 32;
pub const SWS_BICUBLIN: u32 = 64;
pub const SWS_GAUSS: u32 = 128;
pub const SWS_SINC: u32 = 256;
pub const SWS_LANCZOS: u32 = 512;
pub const SWS_SPLINE: u32 = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: u32 = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: u32 = 16;
pub const SWS_PARAM_DEFAULT: u32 = 123456;
pub const SWS_PRINT_INFO: u32 = 4096;
pub const SWS_FULL_CHR_H_INT: u32 = 8192;
pub const SWS_FULL_CHR_H_INP: u32 = 16384;
pub const SWS_DIRECT_BGR: u32 = 32768;
pub const SWS_ACCURATE_RND: u32 = 262144;
pub const SWS_BITEXACT: u32 = 524288;
pub const SWS_ERROR_DIFFUSION: u32 = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: u32 = 1;
pub const SWS_CS_FCC: u32 = 4;
pub const SWS_CS_ITU601: u32 = 5;
pub const SWS_CS_ITU624: u32 = 5;
pub const SWS_CS_SMPTE170M: u32 = 5;
pub const SWS_CS_SMPTE240M: u32 = 7;
pub const SWS_CS_DEFAULT: u32 = 5;
pub const SWS_CS_BT2020: u32 = 9;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    __vcrt_va_list_is_reference__bindgen_ty_1::__the_value;
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __vcrt_va_list_is_reference__bindgen_ty_1 {
    __the_value = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution = 0,
    ExceptionContinueSearch = 1,
    ExceptionNestedException = 2,
    ExceptionCollidedUnwind = 3,
}
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
extern "C" {
    pub fn __C_specific_handler(
        ExceptionRecord: *mut _EXCEPTION_RECORD,
        EstablisherFrame: *mut ::std::os::raw::c_void,
        ContextRecord: *mut _CONTEXT,
        DispatcherContext: *mut _DISPATCHER_CONTEXT,
    ) -> EXCEPTION_DISPOSITION;
}
extern "C" {
    pub fn _exception_code() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _exception_info() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _abnormal_termination() -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type PUSHORT = *mut USHORT;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type PSZ = *mut ::std::os::raw::c_char;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type PFLOAT = *mut FLOAT;
pub type PBOOL = *mut BOOL;
pub type LPBOOL = *mut BOOL;
pub type PBYTE = *mut BYTE;
pub type LPBYTE = *mut BYTE;
pub type PINT = *mut ::std::os::raw::c_int;
pub type LPINT = *mut ::std::os::raw::c_int;
pub type PWORD = *mut WORD;
pub type LPWORD = *mut WORD;
pub type LPLONG = *mut ::std::os::raw::c_long;
pub type PDWORD = *mut DWORD;
pub type LPDWORD = *mut DWORD;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type LPCVOID = *const ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type PUINT = *mut ::std::os::raw::c_uint;
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const u16,
        _FunctionName: *const u16,
        _FileName: *const u16,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn __pctype_func() -> *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __pwctype_func() -> *const wctype_t;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsym(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype_l(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalpha_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _islower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isxdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isspace_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ispunct_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isblank_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalnum_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isprint_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isgraph_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscntrl_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsymf(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsym(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __acrt_locale_get_ctype_array_value(
        _Locale_pctype_array: *const ::std::os::raw::c_ushort,
        _Char_value: ::std::os::raw::c_int,
        _Mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ascii_tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ascii_toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ascii_iswalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ascii_iswdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ascii_towlower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ascii_towupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __acrt_get_locale_data_prefix(
        _LocalePointers: *const ::std::os::raw::c_void,
    ) -> *mut __crt_locale_data_public;
}
extern "C" {
    pub fn _chvalidchk_l(
        _C: ::std::os::raw::c_int,
        _Mask: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ischartype_l(
        _C: ::std::os::raw::c_int,
        _Mask: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
pub type POINTER_64_INT = ::std::os::raw::c_ulonglong;
pub type INT8 = ::std::os::raw::c_schar;
pub type PINT8 = *mut ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type PINT16 = *mut ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type PINT32 = *mut ::std::os::raw::c_int;
pub type INT64 = ::std::os::raw::c_longlong;
pub type PINT64 = *mut ::std::os::raw::c_longlong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type PUINT8 = *mut ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type PUINT16 = *mut ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type PUINT64 = *mut ::std::os::raw::c_ulonglong;
pub type LONG32 = ::std::os::raw::c_int;
pub type PLONG32 = *mut ::std::os::raw::c_int;
pub type ULONG32 = ::std::os::raw::c_uint;
pub type PULONG32 = *mut ::std::os::raw::c_uint;
pub type DWORD32 = ::std::os::raw::c_uint;
pub type PDWORD32 = *mut ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type PINT_PTR = *mut ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type PUINT_PTR = *mut ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type PLONG_PTR = *mut ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type PULONG_PTR = *mut ::std::os::raw::c_ulonglong;
pub type PHANDLE64 = *mut *mut ::std::os::raw::c_void;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type HANDLE_PTR = ::std::os::raw::c_ulonglong;
pub type UHALF_PTR = ::std::os::raw::c_uint;
pub type PUHALF_PTR = *mut ::std::os::raw::c_uint;
pub type HALF_PTR = ::std::os::raw::c_int;
pub type PHALF_PTR = *mut ::std::os::raw::c_int;
extern "C" {
    pub fn HandleToULong(h: *const ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HandleToLong(h: *const ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ULongToHandle(h: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LongToHandle(h: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PtrToUlong(p: *const ::std::os::raw::c_void) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn PtrToUint(p: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn PtrToUshort(p: *const ::std::os::raw::c_void) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn PtrToLong(p: *const ::std::os::raw::c_void) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn PtrToInt(p: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PtrToShort(p: *const ::std::os::raw::c_void) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn IntToPtr(i: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn UIntToPtr(ui: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LongToPtr(l: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ULongToPtr(ul: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Ptr32ToPtr(p: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Handle32ToHandle(h: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PtrToPtr32(p: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = ::std::os::raw::c_longlong;
pub type PLONG64 = *mut ::std::os::raw::c_longlong;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PULONG64 = *mut ::std::os::raw::c_ulonglong;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type PDWORD64 = *mut ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type PCZPCWSTR = *const PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type LPCWCHAR = *const WCHAR;
pub type PCWCHAR = *const WCHAR;
pub type LPCUWCHAR = *const WCHAR;
pub type PCUWCHAR = *const WCHAR;
pub type UCSCHAR = ::std::os::raw::c_ulong;
pub type PUCSCHAR = *mut UCSCHAR;
pub type PCUCSCHAR = *const UCSCHAR;
pub type PUCSSTR = *mut UCSCHAR;
pub type PUUCSSTR = *mut UCSCHAR;
pub type PCUCSSTR = *const UCSCHAR;
pub type PCUUCSSTR = *const UCSCHAR;
pub type PUUCSCHAR = *mut UCSCHAR;
pub type PCUUCSCHAR = *const UCSCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PCZPCSTR = *const PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = ::std::os::raw::c_char;
pub type PTCHAR = *mut ::std::os::raw::c_char;
pub type TBYTE = ::std::os::raw::c_uchar;
pub type PTBYTE = *mut ::std::os::raw::c_uchar;
pub type LPTCH = LPCH;
pub type PTCH = LPCH;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
    pub Group: WORD,
    pub Number: BYTE,
    pub Reserved: BYTE,
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
    pub Mask: KAFFINITY,
    pub Group: WORD,
    pub Reserved: [WORD; 3usize],
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = BYTE;
pub type FSHORT = WORD;
pub type FLONG = DWORD;
pub type HRESULT = ::std::os::raw::c_long;
pub type CCHAR = ::std::os::raw::c_char;
pub type LCID = DWORD;
pub type PLCID = PDWORD;
pub type LANGID = WORD;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum COMPARTMENT_ID {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID = 1,
}
pub type PCOMPARTMENT_ID = *mut COMPARTMENT_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOAT128 {
    pub LowPart: ::std::os::raw::c_longlong,
    pub HighPart: ::std::os::raw::c_longlong,
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
pub type RTL_REFERENCE_COUNT32 = LONG;
pub type PRTL_REFERENCE_COUNT32 = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
extern "C" {
    pub fn _rotl8(
        Value: ::std::os::raw::c_uchar,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _rotl16(
        Value: ::std::os::raw::c_ushort,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _rotr8(
        Value: ::std::os::raw::c_uchar,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _rotr16(
        Value: ::std::os::raw::c_ushort,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _rotl(
        Value: ::std::os::raw::c_uint,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotl64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        Value: ::std::os::raw::c_uint,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotr64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type BOOLEAN = BYTE;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: DWORD,
    pub Blink: DWORD,
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY64 {
    pub Flink: ULONGLONG,
    pub Blink: ULONGLONG,
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type LPIID = *mut IID;
pub type CLSID = GUID;
pub type LPCLSID = *mut CLSID;
pub type FMTID = GUID;
pub type LPFMTID = *mut FMTID;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const u16, _Ch: u16) -> *const u16;
}
extern "C" {
    pub fn wcsrchr(_Str: *const u16, _Ch: u16) -> *const u16;
}
extern "C" {
    pub fn wcsstr(_Str: *const u16, _SubStr: *const u16) -> *const u16;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?memchr@@YAPEAXPEAXH_K@Z"]
    pub fn memchr1(
        _Pv: *mut ::std::os::raw::c_void,
        _C: ::std::os::raw::c_int,
        _N: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wcscat_s(_Destination: *mut u16, _SizeInWords: rsize_t, _Source: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Destination: *mut u16, _SizeInWords: rsize_t, _Source: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut u16,
        _SizeInWords: rsize_t,
        _Source: *const u16,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut u16,
        _SizeInWords: rsize_t,
        _Source: *const u16,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(_String: *mut u16, _Delimiter: *const u16, _Context: *mut *mut u16)
        -> *mut u16;
}
extern "C" {
    pub fn _wcsdup(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscat(_Destination: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscspn(_String: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const u16) -> usize;
}
extern "C" {
    pub fn wcsnlen(_Source: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Destination: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Destination: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcspbrk(_String: *const u16, _Control: *const u16) -> *const u16;
}
extern "C" {
    pub fn wcsspn(_String: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcstok(_String: *mut u16, _Delimiter: *const u16, _Context: *mut *mut u16) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}?wcstok@@YAPEA_WPEA_WPEB_W@Z"]
    pub fn wcstok1(_String: *mut u16, _Delimiter: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _ErrorMessage: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut u16,
        _SizeInWords: usize,
        _Value: u16,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut u16, _Value: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wcsrev(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut u16, _SizeInWords: usize, _Value: u16) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut u16, _Value: u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut u16, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut u16, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut u16, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut u16, _Source: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut u16,
        _Source: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?wcschr@@YAPEA_WPEA_W_W@Z"]
    pub fn wcschr1(_String: *mut u16, _C: u16) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}?wcspbrk@@YAPEA_WPEA_WPEB_W@Z"]
    pub fn wcspbrk1(_String: *mut u16, _Control: *const u16) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}?wcsrchr@@YAPEA_WPEA_W_W@Z"]
    pub fn wcsrchr1(_String: *mut u16, _C: u16) -> *mut u16;
}
extern "C" {
    #[link_name = "\u{1}?wcsstr@@YAPEA_WPEA_WPEB_W@Z"]
    pub fn wcsstr1(_String: *mut u16, _SubStr: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsdup(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut u16, _Value: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsrev(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsset(_String: *mut u16, _Value: u16) -> *mut u16;
}
extern "C" {
    pub fn wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}?strchr@@YAPEADQEADH@Z"]
    pub fn strchr1(
        _String: *mut ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?strpbrk@@YAPEADQEADQEBD@Z"]
    pub fn strpbrk1(
        _String: *mut ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?strrchr@@YAPEADQEADH@Z"]
    pub fn strrchr1(
        _String: *mut ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?strstr@@YAPEADQEADQEBD@Z"]
    pub fn strstr1(
        _String: *mut ::std::os::raw::c_char,
        _SubString: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn InlineIsEqualGUID(rguid1: *const GUID, rguid2: *const GUID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsEqualGUID(rguid1: *const GUID, rguid2: *const GUID) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECTID {
    pub Lineage: GUID,
    pub Uniquifier: DWORD,
}
pub type OBJECTID = _OBJECTID;
pub type PEXCEPTION_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _EXCEPTION_RECORD,
        arg2: PVOID,
        arg3: *mut _CONTEXT,
        arg4: PVOID,
    ) -> EXCEPTION_DISPOSITION,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENUM_FLAG_SIZED_INTEGER {
    pub _address: u8,
}
pub type _ENUM_FLAG_SIZED_INTEGER_type = u8;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
pub type M128A = _M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: BYTE,
    pub Reserved1: BYTE,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: WORD,
    pub Reserved2: WORD,
    pub DataOffset: DWORD,
    pub DataSelector: WORD,
    pub Reserved3: WORD,
    pub MxCsr: DWORD,
    pub MxCsr_Mask: DWORD,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [BYTE; 96usize],
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_CET_U_FORMAT {
    pub Ia32CetUMsr: DWORD64,
    pub Ia32Pl3SspMsr: DWORD64,
}
pub type XSAVE_CET_U_FORMAT = _XSAVE_CET_U_FORMAT;
pub type PXSAVE_CET_U_FORMAT = *mut _XSAVE_CET_U_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
    pub Mask: DWORD64,
    pub CompactionMask: DWORD64,
    pub Reserved2: [DWORD64; 6usize],
}
pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
pub type XSAVE_AREA = _XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONTEXT {
    pub Mask: DWORD64,
    pub Length: DWORD,
    pub Reserved1: DWORD,
    pub Area: PXSAVE_AREA,
    pub Buffer: PVOID,
}
pub type XSTATE_CONTEXT = _XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT {
    pub Ssp: DWORD64,
    pub Rip: DWORD64,
    pub SegCs: WORD,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1,
    pub Fill: [WORD; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KERNEL_CET_CONTEXT__bindgen_ty_1 {
    pub AllFlags: WORD,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn UseWrss(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UseWrss(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PopShadowStackOne(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PopShadowStackOne(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UseWrss: WORD,
        PopShadowStackOne: WORD,
        Unused: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UseWrss: u16 = unsafe { ::std::mem::transmute(UseWrss) };
            UseWrss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PopShadowStackOne: u16 = unsafe { ::std::mem::transmute(PopShadowStackOne) };
            PopShadowStackOne as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Unused: u16 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type KERNEL_CET_CONTEXT = _KERNEL_CET_CONTEXT;
pub type PKERNEL_CET_CONTEXT = *mut _KERNEL_CET_CONTEXT;
pub type __C_ASSERT__ = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64 {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_AMD64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
pub type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE_AMD64 = *mut _SCOPE_TABLE_AMD64;
extern "C" {
    pub fn _bittest(Base: *const LONG, Offset: LONG) -> BOOLEAN;
}
extern "C" {
    pub fn _bittestandcomplement(Base: *mut LONG, Offset: LONG) -> BOOLEAN;
}
extern "C" {
    pub fn _bittestandset(Base: *mut LONG, Offset: LONG) -> BOOLEAN;
}
extern "C" {
    pub fn _bittestandreset(Base: *mut LONG, Offset: LONG) -> BOOLEAN;
}
extern "C" {
    pub fn _interlockedbittestandset(Base: *mut LONG, Offset: LONG) -> BOOLEAN;
}
extern "C" {
    pub fn _interlockedbittestandreset(Base: *mut LONG, Offset: LONG) -> BOOLEAN;
}
extern "C" {
    pub fn _bittest64(Base: *const LONG64, Offset: LONG64) -> BOOLEAN;
}
extern "C" {
    pub fn _bittestandcomplement64(Base: *mut LONG64, Offset: LONG64) -> BOOLEAN;
}
extern "C" {
    pub fn _bittestandset64(Base: *mut LONG64, Offset: LONG64) -> BOOLEAN;
}
extern "C" {
    pub fn _bittestandreset64(Base: *mut LONG64, Offset: LONG64) -> BOOLEAN;
}
extern "C" {
    pub fn _interlockedbittestandset64(Base: *mut LONG64, Offset: LONG64) -> BOOLEAN;
}
extern "C" {
    pub fn _interlockedbittestandreset64(Base: *mut LONG64, Offset: LONG64) -> BOOLEAN;
}
extern "C" {
    pub fn _BitScanForward(Index: *mut DWORD, Mask: DWORD) -> BOOLEAN;
}
extern "C" {
    pub fn _BitScanReverse(Index: *mut DWORD, Mask: DWORD) -> BOOLEAN;
}
extern "C" {
    pub fn _BitScanForward64(Index: *mut DWORD, Mask: DWORD64) -> BOOLEAN;
}
extern "C" {
    pub fn _BitScanReverse64(Index: *mut DWORD, Mask: DWORD64) -> BOOLEAN;
}
extern "C" {
    pub fn _InterlockedIncrement16(Addend: *mut SHORT) -> SHORT;
}
extern "C" {
    pub fn _InterlockedDecrement16(Addend: *mut SHORT) -> SHORT;
}
extern "C" {
    pub fn _InterlockedCompareExchange16(
        Destination: *mut SHORT,
        ExChange: SHORT,
        Comperand: SHORT,
    ) -> SHORT;
}
extern "C" {
    pub fn _InterlockedAnd(Destination: *mut LONG, Value: LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedOr(Destination: *mut LONG, Value: LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedXor(Destination: *mut LONG, Value: LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedAnd64(Destination: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedOr64(Destination: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedXor64(Destination: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedIncrement(Addend: *mut LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedDecrement(Addend: *mut LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedExchange(Target: *mut LONG, Value: LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedExchangeAdd(Addend: *mut LONG, Value: LONG) -> LONG;
}
extern "C" {
    pub fn _InlineInterlockedAdd(Addend: *mut LONG, Value: LONG) -> LONG;
}
extern "C" {
    pub fn _InterlockedCompareExchange(
        Destination: *mut LONG,
        ExChange: LONG,
        Comperand: LONG,
    ) -> LONG;
}
extern "C" {
    pub fn _InterlockedIncrement64(Addend: *mut LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedDecrement64(Addend: *mut LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedExchange64(Target: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedExchangeAdd64(Addend: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn _InlineInterlockedAdd64(Addend: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn _InterlockedCompareExchange64(
        Destination: *mut LONG64,
        ExChange: LONG64,
        Comperand: LONG64,
    ) -> LONG64;
}
extern "C" {
    pub fn _InterlockedCompareExchange128(
        Destination: *mut LONG64,
        ExchangeHigh: LONG64,
        ExchangeLow: LONG64,
        ComparandResult: *mut LONG64,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn _InterlockedCompareExchangePointer(
        Destination: *mut PVOID,
        Exchange: PVOID,
        Comperand: PVOID,
    ) -> PVOID;
}
extern "C" {
    pub fn _InterlockedExchangePointer(Target: *mut PVOID, Value: PVOID) -> PVOID;
}
extern "C" {
    pub fn _InterlockedExchange8(Target: *mut CHAR, Value: CHAR) -> CHAR;
}
extern "C" {
    pub fn _InterlockedExchange16(Destination: *mut SHORT, ExChange: SHORT) -> SHORT;
}
extern "C" {
    pub fn _InterlockedExchangeAdd8(
        _Addend: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedAnd8(
        Destination: *mut ::std::os::raw::c_char,
        Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedOr8(
        Destination: *mut ::std::os::raw::c_char,
        Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedXor8(
        Destination: *mut ::std::os::raw::c_char,
        Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedAnd16(Destination: *mut SHORT, Value: SHORT) -> SHORT;
}
extern "C" {
    pub fn _InterlockedOr16(Destination: *mut SHORT, Value: SHORT) -> SHORT;
}
extern "C" {
    pub fn _InterlockedXor16(Destination: *mut SHORT, Value: SHORT) -> SHORT;
}
extern "C" {
    pub fn __cpuidex(
        CPUInfo: *mut ::std::os::raw::c_int,
        Function: ::std::os::raw::c_int,
        SubLeaf: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _mm_clflush(Address: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _ReadWriteBarrier();
}
extern "C" {
    pub fn __faststorefence();
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    pub fn _mm_prefetch(a: *const CHAR, sel: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _m_prefetchw(Source: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(MxCsr: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __getcallerseflags() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __segmentlimit(Selector: DWORD) -> DWORD;
}
extern "C" {
    pub fn __readpmc(Counter: DWORD) -> DWORD64;
}
extern "C" {
    pub fn __rdtsc() -> DWORD64;
}
extern "C" {
    pub fn __movsb(Destination: PBYTE, Source: *const BYTE, Count: SIZE_T);
}
extern "C" {
    pub fn __movsw(Destination: PWORD, Source: *const WORD, Count: SIZE_T);
}
extern "C" {
    pub fn __movsd(Destination: PDWORD, Source: *const DWORD, Count: SIZE_T);
}
extern "C" {
    pub fn __movsq(Destination: PDWORD64, Source: *const DWORD64, Count: SIZE_T);
}
extern "C" {
    pub fn __stosb(Destination: PBYTE, Value: BYTE, Count: SIZE_T);
}
extern "C" {
    pub fn __stosw(Destination: PWORD, Value: WORD, Count: SIZE_T);
}
extern "C" {
    pub fn __stosd(Destination: PDWORD, Value: DWORD, Count: SIZE_T);
}
extern "C" {
    pub fn __stosq(Destination: PDWORD64, Value: DWORD64, Count: SIZE_T);
}
extern "C" {
    pub fn __mulh(Multiplier: LONG64, Multiplicand: LONG64) -> LONGLONG;
}
extern "C" {
    pub fn __umulh(Multiplier: DWORD64, Multiplicand: DWORD64) -> ULONGLONG;
}
extern "C" {
    pub fn __popcnt64(operand: DWORD64) -> DWORD64;
}
extern "C" {
    pub fn __shiftleft128(LowPart: DWORD64, HighPart: DWORD64, Shift: BYTE) -> DWORD64;
}
extern "C" {
    pub fn __shiftright128(LowPart: DWORD64, HighPart: DWORD64, Shift: BYTE) -> DWORD64;
}
extern "C" {
    pub fn _mul128(Multiplier: LONG64, Multiplicand: LONG64, HighProduct: *mut LONG64) -> LONG64;
}
extern "C" {
    pub fn UnsignedMultiply128(
        Multiplier: DWORD64,
        Multiplicand: DWORD64,
        HighProduct: *mut DWORD64,
    ) -> DWORD64;
}
extern "C" {
    pub fn _umul128(
        Multiplier: DWORD64,
        Multiplicand: DWORD64,
        HighProduct: *mut DWORD64,
    ) -> DWORD64;
}
extern "C" {
    pub fn MultiplyExtract128(Multiplier: LONG64, Multiplicand: LONG64, Shift: BYTE) -> LONG64;
}
extern "C" {
    pub fn UnsignedMultiplyExtract128(
        Multiplier: DWORD64,
        Multiplicand: DWORD64,
        Shift: BYTE,
    ) -> DWORD64;
}
extern "C" {
    pub fn __readgsbyte(Offset: DWORD) -> BYTE;
}
extern "C" {
    pub fn __readgsword(Offset: DWORD) -> WORD;
}
extern "C" {
    pub fn __readgsdword(Offset: DWORD) -> DWORD;
}
extern "C" {
    pub fn __readgsqword(Offset: DWORD) -> DWORD64;
}
extern "C" {
    pub fn __writegsbyte(Offset: DWORD, Data: BYTE);
}
extern "C" {
    pub fn __writegsword(Offset: DWORD, Data: WORD);
}
extern "C" {
    pub fn __writegsdword(Offset: DWORD, Data: DWORD);
}
extern "C" {
    pub fn __writegsqword(Offset: DWORD, Data: DWORD64);
}
extern "C" {
    pub fn __incgsbyte(Offset: DWORD);
}
extern "C" {
    pub fn __addgsbyte(Offset: DWORD, Value: BYTE);
}
extern "C" {
    pub fn __incgsword(Offset: DWORD);
}
extern "C" {
    pub fn __addgsword(Offset: DWORD, Value: WORD);
}
extern "C" {
    pub fn __incgsdword(Offset: DWORD);
}
extern "C" {
    pub fn __addgsdword(Offset: DWORD, Value: DWORD);
}
extern "C" {
    pub fn __incgsqword(Offset: DWORD);
}
extern "C" {
    pub fn __addgsqword(Offset: DWORD, Value: DWORD64);
}
pub type XMM_SAVE_AREA32 = XSAVE_FORMAT;
pub type PXMM_SAVE_AREA32 = *mut XSAVE_FORMAT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
    pub P1Home: DWORD64,
    pub P2Home: DWORD64,
    pub P3Home: DWORD64,
    pub P4Home: DWORD64,
    pub P5Home: DWORD64,
    pub P6Home: DWORD64,
    pub ContextFlags: DWORD,
    pub MxCsr: DWORD,
    pub SegCs: WORD,
    pub SegDs: WORD,
    pub SegEs: WORD,
    pub SegFs: WORD,
    pub SegGs: WORD,
    pub SegSs: WORD,
    pub EFlags: DWORD,
    pub Dr0: DWORD64,
    pub Dr1: DWORD64,
    pub Dr2: DWORD64,
    pub Dr3: DWORD64,
    pub Dr6: DWORD64,
    pub Dr7: DWORD64,
    pub Rax: DWORD64,
    pub Rcx: DWORD64,
    pub Rdx: DWORD64,
    pub Rbx: DWORD64,
    pub Rsp: DWORD64,
    pub Rbp: DWORD64,
    pub Rsi: DWORD64,
    pub Rdi: DWORD64,
    pub R8: DWORD64,
    pub R9: DWORD64,
    pub R10: DWORD64,
    pub R11: DWORD64,
    pub R12: DWORD64,
    pub R13: DWORD64,
    pub R14: DWORD64,
    pub R15: DWORD64,
    pub Rip: DWORD64,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
    pub VectorRegister: [M128A; 26usize],
    pub VectorControl: DWORD64,
    pub DebugControl: DWORD64,
    pub LastBranchToRip: DWORD64,
    pub LastBranchFromRip: DWORD64,
    pub LastExceptionToRip: DWORD64,
    pub LastExceptionFromRip: DWORD64,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
    pub FltSave: XMM_SAVE_AREA32,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Header: [M128A; 2usize],
    pub Legacy: [M128A; 8usize],
    pub Xmm0: M128A,
    pub Xmm1: M128A,
    pub Xmm2: M128A,
    pub Xmm3: M128A,
    pub Xmm4: M128A,
    pub Xmm5: M128A,
    pub Xmm6: M128A,
    pub Xmm7: M128A,
    pub Xmm8: M128A,
    pub Xmm9: M128A,
    pub Xmm10: M128A,
    pub Xmm11: M128A,
    pub Xmm12: M128A,
    pub Xmm13: M128A,
    pub Xmm14: M128A,
    pub Xmm15: M128A,
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
pub type RUNTIME_FUNCTION = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PRUNTIME_FUNCTION = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type SCOPE_TABLE = SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE = *mut SCOPE_TABLE_AMD64;
pub type GET_RUNTIME_FUNCTION_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(ControlPc: DWORD64, Context: PVOID) -> PRUNTIME_FUNCTION,
>;
pub type PGET_RUNTIME_FUNCTION_CALLBACK = GET_RUNTIME_FUNCTION_CALLBACK;
pub type OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Process: HANDLE,
        TableAddress: PVOID,
        Entries: PDWORD,
        Functions: *mut PRUNTIME_FUNCTION,
    ) -> DWORD,
>;
pub type POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT {
    pub ControlPc: DWORD64,
    pub ImageBase: DWORD64,
    pub FunctionEntry: PRUNTIME_FUNCTION,
    pub EstablisherFrame: DWORD64,
    pub TargetIp: DWORD64,
    pub ContextRecord: PCONTEXT,
    pub LanguageHandler: PEXCEPTION_ROUTINE,
    pub HandlerData: PVOID,
    pub HistoryTable: *mut _UNWIND_HISTORY_TABLE,
    pub ScopeIndex: DWORD,
    pub Fill0: DWORD,
}
pub type DISPATCHER_CONTEXT = _DISPATCHER_CONTEXT;
pub type PDISPATCHER_CONTEXT = *mut _DISPATCHER_CONTEXT;
pub type PEXCEPTION_FILTER = ::std::option::Option<
    unsafe extern "C" fn(
        ExceptionPointers: *mut _EXCEPTION_POINTERS,
        EstablisherFrame: PVOID,
    ) -> LONG,
>;
pub type PTERMINATION_HANDLER = ::std::option::Option<
    unsafe extern "C" fn(_abnormal_termination: BOOLEAN, EstablisherFrame: PVOID),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS {
    pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1,
    pub __bindgen_anon_2: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1 {
    pub FloatingContext: [PM128A; 16usize],
    pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1 {
    pub Xmm0: PM128A,
    pub Xmm1: PM128A,
    pub Xmm2: PM128A,
    pub Xmm3: PM128A,
    pub Xmm4: PM128A,
    pub Xmm5: PM128A,
    pub Xmm6: PM128A,
    pub Xmm7: PM128A,
    pub Xmm8: PM128A,
    pub Xmm9: PM128A,
    pub Xmm10: PM128A,
    pub Xmm11: PM128A,
    pub Xmm12: PM128A,
    pub Xmm13: PM128A,
    pub Xmm14: PM128A,
    pub Xmm15: PM128A,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2 {
    pub IntegerContext: [PDWORD64; 16usize],
    pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1 {
    pub Rax: PDWORD64,
    pub Rcx: PDWORD64,
    pub Rdx: PDWORD64,
    pub Rbx: PDWORD64,
    pub Rsp: PDWORD64,
    pub Rbp: PDWORD64,
    pub Rsi: PDWORD64,
    pub Rdi: PDWORD64,
    pub R8: PDWORD64,
    pub R9: PDWORD64,
    pub R10: PDWORD64,
    pub R11: PDWORD64,
    pub R12: PDWORD64,
    pub R13: PDWORD64,
    pub R14: PDWORD64,
    pub R15: PDWORD64,
}
pub type KNONVOLATILE_CONTEXT_POINTERS = _KNONVOLATILE_CONTEXT_POINTERS;
pub type PKNONVOLATILE_CONTEXT_POINTERS = *mut _KNONVOLATILE_CONTEXT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_ARM__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
pub type SCOPE_TABLE_ARM = _SCOPE_TABLE_ARM;
pub type PSCOPE_TABLE_ARM = *mut _SCOPE_TABLE_ARM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64 {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_ARM64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
pub type SCOPE_TABLE_ARM64 = _SCOPE_TABLE_ARM64;
pub type PSCOPE_TABLE_ARM64 = *mut _SCOPE_TABLE_ARM64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64_NT_NEON128 {
    pub __bindgen_anon_1: _ARM64_NT_NEON128__bindgen_ty_1,
    pub D: [f64; 2usize],
    pub S: [f32; 4usize],
    pub H: [WORD; 8usize],
    pub B: [BYTE; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARM64_NT_NEON128__bindgen_ty_1 {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
pub type ARM64_NT_NEON128 = _ARM64_NT_NEON128;
pub type PARM64_NT_NEON128 = *mut _ARM64_NT_NEON128;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _ARM64_NT_CONTEXT {
    pub ContextFlags: DWORD,
    pub Cpsr: DWORD,
    pub __bindgen_anon_1: _ARM64_NT_CONTEXT__bindgen_ty_1,
    pub Sp: DWORD64,
    pub Pc: DWORD64,
    pub V: [ARM64_NT_NEON128; 32usize],
    pub Fpcr: DWORD,
    pub Fpsr: DWORD,
    pub Bcr: [DWORD; 8usize],
    pub Bvr: [DWORD64; 8usize],
    pub Wcr: [DWORD; 2usize],
    pub Wvr: [DWORD64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64_NT_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _ARM64_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub X: [DWORD64; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ARM64_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub X0: DWORD64,
    pub X1: DWORD64,
    pub X2: DWORD64,
    pub X3: DWORD64,
    pub X4: DWORD64,
    pub X5: DWORD64,
    pub X6: DWORD64,
    pub X7: DWORD64,
    pub X8: DWORD64,
    pub X9: DWORD64,
    pub X10: DWORD64,
    pub X11: DWORD64,
    pub X12: DWORD64,
    pub X13: DWORD64,
    pub X14: DWORD64,
    pub X15: DWORD64,
    pub X16: DWORD64,
    pub X17: DWORD64,
    pub X18: DWORD64,
    pub X19: DWORD64,
    pub X20: DWORD64,
    pub X21: DWORD64,
    pub X22: DWORD64,
    pub X23: DWORD64,
    pub X24: DWORD64,
    pub X25: DWORD64,
    pub X26: DWORD64,
    pub X27: DWORD64,
    pub X28: DWORD64,
    pub Fp: DWORD64,
    pub Lr: DWORD64,
}
pub type ARM64_NT_CONTEXT = _ARM64_NT_CONTEXT;
pub type PARM64_NT_CONTEXT = *mut _ARM64_NT_CONTEXT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _ARM64EC_NT_CONTEXT {
    pub __bindgen_anon_1: _ARM64EC_NT_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ARM64EC_NT_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub AMD64_P1Home: DWORD64,
    pub AMD64_P2Home: DWORD64,
    pub AMD64_P3Home: DWORD64,
    pub AMD64_P4Home: DWORD64,
    pub AMD64_P5Home: DWORD64,
    pub AMD64_P6Home: DWORD64,
    pub ContextFlags: DWORD,
    pub AMD64_MxCsr_copy: DWORD,
    pub AMD64_SegCs: WORD,
    pub AMD64_SegDs: WORD,
    pub AMD64_SegEs: WORD,
    pub AMD64_SegFs: WORD,
    pub AMD64_SegGs: WORD,
    pub AMD64_SegSs: WORD,
    pub AMD64_EFlags: DWORD,
    pub AMD64_Dr0: DWORD64,
    pub AMD64_Dr1: DWORD64,
    pub AMD64_Dr2: DWORD64,
    pub AMD64_Dr3: DWORD64,
    pub AMD64_Dr6: DWORD64,
    pub AMD64_Dr7: DWORD64,
    pub X8: DWORD64,
    pub X0: DWORD64,
    pub X1: DWORD64,
    pub X27: DWORD64,
    pub Sp: DWORD64,
    pub Fp: DWORD64,
    pub X25: DWORD64,
    pub X26: DWORD64,
    pub X2: DWORD64,
    pub X3: DWORD64,
    pub X4: DWORD64,
    pub X5: DWORD64,
    pub X19: DWORD64,
    pub X20: DWORD64,
    pub X21: DWORD64,
    pub X22: DWORD64,
    pub Pc: DWORD64,
    pub __bindgen_anon_1: _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub AMD64_VectorRegister: [ARM64_NT_NEON128; 26usize],
    pub AMD64_VectorControl: DWORD64,
    pub AMD64_DebugControl: DWORD64,
    pub AMD64_LastBranchToRip: DWORD64,
    pub AMD64_LastBranchFromRip: DWORD64,
    pub AMD64_LastExceptionToRip: DWORD64,
    pub AMD64_LastExceptionFromRip: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ARM64EC_NT_CONTEXT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AMD64_ControlWord: WORD,
    pub AMD64_StatusWord: WORD,
    pub AMD64_TagWord: BYTE,
    pub AMD64_Reserved1: BYTE,
    pub AMD64_ErrorOpcode: WORD,
    pub AMD64_ErrorOffset: DWORD,
    pub AMD64_ErrorSelector: WORD,
    pub AMD64_Reserved2: WORD,
    pub AMD64_DataOffset: DWORD,
    pub AMD64_DataSelector: WORD,
    pub AMD64_Reserved3: WORD,
    pub AMD64_MxCsr: DWORD,
    pub AMD64_MxCsr_Mask: DWORD,
    pub Lr: DWORD64,
    pub X16_0: WORD,
    pub AMD64_St0_Reserved1: WORD,
    pub AMD64_St0_Reserved2: DWORD,
    pub X6: DWORD64,
    pub X16_1: WORD,
    pub AMD64_St1_Reserved1: WORD,
    pub AMD64_St1_Reserved2: DWORD,
    pub X7: DWORD64,
    pub X16_2: WORD,
    pub AMD64_St2_Reserved1: WORD,
    pub AMD64_St2_Reserved2: DWORD,
    pub X9: DWORD64,
    pub X16_3: WORD,
    pub AMD64_St3_Reserved1: WORD,
    pub AMD64_St3_Reserved2: DWORD,
    pub X10: DWORD64,
    pub X17_0: WORD,
    pub AMD64_St4_Reserved1: WORD,
    pub AMD64_St4_Reserved2: DWORD,
    pub X11: DWORD64,
    pub X17_1: WORD,
    pub AMD64_St5_Reserved1: WORD,
    pub AMD64_St5_Reserved2: DWORD,
    pub X12: DWORD64,
    pub X17_2: WORD,
    pub AMD64_St6_Reserved1: WORD,
    pub AMD64_St6_Reserved2: DWORD,
    pub X15: DWORD64,
    pub X17_3: WORD,
    pub AMD64_St7_Reserved1: WORD,
    pub AMD64_St7_Reserved2: DWORD,
    pub V: [ARM64_NT_NEON128; 16usize],
    pub AMD64_XSAVE_FORMAT_Reserved4: [BYTE; 96usize],
}
pub type ARM64EC_NT_CONTEXT = _ARM64EC_NT_CONTEXT;
pub type PARM64EC_NT_CONTEXT = *mut _ARM64EC_NT_CONTEXT;
pub type ARM64_RUNTIME_FUNCTION = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type PARM64_RUNTIME_FUNCTION = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_CONTEXT_NONVOLREG_ARM64 {
    pub Buffer: [BYTE; 152usize],
    pub __bindgen_anon_1: _DISPATCHER_CONTEXT_NONVOLREG_ARM64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT_NONVOLREG_ARM64__bindgen_ty_1 {
    pub GpNvRegs: [DWORD64; 11usize],
    pub FpNvRegs: [f64; 8usize],
}
pub type DISPATCHER_CONTEXT_NONVOLREG_ARM64 = _DISPATCHER_CONTEXT_NONVOLREG_ARM64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT_ARM64 {
    pub ControlPc: ULONG_PTR,
    pub ImageBase: ULONG_PTR,
    pub FunctionEntry: PARM64_RUNTIME_FUNCTION,
    pub EstablisherFrame: ULONG_PTR,
    pub TargetPc: ULONG_PTR,
    pub ContextRecord: PARM64_NT_CONTEXT,
    pub LanguageHandler: PEXCEPTION_ROUTINE,
    pub HandlerData: PVOID,
    pub HistoryTable: *mut _UNWIND_HISTORY_TABLE,
    pub ScopeIndex: DWORD,
    pub ControlPcIsUnwound: BOOLEAN,
    pub NonVolatileRegisters: PBYTE,
}
pub type DISPATCHER_CONTEXT_ARM64 = _DISPATCHER_CONTEXT_ARM64;
pub type PDISPATCHER_CONTEXT_ARM64 = *mut _DISPATCHER_CONTEXT_ARM64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    pub X19: PDWORD64,
    pub X20: PDWORD64,
    pub X21: PDWORD64,
    pub X22: PDWORD64,
    pub X23: PDWORD64,
    pub X24: PDWORD64,
    pub X25: PDWORD64,
    pub X26: PDWORD64,
    pub X27: PDWORD64,
    pub X28: PDWORD64,
    pub Fp: PDWORD64,
    pub Lr: PDWORD64,
    pub D8: PDWORD64,
    pub D9: PDWORD64,
    pub D10: PDWORD64,
    pub D11: PDWORD64,
    pub D12: PDWORD64,
    pub D13: PDWORD64,
    pub D14: PDWORD64,
    pub D15: PDWORD64,
}
pub type KNONVOLATILE_CONTEXT_POINTERS_ARM64 = _KNONVOLATILE_CONTEXT_POINTERS_ARM64;
pub type PKNONVOLATILE_CONTEXT_POINTERS_ARM64 = *mut _KNONVOLATILE_CONTEXT_POINTERS_ARM64;
extern "C" {
    pub fn __int2c() -> !;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDT_ENTRY {
    pub LimitLow: WORD,
    pub BaseLow: WORD,
    pub HighWord: _LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDT_ENTRY__bindgen_ty_1 {
    pub Bytes: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Bits: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub BaseMid: BYTE,
    pub Flags1: BYTE,
    pub Flags2: BYTE,
    pub BaseHi: BYTE,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: DWORD,
        Type: DWORD,
        Dpl: DWORD,
        Pres: DWORD,
        LimitHi: DWORD,
        Sys: DWORD,
        Reserved_0: DWORD,
        Default_Big: DWORD,
        Granularity: DWORD,
        BaseHi: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type LDT_ENTRY = _LDT_ENTRY;
pub type PLDT_ENTRY = *mut _LDT_ENTRY;
extern "C" {
    pub fn ReadAcquire8(Source: *const CHAR) -> CHAR;
}
extern "C" {
    pub fn ReadNoFence8(Source: *const CHAR) -> CHAR;
}
extern "C" {
    pub fn WriteRelease8(Destination: *mut CHAR, Value: CHAR);
}
extern "C" {
    pub fn WriteNoFence8(Destination: *mut CHAR, Value: CHAR);
}
extern "C" {
    pub fn ReadAcquire16(Source: *const SHORT) -> SHORT;
}
extern "C" {
    pub fn ReadNoFence16(Source: *const SHORT) -> SHORT;
}
extern "C" {
    pub fn WriteRelease16(Destination: *mut SHORT, Value: SHORT);
}
extern "C" {
    pub fn WriteNoFence16(Destination: *mut SHORT, Value: SHORT);
}
extern "C" {
    pub fn ReadAcquire(Source: *const LONG) -> LONG;
}
extern "C" {
    pub fn ReadNoFence(Source: *const LONG) -> LONG;
}
extern "C" {
    pub fn WriteRelease(Destination: *mut LONG, Value: LONG);
}
extern "C" {
    pub fn WriteNoFence(Destination: *mut LONG, Value: LONG);
}
extern "C" {
    pub fn ReadAcquire64(Source: *const LONG64) -> LONG64;
}
extern "C" {
    pub fn ReadNoFence64(Source: *const LONG64) -> LONG64;
}
extern "C" {
    pub fn WriteRelease64(Destination: *mut LONG64, Value: LONG64);
}
extern "C" {
    pub fn WriteNoFence64(Destination: *mut LONG64, Value: LONG64);
}
extern "C" {
    pub fn BarrierAfterRead();
}
extern "C" {
    pub fn ReadRaw8(Source: *const CHAR) -> CHAR;
}
extern "C" {
    pub fn WriteRaw8(Destination: *mut CHAR, Value: CHAR);
}
extern "C" {
    pub fn ReadRaw16(Source: *const SHORT) -> SHORT;
}
extern "C" {
    pub fn WriteRaw16(Destination: *mut SHORT, Value: SHORT);
}
extern "C" {
    pub fn ReadRaw(Source: *const LONG) -> LONG;
}
extern "C" {
    pub fn WriteRaw(Destination: *mut LONG, Value: LONG);
}
extern "C" {
    pub fn ReadRaw64(Source: *const LONG64) -> LONG64;
}
extern "C" {
    pub fn WriteRaw64(Destination: *mut LONG64, Value: LONG64);
}
extern "C" {
    pub fn ReadUCharAcquire(Source: *const BYTE) -> BYTE;
}
extern "C" {
    pub fn ReadUCharNoFence(Source: *const BYTE) -> BYTE;
}
extern "C" {
    pub fn ReadBooleanAcquire(Source: *const BOOLEAN) -> BYTE;
}
extern "C" {
    pub fn ReadBooleanNoFence(Source: *const BOOLEAN) -> BYTE;
}
extern "C" {
    pub fn ReadBooleanRaw(Source: *const BOOLEAN) -> BYTE;
}
extern "C" {
    pub fn ReadUCharRaw(Source: *const BYTE) -> BYTE;
}
extern "C" {
    pub fn WriteUCharRelease(Destination: *mut BYTE, Value: BYTE);
}
extern "C" {
    pub fn WriteUCharNoFence(Destination: *mut BYTE, Value: BYTE);
}
extern "C" {
    pub fn WriteBooleanRelease(Destination: *mut BOOLEAN, Value: BOOLEAN);
}
extern "C" {
    pub fn WriteBooleanNoFence(Destination: *mut BOOLEAN, Value: BOOLEAN);
}
extern "C" {
    pub fn WriteUCharRaw(Destination: *mut BYTE, Value: BYTE);
}
extern "C" {
    pub fn ReadUShortAcquire(Source: *const WORD) -> WORD;
}
extern "C" {
    pub fn ReadUShortNoFence(Source: *const WORD) -> WORD;
}
extern "C" {
    pub fn ReadUShortRaw(Source: *const WORD) -> WORD;
}
extern "C" {
    pub fn WriteUShortRelease(Destination: *mut WORD, Value: WORD);
}
extern "C" {
    pub fn WriteUShortNoFence(Destination: *mut WORD, Value: WORD);
}
extern "C" {
    pub fn WriteUShortRaw(Destination: *mut WORD, Value: WORD);
}
extern "C" {
    pub fn ReadULongAcquire(Source: *const DWORD) -> DWORD;
}
extern "C" {
    pub fn ReadULongNoFence(Source: *const DWORD) -> DWORD;
}
extern "C" {
    pub fn ReadULongRaw(Source: *const DWORD) -> DWORD;
}
extern "C" {
    pub fn WriteULongRelease(Destination: *mut DWORD, Value: DWORD);
}
extern "C" {
    pub fn WriteULongNoFence(Destination: *mut DWORD, Value: DWORD);
}
extern "C" {
    pub fn WriteULongRaw(Destination: *mut DWORD, Value: DWORD);
}
extern "C" {
    pub fn ReadInt32Acquire(Source: *const INT32) -> INT32;
}
extern "C" {
    pub fn ReadInt32NoFence(Source: *const INT32) -> INT32;
}
extern "C" {
    pub fn ReadInt32Raw(Source: *const INT32) -> INT32;
}
extern "C" {
    pub fn WriteInt32Release(Destination: *mut INT32, Value: INT32);
}
extern "C" {
    pub fn WriteInt32NoFence(Destination: *mut INT32, Value: INT32);
}
extern "C" {
    pub fn WriteInt32Raw(Destination: *mut INT32, Value: INT32);
}
extern "C" {
    pub fn ReadUInt32Acquire(Source: *const UINT32) -> UINT32;
}
extern "C" {
    pub fn ReadUInt32NoFence(Source: *const UINT32) -> UINT32;
}
extern "C" {
    pub fn ReadUInt32Raw(Source: *const UINT32) -> UINT32;
}
extern "C" {
    pub fn WriteUInt32Release(Destination: *mut UINT32, Value: UINT32);
}
extern "C" {
    pub fn WriteUInt32NoFence(Destination: *mut UINT32, Value: UINT32);
}
extern "C" {
    pub fn WriteUInt32Raw(Destination: *mut UINT32, Value: UINT32);
}
extern "C" {
    pub fn ReadULong64Acquire(Source: *const DWORD64) -> DWORD64;
}
extern "C" {
    pub fn ReadULong64NoFence(Source: *const DWORD64) -> DWORD64;
}
extern "C" {
    pub fn ReadULong64Raw(Source: *const DWORD64) -> DWORD64;
}
extern "C" {
    pub fn WriteULong64Release(Destination: *mut DWORD64, Value: DWORD64);
}
extern "C" {
    pub fn WriteULong64NoFence(Destination: *mut DWORD64, Value: DWORD64);
}
extern "C" {
    pub fn WriteULong64Raw(Destination: *mut DWORD64, Value: DWORD64);
}
extern "C" {
    pub fn ReadPointerAcquire(Source: *const PVOID) -> PVOID;
}
extern "C" {
    pub fn ReadPointerNoFence(Source: *const PVOID) -> PVOID;
}
extern "C" {
    pub fn ReadPointerRaw(Source: *const PVOID) -> PVOID;
}
extern "C" {
    pub fn WritePointerRelease(Destination: *mut PVOID, Value: PVOID);
}
extern "C" {
    pub fn WritePointerNoFence(Destination: *mut PVOID, Value: PVOID);
}
extern "C" {
    pub fn WritePointerRaw(Destination: *mut PVOID, Value: PVOID);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_FLOATING_SAVE_AREA {
    pub ControlWord: DWORD,
    pub StatusWord: DWORD,
    pub TagWord: DWORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub RegisterArea: [BYTE; 80usize],
    pub Cr0NpxState: DWORD,
}
pub type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA;
pub type PWOW64_FLOATING_SAVE_AREA = *mut WOW64_FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_CONTEXT {
    pub ContextFlags: DWORD,
    pub Dr0: DWORD,
    pub Dr1: DWORD,
    pub Dr2: DWORD,
    pub Dr3: DWORD,
    pub Dr6: DWORD,
    pub Dr7: DWORD,
    pub FloatSave: WOW64_FLOATING_SAVE_AREA,
    pub SegGs: DWORD,
    pub SegFs: DWORD,
    pub SegEs: DWORD,
    pub SegDs: DWORD,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
    pub ExtendedRegisters: [BYTE; 512usize],
}
pub type WOW64_CONTEXT = _WOW64_CONTEXT;
pub type PWOW64_CONTEXT = *mut WOW64_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_LDT_ENTRY {
    pub LimitLow: WORD,
    pub BaseLow: WORD,
    pub HighWord: _WOW64_LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WOW64_LDT_ENTRY__bindgen_ty_1 {
    pub Bytes: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Bits: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub BaseMid: BYTE,
    pub Flags1: BYTE,
    pub Flags2: BYTE,
    pub BaseHi: BYTE,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: DWORD,
        Type: DWORD,
        Dpl: DWORD,
        Pres: DWORD,
        LimitHi: DWORD,
        Sys: DWORD,
        Reserved_0: DWORD,
        Default_Big: DWORD,
        Granularity: DWORD,
        BaseHi: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WOW64_LDT_ENTRY = _WOW64_LDT_ENTRY;
pub type PWOW64_LDT_ENTRY = *mut _WOW64_LDT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    pub Selector: DWORD,
    pub Descriptor: WOW64_LDT_ENTRY,
}
pub type WOW64_DESCRIPTOR_TABLE_ENTRY = _WOW64_DESCRIPTOR_TABLE_ENTRY;
pub type PWOW64_DESCRIPTOR_TABLE_ENTRY = *mut _WOW64_DESCRIPTOR_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: DWORD,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD32 {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: DWORD,
    pub ExceptionAddress: DWORD,
    pub NumberParameters: DWORD,
    pub ExceptionInformation: [DWORD; 15usize],
}
pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD64 {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: DWORD64,
    pub ExceptionAddress: DWORD64,
    pub NumberParameters: DWORD,
    pub __unusedAlignment: DWORD,
    pub ExceptionInformation: [DWORD64; 15usize],
}
pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: DWORD,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [DWORD; 1usize],
}
pub type SID = _SID;
pub type PISID = *mut _SID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_SID {
    pub Sid: SID,
    pub Buffer: [BYTE; 68usize],
}
pub type SE_SID = _SE_SID;
pub type PSE_SID = *mut _SE_SID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup = 2,
    SidTypeDomain = 3,
    SidTypeAlias = 4,
    SidTypeWellKnownGroup = 5,
    SidTypeDeletedAccount = 6,
    SidTypeInvalid = 7,
    SidTypeUnknown = 8,
    SidTypeComputer = 9,
    SidTypeLabel = 10,
    SidTypeLogonSession = 11,
}
pub use self::_SID_NAME_USE as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
    pub Sid: PSID,
    pub Attributes: DWORD,
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type PSID_AND_ATTRIBUTES_ARRAY = *mut SID_AND_ATTRIBUTES_ARRAY;
pub type SID_HASH_ENTRY = ULONG_PTR;
pub type PSID_HASH_ENTRY = *mut ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
    pub SidCount: DWORD,
    pub SidAttr: PSID_AND_ATTRIBUTES,
    pub Hash: [SID_HASH_ENTRY; 32usize],
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WELL_KNOWN_SID_TYPE {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
    WinBuiltinDeviceOwnersSid = 119,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
    pub AclRevision: BYTE,
    pub Sbz1: BYTE,
    pub AclSize: WORD,
    pub AceCount: WORD,
    pub Sbz2: WORD,
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACE_HEADER {
    pub AceType: BYTE,
    pub AceFlags: BYTE,
    pub AceSize: WORD,
}
pub type ACE_HEADER = _ACE_HEADER;
pub type PACE_HEADER = *mut ACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE;
pub type PACCESS_ALLOWED_ACE = *mut ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE;
pub type PACCESS_DENIED_ACE = *mut ACCESS_DENIED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
pub type PSYSTEM_AUDIT_ACE = *mut SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
pub type PSYSTEM_ALARM_ACE = *mut SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub type PSYSTEM_RESOURCE_ATTRIBUTE_ACE = *mut _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
pub type PSYSTEM_SCOPED_POLICY_ID_ACE = *mut _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
pub type PSYSTEM_MANDATORY_LABEL_ACE = *mut _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub type PSYSTEM_PROCESS_TRUST_LABEL_ACE = *mut _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
pub type PSYSTEM_ACCESS_FILTER_ACE = *mut _SYSTEM_ACCESS_FILTER_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type ACCESS_ALLOWED_OBJECT_ACE = _ACCESS_ALLOWED_OBJECT_ACE;
pub type PACCESS_ALLOWED_OBJECT_ACE = *mut _ACCESS_ALLOWED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type ACCESS_DENIED_OBJECT_ACE = _ACCESS_DENIED_OBJECT_ACE;
pub type PACCESS_DENIED_OBJECT_ACE = *mut _ACCESS_DENIED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE;
pub type PSYSTEM_AUDIT_OBJECT_ACE = *mut _SYSTEM_AUDIT_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE;
pub type PSYSTEM_ALARM_OBJECT_ACE = *mut _SYSTEM_ALARM_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type ACCESS_ALLOWED_CALLBACK_ACE = _ACCESS_ALLOWED_CALLBACK_ACE;
pub type PACCESS_ALLOWED_CALLBACK_ACE = *mut _ACCESS_ALLOWED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type ACCESS_DENIED_CALLBACK_ACE = _ACCESS_DENIED_CALLBACK_ACE;
pub type PACCESS_DENIED_CALLBACK_ACE = *mut _ACCESS_DENIED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_ACE = *mut _SYSTEM_AUDIT_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
pub type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE;
pub type PSYSTEM_ALARM_CALLBACK_ACE = *mut _SYSTEM_ALARM_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub type PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = *mut _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type ACCESS_DENIED_CALLBACK_OBJECT_ACE = _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub type PACCESS_DENIED_CALLBACK_OBJECT_ACE = *mut _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = *mut _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
pub type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = *mut _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation = 2,
}
pub use self::_ACL_INFORMATION_CLASS as ACL_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL_REVISION_INFORMATION {
    pub AclRevision: DWORD,
}
pub type ACL_REVISION_INFORMATION = _ACL_REVISION_INFORMATION;
pub type PACL_REVISION_INFORMATION = *mut ACL_REVISION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL_SIZE_INFORMATION {
    pub AceCount: DWORD,
    pub AclBytesInUse: DWORD,
    pub AclBytesFree: DWORD,
}
pub type ACL_SIZE_INFORMATION = _ACL_SIZE_INFORMATION;
pub type PACL_SIZE_INFORMATION = *mut ACL_SIZE_INFORMATION;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
    pub Revision: BYTE,
    pub Sbz1: BYTE,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: DWORD,
    pub Group: DWORD,
    pub Sacl: DWORD,
    pub Dacl: DWORD,
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
pub type PISECURITY_DESCRIPTOR_RELATIVE = *mut _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
    pub Revision: BYTE,
    pub Sbz1: BYTE,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: PSID,
    pub Group: PSID,
    pub Sacl: PACL,
    pub Dacl: PACL,
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
pub type PISECURITY_DESCRIPTOR = *mut _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
    pub Size: DWORD,
    pub ConstraintMask: DWORD,
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
pub type PSECURITY_OBJECT_AI_PARAMS = *mut _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
    pub Level: WORD,
    pub Sbz: WORD,
    pub ObjectType: *mut GUID,
}
pub type OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST;
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess = 0,
    AuditEventDirectoryServiceAccess = 1,
}
pub use self::_AUDIT_EVENT_TYPE as AUDIT_EVENT_TYPE;
pub type PAUDIT_EVENT_TYPE = *mut _AUDIT_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: DWORD,
    pub Control: DWORD,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACCESS_REASON_TYPE {
    AccessReasonNone = 0,
    AccessReasonAllowedAce = 65536,
    AccessReasonDeniedAce = 131072,
    AccessReasonAllowedParentAce = 196608,
    AccessReasonDeniedParentAce = 262144,
    AccessReasonNotGrantedByCape = 327680,
    AccessReasonNotGrantedByParentCape = 393216,
    AccessReasonNotGrantedToAppContainer = 458752,
    AccessReasonMissingPrivilege = 1048576,
    AccessReasonFromPrivilege = 2097152,
    AccessReasonIntegrityLevel = 3145728,
    AccessReasonOwnership = 4194304,
    AccessReasonNullDacl = 5242880,
    AccessReasonEmptyDacl = 6291456,
    AccessReasonNoSD = 7340032,
    AccessReasonNoGrant = 8388608,
    AccessReasonTrustLabel = 9437184,
    AccessReasonFilterAce = 10485760,
}
pub use self::_ACCESS_REASON_TYPE as ACCESS_REASON_TYPE;
pub type ACCESS_REASON = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_REASONS {
    pub Data: [ACCESS_REASON; 32usize],
}
pub type ACCESS_REASONS = _ACCESS_REASONS;
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SECURITY_DESCRIPTOR {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REQUEST {
    pub Size: DWORD,
    pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
    pub DesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub PrincipalSelfSid: PSID,
    pub GenericMapping: PGENERIC_MAPPING,
    pub ObjectTypeListCount: DWORD,
    pub ObjectTypeList: POBJECT_TYPE_LIST,
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
pub type PSE_ACCESS_REQUEST = *mut _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REPLY {
    pub Size: DWORD,
    pub ResultListCount: DWORD,
    pub GrantedAccess: PACCESS_MASK,
    pub AccessStatus: PDWORD,
    pub AccessReason: PACCESS_REASONS,
    pub Privileges: *mut PPRIVILEGE_SET,
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub type PSE_ACCESS_REPLY = *mut _SE_ACCESS_REPLY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3,
}
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation = 2,
}
pub use self::_TOKEN_TYPE as TOKEN_TYPE;
pub type PTOKEN_TYPE = *mut TOKEN_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull = 2,
    TokenElevationTypeLimited = 3,
}
pub use self::_TOKEN_ELEVATION_TYPE as TOKEN_ELEVATION_TYPE;
pub type PTOKEN_ELEVATION_TYPE = *mut _TOKEN_ELEVATION_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups = 2,
    TokenPrivileges = 3,
    TokenOwner = 4,
    TokenPrimaryGroup = 5,
    TokenDefaultDacl = 6,
    TokenSource = 7,
    TokenType = 8,
    TokenImpersonationLevel = 9,
    TokenStatistics = 10,
    TokenRestrictedSids = 11,
    TokenSessionId = 12,
    TokenGroupsAndPrivileges = 13,
    TokenSessionReference = 14,
    TokenSandBoxInert = 15,
    TokenAuditPolicy = 16,
    TokenOrigin = 17,
    TokenElevationType = 18,
    TokenLinkedToken = 19,
    TokenElevation = 20,
    TokenHasRestrictions = 21,
    TokenAccessInformation = 22,
    TokenVirtualizationAllowed = 23,
    TokenVirtualizationEnabled = 24,
    TokenIntegrityLevel = 25,
    TokenUIAccess = 26,
    TokenMandatoryPolicy = 27,
    TokenLogonSid = 28,
    TokenIsAppContainer = 29,
    TokenCapabilities = 30,
    TokenAppContainerSid = 31,
    TokenAppContainerNumber = 32,
    TokenUserClaimAttributes = 33,
    TokenDeviceClaimAttributes = 34,
    TokenRestrictedUserClaimAttributes = 35,
    TokenRestrictedDeviceClaimAttributes = 36,
    TokenDeviceGroups = 37,
    TokenRestrictedDeviceGroups = 38,
    TokenSecurityAttributes = 39,
    TokenIsRestricted = 40,
    TokenProcessTrustLevel = 41,
    TokenPrivateNameSpace = 42,
    TokenSingletonAttributes = 43,
    TokenBnoIsolation = 44,
    TokenChildProcessFlags = 45,
    TokenIsLessPrivilegedAppContainer = 46,
    TokenIsSandboxed = 47,
    TokenIsAppSilo = 48,
    MaxTokenInfoClass = 49,
}
pub use self::_TOKEN_INFORMATION_CLASS as TOKEN_INFORMATION_CLASS;
pub type PTOKEN_INFORMATION_CLASS = *mut _TOKEN_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
    pub User: SID_AND_ATTRIBUTES,
}
pub type TOKEN_USER = _TOKEN_USER;
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
    pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
    pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
    pub TokenUser: TOKEN_USER,
    pub User: SID_AND_ATTRIBUTES,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
    pub Sid: SID,
    pub Buffer: [BYTE; 68usize],
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type PSE_TOKEN_USER = _SE_TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS {
    pub GroupCount: DWORD,
    pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
pub type TOKEN_GROUPS = _TOKEN_GROUPS;
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
    pub PrivilegeCount: DWORD,
    pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES;
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_OWNER {
    pub Owner: PSID,
}
pub type TOKEN_OWNER = _TOKEN_OWNER;
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIMARY_GROUP {
    pub PrimaryGroup: PSID,
}
pub type TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP;
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEFAULT_DACL {
    pub DefaultDacl: PACL,
}
pub type TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL;
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER_CLAIMS {
    pub UserClaims: PCLAIMS_BLOB,
}
pub type TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS;
pub type PTOKEN_USER_CLAIMS = *mut _TOKEN_USER_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEVICE_CLAIMS {
    pub DeviceClaims: PCLAIMS_BLOB,
}
pub type TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS;
pub type PTOKEN_DEVICE_CLAIMS = *mut _TOKEN_DEVICE_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS_AND_PRIVILEGES {
    pub SidCount: DWORD,
    pub SidLength: DWORD,
    pub Sids: PSID_AND_ATTRIBUTES,
    pub RestrictedSidCount: DWORD,
    pub RestrictedSidLength: DWORD,
    pub RestrictedSids: PSID_AND_ATTRIBUTES,
    pub PrivilegeCount: DWORD,
    pub PrivilegeLength: DWORD,
    pub Privileges: PLUID_AND_ATTRIBUTES,
    pub AuthenticationId: LUID,
}
pub type TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES;
pub type PTOKEN_GROUPS_AND_PRIVILEGES = *mut _TOKEN_GROUPS_AND_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_LINKED_TOKEN {
    pub LinkedToken: HANDLE,
}
pub type TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN;
pub type PTOKEN_LINKED_TOKEN = *mut _TOKEN_LINKED_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ELEVATION {
    pub TokenIsElevated: DWORD,
}
pub type TOKEN_ELEVATION = _TOKEN_ELEVATION;
pub type PTOKEN_ELEVATION = *mut _TOKEN_ELEVATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_LABEL {
    pub Label: SID_AND_ATTRIBUTES,
}
pub type TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL;
pub type PTOKEN_MANDATORY_LABEL = *mut _TOKEN_MANDATORY_LABEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
    pub Policy: DWORD,
}
pub type TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY;
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
pub type PSECURITY_ATTRIBUTES_OPAQUE = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ACCESS_INFORMATION {
    pub SidHash: PSID_AND_ATTRIBUTES_HASH,
    pub RestrictedSidHash: PSID_AND_ATTRIBUTES_HASH,
    pub Privileges: PTOKEN_PRIVILEGES,
    pub AuthenticationId: LUID,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    pub Flags: DWORD,
    pub AppContainerNumber: DWORD,
    pub PackageSid: PSID,
    pub CapabilitiesHash: PSID_AND_ATTRIBUTES_HASH,
    pub TrustLevelSid: PSID,
    pub SecurityAttributes: PSECURITY_ATTRIBUTES_OPAQUE,
}
pub type TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION;
pub type PTOKEN_ACCESS_INFORMATION = *mut _TOKEN_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_AUDIT_POLICY {
    pub PerUserPolicy: [BYTE; 30usize],
}
pub type TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY;
pub type PTOKEN_AUDIT_POLICY = *mut _TOKEN_AUDIT_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SOURCE {
    pub SourceName: [CHAR; 8usize],
    pub SourceIdentifier: LUID,
}
pub type TOKEN_SOURCE = _TOKEN_SOURCE;
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_STATISTICS {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ExpirationTime: LARGE_INTEGER,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub DynamicCharged: DWORD,
    pub DynamicAvailable: DWORD,
    pub GroupCount: DWORD,
    pub PrivilegeCount: DWORD,
    pub ModifiedId: LUID,
}
pub type TOKEN_STATISTICS = _TOKEN_STATISTICS;
pub type PTOKEN_STATISTICS = *mut _TOKEN_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_CONTROL {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ModifiedId: LUID,
    pub TokenSource: TOKEN_SOURCE,
}
pub type TOKEN_CONTROL = _TOKEN_CONTROL;
pub type PTOKEN_CONTROL = *mut _TOKEN_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ORIGIN {
    pub OriginatingLogonSession: LUID,
}
pub type TOKEN_ORIGIN = _TOKEN_ORIGIN;
pub type PTOKEN_ORIGIN = *mut _TOKEN_ORIGIN;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow = 1,
    MandatoryLevelMedium = 2,
    MandatoryLevelHigh = 3,
    MandatoryLevelSystem = 4,
    MandatoryLevelSecureProcess = 5,
    MandatoryLevelCount = 6,
}
pub use self::_MANDATORY_LEVEL as MANDATORY_LEVEL;
pub type PMANDATORY_LEVEL = *mut _MANDATORY_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_APPCONTAINER_INFORMATION {
    pub TokenAppContainer: PSID,
}
pub type TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION;
pub type PTOKEN_APPCONTAINER_INFORMATION = *mut _TOKEN_APPCONTAINER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SID_INFORMATION {
    pub Sid: PSID,
}
pub type TOKEN_SID_INFORMATION = _TOKEN_SID_INFORMATION;
pub type PTOKEN_SID_INFORMATION = *mut _TOKEN_SID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_BNO_ISOLATION_INFORMATION {
    pub IsolationPrefix: PWSTR,
    pub IsolationEnabled: BOOLEAN,
}
pub type TOKEN_BNO_ISOLATION_INFORMATION = _TOKEN_BNO_ISOLATION_INFORMATION;
pub type PTOKEN_BNO_ISOLATION_INFORMATION = *mut _TOKEN_BNO_ISOLATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    pub Version: DWORD64,
    pub Name: PWSTR,
}
pub type CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    pub pValue: PVOID,
    pub ValueLength: DWORD,
}
pub type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
    *mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
    pub Name: PWSTR,
    pub ValueType: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ValueCount: DWORD,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
    pub pInt64: PLONG64,
    pub pUint64: PDWORD64,
    pub ppString: *mut PWSTR,
    pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
    pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
pub type CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    pub Name: DWORD,
    pub ValueType: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ValueCount: DWORD,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
    pub pInt64: [DWORD; 1usize],
    pub pUint64: [DWORD; 1usize],
    pub ppString: [DWORD; 1usize],
    pub pFqbn: [DWORD; 1usize],
    pub pOctetString: [DWORD; 1usize],
}
pub type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    pub Version: WORD,
    pub Reserved: WORD,
    pub AttributeCount: DWORD,
    pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
    pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
}
pub type CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: DWORD,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
    pub Token: PACCESS_TOKEN,
    pub CopyOnOpen: BOOLEAN,
    pub EffectiveOnly: BOOLEAN,
    pub Level: SECURITY_IMPERSONATION_LEVEL,
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = DWORD;
pub type PSECURITY_INFORMATION = *mut DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub type PSE_SIGNING_LEVEL = *mut BYTE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SE_IMAGE_SIGNATURE_TYPE {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded = 1,
    SeImageSignatureCache = 2,
    SeImageSignatureCatalogCached = 3,
    SeImageSignatureCatalogNotCached = 4,
    SeImageSignatureCatalogHint = 5,
    SeImageSignaturePackageCatalog = 6,
    SeImageSignaturePplMitigated = 7,
}
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub type PSE_IMAGE_SIGNATURE_TYPE = *mut _SE_IMAGE_SIGNATURE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CAPABILITIES {
    pub AppContainerSid: PSID,
    pub Capabilities: PSID_AND_ATTRIBUTES,
    pub CapabilityCount: DWORD,
    pub Reserved: DWORD,
}
pub type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES;
pub type PSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
pub type LPSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_SET_ARRAY {
    pub JobHandle: HANDLE,
    pub MemberLevel: DWORD,
    pub Flags: DWORD,
}
pub type JOB_SET_ARRAY = _JOB_SET_ARRAY;
pub type PJOB_SET_ARRAY = *mut _JOB_SET_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Handler: PEXCEPTION_ROUTINE,
}
pub type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION_RECORD = *mut EXCEPTION_REGISTRATION_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub SubSystemTib: PVOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    pub ArbitraryUserPointer: PVOID,
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
    pub FiberData: PVOID,
    pub Version: DWORD,
}
pub type NT_TIB = _NT_TIB;
pub type PNT_TIB = *mut NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
    pub ExceptionList: DWORD,
    pub StackBase: DWORD,
    pub StackLimit: DWORD,
    pub SubSystemTib: DWORD,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    pub ArbitraryUserPointer: DWORD,
    pub Self_: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
    pub FiberData: DWORD,
    pub Version: DWORD,
}
pub type NT_TIB32 = _NT_TIB32;
pub type PNT_TIB32 = *mut _NT_TIB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
    pub ExceptionList: DWORD64,
    pub StackBase: DWORD64,
    pub StackLimit: DWORD64,
    pub SubSystemTib: DWORD64,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    pub ArbitraryUserPointer: DWORD64,
    pub Self_: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
    pub FiberData: DWORD64,
    pub Version: DWORD,
}
pub type NT_TIB64 = _NT_TIB64;
pub type PNT_TIB64 = *mut _NT_TIB64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UMS_CREATE_THREAD_ATTRIBUTES {
    pub UmsVersion: DWORD,
    pub UmsContext: PVOID,
    pub UmsCompletionList: PVOID,
}
pub type UMS_CREATE_THREAD_ATTRIBUTES = _UMS_CREATE_THREAD_ATTRIBUTES;
pub type PUMS_CREATE_THREAD_ATTRIBUTES = *mut _UMS_CREATE_THREAD_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPONENT_FILTER {
    pub ComponentFlags: DWORD,
}
pub type COMPONENT_FILTER = _COMPONENT_FILTER;
pub type PCOMPONENT_FILTER = *mut _COMPONENT_FILTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    pub TargetAddress: ULONG_PTR,
    pub Flags: ULONG_PTR,
}
pub type PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
pub type PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET = *mut _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    pub NumberOfTargets: WORD,
    pub Reserved: WORD,
    pub Reserved2: DWORD,
    pub Targets: PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
}
pub type PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION =
    _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
pub type PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION =
    *mut _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    pub BaseAddress: ULONG_PTR,
    pub Size: SIZE_T,
    pub Flags: DWORD,
}
pub type PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
pub type PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = *mut _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    pub NumberOfRanges: WORD,
    pub Reserved: WORD,
    pub Reserved2: DWORD,
    pub Ranges: PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE,
}
pub type PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION =
    _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
pub type PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION =
    *mut _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
}
pub type QUOTA_LIMITS = _QUOTA_LIMITS;
pub type PQUOTA_LIMITS = *mut _QUOTA_LIMITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RATE_QUOTA_LIMIT {
    pub RateData: DWORD,
    pub __bindgen_anon_1: _RATE_QUOTA_LIMIT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    #[inline]
    pub fn RatePercent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_RatePercent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RatePercent: DWORD,
        Reserved0: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let RatePercent: u32 = unsafe { ::std::mem::transmute(RatePercent) };
            RatePercent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT;
pub type PRATE_QUOTA_LIMIT = *mut _RATE_QUOTA_LIMIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS_EX {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
    pub WorkingSetLimit: SIZE_T,
    pub Reserved2: SIZE_T,
    pub Reserved3: SIZE_T,
    pub Reserved4: SIZE_T,
    pub Flags: DWORD,
    pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
pub type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX;
pub type PQUOTA_LIMITS_EX = *mut _QUOTA_LIMITS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COUNTERS {
    pub ReadOperationCount: ULONGLONG,
    pub WriteOperationCount: ULONGLONG,
    pub OtherOperationCount: ULONGLONG,
    pub ReadTransferCount: ULONGLONG,
    pub WriteTransferCount: ULONGLONG,
    pub OtherTransferCount: ULONGLONG,
}
pub type IO_COUNTERS = _IO_COUNTERS;
pub type PIO_COUNTERS = *mut IO_COUNTERS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HARDWARE_COUNTER_TYPE {
    PMCCounter = 0,
    MaxHardwareCounterType = 1,
}
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
pub type PHARDWARE_COUNTER_TYPE = *mut _HARDWARE_COUNTER_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy = 0,
    ProcessASLRPolicy = 1,
    ProcessDynamicCodePolicy = 2,
    ProcessStrictHandleCheckPolicy = 3,
    ProcessSystemCallDisablePolicy = 4,
    ProcessMitigationOptionsMask = 5,
    ProcessExtensionPointDisablePolicy = 6,
    ProcessControlFlowGuardPolicy = 7,
    ProcessSignaturePolicy = 8,
    ProcessFontDisablePolicy = 9,
    ProcessImageLoadPolicy = 10,
    ProcessSystemCallFilterPolicy = 11,
    ProcessPayloadRestrictionPolicy = 12,
    ProcessChildProcessPolicy = 13,
    ProcessSideChannelIsolationPolicy = 14,
    ProcessUserShadowStackPolicy = 15,
    ProcessRedirectionTrustPolicy = 16,
    ProcessUserPointerAuthPolicy = 17,
    ProcessSEHOPPolicy = 18,
    MaxProcessMitigationPolicy = 19,
}
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
pub type PPROCESS_MITIGATION_POLICY = *mut _PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableBottomUpRandomization(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableBottomUpRandomization(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableForceRelocateImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableForceRelocateImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableHighEntropy(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableHighEntropy(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowStrippedImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowStrippedImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableBottomUpRandomization: DWORD,
        EnableForceRelocateImages: DWORD,
        EnableHighEntropy: DWORD,
        DisallowStrippedImages: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableBottomUpRandomization: u32 =
                unsafe { ::std::mem::transmute(EnableBottomUpRandomization) };
            EnableBottomUpRandomization as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableForceRelocateImages: u32 =
                unsafe { ::std::mem::transmute(EnableForceRelocateImages) };
            EnableForceRelocateImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableHighEntropy: u32 = unsafe { ::std::mem::transmute(EnableHighEntropy) };
            EnableHighEntropy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DisallowStrippedImages: u32 =
                unsafe { ::std::mem::transmute(DisallowStrippedImages) };
            DisallowStrippedImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
pub type PPROCESS_MITIGATION_ASLR_POLICY = *mut _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1,
    pub Permanent: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableAtlThunkEmulation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableAtlThunkEmulation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: DWORD,
        DisableAtlThunkEmulation: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::std::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableAtlThunkEmulation: u32 =
                unsafe { ::std::mem::transmute(DisableAtlThunkEmulation) };
            DisableAtlThunkEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY;
pub type PPROCESS_MITIGATION_DEP_POLICY = *mut _PROCESS_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableSehop(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableSehop(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableSehop: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableSehop: u32 = unsafe { ::std::mem::transmute(EnableSehop) };
            EnableSehop as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SEHOP_POLICY = _PROCESS_MITIGATION_SEHOP_POLICY;
pub type PPROCESS_MITIGATION_SEHOP_POLICY = *mut _PROCESS_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RaiseExceptionOnInvalidHandleReference(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HandleExceptionsPermanentlyEnabled(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RaiseExceptionOnInvalidHandleReference: DWORD,
        HandleExceptionsPermanentlyEnabled: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RaiseExceptionOnInvalidHandleReference: u32 =
                unsafe { ::std::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
            RaiseExceptionOnInvalidHandleReference as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HandleExceptionsPermanentlyEnabled: u32 =
                unsafe { ::std::mem::transmute(HandleExceptionsPermanentlyEnabled) };
            HandleExceptionsPermanentlyEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    *mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisallowWin32kSystemCalls(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowWin32kSystemCalls(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditDisallowWin32kSystemCalls(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisallowWin32kSystemCalls: DWORD,
        AuditDisallowWin32kSystemCalls: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(DisallowWin32kSystemCalls) };
            DisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditDisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(AuditDisallowWin32kSystemCalls) };
            AuditDisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableExtensionPoints(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableExtensionPoints(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableExtensionPoints: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableExtensionPoints: u32 =
                unsafe { ::std::mem::transmute(DisableExtensionPoints) };
            DisableExtensionPoints as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ProhibitDynamicCode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProhibitDynamicCode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowThreadOptOut(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowThreadOptOut(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowRemoteDowngrade(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowRemoteDowngrade(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditProhibitDynamicCode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditProhibitDynamicCode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProhibitDynamicCode: DWORD,
        AllowThreadOptOut: DWORD,
        AllowRemoteDowngrade: DWORD,
        AuditProhibitDynamicCode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProhibitDynamicCode: u32 = unsafe { ::std::mem::transmute(ProhibitDynamicCode) };
            ProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowThreadOptOut: u32 = unsafe { ::std::mem::transmute(AllowThreadOptOut) };
            AllowThreadOptOut as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowRemoteDowngrade: u32 = unsafe { ::std::mem::transmute(AllowRemoteDowngrade) };
            AllowRemoteDowngrade as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditProhibitDynamicCode: u32 =
                unsafe { ::std::mem::transmute(AuditProhibitDynamicCode) };
            AuditProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = *mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableControlFlowGuard(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableControlFlowGuard(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportSuppression(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportSuppression(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StrictMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StrictMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableXfg(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableXfg(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableXfgAuditMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableXfgAuditMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableControlFlowGuard: DWORD,
        EnableExportSuppression: DWORD,
        StrictMode: DWORD,
        EnableXfg: DWORD,
        EnableXfgAuditMode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableControlFlowGuard: u32 =
                unsafe { ::std::mem::transmute(EnableControlFlowGuard) };
            EnableControlFlowGuard as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableExportSuppression: u32 =
                unsafe { ::std::mem::transmute(EnableExportSuppression) };
            EnableExportSuppression as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let StrictMode: u32 = unsafe { ::std::mem::transmute(StrictMode) };
            StrictMode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EnableXfg: u32 = unsafe { ::std::mem::transmute(EnableXfg) };
            EnableXfg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableXfgAuditMode: u32 = unsafe { ::std::mem::transmute(EnableXfgAuditMode) };
            EnableXfgAuditMode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    *mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MicrosoftSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MicrosoftSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StoreSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StoreSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MitigationOptIn(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MitigationOptIn(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditMicrosoftSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditMicrosoftSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditStoreSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditStoreSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MicrosoftSignedOnly: DWORD,
        StoreSignedOnly: DWORD,
        MitigationOptIn: DWORD,
        AuditMicrosoftSignedOnly: DWORD,
        AuditStoreSignedOnly: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MicrosoftSignedOnly: u32 = unsafe { ::std::mem::transmute(MicrosoftSignedOnly) };
            MicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let StoreSignedOnly: u32 = unsafe { ::std::mem::transmute(StoreSignedOnly) };
            StoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MitigationOptIn: u32 = unsafe { ::std::mem::transmute(MitigationOptIn) };
            MitigationOptIn as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditMicrosoftSignedOnly: u32 =
                unsafe { ::std::mem::transmute(AuditMicrosoftSignedOnly) };
            AuditMicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuditStoreSignedOnly: u32 = unsafe { ::std::mem::transmute(AuditStoreSignedOnly) };
            AuditStoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY =
    *mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableNonSystemFonts(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableNonSystemFonts(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNonSystemFontLoading(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNonSystemFontLoading(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableNonSystemFonts: DWORD,
        AuditNonSystemFontLoading: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableNonSystemFonts: u32 =
                unsafe { ::std::mem::transmute(DisableNonSystemFonts) };
            DisableNonSystemFonts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNonSystemFontLoading: u32 =
                unsafe { ::std::mem::transmute(AuditNonSystemFontLoading) };
            AuditNonSystemFontLoading as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = *mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoRemoteImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoRemoteImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoLowMandatoryLabelImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoLowMandatoryLabelImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferSystem32Images(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreferSystem32Images(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoRemoteImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoRemoteImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoLowMandatoryLabelImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoLowMandatoryLabelImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoRemoteImages: DWORD,
        NoLowMandatoryLabelImages: DWORD,
        PreferSystem32Images: DWORD,
        AuditNoRemoteImages: DWORD,
        AuditNoLowMandatoryLabelImages: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoRemoteImages: u32 = unsafe { ::std::mem::transmute(NoRemoteImages) };
            NoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoLowMandatoryLabelImages: u32 =
                unsafe { ::std::mem::transmute(NoLowMandatoryLabelImages) };
            NoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PreferSystem32Images: u32 = unsafe { ::std::mem::transmute(PreferSystem32Images) };
            PreferSystem32Images as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditNoRemoteImages: u32 = unsafe { ::std::mem::transmute(AuditNoRemoteImages) };
            AuditNoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuditNoLowMandatoryLabelImages: u32 =
                unsafe { ::std::mem::transmute(AuditNoLowMandatoryLabelImages) };
            AuditNoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = *mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FilterId(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FilterId(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilterId: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FilterId: u32 = unsafe { ::std::mem::transmute(FilterId) };
            FilterId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
    _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableExportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportAddressFilterPlus(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilterPlus(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilterPlus(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilterPlus(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableImportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableImportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditImportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditImportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopStackPivot(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopStackPivot(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopStackPivot(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopStackPivot(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopCallerCheck(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopCallerCheck(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopCallerCheck(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopCallerCheck(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopSimExec(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopSimExec(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopSimExec(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopSimExec(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableExportAddressFilter: DWORD,
        AuditExportAddressFilter: DWORD,
        EnableExportAddressFilterPlus: DWORD,
        AuditExportAddressFilterPlus: DWORD,
        EnableImportAddressFilter: DWORD,
        AuditImportAddressFilter: DWORD,
        EnableRopStackPivot: DWORD,
        AuditRopStackPivot: DWORD,
        EnableRopCallerCheck: DWORD,
        AuditRopCallerCheck: DWORD,
        EnableRopSimExec: DWORD,
        AuditRopSimExec: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilter) };
            EnableExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilter) };
            AuditExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilterPlus) };
            EnableExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilterPlus) };
            AuditExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableImportAddressFilter) };
            EnableImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AuditImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditImportAddressFilter) };
            AuditImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableRopStackPivot: u32 = unsafe { ::std::mem::transmute(EnableRopStackPivot) };
            EnableRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditRopStackPivot: u32 = unsafe { ::std::mem::transmute(AuditRopStackPivot) };
            AuditRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EnableRopCallerCheck: u32 = unsafe { ::std::mem::transmute(EnableRopCallerCheck) };
            EnableRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AuditRopCallerCheck: u32 = unsafe { ::std::mem::transmute(AuditRopCallerCheck) };
            AuditRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EnableRopSimExec: u32 = unsafe { ::std::mem::transmute(EnableRopSimExec) };
            EnableRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AuditRopSimExec: u32 = unsafe { ::std::mem::transmute(AuditRopSimExec) };
            AuditRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
    _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
    *mut _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoChildProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChildProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoChildProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoChildProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowSecureProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowSecureProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoChildProcessCreation: DWORD,
        AuditNoChildProcessCreation: DWORD,
        AllowSecureProcessCreation: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoChildProcessCreation: u32 =
                unsafe { ::std::mem::transmute(NoChildProcessCreation) };
            NoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNoChildProcessCreation: u32 =
                unsafe { ::std::mem::transmute(AuditNoChildProcessCreation) };
            AuditNoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowSecureProcessCreation: u32 =
                unsafe { ::std::mem::transmute(AllowSecureProcessCreation) };
            AllowSecureProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub type PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = *mut _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SmtBranchTargetIsolation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SmtBranchTargetIsolation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsolateSecurityDomain(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsolateSecurityDomain(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisablePageCombine(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisablePageCombine(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RestrictCoreSharing(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestrictCoreSharing(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SmtBranchTargetIsolation: DWORD,
        IsolateSecurityDomain: DWORD,
        DisablePageCombine: DWORD,
        SpeculativeStoreBypassDisable: DWORD,
        RestrictCoreSharing: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SmtBranchTargetIsolation: u32 =
                unsafe { ::std::mem::transmute(SmtBranchTargetIsolation) };
            SmtBranchTargetIsolation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsolateSecurityDomain: u32 =
                unsafe { ::std::mem::transmute(IsolateSecurityDomain) };
            IsolateSecurityDomain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisablePageCombine: u32 = unsafe { ::std::mem::transmute(DisablePageCombine) };
            DisablePageCombine as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SpeculativeStoreBypassDisable: u32 =
                unsafe { ::std::mem::transmute(SpeculativeStoreBypassDisable) };
            SpeculativeStoreBypassDisable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RestrictCoreSharing: u32 = unsafe { ::std::mem::transmute(RestrictCoreSharing) };
            RestrictCoreSharing as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
    _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub type PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
    *mut _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableUserShadowStack(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUserShadowStack(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditUserShadowStack(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditUserShadowStack(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetContextIpValidation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetContextIpValidation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditSetContextIpValidation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditSetContextIpValidation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableUserShadowStackStrictMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUserShadowStackStrictMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockNonCetBinaries(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockNonCetBinaries(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockNonCetBinariesNonEhcont(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockNonCetBinariesNonEhcont(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditBlockNonCetBinaries(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditBlockNonCetBinaries(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CetDynamicApisOutOfProcOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CetDynamicApisOutOfProcOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetContextIpValidationRelaxedMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetContextIpValidationRelaxedMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableUserShadowStack: DWORD,
        AuditUserShadowStack: DWORD,
        SetContextIpValidation: DWORD,
        AuditSetContextIpValidation: DWORD,
        EnableUserShadowStackStrictMode: DWORD,
        BlockNonCetBinaries: DWORD,
        BlockNonCetBinariesNonEhcont: DWORD,
        AuditBlockNonCetBinaries: DWORD,
        CetDynamicApisOutOfProcOnly: DWORD,
        SetContextIpValidationRelaxedMode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableUserShadowStack: u32 =
                unsafe { ::std::mem::transmute(EnableUserShadowStack) };
            EnableUserShadowStack as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditUserShadowStack: u32 = unsafe { ::std::mem::transmute(AuditUserShadowStack) };
            AuditUserShadowStack as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SetContextIpValidation: u32 =
                unsafe { ::std::mem::transmute(SetContextIpValidation) };
            SetContextIpValidation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditSetContextIpValidation: u32 =
                unsafe { ::std::mem::transmute(AuditSetContextIpValidation) };
            AuditSetContextIpValidation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableUserShadowStackStrictMode: u32 =
                unsafe { ::std::mem::transmute(EnableUserShadowStackStrictMode) };
            EnableUserShadowStackStrictMode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BlockNonCetBinaries: u32 = unsafe { ::std::mem::transmute(BlockNonCetBinaries) };
            BlockNonCetBinaries as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BlockNonCetBinariesNonEhcont: u32 =
                unsafe { ::std::mem::transmute(BlockNonCetBinariesNonEhcont) };
            BlockNonCetBinariesNonEhcont as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditBlockNonCetBinaries: u32 =
                unsafe { ::std::mem::transmute(AuditBlockNonCetBinaries) };
            AuditBlockNonCetBinaries as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CetDynamicApisOutOfProcOnly: u32 =
                unsafe { ::std::mem::transmute(CetDynamicApisOutOfProcOnly) };
            CetDynamicApisOutOfProcOnly as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SetContextIpValidationRelaxedMode: u32 =
                unsafe { ::std::mem::transmute(SetContextIpValidationRelaxedMode) };
            SetContextIpValidationRelaxedMode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
pub type PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY =
    *mut _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnablePointerAuthUserIp(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnablePointerAuthUserIp(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnablePointerAuthUserIp: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnablePointerAuthUserIp: u32 =
                unsafe { ::std::mem::transmute(EnablePointerAuthUserIp) };
            EnablePointerAuthUserIp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY = _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
pub type PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY =
    *mut _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnforceRedirectionTrust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnforceRedirectionTrust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRedirectionTrust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRedirectionTrust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnforceRedirectionTrust: DWORD,
        AuditRedirectionTrust: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnforceRedirectionTrust: u32 =
                unsafe { ::std::mem::transmute(EnforceRedirectionTrust) };
            EnforceRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditRedirectionTrust: u32 =
                unsafe { ::std::mem::transmute(AuditRedirectionTrust) };
            AuditRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY = _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
pub type PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY =
    *mut _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    pub TotalUserTime: LARGE_INTEGER,
    pub TotalKernelTime: LARGE_INTEGER,
    pub ThisPeriodTotalUserTime: LARGE_INTEGER,
    pub ThisPeriodTotalKernelTime: LARGE_INTEGER,
    pub TotalPageFaultCount: DWORD,
    pub TotalProcesses: DWORD,
    pub ActiveProcesses: DWORD,
    pub TotalTerminatedProcesses: DWORD,
}
pub type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = *mut _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    pub PerProcessUserTimeLimit: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub LimitFlags: DWORD,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub ActiveProcessLimit: DWORD,
    pub Affinity: ULONG_PTR,
    pub PriorityClass: DWORD,
    pub SchedulingClass: DWORD,
}
pub type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub type PJOBOBJECT_BASIC_LIMIT_INFORMATION = *mut _JOBOBJECT_BASIC_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    pub IoInfo: IO_COUNTERS,
    pub ProcessMemoryLimit: SIZE_T,
    pub JobMemoryLimit: SIZE_T,
    pub PeakProcessMemoryUsed: SIZE_T,
    pub PeakJobMemoryUsed: SIZE_T,
}
pub type JOBOBJECT_EXTENDED_LIMIT_INFORMATION = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = *mut _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    pub NumberOfAssignedProcesses: DWORD,
    pub NumberOfProcessIdsInList: DWORD,
    pub ProcessIdList: [ULONG_PTR; 1usize],
}
pub type JOBOBJECT_BASIC_PROCESS_ID_LIST = _JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub type PJOBOBJECT_BASIC_PROCESS_ID_LIST = *mut _JOBOBJECT_BASIC_PROCESS_ID_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    pub UIRestrictionsClass: DWORD,
}
pub type JOBOBJECT_BASIC_UI_RESTRICTIONS = _JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub type PJOBOBJECT_BASIC_UI_RESTRICTIONS = *mut _JOBOBJECT_BASIC_UI_RESTRICTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    pub SecurityLimitFlags: DWORD,
    pub JobToken: HANDLE,
    pub SidsToDisable: PTOKEN_GROUPS,
    pub PrivilegesToDelete: PTOKEN_PRIVILEGES,
    pub RestrictedSids: PTOKEN_GROUPS,
}
pub type JOBOBJECT_SECURITY_LIMIT_INFORMATION = _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub type PJOBOBJECT_SECURITY_LIMIT_INFORMATION = *mut _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    pub EndOfJobTimeAction: DWORD,
}
pub type JOBOBJECT_END_OF_JOB_TIME_INFORMATION = _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub type PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = *mut _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    pub CompletionKey: PVOID,
    pub CompletionPort: HANDLE,
}
pub type JOBOBJECT_ASSOCIATE_COMPLETION_PORT = _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub type PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = *mut _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    pub IoInfo: IO_COUNTERS,
}
pub type JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
    _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
    *mut _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_JOBSET_INFORMATION {
    pub MemberLevel: DWORD,
}
pub type JOBOBJECT_JOBSET_INFORMATION = _JOBOBJECT_JOBSET_INFORMATION;
pub type PJOBOBJECT_JOBSET_INFORMATION = *mut _JOBOBJECT_JOBSET_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium = 2,
    ToleranceHigh = 3,
}
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE as JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub type PJOBOBJECT_RATE_CONTROL_TOLERANCE = *mut _JOBOBJECT_RATE_CONTROL_TOLERANCE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium = 2,
    ToleranceIntervalLong = 3,
}
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL as JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
pub type PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL =
    *mut _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemoryLimit: DWORD64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub LimitFlags: DWORD,
}
pub type JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub type PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = *mut _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub __bindgen_anon_1: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1,
    pub __bindgen_anon_2: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2,
    pub __bindgen_anon_3: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3,
    pub LimitFlags: DWORD,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub JobLowMemoryLimit: DWORD64,
    pub IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {
    pub JobHighMemoryLimit: DWORD64,
    pub JobMemoryLimit: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub CpuRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    pub LimitFlags: DWORD,
    pub ViolationLimitFlags: DWORD,
    pub IoReadBytes: DWORD64,
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytes: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTime: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemory: DWORD64,
    pub JobMemoryLimit: DWORD64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
pub type JOBOBJECT_LIMIT_VIOLATION_INFORMATION = _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub type PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = *mut _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    pub LimitFlags: DWORD,
    pub ViolationLimitFlags: DWORD,
    pub IoReadBytes: DWORD64,
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytes: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTime: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemory: DWORD64,
    pub __bindgen_anon_1: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1,
    pub __bindgen_anon_2: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2,
    pub __bindgen_anon_3: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3,
    pub JobLowMemoryLimit: DWORD64,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {
    pub JobHighMemoryLimit: DWORD64,
    pub JobMemoryLimit: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    pub ControlFlags: DWORD,
    pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {
    pub CpuRate: DWORD,
    pub Weight: DWORD,
    pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub MinRate: WORD,
    pub MaxRate: WORD,
}
pub type JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub type PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = *mut _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    pub MaxBandwidth: DWORD64,
    pub ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    pub DscpTag: BYTE,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 15,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
}
pub type JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1 =
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
    pub CriticalReservationIops: LONG64,
    pub ReservationBandwidth: LONG64,
    pub CriticalReservationBandwidth: LONG64,
    pub MaxTimePercent: LONG64,
    pub ReservationTimePercent: LONG64,
    pub CriticalReservationTimePercent: LONG64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
    pub CriticalReservationIops: LONG64,
    pub ReservationBandwidth: LONG64,
    pub CriticalReservationBandwidth: LONG64,
    pub MaxTimePercent: LONG64,
    pub ReservationTimePercent: LONG64,
    pub CriticalReservationTimePercent: LONG64,
    pub SoftMaxIops: LONG64,
    pub SoftMaxBandwidth: LONG64,
    pub SoftMaxTimePercent: LONG64,
    pub LimitExcessNotifyIops: LONG64,
    pub LimitExcessNotifyBandwidth: LONG64,
    pub LimitExcessNotifyTimePercent: LONG64,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_STATS {
    pub IoCount: ULONG_PTR,
    pub TotalNonOverlappedQueueTime: ULONGLONG,
    pub TotalNonOverlappedServiceTime: ULONGLONG,
    pub TotalSize: ULONGLONG,
}
pub type JOBOBJECT_IO_ATTRIBUTION_STATS = _JOBOBJECT_IO_ATTRIBUTION_STATS;
pub type PJOBOBJECT_IO_ATTRIBUTION_STATS = *mut _JOBOBJECT_IO_ATTRIBUTION_STATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    pub ControlFlags: DWORD,
    pub ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    pub WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
}
pub type JOBOBJECT_IO_ATTRIBUTION_INFORMATION = _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub type PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = *mut _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information = 19,
    JobObjectReserved3Information = 20,
    JobObjectReserved4Information = 21,
    JobObjectReserved5Information = 22,
    JobObjectReserved6Information = 23,
    JobObjectReserved7Information = 24,
    JobObjectReserved8Information = 25,
    JobObjectReserved9Information = 26,
    JobObjectReserved10Information = 27,
    JobObjectReserved11Information = 28,
    JobObjectReserved12Information = 29,
    JobObjectReserved13Information = 30,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation = 32,
    JobObjectNotificationLimitInformation2 = 33,
    JobObjectLimitViolationInformation2 = 34,
    JobObjectCreateSilo = 35,
    JobObjectSiloBasicInformation = 36,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    JobObjectReserved26Information = 48,
    JobObjectReserved27Information = 49,
    MaxJobObjectInfoClass = 50,
}
pub use self::_JOBOBJECTINFOCLASS as JOBOBJECTINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILOOBJECT_BASIC_INFORMATION {
    pub SiloId: DWORD,
    pub SiloParentId: DWORD,
    pub NumberOfProcesses: DWORD,
    pub IsInServerSilo: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
}
pub type SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION;
pub type PSILOOBJECT_BASIC_INFORMATION = *mut _SILOOBJECT_BASIC_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED = 1,
    SERVERSILO_SHUTTING_DOWN = 2,
    SERVERSILO_TERMINATING = 3,
    SERVERSILO_TERMINATED = 4,
}
pub use self::_SERVERSILO_STATE as SERVERSILO_STATE;
pub type PSERVERSILO_STATE = *mut _SERVERSILO_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVERSILO_BASIC_INFORMATION {
    pub ServiceSessionId: DWORD,
    pub State: SERVERSILO_STATE,
    pub ExitStatus: DWORD,
    pub IsDownlevelContainer: BOOLEAN,
    pub ApiSetSchema: PVOID,
    pub HostApiSetSchema: PVOID,
}
pub type SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION;
pub type PSERVERSILO_BASIC_INFORMATION = *mut _SERVERSILO_BASIC_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown = 0,
    FirmwareTypeBios = 1,
    FirmwareTypeUefi = 2,
    FirmwareTypeMax = 3,
}
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore = 0,
    RelationNumaNode = 1,
    RelationCache = 2,
    RelationProcessorPackage = 3,
    RelationGroup = 4,
    RelationProcessorDie = 5,
    RelationNumaNodeEx = 6,
    RelationProcessorModule = 7,
    RelationAll = 65535,
}
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESSOR_CACHE_TYPE {
    CacheUnified = 0,
    CacheInstruction = 1,
    CacheData = 2,
    CacheTrace = 3,
}
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
    pub Level: BYTE,
    pub Associativity: BYTE,
    pub LineSize: WORD,
    pub Size: DWORD,
    pub Type: PROCESSOR_CACHE_TYPE,
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    pub ProcessorMask: ULONG_PTR,
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
    pub Cache: CACHE_DESCRIPTOR,
    pub Reserved: [ULONGLONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Flags: BYTE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub NodeNumber: DWORD,
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
    pub Flags: BYTE,
    pub EfficiencyClass: BYTE,
    pub Reserved: [BYTE; 20usize],
    pub GroupCount: WORD,
    pub GroupMask: [GROUP_AFFINITY; 1usize],
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: DWORD,
    pub Reserved: [BYTE; 18usize],
    pub GroupCount: WORD,
    pub __bindgen_anon_1: _NUMA_NODE_RELATIONSHIP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NUMA_NODE_RELATIONSHIP__bindgen_ty_1 {
    pub GroupMask: GROUP_AFFINITY,
    pub GroupMasks: [GROUP_AFFINITY; 1usize],
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
    pub Level: BYTE,
    pub Associativity: BYTE,
    pub LineSize: WORD,
    pub CacheSize: DWORD,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [BYTE; 18usize],
    pub GroupCount: WORD,
    pub __bindgen_anon_1: _CACHE_RELATIONSHIP__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CACHE_RELATIONSHIP__bindgen_ty_1 {
    pub GroupMask: GROUP_AFFINITY,
    pub GroupMasks: [GROUP_AFFINITY; 1usize],
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: BYTE,
    pub ActiveProcessorCount: BYTE,
    pub Reserved: [BYTE; 38usize],
    pub ActiveProcessorMask: KAFFINITY,
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
    pub MaximumGroupCount: WORD,
    pub ActiveGroupCount: WORD,
    pub Reserved: [BYTE; 20usize],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: DWORD,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    pub Processor: PROCESSOR_RELATIONSHIP,
    pub NumaNode: NUMA_NODE_RELATIONSHIP,
    pub Cache: CACHE_RELATIONSHIP,
    pub Group: GROUP_RELATIONSHIP,
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CPU_SET_INFORMATION_TYPE {
    CpuSetInformation = 0,
}
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
    pub Size: DWORD,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Id: DWORD,
    pub Group: WORD,
    pub LogicalProcessorIndex: BYTE,
    pub CoreIndex: BYTE,
    pub LastLevelCacheIndex: BYTE,
    pub NumaNodeIndex: BYTE,
    pub EfficiencyClass: BYTE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub AllocationTag: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AllFlags: BYTE,
    pub __bindgen_anon_1:
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Parked(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Parked(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Allocated(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllocatedToTargetProcess(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllocatedToTargetProcess(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RealTime(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Parked: BYTE,
        Allocated: BYTE,
        AllocatedToTargetProcess: BYTE,
        RealTime: BYTE,
        ReservedFlags: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Parked: u8 = unsafe { ::std::mem::transmute(Parked) };
            Parked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Allocated: u8 = unsafe { ::std::mem::transmute(Allocated) };
            Allocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllocatedToTargetProcess: u8 =
                unsafe { ::std::mem::transmute(AllocatedToTargetProcess) };
            AllocatedToTargetProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u8 = unsafe { ::std::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ReservedFlags: u8 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub Reserved: DWORD,
    pub SchedulingClass: BYTE,
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POOL_ZEROING_INFORMATION {
    pub PoolZeroingSupportPresent: BOOLEAN,
}
pub type SYSTEM_POOL_ZEROING_INFORMATION = _SYSTEM_POOL_ZEROING_INFORMATION;
pub type PSYSTEM_POOL_ZEROING_INFORMATION = *mut _SYSTEM_POOL_ZEROING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    pub CycleTime: DWORD64,
}
pub type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub type PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = *mut _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    #[inline]
    pub fn Machine(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Machine(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Native(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Native(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Process(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Process(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WoW64Container(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WoW64Container(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedZero0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedZero0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Machine: DWORD,
        KernelMode: DWORD,
        UserMode: DWORD,
        Native: DWORD,
        Process: DWORD,
        WoW64Container: DWORD,
        ReservedZero0: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Machine: u32 = unsafe { ::std::mem::transmute(Machine) };
            Machine as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let KernelMode: u32 = unsafe { ::std::mem::transmute(KernelMode) };
            KernelMode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UserMode: u32 = unsafe { ::std::mem::transmute(UserMode) };
            UserMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Native: u32 = unsafe { ::std::mem::transmute(Native) };
            Native as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Process: u32 = unsafe { ::std::mem::transmute(Process) };
            Process as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let WoW64Container: u32 = unsafe { ::std::mem::transmute(WoW64Container) };
            WoW64Container as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let ReservedZero0: u32 = unsafe { ::std::mem::transmute(ReservedZero0) };
            ReservedZero0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION =
    _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_FEATURE {
    pub Offset: DWORD,
    pub Size: DWORD,
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
pub type PXSTATE_FEATURE = *mut _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
    pub EnabledFeatures: DWORD64,
    pub EnabledVolatileFeatures: DWORD64,
    pub Size: DWORD,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
    pub Features: [XSTATE_FEATURE; 64usize],
    pub EnabledSupervisorFeatures: DWORD64,
    pub AlignedFeatures: DWORD64,
    pub AllFeatureSize: DWORD,
    pub AllFeatures: [DWORD; 64usize],
    pub EnabledUserVisibleSupervisorFeatures: DWORD64,
    pub ExtendedFeatureDisableFeatures: DWORD64,
    pub AllNonLargeFeatureSize: DWORD,
    pub Spare: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
    pub ControlFlags: DWORD,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn OptimizedSave(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OptimizedSave(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompactionEnabled(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompactionEnabled(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedFeatureDisable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedFeatureDisable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OptimizedSave: DWORD,
        CompactionEnabled: DWORD,
        ExtendedFeatureDisable: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OptimizedSave: u32 = unsafe { ::std::mem::transmute(OptimizedSave) };
            OptimizedSave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CompactionEnabled: u32 = unsafe { ::std::mem::transmute(CompactionEnabled) };
            CompactionEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExtendedFeatureDisable: u32 =
                unsafe { ::std::mem::transmute(ExtendedFeatureDisable) };
            ExtendedFeatureDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
pub type PXSTATE_CONFIGURATION = *mut _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: DWORD,
    pub PartitionId: WORD,
    pub RegionSize: SIZE_T,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION32 {
    pub BaseAddress: DWORD,
    pub AllocationBase: DWORD,
    pub AllocationProtect: DWORD,
    pub RegionSize: DWORD,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
pub type MEMORY_BASIC_INFORMATION32 = _MEMORY_BASIC_INFORMATION32;
pub type PMEMORY_BASIC_INFORMATION32 = *mut _MEMORY_BASIC_INFORMATION32;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION64 {
    pub BaseAddress: ULONGLONG,
    pub AllocationBase: ULONGLONG,
    pub AllocationProtect: DWORD,
    pub __alignment1: DWORD,
    pub RegionSize: ULONGLONG,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
    pub __alignment2: DWORD,
}
pub type MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64;
pub type PMEMORY_BASIC_INFORMATION64 = *mut _MEMORY_BASIC_INFORMATION64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CFG_CALL_TARGET_INFO {
    pub Offset: ULONG_PTR,
    pub Flags: ULONG_PTR,
}
pub type CFG_CALL_TARGET_INFO = _CFG_CALL_TARGET_INFO;
pub type PCFG_CALL_TARGET_INFO = *mut _CFG_CALL_TARGET_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEM_ADDRESS_REQUIREMENTS {
    pub LowestStartingAddress: PVOID,
    pub HighestEndingAddress: PVOID,
    pub Alignment: SIZE_T,
}
pub type MEM_ADDRESS_REQUIREMENTS = _MEM_ADDRESS_REQUIREMENTS;
pub type PMEM_ADDRESS_REQUIREMENTS = *mut _MEM_ADDRESS_REQUIREMENTS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MEM_EXTENDED_PARAMETER_TYPE {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements = 1,
    MemExtendedParameterNumaNode = 2,
    MemExtendedParameterPartitionHandle = 3,
    MemExtendedParameterUserPhysicalHandle = 4,
    MemExtendedParameterAttributeFlags = 5,
    MemExtendedParameterImageMachine = 6,
    MemExtendedParameterMax = 7,
}
pub type PMEM_EXTENDED_PARAMETER_TYPE = *mut MEM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> DWORD64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Type: DWORD64, Reserved: DWORD64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub ULong64: DWORD64,
    pub Pointer: PVOID,
    pub Size: SIZE_T,
    pub Handle: HANDLE,
    pub ULong: DWORD,
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEM_DEDICATED_ATTRIBUTE_TYPE {
    MemDedicatedAttributeReadBandwidth = 0,
    MemDedicatedAttributeReadLatency = 1,
    MemDedicatedAttributeWriteBandwidth = 2,
    MemDedicatedAttributeWriteLatency = 3,
    MemDedicatedAttributeMax = 4,
}
pub use self::_MEM_DEDICATED_ATTRIBUTE_TYPE as MEM_DEDICATED_ATTRIBUTE_TYPE;
pub type PMEM_DEDICATED_ATTRIBUTE_TYPE = *mut _MEM_DEDICATED_ATTRIBUTE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MEM_SECTION_EXTENDED_PARAMETER_TYPE {
    MemSectionExtendedParameterInvalidType = 0,
    MemSectionExtendedParameterUserPhysicalFlags = 1,
    MemSectionExtendedParameterNumaNode = 2,
    MemSectionExtendedParameterSigningLevel = 3,
    MemSectionExtendedParameterMax = 4,
}
pub type PMEM_SECTION_EXTENDED_PARAMETER_TYPE = *mut MEM_SECTION_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_SGX {
    pub Secs: [BYTE; 4096usize],
}
pub type ENCLAVE_CREATE_INFO_SGX = _ENCLAVE_CREATE_INFO_SGX;
pub type PENCLAVE_CREATE_INFO_SGX = *mut _ENCLAVE_CREATE_INFO_SGX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_SGX {
    pub SigStruct: [BYTE; 1808usize],
    pub Reserved1: [BYTE; 240usize],
    pub EInitToken: [BYTE; 304usize],
    pub Reserved2: [BYTE; 1744usize],
}
pub type ENCLAVE_INIT_INFO_SGX = _ENCLAVE_INIT_INFO_SGX;
pub type PENCLAVE_INIT_INFO_SGX = *mut _ENCLAVE_INIT_INFO_SGX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_VBS {
    pub Flags: DWORD,
    pub OwnerID: [BYTE; 32usize],
}
pub type ENCLAVE_CREATE_INFO_VBS = _ENCLAVE_CREATE_INFO_VBS;
pub type PENCLAVE_CREATE_INFO_VBS = *mut _ENCLAVE_CREATE_INFO_VBS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_VBS_BASIC {
    pub Flags: DWORD,
    pub OwnerID: [BYTE; 32usize],
}
pub type ENCLAVE_CREATE_INFO_VBS_BASIC = _ENCLAVE_CREATE_INFO_VBS_BASIC;
pub type PENCLAVE_CREATE_INFO_VBS_BASIC = *mut _ENCLAVE_CREATE_INFO_VBS_BASIC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_LOAD_DATA_VBS_BASIC {
    pub PageType: DWORD,
}
pub type ENCLAVE_LOAD_DATA_VBS_BASIC = _ENCLAVE_LOAD_DATA_VBS_BASIC;
pub type PENCLAVE_LOAD_DATA_VBS_BASIC = *mut _ENCLAVE_LOAD_DATA_VBS_BASIC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_VBS_BASIC {
    pub FamilyId: [BYTE; 16usize],
    pub ImageId: [BYTE; 16usize],
    pub EnclaveSize: ULONGLONG,
    pub EnclaveSvn: DWORD,
    pub Reserved: DWORD,
    pub __bindgen_anon_1: _ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1 {
    pub SignatureInfoHandle: HANDLE,
    pub Unused: ULONGLONG,
}
pub type ENCLAVE_INIT_INFO_VBS_BASIC = _ENCLAVE_INIT_INFO_VBS_BASIC;
pub type PENCLAVE_INIT_INFO_VBS_BASIC = *mut _ENCLAVE_INIT_INFO_VBS_BASIC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_VBS {
    pub Length: DWORD,
    pub ThreadCount: DWORD,
}
pub type ENCLAVE_INIT_INFO_VBS = _ENCLAVE_INIT_INFO_VBS;
pub type PENCLAVE_INIT_INFO_VBS = *mut _ENCLAVE_INIT_INFO_VBS;
pub type ENCLAVE_TARGET_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(arg1: PVOID) -> PVOID>;
pub type PENCLAVE_TARGET_FUNCTION = ENCLAVE_TARGET_FUNCTION;
pub type LPENCLAVE_TARGET_FUNCTION = PENCLAVE_TARGET_FUNCTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    pub Type: MEM_DEDICATED_ATTRIBUTE_TYPE,
    pub Reserved: DWORD,
    pub Value: DWORD64,
}
pub type MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE = _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE;
pub type PMEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE =
    *mut _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub SizeOfInformation: DWORD,
    pub Flags: DWORD,
    pub AttributesOffset: DWORD,
    pub AttributeCount: DWORD,
    pub Reserved: DWORD,
    pub TypeId: DWORD64,
}
pub type MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION =
    _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION;
pub type PMEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION =
    *mut _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_128 {
    pub Identifier: [BYTE; 16usize],
}
pub type FILE_ID_128 = _FILE_ID_128;
pub type PFILE_ID_128 = *mut _FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NOTIFY_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION;
pub type PFILE_NOTIFY_INFORMATION = *mut _FILE_NOTIFY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub __bindgen_anon_1: _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: DWORD,
    pub EaSize: DWORD,
}
pub type FILE_NOTIFY_EXTENDED_INFORMATION = _FILE_NOTIFY_EXTENDED_INFORMATION;
pub type PFILE_NOTIFY_EXTENDED_INFORMATION = *mut _FILE_NOTIFY_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_FULL_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub __bindgen_anon_1: _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: WORD,
    pub FileNameFlags: BYTE,
    pub Reserved: BYTE,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: DWORD,
    pub EaSize: DWORD,
}
pub type FILE_NOTIFY_FULL_INFORMATION = _FILE_NOTIFY_FULL_INFORMATION;
pub type PFILE_NOTIFY_FULL_INFORMATION = *mut _FILE_NOTIFY_FULL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: *mut ::std::os::raw::c_void,
    pub Alignment: ULONGLONG,
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER {
    pub ReparseTag: DWORD,
    pub ReparseDataLength: WORD,
    pub Reserved: WORD,
    pub ReparseGuid: GUID,
    pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
    pub DataBuffer: [BYTE; 1usize],
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
pub type PREPARSE_GUID_DATA_BUFFER = *mut _REPARSE_GUID_DATA_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub MaximumIos: DWORD,
    pub ObjectId: [DWORD; 4usize],
    pub Reserved: [DWORD; 41usize],
    pub ResumeContext: [BYTE; 1040usize],
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
pub type PSCRUB_DATA_INPUT = *mut _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT {
    pub Offset: LONGLONG,
    pub Length: ULONGLONG,
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
pub type PSCRUB_PARITY_EXTENT = *mut _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
    pub Size: WORD,
    pub Flags: WORD,
    pub NumberOfParityExtents: WORD,
    pub MaximumNumberOfParityExtents: WORD,
    pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
pub type PSCRUB_PARITY_EXTENT_DATA = *mut _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Status: DWORD,
    pub ErrorFileOffset: ULONGLONG,
    pub ErrorLength: ULONGLONG,
    pub NumberOfBytesRepaired: ULONGLONG,
    pub NumberOfBytesFailed: ULONGLONG,
    pub InternalFileReference: ULONGLONG,
    pub ResumeContextLength: WORD,
    pub ParityExtentDataOffset: WORD,
    pub Reserved: [DWORD; 9usize],
    pub NumberOfMetadataBytesProcessed: ULONGLONG,
    pub NumberOfDataBytesProcessed: ULONGLONG,
    pub TotalNumberOfMetadataBytesInUse: ULONGLONG,
    pub TotalNumberOfDataBytesInUse: ULONGLONG,
    pub DataBytesSkippedDueToNoAllocation: ULONGLONG,
    pub DataBytesSkippedDueToInvalidRun: ULONGLONG,
    pub DataBytesSkippedDueToIntegrityStream: ULONGLONG,
    pub DataBytesSkippedDueToRegionBeingClean: ULONGLONG,
    pub DataBytesSkippedDueToLockConflict: ULONGLONG,
    pub DataBytesSkippedDueToNoScrubDataFlag: ULONGLONG,
    pub DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag: ULONGLONG,
    pub DataBytesScrubbed: ULONGLONG,
    pub ResumeContext: [BYTE; 1040usize],
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub type PSCRUB_DATA_OUTPUT = *mut _SCRUB_DATA_OUTPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SharedVirtualDiskSupportType {
    SharedVirtualDisksUnsupported = 0,
    SharedVirtualDisksSupported = 1,
    SharedVirtualDiskSnapshotsSupported = 3,
    SharedVirtualDiskCDPSnapshotsSupported = 7,
}
pub use self::_SharedVirtualDiskSupportType as SharedVirtualDiskSupportType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SharedVirtualDiskHandleState {
    SharedVirtualDiskHandleStateNone = 0,
    SharedVirtualDiskHandleStateFileShared = 1,
    SharedVirtualDiskHandleStateHandleShared = 3,
}
pub use self::_SharedVirtualDiskHandleState as SharedVirtualDiskHandleState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARED_VIRTUAL_DISK_SUPPORT {
    pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    pub HandleState: SharedVirtualDiskHandleState,
}
pub type SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT;
pub type PSHARED_VIRTUAL_DISK_SUPPORT = *mut _SHARED_VIRTUAL_DISK_SUPPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REARRANGE_FILE_DATA {
    pub SourceStartingOffset: ULONGLONG,
    pub TargetOffset: ULONGLONG,
    pub SourceFileHandle: HANDLE,
    pub Length: DWORD,
    pub Flags: DWORD,
}
pub type REARRANGE_FILE_DATA = _REARRANGE_FILE_DATA;
pub type PREARRANGE_FILE_DATA = *mut _REARRANGE_FILE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REARRANGE_FILE_DATA32 {
    pub SourceStartingOffset: ULONGLONG,
    pub TargetOffset: ULONGLONG,
    pub SourceFileHandle: UINT32,
    pub Length: DWORD,
    pub Flags: DWORD,
}
pub type REARRANGE_FILE_DATA32 = _REARRANGE_FILE_DATA32;
pub type PREARRANGE_FILE_DATA32 = *mut _REARRANGE_FILE_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHUFFLE_FILE_DATA {
    pub StartingOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Flags: DWORD,
}
pub type SHUFFLE_FILE_DATA = _SHUFFLE_FILE_DATA;
pub type PSHUFFLE_FILE_DATA = *mut _SHUFFLE_FILE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_APP_INSTANCE_EA {
    pub AppInstanceID: GUID,
    pub CsvFlags: DWORD,
}
pub type NETWORK_APP_INSTANCE_EA = _NETWORK_APP_INSTANCE_EA;
pub type PNETWORK_APP_INSTANCE_EA = *mut _NETWORK_APP_INSTANCE_EA;
extern "C" {
    pub static GUID_MAX_POWER_SAVINGS: GUID;
}
extern "C" {
    pub static GUID_MIN_POWER_SAVINGS: GUID;
}
extern "C" {
    pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
extern "C" {
    pub static NO_SUBGROUP_GUID: GUID;
}
extern "C" {
    pub static ALL_POWERSCHEMES_GUID: GUID;
}
extern "C" {
    pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
extern "C" {
    pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
extern "C" {
    pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
extern "C" {
    pub static GUID_DEEP_SLEEP_ENABLED: GUID;
}
extern "C" {
    pub static GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
}
extern "C" {
    pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
extern "C" {
    pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    pub static GUID_MONITOR_POWER_ON: GUID;
}
extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
extern "C" {
    pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
extern "C" {
    pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_ADVANCED_COLOR_QUALITY_BIAS: GUID;
}
extern "C" {
    pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: GUID;
}
extern "C" {
    pub static GUID_DISK_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_DISK_MAX_POWER: GUID;
}
extern "C" {
    pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    pub static GUID_DISK_NVME_NOPPME: GUID;
}
extern "C" {
    pub static GUID_SLEEP_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_STANDBY_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
extern "C" {
    pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
extern "C" {
    pub static GUID_SYSTEM_AWAYMODE: GUID;
}
extern "C" {
    pub static GUID_ALLOW_AWAYMODE: GUID;
}
extern "C" {
    pub static GUID_USER_PRESENCE_PREDICTION: GUID;
}
extern "C" {
    pub static GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
}
extern "C" {
    pub static GUID_STANDBY_BUDGET_PERCENT: GUID;
}
extern "C" {
    pub static GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
}
extern "C" {
    pub static GUID_STANDBY_RESERVE_TIME: GUID;
}
extern "C" {
    pub static GUID_STANDBY_RESET_PERCENT: GUID;
}
extern "C" {
    pub static GUID_HUPR_ADAPTIVE_DISPLAY_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_HUPR_ADAPTIVE_DIM_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
extern "C" {
    pub static GUID_ALLOW_RTC_WAKE: GUID;
}
extern "C" {
    pub static GUID_LEGACY_RTC_MITIGATION: GUID;
}
extern "C" {
    pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
extern "C" {
    pub static GUID_POWER_SAVING_STATUS: GUID;
}
extern "C" {
    pub static GUID_ENERGY_SAVER_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_ENERGY_SAVER_POLICY: GUID;
}
extern "C" {
    pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_POWERBUTTON_ACTION: GUID;
}
extern "C" {
    pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
extern "C" {
    pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
extern "C" {
    pub static GUID_LIDCLOSE_ACTION: GUID;
}
extern "C" {
    pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
extern "C" {
    pub static GUID_BATTERY_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_DUTY_CYCLING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SOFT_PARKING_LATENCY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_MODULE_PARKING_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_COMPLEX_PARKING_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SMT_UNPARKING_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_RUNTIME_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_ARCH_CLASS_UPPER_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SHORT_THREAD_ARCH_CLASS_LOWER_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_LONG_THREAD_ARCH_CLASS_UPPER_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_LONG_THREAD_ARCH_CLASS_LOWER_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1: GUID;
}
extern "C" {
    pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
extern "C" {
    pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
extern "C" {
    pub static GUID_CONNECTIVITY_IN_STANDBY: GUID;
}
extern "C" {
    pub static GUID_DISCONNECTED_STANDBY_MODE: GUID;
}
extern "C" {
    pub static GUID_ACDC_POWER_SOURCE: GUID;
}
extern "C" {
    pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
extern "C" {
    pub static GUID_LIDSWITCH_STATE_RELIABILITY: GUID;
}
extern "C" {
    pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
extern "C" {
    pub static GUID_BATTERY_COUNT: GUID;
}
extern "C" {
    pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
extern "C" {
    pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
extern "C" {
    pub static GUID_SESSION_USER_PRESENCE: GUID;
}
extern "C" {
    pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
extern "C" {
    pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
extern "C" {
    pub static GUID_APPLAUNCH_BUTTON: GUID;
}
extern "C" {
    pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
extern "C" {
    pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
extern "C" {
    pub static GUID_INTSTEER_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_INTSTEER_MODE: GUID;
}
extern "C" {
    pub static GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
}
extern "C" {
    pub static GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
}
extern "C" {
    pub static GUID_GRAPHICS_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_GPU_PREFERENCE_POLICY: GUID;
}
extern "C" {
    pub static GUID_MIXED_REALITY_MODE: GUID;
}
extern "C" {
    pub static GUID_SPR_ACTIVE_SESSION_CHANGE: GUID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
}
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_ACTION {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
}
pub type PPOWER_ACTION = *mut POWER_ACTION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
}
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn = 1,
    PowerMonitorDim = 2,
}
pub use self::_MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE;
impl _USER_ACTIVITY_PRESENCE {
    pub const PowerUserInvalid: _USER_ACTIVITY_PRESENCE = _USER_ACTIVITY_PRESENCE::PowerUserMaximum;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent = 1,
    PowerUserInactive = 2,
    PowerUserMaximum = 3,
}
pub use self::_USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE;
pub type EXECUTION_STATE = DWORD;
pub type PEXECUTION_STATE = *mut DWORD;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LATENCY_TIME {
    LT_DONT_CARE = 0,
    LT_LOWEST_LATENCY = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired = 0,
    PowerRequestSystemRequired = 1,
    PowerRequestAwayModeRequired = 2,
    PowerRequestExecutionRequired = 3,
}
pub use self::_POWER_REQUEST_TYPE as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CM_Power_Data_s {
    pub PD_Size: DWORD,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: DWORD,
    pub PD_D1Latency: DWORD,
    pub PD_D2Latency: DWORD,
    pub PD_D3Latency: DWORD,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
    pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
pub type CM_POWER_DATA = CM_Power_Data_s;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_INFORMATION_LEVEL {
    SystemPowerPolicyAc = 0,
    SystemPowerPolicyDc = 1,
    VerifySystemPolicyAc = 2,
    VerifySystemPolicyDc = 3,
    SystemPowerCapabilities = 4,
    SystemBatteryState = 5,
    SystemPowerStateHandler = 6,
    ProcessorStateHandler = 7,
    SystemPowerPolicyCurrent = 8,
    AdministratorPowerPolicy = 9,
    SystemReserveHiberFile = 10,
    ProcessorInformation = 11,
    SystemPowerInformation = 12,
    ProcessorStateHandler2 = 13,
    LastWakeTime = 14,
    LastSleepTime = 15,
    SystemExecutionState = 16,
    SystemPowerStateNotifyHandler = 17,
    ProcessorPowerPolicyAc = 18,
    ProcessorPowerPolicyDc = 19,
    VerifyProcessorPowerPolicyAc = 20,
    VerifyProcessorPowerPolicyDc = 21,
    ProcessorPowerPolicyCurrent = 22,
    SystemPowerStateLogging = 23,
    SystemPowerLoggingEntry = 24,
    SetPowerSettingValue = 25,
    NotifyUserPowerSetting = 26,
    PowerInformationLevelUnused0 = 27,
    SystemMonitorHiberBootPowerOff = 28,
    SystemVideoState = 29,
    TraceApplicationPowerMessage = 30,
    TraceApplicationPowerMessageEnd = 31,
    ProcessorPerfStates = 32,
    ProcessorIdleStates = 33,
    ProcessorCap = 34,
    SystemWakeSource = 35,
    SystemHiberFileInformation = 36,
    TraceServicePowerMessage = 37,
    ProcessorLoad = 38,
    PowerShutdownNotification = 39,
    MonitorCapabilities = 40,
    SessionPowerInit = 41,
    SessionDisplayState = 42,
    PowerRequestCreate = 43,
    PowerRequestAction = 44,
    GetPowerRequestList = 45,
    ProcessorInformationEx = 46,
    NotifyUserModeLegacyPowerEvent = 47,
    GroupPark = 48,
    ProcessorIdleDomains = 49,
    WakeTimerList = 50,
    SystemHiberFileSize = 51,
    ProcessorIdleStatesHv = 52,
    ProcessorPerfStatesHv = 53,
    ProcessorPerfCapHv = 54,
    ProcessorSetIdle = 55,
    LogicalProcessorIdling = 56,
    UserPresence = 57,
    PowerSettingNotificationName = 58,
    GetPowerSettingValue = 59,
    IdleResiliency = 60,
    SessionRITState = 61,
    SessionConnectNotification = 62,
    SessionPowerCleanup = 63,
    SessionLockState = 64,
    SystemHiberbootState = 65,
    PlatformInformation = 66,
    PdcInvocation = 67,
    MonitorInvocation = 68,
    FirmwareTableInformationRegistered = 69,
    SetShutdownSelectedTime = 70,
    SuspendResumeInvocation = 71,
    PlmPowerRequestCreate = 72,
    ScreenOff = 73,
    CsDeviceNotification = 74,
    PlatformRole = 75,
    LastResumePerformance = 76,
    DisplayBurst = 77,
    ExitLatencySamplingPercentage = 78,
    RegisterSpmPowerSettings = 79,
    PlatformIdleStates = 80,
    ProcessorIdleVeto = 81,
    PlatformIdleVeto = 82,
    SystemBatteryStatePrecise = 83,
    ThermalEvent = 84,
    PowerRequestActionInternal = 85,
    BatteryDeviceState = 86,
    PowerInformationInternal = 87,
    ThermalStandby = 88,
    SystemHiberFileType = 89,
    PhysicalPowerButtonPress = 90,
    QueryPotentialDripsConstraint = 91,
    EnergyTrackerCreate = 92,
    EnergyTrackerQuery = 93,
    UpdateBlackBoxRecorder = 94,
    SessionAllowExternalDmaDevices = 95,
    SendSuspendResumeNotification = 96,
    BlackBoxRecorderDirectAccessBuffer = 97,
    PowerInformationLevelMaximum = 98,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_USER_PRESENCE_TYPE {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 255,
}
pub type PPOWER_USER_PRESENCE_TYPE = *mut POWER_USER_PRESENCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_CONNECT {
    pub Connected: BOOLEAN,
    pub Console: BOOLEAN,
}
pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_TIMEOUTS {
    pub InputTimeout: DWORD,
    pub DisplayTimeout: DWORD,
}
pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_RIT_STATE {
    pub Active: BOOLEAN,
    pub LastInputTime: DWORD64,
}
pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_WINLOGON {
    pub SessionId: DWORD,
    pub Console: BOOLEAN,
    pub Locked: BOOLEAN,
}
pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES {
    pub IsAllowed: BOOLEAN,
}
pub type POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
pub type PPOWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = *mut _POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: DWORD,
    pub IdleResiliencyPeriod: DWORD,
}
pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_MONITOR_REQUEST_REASON {
    MonitorRequestReasonUnknown = 0,
    MonitorRequestReasonPowerButton = 1,
    MonitorRequestReasonRemoteConnection = 2,
    MonitorRequestReasonScMonitorpower = 3,
    MonitorRequestReasonUserInput = 4,
    MonitorRequestReasonAcDcDisplayBurst = 5,
    MonitorRequestReasonUserDisplayBurst = 6,
    MonitorRequestReasonPoSetSystemState = 7,
    MonitorRequestReasonSetThreadExecutionState = 8,
    MonitorRequestReasonFullWake = 9,
    MonitorRequestReasonSessionUnlock = 10,
    MonitorRequestReasonScreenOffRequest = 11,
    MonitorRequestReasonIdleTimeout = 12,
    MonitorRequestReasonPolicyChange = 13,
    MonitorRequestReasonSleepButton = 14,
    MonitorRequestReasonLid = 15,
    MonitorRequestReasonBatteryCountChange = 16,
    MonitorRequestReasonGracePeriod = 17,
    MonitorRequestReasonPnP = 18,
    MonitorRequestReasonDP = 19,
    MonitorRequestReasonSxTransition = 20,
    MonitorRequestReasonSystemIdle = 21,
    MonitorRequestReasonNearProximity = 22,
    MonitorRequestReasonThermalStandby = 23,
    MonitorRequestReasonResumePdc = 24,
    MonitorRequestReasonResumeS4 = 25,
    MonitorRequestReasonTerminal = 26,
    MonitorRequestReasonPdcSignal = 27,
    MonitorRequestReasonAcDcDisplayBurstSuppressed = 28,
    MonitorRequestReasonSystemStateEntered = 29,
    MonitorRequestReasonWinrt = 30,
    MonitorRequestReasonUserInputKeyboard = 31,
    MonitorRequestReasonUserInputMouse = 32,
    MonitorRequestReasonUserInputTouchpad = 33,
    MonitorRequestReasonUserInputPen = 34,
    MonitorRequestReasonUserInputAccelerometer = 35,
    MonitorRequestReasonUserInputHid = 36,
    MonitorRequestReasonUserInputPoUserPresent = 37,
    MonitorRequestReasonUserInputSessionSwitch = 38,
    MonitorRequestReasonUserInputInitialization = 39,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 40,
    MonitorRequestReasonPdcSignalWindowsMobileShell = 41,
    MonitorRequestReasonPdcSignalHeyCortana = 42,
    MonitorRequestReasonPdcSignalHolographicShell = 43,
    MonitorRequestReasonPdcSignalFingerprint = 44,
    MonitorRequestReasonDirectedDrips = 45,
    MonitorRequestReasonDim = 46,
    MonitorRequestReasonBuiltinPanel = 47,
    MonitorRequestReasonDisplayRequiredUnDim = 48,
    MonitorRequestReasonBatteryCountChangeSuppressed = 49,
    MonitorRequestReasonResumeModernStandby = 50,
    MonitorRequestReasonTerminalInit = 51,
    MonitorRequestReasonPdcSignalSensorsHumanPresence = 52,
    MonitorRequestReasonBatteryPreCritical = 53,
    MonitorRequestReasonUserInputTouch = 54,
    MonitorRequestReasonMax = 55,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff = 0,
    MonitorRequestTypeOnAndPresent = 1,
    MonitorRequestTypeToggleOn = 2,
}
pub use self::_POWER_MONITOR_REQUEST_TYPE as POWER_MONITOR_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_MONITOR_INVOCATION {
    pub Console: BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESUME_PERFORMANCE {
    pub PostTimeMs: DWORD,
    pub TotalResumeTimeMs: ULONGLONG,
    pub ResumeCompleteTimestamp: ULONGLONG,
}
pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_POWER_CONDITION {
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
    pub Version: DWORD,
    pub Guid: GUID,
    pub PowerCondition: SYSTEM_POWER_CONDITION,
    pub DataLength: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type PSET_POWER_SETTING_VALUE = *mut SET_POWER_SETTING_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTIFY_USER_POWER_SETTING {
    pub Guid: GUID,
}
pub type PNOTIFY_USER_POWER_SETTING = *mut NOTIFY_USER_POWER_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: LARGE_INTEGER,
    pub Flags: DWORD,
    pub ButtonInstanceID: DWORD,
}
pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE = *mut _APPLICATIONLAUNCH_SETTING_VALUE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop = 1,
    PlatformRoleMobile = 2,
    PlatformRoleWorkstation = 3,
    PlatformRoleEnterpriseServer = 4,
    PlatformRoleSOHOServer = 5,
    PlatformRoleAppliancePC = 6,
    PlatformRolePerformanceServer = 7,
    PlatformRoleSlate = 8,
    PlatformRoleMaximum = 9,
}
pub use self::_POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PLATFORM_INFORMATION {
    pub AoAc: BOOLEAN,
}
pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POWER_SETTING_ALTITUDE {
    ALTITUDE_GROUP_POLICY = 0,
    ALTITUDE_USER = 1,
    ALTITUDE_RUNTIME_OVERRIDE = 2,
    ALTITUDE_PROVISIONING = 3,
    ALTITUDE_OEM_CUSTOMIZATION = 4,
    ALTITUDE_INTERNAL_OVERRIDE = 5,
    ALTITUDE_OS_DEFAULT = 6,
}
pub type PPOWER_SETTING_ALTITUDE = *mut POWER_SETTING_ALTITUDE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
    pub Granularity: DWORD,
    pub Capacity: DWORD,
}
pub type PBATTERY_REPORTING_SCALE = *mut BATTERY_REPORTING_SCALE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_LEGACY_PERFSTATE {
    pub Frequency: DWORD,
    pub Flags: DWORD,
    pub PercentFrequency: DWORD,
}
pub type PPPM_WMI_LEGACY_PERFSTATE = *mut PPM_WMI_LEGACY_PERFSTATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATE {
    pub Latency: DWORD,
    pub Power: DWORD,
    pub TimeCheck: DWORD,
    pub PromotePercent: BYTE,
    pub DemotePercent: BYTE,
    pub StateType: BYTE,
    pub Reserved: BYTE,
    pub StateFlags: DWORD,
    pub Context: DWORD,
    pub IdleHandler: DWORD,
    pub Reserved1: DWORD,
}
pub type PPPM_WMI_IDLE_STATE = *mut PPM_WMI_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATES {
    pub Type: DWORD,
    pub Count: DWORD,
    pub TargetState: DWORD,
    pub OldState: DWORD,
    pub TargetProcessors: DWORD64,
    pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
pub type PPPM_WMI_IDLE_STATES = *mut PPM_WMI_IDLE_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATES_EX {
    pub Type: DWORD,
    pub Count: DWORD,
    pub TargetState: DWORD,
    pub OldState: DWORD,
    pub TargetProcessors: PVOID,
    pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
pub type PPPM_WMI_IDLE_STATES_EX = *mut PPM_WMI_IDLE_STATES_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATE {
    pub Frequency: DWORD,
    pub Power: DWORD,
    pub PercentFrequency: BYTE,
    pub IncreaseLevel: BYTE,
    pub DecreaseLevel: BYTE,
    pub Type: BYTE,
    pub IncreaseTime: DWORD,
    pub DecreaseTime: DWORD,
    pub Control: DWORD64,
    pub Status: DWORD64,
    pub HitCount: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub Reserved3: DWORD64,
}
pub type PPPM_WMI_PERF_STATE = *mut PPM_WMI_PERF_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATES {
    pub Count: DWORD,
    pub MaxFrequency: DWORD,
    pub CurrentState: DWORD,
    pub MaxPerfState: DWORD,
    pub MinPerfState: DWORD,
    pub LowestPerfState: DWORD,
    pub ThermalConstraint: DWORD,
    pub BusyAdjThreshold: BYTE,
    pub PolicyType: BYTE,
    pub Type: BYTE,
    pub Reserved: BYTE,
    pub TimerInterval: DWORD,
    pub TargetProcessors: DWORD64,
    pub PStateHandler: DWORD,
    pub PStateContext: DWORD,
    pub TStateHandler: DWORD,
    pub TStateContext: DWORD,
    pub FeedbackHandler: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub State: [PPM_WMI_PERF_STATE; 1usize],
}
pub type PPPM_WMI_PERF_STATES = *mut PPM_WMI_PERF_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATES_EX {
    pub Count: DWORD,
    pub MaxFrequency: DWORD,
    pub CurrentState: DWORD,
    pub MaxPerfState: DWORD,
    pub MinPerfState: DWORD,
    pub LowestPerfState: DWORD,
    pub ThermalConstraint: DWORD,
    pub BusyAdjThreshold: BYTE,
    pub PolicyType: BYTE,
    pub Type: BYTE,
    pub Reserved: BYTE,
    pub TimerInterval: DWORD,
    pub TargetProcessors: PVOID,
    pub PStateHandler: DWORD,
    pub PStateContext: DWORD,
    pub TStateHandler: DWORD,
    pub TStateContext: DWORD,
    pub FeedbackHandler: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub State: [PPM_WMI_PERF_STATE; 1usize],
}
pub type PPPM_WMI_PERF_STATES_EX = *mut PPM_WMI_PERF_STATES_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_ACCOUNTING {
    pub IdleTransitions: DWORD,
    pub FailedTransitions: DWORD,
    pub InvalidBucketIndex: DWORD,
    pub TotalTime: DWORD64,
    pub IdleTimeBuckets: [DWORD; 6usize],
}
pub type PPPM_IDLE_STATE_ACCOUNTING = *mut PPM_IDLE_STATE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_ACCOUNTING {
    pub StateCount: DWORD,
    pub TotalTransitions: DWORD,
    pub ResetCount: DWORD,
    pub StartTime: DWORD64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING; 1usize],
}
pub type PPPM_IDLE_ACCOUNTING = *mut PPM_IDLE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_BUCKET_EX {
    pub TotalTimeUs: DWORD64,
    pub MinTimeUs: DWORD,
    pub MaxTimeUs: DWORD,
    pub Count: DWORD,
}
pub type PPPM_IDLE_STATE_BUCKET_EX = *mut PPM_IDLE_STATE_BUCKET_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_ACCOUNTING_EX {
    pub TotalTime: DWORD64,
    pub IdleTransitions: DWORD,
    pub FailedTransitions: DWORD,
    pub InvalidBucketIndex: DWORD,
    pub MinTimeUs: DWORD,
    pub MaxTimeUs: DWORD,
    pub CancelledTransitions: DWORD,
    pub IdleTimeBuckets: [PPM_IDLE_STATE_BUCKET_EX; 16usize],
}
pub type PPPM_IDLE_STATE_ACCOUNTING_EX = *mut PPM_IDLE_STATE_ACCOUNTING_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_ACCOUNTING_EX {
    pub StateCount: DWORD,
    pub TotalTransitions: DWORD,
    pub ResetCount: DWORD,
    pub AbortCount: DWORD,
    pub StartTime: DWORD64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING_EX; 1usize],
}
pub type PPPM_IDLE_ACCOUNTING_EX = *mut PPM_IDLE_ACCOUNTING_EX;
extern "C" {
    pub static PPM_PERFSTATE_CHANGE_GUID: GUID;
}
extern "C" {
    pub static PPM_PERFSTATE_DOMAIN_CHANGE_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLESTATE_CHANGE_GUID: GUID;
}
extern "C" {
    pub static PPM_PERFSTATES_DATA_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLESTATES_DATA_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLE_ACCOUNTING_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLE_ACCOUNTING_EX_GUID: GUID;
}
extern "C" {
    pub static PPM_THERMALCONSTRAINT_GUID: GUID;
}
extern "C" {
    pub static PPM_PERFMON_PERFSTATE_GUID: GUID;
}
extern "C" {
    pub static PPM_THERMAL_POLICY_CHANGE_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_PERFSTATE_EVENT {
    pub State: DWORD,
    pub Status: DWORD,
    pub Latency: DWORD,
    pub Speed: DWORD,
    pub Processor: DWORD,
}
pub type PPPM_PERFSTATE_EVENT = *mut PPM_PERFSTATE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_PERFSTATE_DOMAIN_EVENT {
    pub State: DWORD,
    pub Latency: DWORD,
    pub Speed: DWORD,
    pub Processors: DWORD64,
}
pub type PPPM_PERFSTATE_DOMAIN_EVENT = *mut PPM_PERFSTATE_DOMAIN_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLESTATE_EVENT {
    pub NewState: DWORD,
    pub OldState: DWORD,
    pub Processors: DWORD64,
}
pub type PPPM_IDLESTATE_EVENT = *mut PPM_IDLESTATE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_THERMALCHANGE_EVENT {
    pub ThermalConstraint: DWORD,
    pub Processors: DWORD64,
}
pub type PPPM_THERMALCHANGE_EVENT = *mut PPM_THERMALCHANGE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_THERMAL_POLICY_EVENT {
    pub Mode: BYTE,
    pub Processors: DWORD64,
}
pub type PPPM_THERMAL_POLICY_EVENT = *mut PPM_THERMAL_POLICY_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWER_ACTION_POLICY {
    pub Action: POWER_ACTION,
    pub Flags: DWORD,
    pub EventCode: DWORD,
}
pub type PPOWER_ACTION_POLICY = *mut POWER_ACTION_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_LEVEL {
    pub Enable: BOOLEAN,
    pub Spare: [BYTE; 3usize],
    pub BatteryLevel: DWORD,
    pub PowerPolicy: POWER_ACTION_POLICY,
    pub MinSystemState: SYSTEM_POWER_STATE,
}
pub type PSYSTEM_POWER_LEVEL = *mut SYSTEM_POWER_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_POLICY {
    pub Revision: DWORD,
    pub PowerButton: POWER_ACTION_POLICY,
    pub SleepButton: POWER_ACTION_POLICY,
    pub LidClose: POWER_ACTION_POLICY,
    pub LidOpenWake: SYSTEM_POWER_STATE,
    pub Reserved: DWORD,
    pub Idle: POWER_ACTION_POLICY,
    pub IdleTimeout: DWORD,
    pub IdleSensitivity: BYTE,
    pub DynamicThrottle: BYTE,
    pub Spare2: [BYTE; 2usize],
    pub MinSleep: SYSTEM_POWER_STATE,
    pub MaxSleep: SYSTEM_POWER_STATE,
    pub ReducedLatencySleep: SYSTEM_POWER_STATE,
    pub WinLogonFlags: DWORD,
    pub Spare3: DWORD,
    pub DozeS4Timeout: DWORD,
    pub BroadcastCapacityResolution: DWORD,
    pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
    pub VideoTimeout: DWORD,
    pub VideoDimDisplay: BOOLEAN,
    pub VideoReserved: [DWORD; 3usize],
    pub SpindownTimeout: DWORD,
    pub OptimizeForPower: BOOLEAN,
    pub FanThrottleTolerance: BYTE,
    pub ForcedThrottle: BYTE,
    pub MinThrottle: BYTE,
    pub OverThrottled: POWER_ACTION_POLICY,
}
pub type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY;
pub type PSYSTEM_POWER_POLICY = *mut _SYSTEM_POWER_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_INFO {
    pub TimeCheck: DWORD,
    pub DemotePercent: BYTE,
    pub PromotePercent: BYTE,
    pub Spare: [BYTE; 2usize],
}
pub type PPROCESSOR_IDLESTATE_INFO = *mut PROCESSOR_IDLESTATE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY {
    pub Revision: WORD,
    pub Flags: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1,
    pub PolicyCount: DWORD,
    pub Policy: [PROCESSOR_IDLESTATE_INFO; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    pub AsWORD: WORD,
    pub __bindgen_anon_1: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AllowScaling(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AllowScaling(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowScaling: WORD,
        Disabled: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowScaling: u16 = unsafe { ::std::mem::transmute(AllowScaling) };
            AllowScaling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u16 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PPROCESSOR_IDLESTATE_POLICY = *mut PROCESSOR_IDLESTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_POWER_POLICY_INFO {
    pub TimeCheck: DWORD,
    pub DemoteLimit: DWORD,
    pub PromoteLimit: DWORD,
    pub DemotePercent: BYTE,
    pub PromotePercent: BYTE,
    pub Spare: [BYTE; 2usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _PROCESSOR_POWER_POLICY_INFO {
    #[inline]
    pub fn AllowDemotion(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowDemotion(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowPromotion(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowPromotion(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowDemotion: DWORD,
        AllowPromotion: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowDemotion: u32 = unsafe { ::std::mem::transmute(AllowDemotion) };
            AllowDemotion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowPromotion: u32 = unsafe { ::std::mem::transmute(AllowPromotion) };
            AllowPromotion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESSOR_POWER_POLICY_INFO = _PROCESSOR_POWER_POLICY_INFO;
pub type PPROCESSOR_POWER_POLICY_INFO = *mut _PROCESSOR_POWER_POLICY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_POWER_POLICY {
    pub Revision: DWORD,
    pub DynamicThrottle: BYTE,
    pub Spare: [BYTE; 3usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub PolicyCount: DWORD,
    pub Policy: [PROCESSOR_POWER_POLICY_INFO; 3usize],
}
impl _PROCESSOR_POWER_POLICY {
    #[inline]
    pub fn DisableCStates(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableCStates(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableCStates: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableCStates: u32 = unsafe { ::std::mem::transmute(DisableCStates) };
            DisableCStates as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESSOR_POWER_POLICY = _PROCESSOR_POWER_POLICY;
pub type PPROCESSOR_POWER_POLICY = *mut _PROCESSOR_POWER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY {
    pub Revision: DWORD,
    pub MaxThrottle: BYTE,
    pub MinThrottle: BYTE,
    pub BusyAdjThreshold: BYTE,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1,
    pub TimeCheck: DWORD,
    pub IncreaseTime: DWORD,
    pub DecreaseTime: DWORD,
    pub IncreasePercent: DWORD,
    pub DecreasePercent: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    pub Spare: BYTE,
    pub Flags: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub AsBYTE: BYTE,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoDomainAccounting(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NoDomainAccounting(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreasePolicy(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IncreasePolicy(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DecreasePolicy(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DecreasePolicy(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoDomainAccounting: BYTE,
        IncreasePolicy: BYTE,
        DecreasePolicy: BYTE,
        Reserved: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoDomainAccounting: u8 = unsafe { ::std::mem::transmute(NoDomainAccounting) };
            NoDomainAccounting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let IncreasePolicy: u8 = unsafe { ::std::mem::transmute(IncreasePolicy) };
            IncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let DecreasePolicy: u8 = unsafe { ::std::mem::transmute(DecreasePolicy) };
            DecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PPROCESSOR_PERFSTATE_POLICY = *mut PROCESSOR_PERFSTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADMINISTRATOR_POWER_POLICY {
    pub MinSleep: SYSTEM_POWER_STATE,
    pub MaxSleep: SYSTEM_POWER_STATE,
    pub MinVideoTimeout: DWORD,
    pub MaxVideoTimeout: DWORD,
    pub MinSpindownTimeout: DWORD,
    pub MaxSpindownTimeout: DWORD,
}
pub type ADMINISTRATOR_POWER_POLICY = _ADMINISTRATOR_POWER_POLICY;
pub type PADMINISTRATOR_POWER_POLICY = *mut _ADMINISTRATOR_POWER_POLICY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB = 1,
    HiberFileBucket4GB = 2,
    HiberFileBucket8GB = 3,
    HiberFileBucket16GB = 4,
    HiberFileBucket32GB = 5,
    HiberFileBucketUnlimited = 6,
    HiberFileBucketMax = 7,
}
pub use self::_HIBERFILE_BUCKET_SIZE as HIBERFILE_BUCKET_SIZE;
pub type PHIBERFILE_BUCKET_SIZE = *mut _HIBERFILE_BUCKET_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIBERFILE_BUCKET {
    pub MaxPhysicalMemory: DWORD64,
    pub PhysicalMemoryPercent: [DWORD; 3usize],
}
pub type HIBERFILE_BUCKET = _HIBERFILE_BUCKET;
pub type PHIBERFILE_BUCKET = *mut _HIBERFILE_BUCKET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_CAPABILITIES {
    pub PowerButtonPresent: BOOLEAN,
    pub SleepButtonPresent: BOOLEAN,
    pub LidPresent: BOOLEAN,
    pub SystemS1: BOOLEAN,
    pub SystemS2: BOOLEAN,
    pub SystemS3: BOOLEAN,
    pub SystemS4: BOOLEAN,
    pub SystemS5: BOOLEAN,
    pub HiberFilePresent: BOOLEAN,
    pub FullWake: BOOLEAN,
    pub VideoDimPresent: BOOLEAN,
    pub ApmPresent: BOOLEAN,
    pub UpsPresent: BOOLEAN,
    pub ThermalControl: BOOLEAN,
    pub ProcessorThrottle: BOOLEAN,
    pub ProcessorMinThrottle: BYTE,
    pub ProcessorMaxThrottle: BYTE,
    pub FastSystemS4: BOOLEAN,
    pub Hiberboot: BOOLEAN,
    pub WakeAlarmPresent: BOOLEAN,
    pub AoAc: BOOLEAN,
    pub DiskSpinDown: BOOLEAN,
    pub HiberFileType: BYTE,
    pub AoAcConnectivitySupported: BOOLEAN,
    pub spare3: [BYTE; 6usize],
    pub SystemBatteriesPresent: BOOLEAN,
    pub BatteriesAreShortTerm: BOOLEAN,
    pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
    pub AcOnLineWake: SYSTEM_POWER_STATE,
    pub SoftLidWake: SYSTEM_POWER_STATE,
    pub RtcWake: SYSTEM_POWER_STATE,
    pub MinDeviceWakeState: SYSTEM_POWER_STATE,
    pub DefaultLowLatencyWake: SYSTEM_POWER_STATE,
}
pub type PSYSTEM_POWER_CAPABILITIES = *mut SYSTEM_POWER_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_BATTERY_STATE {
    pub AcOnLine: BOOLEAN,
    pub BatteryPresent: BOOLEAN,
    pub Charging: BOOLEAN,
    pub Discharging: BOOLEAN,
    pub Spare1: [BOOLEAN; 3usize],
    pub Tag: BYTE,
    pub MaxCapacity: DWORD,
    pub RemainingCapacity: DWORD,
    pub Rate: DWORD,
    pub EstimatedTime: DWORD,
    pub DefaultAlert1: DWORD,
    pub DefaultAlert2: DWORD,
}
pub type PSYSTEM_BATTERY_STATE = *mut SYSTEM_BATTERY_STATE;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
    pub e_magic: WORD,
    pub e_cblp: WORD,
    pub e_cp: WORD,
    pub e_crlc: WORD,
    pub e_cparhdr: WORD,
    pub e_minalloc: WORD,
    pub e_maxalloc: WORD,
    pub e_ss: WORD,
    pub e_sp: WORD,
    pub e_csum: WORD,
    pub e_ip: WORD,
    pub e_cs: WORD,
    pub e_lfarlc: WORD,
    pub e_ovno: WORD,
    pub e_res: [WORD; 4usize],
    pub e_oemid: WORD,
    pub e_oeminfo: WORD,
    pub e_res2: [WORD; 10usize],
    pub e_lfanew: LONG,
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
pub type PIMAGE_DOS_HEADER = *mut _IMAGE_DOS_HEADER;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OS2_HEADER {
    pub ne_magic: WORD,
    pub ne_ver: CHAR,
    pub ne_rev: CHAR,
    pub ne_enttab: WORD,
    pub ne_cbenttab: WORD,
    pub ne_crc: LONG,
    pub ne_flags: WORD,
    pub ne_autodata: WORD,
    pub ne_heap: WORD,
    pub ne_stack: WORD,
    pub ne_csip: LONG,
    pub ne_sssp: LONG,
    pub ne_cseg: WORD,
    pub ne_cmod: WORD,
    pub ne_cbnrestab: WORD,
    pub ne_segtab: WORD,
    pub ne_rsrctab: WORD,
    pub ne_restab: WORD,
    pub ne_modtab: WORD,
    pub ne_imptab: WORD,
    pub ne_nrestab: LONG,
    pub ne_cmovent: WORD,
    pub ne_align: WORD,
    pub ne_cres: WORD,
    pub ne_exetyp: BYTE,
    pub ne_flagsothers: BYTE,
    pub ne_pretthunks: WORD,
    pub ne_psegrefbytes: WORD,
    pub ne_swaparea: WORD,
    pub ne_expver: WORD,
}
pub type IMAGE_OS2_HEADER = _IMAGE_OS2_HEADER;
pub type PIMAGE_OS2_HEADER = *mut _IMAGE_OS2_HEADER;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_VXD_HEADER {
    pub e32_magic: WORD,
    pub e32_border: BYTE,
    pub e32_worder: BYTE,
    pub e32_level: DWORD,
    pub e32_cpu: WORD,
    pub e32_os: WORD,
    pub e32_ver: DWORD,
    pub e32_mflags: DWORD,
    pub e32_mpages: DWORD,
    pub e32_startobj: DWORD,
    pub e32_eip: DWORD,
    pub e32_stackobj: DWORD,
    pub e32_esp: DWORD,
    pub e32_pagesize: DWORD,
    pub e32_lastpagesize: DWORD,
    pub e32_fixupsize: DWORD,
    pub e32_fixupsum: DWORD,
    pub e32_ldrsize: DWORD,
    pub e32_ldrsum: DWORD,
    pub e32_objtab: DWORD,
    pub e32_objcnt: DWORD,
    pub e32_objmap: DWORD,
    pub e32_itermap: DWORD,
    pub e32_rsrctab: DWORD,
    pub e32_rsrccnt: DWORD,
    pub e32_restab: DWORD,
    pub e32_enttab: DWORD,
    pub e32_dirtab: DWORD,
    pub e32_dircnt: DWORD,
    pub e32_fpagetab: DWORD,
    pub e32_frectab: DWORD,
    pub e32_impmod: DWORD,
    pub e32_impmodcnt: DWORD,
    pub e32_impproc: DWORD,
    pub e32_pagesum: DWORD,
    pub e32_datapage: DWORD,
    pub e32_preload: DWORD,
    pub e32_nrestab: DWORD,
    pub e32_cbnrestab: DWORD,
    pub e32_nressum: DWORD,
    pub e32_autodata: DWORD,
    pub e32_debuginfo: DWORD,
    pub e32_debuglen: DWORD,
    pub e32_instpreload: DWORD,
    pub e32_instdemand: DWORD,
    pub e32_heapsize: DWORD,
    pub e32_res3: [BYTE; 12usize],
    pub e32_winresoff: DWORD,
    pub e32_winreslen: DWORD,
    pub e32_devid: WORD,
    pub e32_ddkver: WORD,
}
pub type IMAGE_VXD_HEADER = _IMAGE_VXD_HEADER;
pub type PIMAGE_VXD_HEADER = *mut _IMAGE_VXD_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
    pub Machine: WORD,
    pub NumberOfSections: WORD,
    pub TimeDateStamp: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
    pub SizeOfOptionalHeader: WORD,
    pub Characteristics: WORD,
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
pub type PIMAGE_FILE_HEADER = *mut _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
    pub VirtualAddress: DWORD,
    pub Size: DWORD,
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
pub type PIMAGE_DATA_DIRECTORY = *mut _IMAGE_DATA_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub ImageBase: DWORD,
    pub SectionAlignment: DWORD,
    pub FileAlignment: DWORD,
    pub MajorOperatingSystemVersion: WORD,
    pub MinorOperatingSystemVersion: WORD,
    pub MajorImageVersion: WORD,
    pub MinorImageVersion: WORD,
    pub MajorSubsystemVersion: WORD,
    pub MinorSubsystemVersion: WORD,
    pub Win32VersionValue: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfHeaders: DWORD,
    pub CheckSum: DWORD,
    pub Subsystem: WORD,
    pub DllCharacteristics: WORD,
    pub SizeOfStackReserve: DWORD,
    pub SizeOfStackCommit: DWORD,
    pub SizeOfHeapReserve: DWORD,
    pub SizeOfHeapCommit: DWORD,
    pub LoaderFlags: DWORD,
    pub NumberOfRvaAndSizes: DWORD,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
pub type IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER;
pub type PIMAGE_OPTIONAL_HEADER32 = *mut _IMAGE_OPTIONAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ROM_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub BaseOfBss: DWORD,
    pub GprMask: DWORD,
    pub CprMask: [DWORD; 4usize],
    pub GpValue: DWORD,
}
pub type IMAGE_ROM_OPTIONAL_HEADER = _IMAGE_ROM_OPTIONAL_HEADER;
pub type PIMAGE_ROM_OPTIONAL_HEADER = *mut _IMAGE_ROM_OPTIONAL_HEADER;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub ImageBase: ULONGLONG,
    pub SectionAlignment: DWORD,
    pub FileAlignment: DWORD,
    pub MajorOperatingSystemVersion: WORD,
    pub MinorOperatingSystemVersion: WORD,
    pub MajorImageVersion: WORD,
    pub MinorImageVersion: WORD,
    pub MajorSubsystemVersion: WORD,
    pub MinorSubsystemVersion: WORD,
    pub Win32VersionValue: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfHeaders: DWORD,
    pub CheckSum: DWORD,
    pub Subsystem: WORD,
    pub DllCharacteristics: WORD,
    pub SizeOfStackReserve: ULONGLONG,
    pub SizeOfStackCommit: ULONGLONG,
    pub SizeOfHeapReserve: ULONGLONG,
    pub SizeOfHeapCommit: ULONGLONG,
    pub LoaderFlags: DWORD,
    pub NumberOfRvaAndSizes: DWORD,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER64 = *mut _IMAGE_OPTIONAL_HEADER64;
pub type IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER = PIMAGE_OPTIONAL_HEADER64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS64 {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER64,
}
pub type IMAGE_NT_HEADERS64 = _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER32,
}
pub type IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS;
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ROM_HEADERS {
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
}
pub type IMAGE_ROM_HEADERS = _IMAGE_ROM_HEADERS;
pub type PIMAGE_ROM_HEADERS = *mut _IMAGE_ROM_HEADERS;
pub type IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER_V2 {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
    pub Flags: DWORD,
    pub MetaDataSize: DWORD,
    pub MetaDataOffset: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER_BIGOBJ {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
    pub Flags: DWORD,
    pub MetaDataSize: DWORD,
    pub MetaDataOffset: DWORD,
    pub NumberOfSections: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
    pub Name: [BYTE; 8usize],
    pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
    pub VirtualAddress: DWORD,
    pub SizeOfRawData: DWORD,
    pub PointerToRawData: DWORD,
    pub PointerToRelocations: DWORD,
    pub PointerToLinenumbers: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub Characteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    pub PhysicalAddress: DWORD,
    pub VirtualSize: DWORD,
}
pub type IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER;
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_SYMBOL {
    pub N: _IMAGE_SYMBOL__bindgen_ty_1,
    pub Value: DWORD,
    pub SectionNumber: SHORT,
    pub Type: WORD,
    pub StorageClass: BYTE,
    pub NumberOfAuxSymbols: BYTE,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL__bindgen_ty_1 {
    pub ShortName: [BYTE; 8usize],
    pub Name: _IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1,
    pub LongName: [DWORD; 2usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
    pub Short: DWORD,
    pub Long: DWORD,
}
pub type IMAGE_SYMBOL = _IMAGE_SYMBOL;
pub type PIMAGE_SYMBOL = *mut IMAGE_SYMBOL;
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_SYMBOL_EX {
    pub N: _IMAGE_SYMBOL_EX__bindgen_ty_1,
    pub Value: DWORD,
    pub SectionNumber: LONG,
    pub Type: WORD,
    pub StorageClass: BYTE,
    pub NumberOfAuxSymbols: BYTE,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL_EX__bindgen_ty_1 {
    pub ShortName: [BYTE; 8usize],
    pub Name: _IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1,
    pub LongName: [DWORD; 2usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1 {
    pub Short: DWORD,
    pub Long: DWORD,
}
pub type IMAGE_SYMBOL_EX = _IMAGE_SYMBOL_EX;
pub type PIMAGE_SYMBOL_EX = *mut IMAGE_SYMBOL_EX;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    pub bAuxType: BYTE,
    pub bReserved: BYTE,
    pub SymbolTableIndex: DWORD,
    pub rgbReserved: [BYTE; 12usize],
}
pub type PIMAGE_AUX_SYMBOL_TOKEN_DEF = *mut IMAGE_AUX_SYMBOL_TOKEN_DEF;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL {
    pub Sym: _IMAGE_AUX_SYMBOL__bindgen_ty_1,
    pub File: _IMAGE_AUX_SYMBOL__bindgen_ty_2,
    pub Section: _IMAGE_AUX_SYMBOL__bindgen_ty_3,
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub CRC: _IMAGE_AUX_SYMBOL__bindgen_ty_4,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1 {
    pub TagIndex: DWORD,
    pub Misc: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1,
    pub FcnAry: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2,
    pub TvIndex: WORD,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
    pub LnSz: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub TotalSize: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub Linenumber: WORD,
    pub Size: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {
    pub Function: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub Array: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub PointerToLinenumber: DWORD,
    pub PointerToNextFunction: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub Dimension: [WORD; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_2 {
    pub Name: [BYTE; 18usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_3 {
    pub Length: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub CheckSum: DWORD,
    pub Number: SHORT,
    pub Selection: BYTE,
    pub bReserved: BYTE,
    pub HighNumber: SHORT,
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_4 {
    pub crc: DWORD,
    pub rgbReserved: [BYTE; 14usize],
}
pub type IMAGE_AUX_SYMBOL = _IMAGE_AUX_SYMBOL;
pub type PIMAGE_AUX_SYMBOL = *mut IMAGE_AUX_SYMBOL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL_EX {
    pub Sym: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1,
    pub File: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2,
    pub Section: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3,
    pub __bindgen_anon_1: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4,
    pub CRC: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5,
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1 {
    pub WeakDefaultSymIndex: DWORD,
    pub WeakSearchType: DWORD,
    pub rgbReserved: [BYTE; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2 {
    pub Name: [BYTE; 20usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3 {
    pub Length: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub CheckSum: DWORD,
    pub Number: SHORT,
    pub Selection: BYTE,
    pub bReserved: BYTE,
    pub HighNumber: SHORT,
    pub rgbReserved: [BYTE; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4 {
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub rgbReserved: [BYTE; 2usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5 {
    pub crc: DWORD,
    pub rgbReserved: [BYTE; 16usize],
}
pub type IMAGE_AUX_SYMBOL_EX = _IMAGE_AUX_SYMBOL_EX;
pub type PIMAGE_AUX_SYMBOL_EX = *mut IMAGE_AUX_SYMBOL_EX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_RELOCATION {
    pub __bindgen_anon_1: _IMAGE_RELOCATION__bindgen_ty_1,
    pub SymbolTableIndex: DWORD,
    pub Type: WORD,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_RELOCATION__bindgen_ty_1 {
    pub VirtualAddress: DWORD,
    pub RelocCount: DWORD,
}
pub type IMAGE_RELOCATION = _IMAGE_RELOCATION;
pub type PIMAGE_RELOCATION = *mut IMAGE_RELOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_LINENUMBER {
    pub Type: _IMAGE_LINENUMBER__bindgen_ty_1,
    pub Linenumber: WORD,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_LINENUMBER__bindgen_ty_1 {
    pub SymbolTableIndex: DWORD,
    pub VirtualAddress: DWORD,
}
pub type IMAGE_LINENUMBER = _IMAGE_LINENUMBER;
pub type PIMAGE_LINENUMBER = *mut IMAGE_LINENUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BASE_RELOCATION {
    pub VirtualAddress: DWORD,
    pub SizeOfBlock: DWORD,
}
pub type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
pub type PIMAGE_BASE_RELOCATION = *mut IMAGE_BASE_RELOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    pub Name: [BYTE; 16usize],
    pub Date: [BYTE; 12usize],
    pub UserID: [BYTE; 6usize],
    pub GroupID: [BYTE; 6usize],
    pub Mode: [BYTE; 8usize],
    pub Size: [BYTE; 10usize],
    pub EndHeader: [BYTE; 2usize],
}
pub type IMAGE_ARCHIVE_MEMBER_HEADER = _IMAGE_ARCHIVE_MEMBER_HEADER;
pub type PIMAGE_ARCHIVE_MEMBER_HEADER = *mut _IMAGE_ARCHIVE_MEMBER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_EXPORT_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Name: DWORD,
    pub Base: DWORD,
    pub NumberOfFunctions: DWORD,
    pub NumberOfNames: DWORD,
    pub AddressOfFunctions: DWORD,
    pub AddressOfNames: DWORD,
    pub AddressOfNameOrdinals: DWORD,
}
pub type IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY;
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_IMPORT_BY_NAME {
    pub Hint: WORD,
    pub Name: [CHAR; 1usize],
}
pub type IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME;
pub type PIMAGE_IMPORT_BY_NAME = *mut _IMAGE_IMPORT_BY_NAME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA64 {
    pub u1: _IMAGE_THUNK_DATA64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA64__bindgen_ty_1 {
    pub ForwarderString: ULONGLONG,
    pub Function: ULONGLONG,
    pub Ordinal: ULONGLONG,
    pub AddressOfData: ULONGLONG,
}
pub type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA32 {
    pub u1: _IMAGE_THUNK_DATA32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA32__bindgen_ty_1 {
    pub ForwarderString: DWORD,
    pub Function: DWORD,
    pub Ordinal: DWORD,
    pub AddressOfData: DWORD,
}
pub type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
pub type PIMAGE_THUNK_DATA32 = *mut IMAGE_THUNK_DATA32;
pub type PIMAGE_TLS_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(DllHandle: PVOID, Reason: DWORD, Reserved: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY64__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn Alignment(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Alignment(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: DWORD,
        Alignment: DWORD,
        Reserved1: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let Alignment: u32 = unsafe { ::std::mem::transmute(Alignment) };
            Alignment as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32 {
    pub StartAddressOfRawData: DWORD,
    pub EndAddressOfRawData: DWORD,
    pub AddressOfIndex: DWORD,
    pub AddressOfCallBacks: DWORD,
    pub SizeOfZeroFill: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn Alignment(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Alignment(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: DWORD,
        Alignment: DWORD,
        Reserved1: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let Alignment: u32 = unsafe { ::std::mem::transmute(Alignment) };
            Alignment as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32;
pub type PIMAGE_TLS_DIRECTORY32 = *mut IMAGE_TLS_DIRECTORY32;
pub type IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_IMPORT_DESCRIPTOR {
    pub __bindgen_anon_1: _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1,
    pub TimeDateStamp: DWORD,
    pub ForwarderChain: DWORD,
    pub Name: DWORD,
    pub FirstThunk: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub OriginalFirstThunk: DWORD,
}
pub type IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR;
pub type PIMAGE_IMPORT_DESCRIPTOR = *mut IMAGE_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    pub TimeDateStamp: DWORD,
    pub OffsetModuleName: WORD,
    pub NumberOfModuleForwarderRefs: WORD,
}
pub type IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub type PIMAGE_BOUND_IMPORT_DESCRIPTOR = *mut _IMAGE_BOUND_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BOUND_FORWARDER_REF {
    pub TimeDateStamp: DWORD,
    pub OffsetModuleName: WORD,
    pub Reserved: WORD,
}
pub type IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF;
pub type PIMAGE_BOUND_FORWARDER_REF = *mut _IMAGE_BOUND_FORWARDER_REF;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    pub Attributes: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1,
    pub DllNameRVA: DWORD,
    pub ModuleHandleRVA: DWORD,
    pub ImportAddressTableRVA: DWORD,
    pub ImportNameTableRVA: DWORD,
    pub BoundImportAddressTableRVA: DWORD,
    pub UnloadInformationTableRVA: DWORD,
    pub TimeDateStamp: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
    pub AllAttributes: DWORD,
    pub __bindgen_anon_1: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RvaBased(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RvaBased(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedAttributes(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedAttributes(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RvaBased: DWORD,
        ReservedAttributes: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RvaBased: u32 = unsafe { ::std::mem::transmute(RvaBased) };
            RvaBased as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedAttributes: u32 = unsafe { ::std::mem::transmute(ReservedAttributes) };
            ReservedAttributes as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PIMAGE_DELAYLOAD_DESCRIPTOR = *mut _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PCIMAGE_DELAYLOAD_DESCRIPTOR = *const IMAGE_DELAYLOAD_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub NumberOfNamedEntries: WORD,
    pub NumberOfIdEntries: WORD,
}
pub type IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY;
pub type PIMAGE_RESOURCE_DIRECTORY = *mut _IMAGE_RESOURCE_DIRECTORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Name: DWORD,
    pub Id: WORD,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NameOffset(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_NameOffset(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn NameIsString(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NameIsString(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NameOffset: DWORD,
        NameIsString: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let NameOffset: u32 = unsafe { ::std::mem::transmute(NameOffset) };
            NameOffset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NameIsString: u32 = unsafe { ::std::mem::transmute(NameIsString) };
            NameIsString as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {
    pub OffsetToData: DWORD,
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn OffsetToDirectory(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_OffsetToDirectory(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn DataIsDirectory(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataIsDirectory(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OffsetToDirectory: DWORD,
        DataIsDirectory: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let OffsetToDirectory: u32 = unsafe { ::std::mem::transmute(OffsetToDirectory) };
            OffsetToDirectory as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DataIsDirectory: u32 = unsafe { ::std::mem::transmute(DataIsDirectory) };
            DataIsDirectory as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub type PIMAGE_RESOURCE_DIRECTORY_ENTRY = *mut _IMAGE_RESOURCE_DIRECTORY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    pub Length: WORD,
    pub NameString: [CHAR; 1usize],
}
pub type IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING;
pub type PIMAGE_RESOURCE_DIRECTORY_STRING = *mut _IMAGE_RESOURCE_DIRECTORY_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIR_STRING_U {
    pub Length: WORD,
    pub NameString: [WCHAR; 1usize],
}
pub type IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U;
pub type PIMAGE_RESOURCE_DIR_STRING_U = *mut _IMAGE_RESOURCE_DIR_STRING_U;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DATA_ENTRY {
    pub OffsetToData: DWORD,
    pub Size: DWORD,
    pub CodePage: DWORD,
    pub Reserved: DWORD,
}
pub type IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY;
pub type PIMAGE_RESOURCE_DATA_ENTRY = *mut _IMAGE_RESOURCE_DATA_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    pub Flags: WORD,
    pub Catalog: WORD,
    pub CatalogOffset: DWORD,
    pub Reserved: DWORD,
}
pub type IMAGE_LOAD_CONFIG_CODE_INTEGRITY = _IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
pub type PIMAGE_LOAD_CONFIG_CODE_INTEGRITY = *mut _IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
    pub Version: DWORD,
    pub Size: DWORD,
}
pub type IMAGE_DYNAMIC_RELOCATION_TABLE = _IMAGE_DYNAMIC_RELOCATION_TABLE;
pub type PIMAGE_DYNAMIC_RELOCATION_TABLE = *mut _IMAGE_DYNAMIC_RELOCATION_TABLE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION32 {
    pub Symbol: DWORD,
    pub BaseRelocSize: DWORD,
}
pub type IMAGE_DYNAMIC_RELOCATION32 = _IMAGE_DYNAMIC_RELOCATION32;
pub type PIMAGE_DYNAMIC_RELOCATION32 = *mut _IMAGE_DYNAMIC_RELOCATION32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION64 {
    pub Symbol: ULONGLONG,
    pub BaseRelocSize: DWORD,
}
pub type IMAGE_DYNAMIC_RELOCATION64 = _IMAGE_DYNAMIC_RELOCATION64;
pub type PIMAGE_DYNAMIC_RELOCATION64 = *mut _IMAGE_DYNAMIC_RELOCATION64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
    pub HeaderSize: DWORD,
    pub FixupInfoSize: DWORD,
    pub Symbol: DWORD,
    pub SymbolGroup: DWORD,
    pub Flags: DWORD,
}
pub type IMAGE_DYNAMIC_RELOCATION32_V2 = _IMAGE_DYNAMIC_RELOCATION32_V2;
pub type PIMAGE_DYNAMIC_RELOCATION32_V2 = *mut _IMAGE_DYNAMIC_RELOCATION32_V2;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
    pub HeaderSize: DWORD,
    pub FixupInfoSize: DWORD,
    pub Symbol: ULONGLONG,
    pub SymbolGroup: DWORD,
    pub Flags: DWORD,
}
pub type IMAGE_DYNAMIC_RELOCATION64_V2 = _IMAGE_DYNAMIC_RELOCATION64_V2;
pub type PIMAGE_DYNAMIC_RELOCATION64_V2 = *mut _IMAGE_DYNAMIC_RELOCATION64_V2;
pub type IMAGE_DYNAMIC_RELOCATION = IMAGE_DYNAMIC_RELOCATION64;
pub type PIMAGE_DYNAMIC_RELOCATION = PIMAGE_DYNAMIC_RELOCATION64;
pub type IMAGE_DYNAMIC_RELOCATION_V2 = IMAGE_DYNAMIC_RELOCATION64_V2;
pub type PIMAGE_DYNAMIC_RELOCATION_V2 = PIMAGE_DYNAMIC_RELOCATION64_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    pub PrologueByteCount: BYTE,
}
pub type IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
pub type PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = *mut IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    pub EpilogueCount: DWORD,
    pub EpilogueByteCount: BYTE,
    pub BranchDescriptorElementSize: BYTE,
    pub BranchDescriptorCount: WORD,
}
pub type IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
pub type PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = *mut IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    #[inline]
    pub fn PageRelativeOffset(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_PageRelativeOffset(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn IndirectCall(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IndirectCall(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IATIndex(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_IATIndex(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageRelativeOffset: DWORD,
        IndirectCall: DWORD,
        IATIndex: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageRelativeOffset: u32 = unsafe { ::std::mem::transmute(PageRelativeOffset) };
            PageRelativeOffset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let IndirectCall: u32 = unsafe { ::std::mem::transmute(IndirectCall) };
            IndirectCall as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let IATIndex: u32 = unsafe { ::std::mem::transmute(IATIndex) };
            IATIndex as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub type PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    *mut IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    #[inline]
    pub fn PageRelativeOffset(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_PageRelativeOffset(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn IndirectCall(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IndirectCall(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RexWPrefix(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RexWPrefix(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CfgCheck(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CfgCheck(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageRelativeOffset: WORD,
        IndirectCall: WORD,
        RexWPrefix: WORD,
        CfgCheck: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageRelativeOffset: u16 = unsafe { ::std::mem::transmute(PageRelativeOffset) };
            PageRelativeOffset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let IndirectCall: u16 = unsafe { ::std::mem::transmute(IndirectCall) };
            IndirectCall as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let RexWPrefix: u16 = unsafe { ::std::mem::transmute(RexWPrefix) };
            RexWPrefix as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CfgCheck: u16 = unsafe { ::std::mem::transmute(CfgCheck) };
            CfgCheck as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub type PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    *mut IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    #[inline]
    pub fn PageRelativeOffset(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_PageRelativeOffset(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn RegisterNumber(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_RegisterNumber(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageRelativeOffset: WORD,
        RegisterNumber: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageRelativeOffset: u16 = unsafe { ::std::mem::transmute(PageRelativeOffset) };
            PageRelativeOffset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let RegisterNumber: u16 = unsafe { ::std::mem::transmute(RegisterNumber) };
            RegisterNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
pub type PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION =
    *mut IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FUNCTION_OVERRIDE_HEADER {
    pub FuncOverrideSize: DWORD,
}
pub type IMAGE_FUNCTION_OVERRIDE_HEADER = _IMAGE_FUNCTION_OVERRIDE_HEADER;
pub type PIMAGE_FUNCTION_OVERRIDE_HEADER = *mut IMAGE_FUNCTION_OVERRIDE_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION {
    pub OriginalRva: DWORD,
    pub BDDOffset: DWORD,
    pub RvaSize: DWORD,
    pub BaseRelocSize: DWORD,
}
pub type IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION = _IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION;
pub type PIMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION =
    *mut IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BDD_INFO {
    pub Version: DWORD,
    pub BDDSize: DWORD,
}
pub type IMAGE_BDD_INFO = _IMAGE_BDD_INFO;
pub type PIMAGE_BDD_INFO = *mut IMAGE_BDD_INFO;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BDD_DYNAMIC_RELOCATION {
    pub Left: WORD,
    pub Right: WORD,
    pub Value: DWORD,
}
pub type IMAGE_BDD_DYNAMIC_RELOCATION = _IMAGE_BDD_DYNAMIC_RELOCATION;
pub type PIMAGE_BDD_DYNAMIC_RELOCATION = *mut IMAGE_BDD_DYNAMIC_RELOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    pub Size: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub GlobalFlagsClear: DWORD,
    pub GlobalFlagsSet: DWORD,
    pub CriticalSectionDefaultTimeout: DWORD,
    pub DeCommitFreeBlockThreshold: DWORD,
    pub DeCommitTotalFreeThreshold: DWORD,
    pub LockPrefixTable: DWORD,
    pub MaximumAllocationSize: DWORD,
    pub VirtualMemoryThreshold: DWORD,
    pub ProcessHeapFlags: DWORD,
    pub ProcessAffinityMask: DWORD,
    pub CSDVersion: WORD,
    pub DependentLoadFlags: WORD,
    pub EditList: DWORD,
    pub SecurityCookie: DWORD,
    pub SEHandlerTable: DWORD,
    pub SEHandlerCount: DWORD,
    pub GuardCFCheckFunctionPointer: DWORD,
    pub GuardCFDispatchFunctionPointer: DWORD,
    pub GuardCFFunctionTable: DWORD,
    pub GuardCFFunctionCount: DWORD,
    pub GuardFlags: DWORD,
    pub CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    pub GuardAddressTakenIatEntryTable: DWORD,
    pub GuardAddressTakenIatEntryCount: DWORD,
    pub GuardLongJumpTargetTable: DWORD,
    pub GuardLongJumpTargetCount: DWORD,
    pub DynamicValueRelocTable: DWORD,
    pub CHPEMetadataPointer: DWORD,
    pub GuardRFFailureRoutine: DWORD,
    pub GuardRFFailureRoutineFunctionPointer: DWORD,
    pub DynamicValueRelocTableOffset: DWORD,
    pub DynamicValueRelocTableSection: WORD,
    pub Reserved2: WORD,
    pub GuardRFVerifyStackPointerFunctionPointer: DWORD,
    pub HotPatchTableOffset: DWORD,
    pub Reserved3: DWORD,
    pub EnclaveConfigurationPointer: DWORD,
    pub VolatileMetadataPointer: DWORD,
    pub GuardEHContinuationTable: DWORD,
    pub GuardEHContinuationCount: DWORD,
    pub GuardXFGCheckFunctionPointer: DWORD,
    pub GuardXFGDispatchFunctionPointer: DWORD,
    pub GuardXFGTableDispatchFunctionPointer: DWORD,
    pub CastGuardOsDeterminedFailureMode: DWORD,
    pub GuardMemcpyFunctionPointer: DWORD,
}
pub type IMAGE_LOAD_CONFIG_DIRECTORY32 = _IMAGE_LOAD_CONFIG_DIRECTORY32;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY32 = *mut _IMAGE_LOAD_CONFIG_DIRECTORY32;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    pub Size: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub GlobalFlagsClear: DWORD,
    pub GlobalFlagsSet: DWORD,
    pub CriticalSectionDefaultTimeout: DWORD,
    pub DeCommitFreeBlockThreshold: ULONGLONG,
    pub DeCommitTotalFreeThreshold: ULONGLONG,
    pub LockPrefixTable: ULONGLONG,
    pub MaximumAllocationSize: ULONGLONG,
    pub VirtualMemoryThreshold: ULONGLONG,
    pub ProcessAffinityMask: ULONGLONG,
    pub ProcessHeapFlags: DWORD,
    pub CSDVersion: WORD,
    pub DependentLoadFlags: WORD,
    pub EditList: ULONGLONG,
    pub SecurityCookie: ULONGLONG,
    pub SEHandlerTable: ULONGLONG,
    pub SEHandlerCount: ULONGLONG,
    pub GuardCFCheckFunctionPointer: ULONGLONG,
    pub GuardCFDispatchFunctionPointer: ULONGLONG,
    pub GuardCFFunctionTable: ULONGLONG,
    pub GuardCFFunctionCount: ULONGLONG,
    pub GuardFlags: DWORD,
    pub CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    pub GuardAddressTakenIatEntryTable: ULONGLONG,
    pub GuardAddressTakenIatEntryCount: ULONGLONG,
    pub GuardLongJumpTargetTable: ULONGLONG,
    pub GuardLongJumpTargetCount: ULONGLONG,
    pub DynamicValueRelocTable: ULONGLONG,
    pub CHPEMetadataPointer: ULONGLONG,
    pub GuardRFFailureRoutine: ULONGLONG,
    pub GuardRFFailureRoutineFunctionPointer: ULONGLONG,
    pub DynamicValueRelocTableOffset: DWORD,
    pub DynamicValueRelocTableSection: WORD,
    pub Reserved2: WORD,
    pub GuardRFVerifyStackPointerFunctionPointer: ULONGLONG,
    pub HotPatchTableOffset: DWORD,
    pub Reserved3: DWORD,
    pub EnclaveConfigurationPointer: ULONGLONG,
    pub VolatileMetadataPointer: ULONGLONG,
    pub GuardEHContinuationTable: ULONGLONG,
    pub GuardEHContinuationCount: ULONGLONG,
    pub GuardXFGCheckFunctionPointer: ULONGLONG,
    pub GuardXFGDispatchFunctionPointer: ULONGLONG,
    pub GuardXFGTableDispatchFunctionPointer: ULONGLONG,
    pub CastGuardOsDeterminedFailureMode: ULONGLONG,
    pub GuardMemcpyFunctionPointer: ULONGLONG,
}
pub type IMAGE_LOAD_CONFIG_DIRECTORY64 = _IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY64 = *mut _IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_HOT_PATCH_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SequenceNumber: DWORD,
    pub BaseImageList: DWORD,
    pub BaseImageCount: DWORD,
    pub BufferOffset: DWORD,
    pub ExtraPatchSize: DWORD,
}
pub type IMAGE_HOT_PATCH_INFO = _IMAGE_HOT_PATCH_INFO;
pub type PIMAGE_HOT_PATCH_INFO = *mut _IMAGE_HOT_PATCH_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_HOT_PATCH_BASE {
    pub SequenceNumber: DWORD,
    pub Flags: DWORD,
    pub OriginalTimeDateStamp: DWORD,
    pub OriginalCheckSum: DWORD,
    pub CodeIntegrityInfo: DWORD,
    pub CodeIntegritySize: DWORD,
    pub PatchTable: DWORD,
    pub BufferOffset: DWORD,
}
pub type IMAGE_HOT_PATCH_BASE = _IMAGE_HOT_PATCH_BASE;
pub type PIMAGE_HOT_PATCH_BASE = *mut _IMAGE_HOT_PATCH_BASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_HOT_PATCH_HASHES {
    pub SHA256: [BYTE; 32usize],
    pub SHA1: [BYTE; 20usize],
}
pub type IMAGE_HOT_PATCH_HASHES = _IMAGE_HOT_PATCH_HASHES;
pub type PIMAGE_HOT_PATCH_HASHES = *mut _IMAGE_HOT_PATCH_HASHES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    pub FuncStart: DWORD,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    #[inline]
    pub fn PrologLen(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PrologLen(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FuncLen(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_FuncLen(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn ThirtyTwoBit(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThirtyTwoBit(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionFlag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionFlag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PrologLen: DWORD,
        FuncLen: DWORD,
        ThirtyTwoBit: DWORD,
        ExceptionFlag: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PrologLen: u32 = unsafe { ::std::mem::transmute(PrologLen) };
            PrologLen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 22u8, {
            let FuncLen: u32 = unsafe { ::std::mem::transmute(FuncLen) };
            FuncLen as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ThirtyTwoBit: u32 = unsafe { ::std::mem::transmute(ThirtyTwoBit) };
            ThirtyTwoBit as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ExceptionFlag: u32 = unsafe { ::std::mem::transmute(ExceptionFlag) };
            ExceptionFlag as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_CE_RUNTIME_FUNCTION_ENTRY = _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindData: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Flag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Flag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn Ret(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Ret(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn H(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_H(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reg(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reg(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn R(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_R(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn L(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_L(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackAdjust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_StackAdjust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flag: DWORD,
        FunctionLength: DWORD,
        Ret: DWORD,
        H: DWORD,
        Reg: DWORD,
        R: DWORD,
        L: DWORD,
        C: DWORD,
        StackAdjust: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Flag: u32 = unsafe { ::std::mem::transmute(Flag) };
            Flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Ret: u32 = unsafe { ::std::mem::transmute(Ret) };
            Ret as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let H: u32 = unsafe { ::std::mem::transmute(H) };
            H as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let Reg: u32 = unsafe { ::std::mem::transmute(Reg) };
            Reg as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let R: u32 = unsafe { ::std::mem::transmute(R) };
            R as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let L: u32 = unsafe { ::std::mem::transmute(L) };
            L as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let C: u32 = unsafe { ::std::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let StackAdjust: u32 = unsafe { ::std::mem::transmute(StackAdjust) };
            StackAdjust as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ARM64_FNPDATA_FLAGS {
    PdataRefToFullXdata = 0,
    PdataPackedUnwindFunction = 1,
    PdataPackedUnwindFragment = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ARM64_FNPDATA_CR {
    PdataCrUnchained = 0,
    PdataCrUnchainedSavedLr = 1,
    PdataCrChainedWithPac = 2,
    PdataCrChained = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindData: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Flag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Flag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn RegF(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RegF(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RegI(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RegI(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn H(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_H(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CR(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CR(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FrameSize(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FrameSize(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flag: DWORD,
        FunctionLength: DWORD,
        RegF: DWORD,
        RegI: DWORD,
        H: DWORD,
        CR: DWORD,
        FrameSize: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Flag: u32 = unsafe { ::std::mem::transmute(Flag) };
            Flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let RegF: u32 = unsafe { ::std::mem::transmute(RegF) };
            RegF as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let RegI: u32 = unsafe { ::std::mem::transmute(RegI) };
            RegI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let H: u32 = unsafe { ::std::mem::transmute(H) };
            H as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let CR: u32 = unsafe { ::std::mem::transmute(CR) };
            CR as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let FrameSize: u32 = unsafe { ::std::mem::transmute(FrameSize) };
            FrameSize as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    pub HeaderData: DWORD,
    pub __bindgen_anon_1: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1 {
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn Version(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionDataPresent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionDataPresent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EpilogInHeader(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EpilogInHeader(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EpilogCount(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_EpilogCount(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CodeWords(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_CodeWords(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLength: DWORD,
        Version: DWORD,
        ExceptionDataPresent: DWORD,
        EpilogInHeader: DWORD,
        EpilogCount: DWORD,
        CodeWords: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let Version: u32 = unsafe { ::std::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ExceptionDataPresent: u32 = unsafe { ::std::mem::transmute(ExceptionDataPresent) };
            ExceptionDataPresent as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EpilogInHeader: u32 = unsafe { ::std::mem::transmute(EpilogInHeader) };
            EpilogInHeader as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let EpilogCount: u32 = unsafe { ::std::mem::transmute(EpilogCount) };
            EpilogCount as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let CodeWords: u32 = unsafe { ::std::mem::transmute(CodeWords) };
            CodeWords as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: ULONGLONG,
    pub EndAddress: ULONGLONG,
    pub ExceptionHandler: ULONGLONG,
    pub HandlerData: ULONGLONG,
    pub PrologEndAddress: ULONGLONG,
}
pub type IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub ExceptionHandler: DWORD,
    pub HandlerData: DWORD,
    pub PrologEndAddress: DWORD,
}
pub type IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindInfoAddress: DWORD,
    pub UnwindData: DWORD,
}
pub type _PIMAGE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_AMD64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_AMD64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ENCLAVE_CONFIG32 {
    pub Size: DWORD,
    pub MinimumRequiredConfigSize: DWORD,
    pub PolicyFlags: DWORD,
    pub NumberOfImports: DWORD,
    pub ImportList: DWORD,
    pub ImportEntrySize: DWORD,
    pub FamilyID: [BYTE; 16usize],
    pub ImageID: [BYTE; 16usize],
    pub ImageVersion: DWORD,
    pub SecurityVersion: DWORD,
    pub EnclaveSize: DWORD,
    pub NumberOfThreads: DWORD,
    pub EnclaveFlags: DWORD,
}
pub type IMAGE_ENCLAVE_CONFIG32 = _IMAGE_ENCLAVE_CONFIG32;
pub type PIMAGE_ENCLAVE_CONFIG32 = *mut _IMAGE_ENCLAVE_CONFIG32;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ENCLAVE_CONFIG64 {
    pub Size: DWORD,
    pub MinimumRequiredConfigSize: DWORD,
    pub PolicyFlags: DWORD,
    pub NumberOfImports: DWORD,
    pub ImportList: DWORD,
    pub ImportEntrySize: DWORD,
    pub FamilyID: [BYTE; 16usize],
    pub ImageID: [BYTE; 16usize],
    pub ImageVersion: DWORD,
    pub SecurityVersion: DWORD,
    pub EnclaveSize: ULONGLONG,
    pub NumberOfThreads: DWORD,
    pub EnclaveFlags: DWORD,
}
pub type IMAGE_ENCLAVE_CONFIG64 = _IMAGE_ENCLAVE_CONFIG64;
pub type PIMAGE_ENCLAVE_CONFIG64 = *mut _IMAGE_ENCLAVE_CONFIG64;
pub type IMAGE_ENCLAVE_CONFIG = IMAGE_ENCLAVE_CONFIG64;
pub type PIMAGE_ENCLAVE_CONFIG = PIMAGE_ENCLAVE_CONFIG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ENCLAVE_IMPORT {
    pub MatchType: DWORD,
    pub MinimumSecurityVersion: DWORD,
    pub UniqueOrAuthorID: [BYTE; 32usize],
    pub FamilyID: [BYTE; 16usize],
    pub ImageID: [BYTE; 16usize],
    pub ImportName: DWORD,
    pub Reserved: DWORD,
}
pub type IMAGE_ENCLAVE_IMPORT = _IMAGE_ENCLAVE_IMPORT;
pub type PIMAGE_ENCLAVE_IMPORT = *mut _IMAGE_ENCLAVE_IMPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DEBUG_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Type: DWORD,
    pub SizeOfData: DWORD,
    pub AddressOfRawData: DWORD,
    pub PointerToRawData: DWORD,
}
pub type IMAGE_DEBUG_DIRECTORY = _IMAGE_DEBUG_DIRECTORY;
pub type PIMAGE_DEBUG_DIRECTORY = *mut _IMAGE_DEBUG_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_COFF_SYMBOLS_HEADER {
    pub NumberOfSymbols: DWORD,
    pub LvaToFirstSymbol: DWORD,
    pub NumberOfLinenumbers: DWORD,
    pub LvaToFirstLinenumber: DWORD,
    pub RvaToFirstByteOfCode: DWORD,
    pub RvaToLastByteOfCode: DWORD,
    pub RvaToFirstByteOfData: DWORD,
    pub RvaToLastByteOfData: DWORD,
}
pub type IMAGE_COFF_SYMBOLS_HEADER = _IMAGE_COFF_SYMBOLS_HEADER;
pub type PIMAGE_COFF_SYMBOLS_HEADER = *mut _IMAGE_COFF_SYMBOLS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPO_DATA {
    pub ulOffStart: DWORD,
    pub cbProcSize: DWORD,
    pub cdwLocals: DWORD,
    pub cdwParams: WORD,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _FPO_DATA {
    #[inline]
    pub fn cbProlog(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_cbProlog(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cbRegs(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_cbRegs(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasSEH(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fHasSEH(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUseBP(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fUseBP(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbFrame(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cbFrame(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cbProlog: WORD,
        cbRegs: WORD,
        fHasSEH: WORD,
        fUseBP: WORD,
        reserved: WORD,
        cbFrame: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cbProlog: u16 = unsafe { ::std::mem::transmute(cbProlog) };
            cbProlog as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let cbRegs: u16 = unsafe { ::std::mem::transmute(cbRegs) };
            cbRegs as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fHasSEH: u16 = unsafe { ::std::mem::transmute(fHasSEH) };
            fHasSEH as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fUseBP: u16 = unsafe { ::std::mem::transmute(fUseBP) };
            fUseBP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let cbFrame: u16 = unsafe { ::std::mem::transmute(cbFrame) };
            cbFrame as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FPO_DATA = _FPO_DATA;
pub type PFPO_DATA = *mut _FPO_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DEBUG_MISC {
    pub DataType: DWORD,
    pub Length: DWORD,
    pub Unicode: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
    pub Data: [BYTE; 1usize],
}
pub type IMAGE_DEBUG_MISC = _IMAGE_DEBUG_MISC;
pub type PIMAGE_DEBUG_MISC = *mut _IMAGE_DEBUG_MISC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FUNCTION_ENTRY {
    pub StartingAddress: DWORD,
    pub EndingAddress: DWORD,
    pub EndOfPrologue: DWORD,
}
pub type IMAGE_FUNCTION_ENTRY = _IMAGE_FUNCTION_ENTRY;
pub type PIMAGE_FUNCTION_ENTRY = *mut _IMAGE_FUNCTION_ENTRY;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _IMAGE_FUNCTION_ENTRY64 {
    pub StartingAddress: ULONGLONG,
    pub EndingAddress: ULONGLONG,
    pub __bindgen_anon_1: _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {
    pub EndOfPrologue: ULONGLONG,
    pub UnwindInfoAddress: ULONGLONG,
}
pub type IMAGE_FUNCTION_ENTRY64 = _IMAGE_FUNCTION_ENTRY64;
pub type PIMAGE_FUNCTION_ENTRY64 = *mut _IMAGE_FUNCTION_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SEPARATE_DEBUG_HEADER {
    pub Signature: WORD,
    pub Flags: WORD,
    pub Machine: WORD,
    pub Characteristics: WORD,
    pub TimeDateStamp: DWORD,
    pub CheckSum: DWORD,
    pub ImageBase: DWORD,
    pub SizeOfImage: DWORD,
    pub NumberOfSections: DWORD,
    pub ExportedNamesSize: DWORD,
    pub DebugDirectorySize: DWORD,
    pub SectionAlignment: DWORD,
    pub Reserved: [DWORD; 2usize],
}
pub type IMAGE_SEPARATE_DEBUG_HEADER = _IMAGE_SEPARATE_DEBUG_HEADER;
pub type PIMAGE_SEPARATE_DEBUG_HEADER = *mut _IMAGE_SEPARATE_DEBUG_HEADER;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NON_PAGED_DEBUG_INFO {
    pub Signature: WORD,
    pub Flags: WORD,
    pub Size: DWORD,
    pub Machine: WORD,
    pub Characteristics: WORD,
    pub TimeDateStamp: DWORD,
    pub CheckSum: DWORD,
    pub SizeOfImage: DWORD,
    pub ImageBase: ULONGLONG,
}
pub type NON_PAGED_DEBUG_INFO = _NON_PAGED_DEBUG_INFO;
pub type PNON_PAGED_DEBUG_INFO = *mut _NON_PAGED_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ImageArchitectureHeader {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub FirstEntryRVA: DWORD,
}
impl _ImageArchitectureHeader {
    #[inline]
    pub fn AmaskValue(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AmaskValue(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AmaskShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_AmaskShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AmaskValue: ::std::os::raw::c_uint,
        AmaskShift: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AmaskValue: u32 = unsafe { ::std::mem::transmute(AmaskValue) };
            AmaskValue as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let AmaskShift: u32 = unsafe { ::std::mem::transmute(AmaskShift) };
            AmaskShift as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_ARCHITECTURE_HEADER = _ImageArchitectureHeader;
pub type PIMAGE_ARCHITECTURE_HEADER = *mut _ImageArchitectureHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ImageArchitectureEntry {
    pub FixupInstRVA: DWORD,
    pub NewInst: DWORD,
}
pub type IMAGE_ARCHITECTURE_ENTRY = _ImageArchitectureEntry;
pub type PIMAGE_ARCHITECTURE_ENTRY = *mut _ImageArchitectureEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPORT_OBJECT_HEADER {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub SizeOfData: DWORD,
    pub __bindgen_anon_1: IMPORT_OBJECT_HEADER__bindgen_ty_1,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPORT_OBJECT_HEADER__bindgen_ty_1 {
    pub Ordinal: WORD,
    pub Hint: WORD,
}
impl IMPORT_OBJECT_HEADER {
    #[inline]
    pub fn Type(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NameType(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_NameType(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: WORD,
        NameType: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Type: u16 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let NameType: u16 = unsafe { ::std::mem::transmute(NameType) };
            NameType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPORT_OBJECT_TYPE {
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPORT_OBJECT_NAME_TYPE {
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,
    IMPORT_OBJECT_NAME_EXPORTAS = 4,
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VERSION_MAJOR_V2: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VERSION_MAJOR: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_DELETED_NAME_LENGTH: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLEGAP_NAME_LENGTH: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const NATIVE_TYPE_MAX_CB: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_METHODRVA: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_EHRVA: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const IMAGE_COR_MIH_BASICBLOCK: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_32BIT: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_ILONLY;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_64BIT: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_32BITREQUIRED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_FROM_UNMANAGED: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_IL_LIBRARY;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_STRONGNAMESIGNED;
}
impl ReplacesCorHdrNumericDefines {
    pub const COR_VTABLE_CALL_MOST_DERIVED: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
}
impl ReplacesCorHdrNumericDefines {
    pub const MAX_PACKAGE_NAME: ReplacesCorHdrNumericDefines =
        ReplacesCorHdrNumericDefines::MAX_CLASS_NAME;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ReplacesCorHdrNumericDefines {
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COMIMAGE_FLAGS_32BITPREFERRED = 131072,
    COR_VERSION_MINOR = 5,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMAGE_COR20_HEADER {
    pub cb: DWORD,
    pub MajorRuntimeVersion: WORD,
    pub MinorRuntimeVersion: WORD,
    pub MetaData: IMAGE_DATA_DIRECTORY,
    pub Flags: DWORD,
    pub __bindgen_anon_1: IMAGE_COR20_HEADER__bindgen_ty_1,
    pub Resources: IMAGE_DATA_DIRECTORY,
    pub StrongNameSignature: IMAGE_DATA_DIRECTORY,
    pub CodeManagerTable: IMAGE_DATA_DIRECTORY,
    pub VTableFixups: IMAGE_DATA_DIRECTORY,
    pub ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    pub ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMAGE_COR20_HEADER__bindgen_ty_1 {
    pub EntryPointToken: DWORD,
    pub EntryPointRVA: DWORD,
}
pub type PIMAGE_COR20_HEADER = *mut IMAGE_COR20_HEADER;
extern "C" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: DWORD,
        FramesToCapture: DWORD,
        BackTrace: *mut PVOID,
        BackTraceHash: PDWORD,
    ) -> WORD;
}
extern "C" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "C" {
    pub fn RtlCaptureContext2(ContextRecord: PCONTEXT);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNWIND_HISTORY_TABLE_ENTRY {
    pub ImageBase: ULONG_PTR,
    pub FunctionEntry: PRUNTIME_FUNCTION,
}
pub type UNWIND_HISTORY_TABLE_ENTRY = _UNWIND_HISTORY_TABLE_ENTRY;
pub type PUNWIND_HISTORY_TABLE_ENTRY = *mut _UNWIND_HISTORY_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNWIND_HISTORY_TABLE {
    pub Count: DWORD,
    pub LocalHint: BYTE,
    pub GlobalHint: BYTE,
    pub Search: BYTE,
    pub Once: BYTE,
    pub LowAddress: ULONG_PTR,
    pub HighAddress: ULONG_PTR,
    pub Entry: [UNWIND_HISTORY_TABLE_ENTRY; 12usize],
}
pub type UNWIND_HISTORY_TABLE = _UNWIND_HISTORY_TABLE;
pub type PUNWIND_HISTORY_TABLE = *mut _UNWIND_HISTORY_TABLE;
extern "C" {
    pub fn RtlUnwind(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
    );
}
extern "C" {
    pub fn RtlAddFunctionTable(
        FunctionTable: PRUNTIME_FUNCTION,
        EntryCount: DWORD,
        BaseAddress: DWORD64,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlDeleteFunctionTable(FunctionTable: PRUNTIME_FUNCTION) -> BOOLEAN;
}
extern "C" {
    pub fn RtlInstallFunctionTableCallback(
        TableIdentifier: DWORD64,
        BaseAddress: DWORD64,
        Length: DWORD,
        Callback: PGET_RUNTIME_FUNCTION_CALLBACK,
        Context: PVOID,
        OutOfProcessCallbackDll: PCWSTR,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlAddGrowableFunctionTable(
        DynamicTable: *mut PVOID,
        FunctionTable: PRUNTIME_FUNCTION,
        EntryCount: DWORD,
        MaximumEntryCount: DWORD,
        RangeBase: ULONG_PTR,
        RangeEnd: ULONG_PTR,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlGrowFunctionTable(DynamicTable: PVOID, NewEntryCount: DWORD);
}
extern "C" {
    pub fn RtlDeleteGrowableFunctionTable(DynamicTable: PVOID);
}
extern "C" {
    pub fn RtlLookupFunctionEntry(
        ControlPc: DWORD64,
        ImageBase: PDWORD64,
        HistoryTable: PUNWIND_HISTORY_TABLE,
    ) -> PRUNTIME_FUNCTION;
}
extern "C" {
    pub fn RtlRestoreContext(ContextRecord: PCONTEXT, ExceptionRecord: *mut _EXCEPTION_RECORD);
}
extern "C" {
    pub fn RtlUnwindEx(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
        ContextRecord: PCONTEXT,
        HistoryTable: PUNWIND_HISTORY_TABLE,
    );
}
extern "C" {
    pub fn RtlVirtualUnwind(
        HandlerType: DWORD,
        ImageBase: DWORD64,
        ControlPc: DWORD64,
        FunctionEntry: PRUNTIME_FUNCTION,
        ContextRecord: PCONTEXT,
        HandlerData: *mut PVOID,
        EstablisherFrame: PDWORD64,
        ContextPointers: PKNONVOLATILE_CONTEXT_POINTERS,
    ) -> PEXCEPTION_ROUTINE;
}
extern "C" {
    pub fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "C" {
    pub fn RtlPcToFileHeader(PcValue: PVOID, BaseOfImage: *mut PVOID) -> PVOID;
}
extern "C" {
    pub fn RtlCompareMemory(
        Source1: *const ::std::os::raw::c_void,
        Source2: *const ::std::os::raw::c_void,
        Length: SIZE_T,
    ) -> SIZE_T;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
    pub Next: *mut _SLIST_ENTRY,
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub Region: ULONGLONG,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl _SLIST_HEADER__bindgen_ty_2 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 4u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
extern "C" {
    pub fn RtlInitializeSListHead(ListHead: PSLIST_HEADER);
}
extern "C" {
    pub fn RtlFirstEntrySList(ListHead: *const SLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSLIST_ENTRY,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPushListSListEx(
        ListHead: PSLIST_HEADER,
        List: PSLIST_ENTRY,
        ListEnd: PSLIST_ENTRY,
        Count: DWORD,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlQueryDepthSList(ListHead: PSLIST_HEADER) -> WORD;
}
extern "C" {
    pub fn RtlGetReturnAddressHijackTarget() -> ULONG_PTR;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
    pub Ptr: PVOID,
}
pub type RTL_RUN_ONCE = _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BARRIER {
    pub Reserved1: DWORD,
    pub Reserved2: DWORD,
    pub Reserved3: [ULONG_PTR; 2usize],
    pub Reserved4: DWORD,
    pub Reserved5: DWORD,
}
pub type RTL_BARRIER = _RTL_BARRIER;
pub type PRTL_BARRIER = *mut _RTL_BARRIER;
extern "C" {
    pub fn __fastfail(Code: ::std::os::raw::c_uint) -> !;
}
extern "C" {
    pub fn HEAP_MAKE_TAG_FLAGS(TagBase: DWORD, Tag: DWORD) -> DWORD;
}
extern "C" {
    pub fn RtlConstantTimeEqualMemory(
        v1: *const ::std::os::raw::c_void,
        v2: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RtlSecureZeroMemory(ptr: PVOID, cnt: SIZE_T) -> PVOID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_ENTRY {
    pub Length: WORD,
    pub Flags: WORD,
    pub Text: [BYTE; 1usize],
}
pub type MESSAGE_RESOURCE_ENTRY = _MESSAGE_RESOURCE_ENTRY;
pub type PMESSAGE_RESOURCE_ENTRY = *mut _MESSAGE_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_BLOCK {
    pub LowId: DWORD,
    pub HighId: DWORD,
    pub OffsetToEntries: DWORD,
}
pub type MESSAGE_RESOURCE_BLOCK = _MESSAGE_RESOURCE_BLOCK;
pub type PMESSAGE_RESOURCE_BLOCK = *mut _MESSAGE_RESOURCE_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_DATA {
    pub NumberOfBlocks: DWORD,
    pub Blocks: [MESSAGE_RESOURCE_BLOCK; 1usize],
}
pub type MESSAGE_RESOURCE_DATA = _MESSAGE_RESOURCE_DATA;
pub type PMESSAGE_RESOURCE_DATA = *mut _MESSAGE_RESOURCE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOA {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [CHAR; 128usize],
}
pub type OSVERSIONINFOA = _OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOW {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [WCHAR; 128usize],
}
pub type OSVERSIONINFOW = _OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type OSVERSIONINFO = OSVERSIONINFOA;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXA {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [CHAR; 128usize],
    pub wServicePackMajor: WORD,
    pub wServicePackMinor: WORD,
    pub wSuiteMask: WORD,
    pub wProductType: BYTE,
    pub wReserved: BYTE,
}
pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [WCHAR; 128usize],
    pub wServicePackMajor: WORD,
    pub wServicePackMinor: WORD,
    pub wSuiteMask: WORD,
    pub wProductType: BYTE,
    pub wReserved: BYTE,
}
pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
extern "C" {
    pub fn VerSetConditionMask(
        ConditionMask: ULONGLONG,
        TypeMask: DWORD,
        Condition: BYTE,
    ) -> ULONGLONG;
}
extern "C" {
    pub fn RtlGetProductInfo(
        OSMajorVersion: DWORD,
        OSMinorVersion: DWORD,
        SpMajorVersion: DWORD,
        SpMinorVersion: DWORD,
        ReturnedProductType: PDWORD,
    ) -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext = 1,
    UmsThreadPriority = 2,
    UmsThreadAffinity = 3,
    UmsThreadTeb = 4,
    UmsThreadIsSuspended = 5,
    UmsThreadIsTerminated = 6,
    UmsThreadMaxInfoClass = 7,
}
pub use self::_RTL_UMS_THREAD_INFO_CLASS as RTL_UMS_THREAD_INFO_CLASS;
pub type PRTL_UMS_THREAD_INFO_CLASS = *mut _RTL_UMS_THREAD_INFO_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked = 1,
    UmsSchedulerThreadYield = 2,
}
pub use self::_RTL_UMS_SCHEDULER_REASON as RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_REASON = *mut _RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_ENTRY_POINT = ::std::option::Option<
    unsafe extern "C" fn(arg1: RTL_UMS_SCHEDULER_REASON, arg2: ULONG_PTR, arg3: PVOID),
>;
extern "C" {
    pub fn RtlCrc32(Buffer: *const ::std::os::raw::c_void, Size: usize, InitialCrc: DWORD)
        -> DWORD;
}
extern "C" {
    pub fn RtlCrc64(
        Buffer: *const ::std::os::raw::c_void,
        Size: usize,
        InitialCrc: ULONGLONG,
    ) -> ULONGLONG;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _OS_DEPLOYEMENT_STATE_VALUES {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT = 2,
}
pub use self::_OS_DEPLOYEMENT_STATE_VALUES as OS_DEPLOYEMENT_STATE_VALUES;
extern "C" {
    pub fn RtlOsDeploymentState(Flags: DWORD) -> OS_DEPLOYEMENT_STATE_VALUES;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MEMORY_RANGE {
    pub BaseAddress: *mut ::std::os::raw::c_void,
    pub Length: SIZE_T,
}
pub type NV_MEMORY_RANGE = _NV_MEMORY_RANGE;
pub type PNV_MEMORY_RANGE = *mut _NV_MEMORY_RANGE;
extern "C" {
    pub fn RtlGetNonVolatileToken(NvBuffer: PVOID, Size: SIZE_T, NvToken: *mut PVOID) -> DWORD;
}
extern "C" {
    pub fn RtlFreeNonVolatileToken(NvToken: PVOID) -> DWORD;
}
extern "C" {
    pub fn RtlFlushNonVolatileMemory(
        NvToken: PVOID,
        NvBuffer: PVOID,
        Size: SIZE_T,
        Flags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlDrainNonVolatileFlush(NvToken: PVOID) -> DWORD;
}
extern "C" {
    pub fn RtlWriteNonVolatileMemory(
        NvToken: PVOID,
        NvDestination: *mut ::std::os::raw::c_void,
        Source: *const ::std::os::raw::c_void,
        Size: SIZE_T,
        Flags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlFillNonVolatileMemory(
        NvToken: PVOID,
        NvDestination: *mut ::std::os::raw::c_void,
        Size: SIZE_T,
        Value: BYTE,
        Flags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlFlushNonVolatileMemoryRanges(
        NvToken: PVOID,
        NvRanges: PNV_MEMORY_RANGE,
        NumRanges: SIZE_T,
        Flags: DWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CORRELATION_VECTOR {
    pub Version: CHAR,
    pub Vector: [CHAR; 129usize],
}
pub type PCORRELATION_VECTOR = *mut CORRELATION_VECTOR;
extern "C" {
    pub fn RtlInitializeCorrelationVector(
        CorrelationVector: PCORRELATION_VECTOR,
        Version: ::std::os::raw::c_int,
        Guid: *const GUID,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlIncrementCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> DWORD;
}
extern "C" {
    pub fn RtlExtendCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> DWORD;
}
extern "C" {
    pub fn RtlValidateCorrelationVector(Vector: PCORRELATION_VECTOR) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    pub Size: DWORD,
    pub TriggerId: PCWSTR,
}
pub type CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
pub type PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = *mut _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
extern "C" {
    pub fn CUSTOM_SYSTEM_EVENT_TRIGGER_INIT(
        Config: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
        TriggerId: PCWSTR,
    );
}
extern "C" {
    pub fn RtlRaiseCustomSystemEventTrigger(
        TriggerConfig: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
    ) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool = 1,
    ImagePolicyEntryTypeInt8 = 2,
    ImagePolicyEntryTypeUInt8 = 3,
    ImagePolicyEntryTypeInt16 = 4,
    ImagePolicyEntryTypeUInt16 = 5,
    ImagePolicyEntryTypeInt32 = 6,
    ImagePolicyEntryTypeUInt32 = 7,
    ImagePolicyEntryTypeInt64 = 8,
    ImagePolicyEntryTypeUInt64 = 9,
    ImagePolicyEntryTypeAnsiString = 10,
    ImagePolicyEntryTypeUnicodeString = 11,
    ImagePolicyEntryTypeOverride = 12,
    ImagePolicyEntryTypeMaximum = 13,
}
pub use self::_IMAGE_POLICY_ENTRY_TYPE as IMAGE_POLICY_ENTRY_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw = 1,
    ImagePolicyIdDebug = 2,
    ImagePolicyIdCrashDump = 3,
    ImagePolicyIdCrashDumpKey = 4,
    ImagePolicyIdCrashDumpKeyGuid = 5,
    ImagePolicyIdParentSd = 6,
    ImagePolicyIdParentSdRev = 7,
    ImagePolicyIdSvn = 8,
    ImagePolicyIdDeviceId = 9,
    ImagePolicyIdCapability = 10,
    ImagePolicyIdScenarioId = 11,
    ImagePolicyIdMaximum = 12,
}
pub use self::_IMAGE_POLICY_ID as IMAGE_POLICY_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_POLICY_ENTRY {
    pub Type: IMAGE_POLICY_ENTRY_TYPE,
    pub PolicyId: IMAGE_POLICY_ID,
    pub u: _IMAGE_POLICY_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
    pub None: *const ::std::os::raw::c_void,
    pub BoolValue: BOOLEAN,
    pub Int8Value: INT8,
    pub UInt8Value: UINT8,
    pub Int16Value: INT16,
    pub UInt16Value: UINT16,
    pub Int32Value: INT32,
    pub UInt32Value: UINT32,
    pub Int64Value: INT64,
    pub UInt64Value: UINT64,
    pub AnsiStringValue: PCSTR,
    pub UnicodeStringValue: PCWSTR,
}
pub type IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY;
pub type PCIMAGE_POLICY_ENTRY = *const IMAGE_POLICY_ENTRY;
#[repr(C)]
pub struct _IMAGE_POLICY_METADATA {
    pub Version: BYTE,
    pub Reserved0: [BYTE; 7usize],
    pub ApplicationId: ULONGLONG,
    pub Policies: __IncompleteArrayField<IMAGE_POLICY_ENTRY>,
}
pub type IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA;
pub type PCIMAGE_POLICY_METADATA = *const IMAGE_POLICY_METADATA;
extern "C" {
    pub fn RtlIsZeroMemory(Buffer: PVOID, Length: SIZE_T) -> BOOLEAN;
}
extern "C" {
    pub fn RtlNormalizeSecurityDescriptor(
        SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        SecurityDescriptorLength: DWORD,
        NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        NewSecurityDescriptorLength: PDWORD,
        CheckOnly: BOOLEAN,
    ) -> BOOLEAN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RTL_SYSTEM_GLOBAL_DATA_ID {
    GlobalDataIdUnknown = 0,
    GlobalDataIdRngSeedVersion = 1,
    GlobalDataIdInterruptTime = 2,
    GlobalDataIdTimeZoneBias = 3,
    GlobalDataIdImageNumberLow = 4,
    GlobalDataIdImageNumberHigh = 5,
    GlobalDataIdTimeZoneId = 6,
    GlobalDataIdNtMajorVersion = 7,
    GlobalDataIdNtMinorVersion = 8,
    GlobalDataIdSystemExpirationDate = 9,
    GlobalDataIdKdDebuggerEnabled = 10,
    GlobalDataIdCyclesPerYield = 11,
    GlobalDataIdSafeBootMode = 12,
    GlobalDataIdLastSystemRITEventTickCount = 13,
    GlobalDataIdConsoleSharedDataFlags = 14,
    GlobalDataIdNtSystemRootDrive = 15,
    GlobalDataIdQpcShift = 16,
    GlobalDataIdQpcBypassEnabled = 17,
    GlobalDataIdQpcData = 18,
    GlobalDataIdQpcBias = 19,
}
pub use self::_RTL_SYSTEM_GLOBAL_DATA_ID as RTL_SYSTEM_GLOBAL_DATA_ID;
pub type PRTL_SYSTEM_GLOBAL_DATA_ID = *mut _RTL_SYSTEM_GLOBAL_DATA_ID;
extern "C" {
    pub fn RtlGetSystemGlobalData(
        DataId: RTL_SYSTEM_GLOBAL_DATA_ID,
        Buffer: PVOID,
        Size: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlSetSystemGlobalData(
        DataId: RTL_SYSTEM_GLOBAL_DATA_ID,
        Buffer: PVOID,
        Size: DWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    pub Type: WORD,
    pub CreatorBackTraceIndex: WORD,
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    pub ProcessLocksList: LIST_ENTRY,
    pub EntryCount: DWORD,
    pub ContentionCount: DWORD,
    pub Flags: DWORD,
    pub CreatorBackTraceIndexHigh: WORD,
    pub Identifier: WORD,
}
pub type RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
pub type RTL_RESOURCE_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_RESOURCE_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: HANDLE,
    pub LockSemaphore: HANDLE,
    pub SpinCount: ULONG_PTR,
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub Ptr: PVOID,
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
pub type PRTL_SRWLOCK = *mut _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CONDITION_VARIABLE {
    pub Ptr: PVOID,
}
pub type RTL_CONDITION_VARIABLE = _RTL_CONDITION_VARIABLE;
pub type PRTL_CONDITION_VARIABLE = *mut _RTL_CONDITION_VARIABLE;
pub type PAPCFUNC = ::std::option::Option<unsafe extern "C" fn(Parameter: ULONG_PTR)>;
pub type PVECTORED_EXCEPTION_HANDLER =
    ::std::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _HEAP_INFORMATION_CLASS {
    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1,
    HeapOptimizeResources = 3,
    HeapTag = 7,
}
pub use self::_HEAP_INFORMATION_CLASS as HEAP_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    pub Version: DWORD,
    pub Flags: DWORD,
}
pub type HEAP_OPTIMIZE_RESOURCES_INFORMATION = _HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub type PHEAP_OPTIMIZE_RESOURCES_INFORMATION = *mut _HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub type WAITORTIMERCALLBACKFUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: BOOLEAN)>;
pub type WORKERCALLBACKFUNC = ::std::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type APC_CALLBACK_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID, arg3: PVOID)>;
pub type WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
pub type PFLS_CALLBACK_FUNCTION = ::std::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
pub type PSECURE_MEMORY_CACHE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Addr: PVOID, Range: SIZE_T) -> BOOLEAN>;
impl _ACTIVATION_CONTEXT_INFO_CLASS {
    pub const AssemblyDetailedInformationInActivationContxt: _ACTIVATION_CONTEXT_INFO_CLASS =
        _ACTIVATION_CONTEXT_INFO_CLASS::AssemblyDetailedInformationInActivationContext;
}
impl _ACTIVATION_CONTEXT_INFO_CLASS {
    pub const FileInformationInAssemblyOfAssemblyInActivationContxt:
        _ACTIVATION_CONTEXT_INFO_CLASS =
        _ACTIVATION_CONTEXT_INFO_CLASS::FileInformationInAssemblyOfAssemblyInActivationContext;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass = 8,
}
pub use self::_ACTIVATION_CONTEXT_INFO_CLASS as ACTIVATION_CONTEXT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    pub ulAssemblyIndex: DWORD,
    pub ulFileIndexInAssembly: DWORD,
}
pub type ACTIVATION_CONTEXT_QUERY_INDEX = _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PACTIVATION_CONTEXT_QUERY_INDEX = *mut _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PCACTIVATION_CONTEXT_QUERY_INDEX = *const _ACTIVATION_CONTEXT_QUERY_INDEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    pub ulFlags: DWORD,
    pub ulFilenameLength: DWORD,
    pub ulPathLength: DWORD,
    pub lpFileName: PCWSTR,
    pub lpFilePath: PCWSTR,
}
pub type ASSEMBLY_FILE_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PASSEMBLY_FILE_DETAILED_INFORMATION = *mut _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PCASSEMBLY_FILE_DETAILED_INFORMATION = *const ASSEMBLY_FILE_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    pub ulFlags: DWORD,
    pub ulEncodedAssemblyIdentityLength: DWORD,
    pub ulManifestPathType: DWORD,
    pub ulManifestPathLength: DWORD,
    pub liManifestLastWriteTime: LARGE_INTEGER,
    pub ulPolicyPathType: DWORD,
    pub ulPolicyPathLength: DWORD,
    pub liPolicyLastWriteTime: LARGE_INTEGER,
    pub ulMetadataSatelliteRosterIndex: DWORD,
    pub ulManifestVersionMajor: DWORD,
    pub ulManifestVersionMinor: DWORD,
    pub ulPolicyVersionMajor: DWORD,
    pub ulPolicyVersionMinor: DWORD,
    pub ulAssemblyDirectoryNameLength: DWORD,
    pub lpAssemblyEncodedAssemblyIdentity: PCWSTR,
    pub lpAssemblyManifestPath: PCWSTR,
    pub lpAssemblyPolicyPath: PCWSTR,
    pub lpAssemblyDirectoryName: PCWSTR,
    pub ulFileCount: DWORD,
}
pub type ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    *mut _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    *const _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ACTCTX_REQUESTED_RUN_LEVEL {
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER = 1,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3,
    ACTCTX_RUN_LEVEL_NUMBERS = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    pub ulFlags: DWORD,
    pub RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    pub UiAccess: DWORD,
}
pub type ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = *mut _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION =
    *const _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE {
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPATIBILITY_CONTEXT_ELEMENT {
    pub Id: GUID,
    pub Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
    pub MaxVersionTested: ULONGLONG,
}
pub type COMPATIBILITY_CONTEXT_ELEMENT = _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCOMPATIBILITY_CONTEXT_ELEMENT = *mut _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCCOMPATIBILITY_CONTEXT_ELEMENT = *const _COMPATIBILITY_CONTEXT_ELEMENT;
#[repr(C)]
#[derive(Debug)]
pub struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    pub ElementCount: DWORD,
    pub Elements: __IncompleteArrayField<COMPATIBILITY_CONTEXT_ELEMENT>,
}
pub type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    *mut _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    *const _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPPORTED_OS_INFO {
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
}
pub type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO;
pub type PSUPPORTED_OS_INFO = *mut _SUPPORTED_OS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MAXVERSIONTESTED_INFO {
    pub MaxVersionTested: ULONGLONG,
}
pub type MAXVERSIONTESTED_INFO = _MAXVERSIONTESTED_INFO;
pub type PMAXVERSIONTESTED_INFO = *mut _MAXVERSIONTESTED_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    pub dwFlags: DWORD,
    pub ulFormatVersion: DWORD,
    pub ulAssemblyCount: DWORD,
    pub ulRootManifestPathType: DWORD,
    pub ulRootManifestPathChars: DWORD,
    pub ulRootConfigurationPathType: DWORD,
    pub ulRootConfigurationPathChars: DWORD,
    pub ulAppDirPathType: DWORD,
    pub ulAppDirPathChars: DWORD,
    pub lpRootManifestPath: PCWSTR,
    pub lpRootConfigurationPath: PCWSTR,
    pub lpAppDirPath: PCWSTR,
}
pub type ACTIVATION_CONTEXT_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_DETAILED_INFORMATION = *mut _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_DETAILED_INFORMATION =
    *const _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_COUNTER_DATA {
    pub Type: HARDWARE_COUNTER_TYPE,
    pub Reserved: DWORD,
    pub Value: DWORD64,
}
pub type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA;
pub type PHARDWARE_COUNTER_DATA = *mut _HARDWARE_COUNTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFORMANCE_DATA {
    pub Size: WORD,
    pub Version: BYTE,
    pub HwCountersCount: BYTE,
    pub ContextSwitchCount: DWORD,
    pub WaitReasonBitMap: DWORD64,
    pub CycleTime: DWORD64,
    pub RetryCount: DWORD,
    pub Reserved: DWORD,
    pub HwCounters: [HARDWARE_COUNTER_DATA; 16usize],
}
pub type PERFORMANCE_DATA = _PERFORMANCE_DATA;
pub type PPERFORMANCE_DATA = *mut _PERFORMANCE_DATA;
extern "C" {
    pub fn RtlGetDeviceFamilyInfoEnum(
        pullUAPInfo: *mut ULONGLONG,
        pulDeviceFamily: *mut DWORD,
        pulDeviceForm: *mut DWORD,
    );
}
extern "C" {
    pub fn RtlConvertDeviceFamilyInfoToString(
        pulDeviceFamilyBufferSize: PDWORD,
        pulDeviceFormBufferSize: PDWORD,
        DeviceFamily: PWSTR,
        DeviceForm: PWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlSwitchedVVI(
        VersionInfo: PRTL_OSVERSIONINFOEXW,
        TypeMask: DWORD,
        ConditionMask: ULONGLONG,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENTLOGRECORD {
    pub Length: DWORD,
    pub Reserved: DWORD,
    pub RecordNumber: DWORD,
    pub TimeGenerated: DWORD,
    pub TimeWritten: DWORD,
    pub EventID: DWORD,
    pub EventType: WORD,
    pub NumStrings: WORD,
    pub EventCategory: WORD,
    pub ReservedFlags: WORD,
    pub ClosingRecordNumber: DWORD,
    pub StringOffset: DWORD,
    pub UserSidLength: DWORD,
    pub UserSidOffset: DWORD,
    pub DataLength: DWORD,
    pub DataOffset: DWORD,
}
pub type EVENTLOGRECORD = _EVENTLOGRECORD;
pub type PEVENTLOGRECORD = *mut _EVENTLOGRECORD;
pub type EVENTSFORLOGFILE = _EVENTSFORLOGFILE;
pub type PEVENTSFORLOGFILE = *mut _EVENTSFORLOGFILE;
pub type PACKEDEVENTINFO = _PACKEDEVENTINFO;
pub type PPACKEDEVENTINFO = *mut _PACKEDEVENTINFO;
#[repr(C)]
#[derive(Debug)]
pub struct _EVENTSFORLOGFILE {
    pub ulSize: DWORD,
    pub szLogicalLogFile: [WCHAR; 256usize],
    pub ulNumRecords: DWORD,
    pub pEventLogRecords: __IncompleteArrayField<EVENTLOGRECORD>,
}
#[repr(C)]
#[derive(Debug)]
pub struct _PACKEDEVENTINFO {
    pub ulSize: DWORD,
    pub ulNumEventsForLogFile: DWORD,
    pub ulOffsets: __IncompleteArrayField<DWORD>,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_SERVICE_NODE_TYPE {
    DriverType = 1,
    FileSystemType = 2,
    Win32ServiceOwnProcess = 16,
    Win32ServiceShareProcess = 32,
    AdapterType = 4,
    RecognizerType = 8,
}
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0,
    SystemLoad = 1,
    AutoLoad = 2,
    DemandLoad = 3,
    DisableLoad = 4,
}
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0,
    NormalError = 1,
    SevereError = 2,
    CriticalError = 3,
}
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_ERASE {
    pub Type: DWORD,
    pub Immediate: BOOLEAN,
}
pub type TAPE_ERASE = _TAPE_ERASE;
pub type PTAPE_ERASE = *mut _TAPE_ERASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_PREPARE {
    pub Operation: DWORD,
    pub Immediate: BOOLEAN,
}
pub type TAPE_PREPARE = _TAPE_PREPARE;
pub type PTAPE_PREPARE = *mut _TAPE_PREPARE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_WRITE_MARKS {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Immediate: BOOLEAN,
}
pub type TAPE_WRITE_MARKS = _TAPE_WRITE_MARKS;
pub type PTAPE_WRITE_MARKS = *mut _TAPE_WRITE_MARKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_POSITION {
    pub Type: DWORD,
    pub Partition: DWORD,
    pub Offset: LARGE_INTEGER,
}
pub type TAPE_GET_POSITION = _TAPE_GET_POSITION;
pub type PTAPE_GET_POSITION = *mut _TAPE_GET_POSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_SET_POSITION {
    pub Method: DWORD,
    pub Partition: DWORD,
    pub Offset: LARGE_INTEGER,
    pub Immediate: BOOLEAN,
}
pub type TAPE_SET_POSITION = _TAPE_SET_POSITION;
pub type PTAPE_SET_POSITION = *mut _TAPE_SET_POSITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_GET_DRIVE_PARAMETERS {
    pub ECC: BOOLEAN,
    pub Compression: BOOLEAN,
    pub DataPadding: BOOLEAN,
    pub ReportSetmarks: BOOLEAN,
    pub DefaultBlockSize: DWORD,
    pub MaximumBlockSize: DWORD,
    pub MinimumBlockSize: DWORD,
    pub MaximumPartitionCount: DWORD,
    pub FeaturesLow: DWORD,
    pub FeaturesHigh: DWORD,
    pub EOTWarningZoneSize: DWORD,
}
pub type TAPE_GET_DRIVE_PARAMETERS = _TAPE_GET_DRIVE_PARAMETERS;
pub type PTAPE_GET_DRIVE_PARAMETERS = *mut _TAPE_GET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_SET_DRIVE_PARAMETERS {
    pub ECC: BOOLEAN,
    pub Compression: BOOLEAN,
    pub DataPadding: BOOLEAN,
    pub ReportSetmarks: BOOLEAN,
    pub EOTWarningZoneSize: DWORD,
}
pub type TAPE_SET_DRIVE_PARAMETERS = _TAPE_SET_DRIVE_PARAMETERS;
pub type PTAPE_SET_DRIVE_PARAMETERS = *mut _TAPE_SET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_MEDIA_PARAMETERS {
    pub Capacity: LARGE_INTEGER,
    pub Remaining: LARGE_INTEGER,
    pub BlockSize: DWORD,
    pub PartitionCount: DWORD,
    pub WriteProtected: BOOLEAN,
}
pub type TAPE_GET_MEDIA_PARAMETERS = _TAPE_GET_MEDIA_PARAMETERS;
pub type PTAPE_GET_MEDIA_PARAMETERS = *mut _TAPE_GET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_SET_MEDIA_PARAMETERS {
    pub BlockSize: DWORD,
}
pub type TAPE_SET_MEDIA_PARAMETERS = _TAPE_SET_MEDIA_PARAMETERS;
pub type PTAPE_SET_MEDIA_PARAMETERS = *mut _TAPE_SET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_CREATE_PARTITION {
    pub Method: DWORD,
    pub Count: DWORD,
    pub Size: DWORD,
}
pub type TAPE_CREATE_PARTITION = _TAPE_CREATE_PARTITION;
pub type PTAPE_CREATE_PARTITION = *mut _TAPE_CREATE_PARTITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_WMI_OPERATIONS {
    pub Method: DWORD,
    pub DataBufferSize: DWORD,
    pub DataBuffer: PVOID,
}
pub type TAPE_WMI_OPERATIONS = _TAPE_WMI_OPERATIONS;
pub type PTAPE_WMI_OPERATIONS = *mut _TAPE_WMI_OPERATIONS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TAPE_DRIVE_PROBLEM_TYPE {
    TapeDriveProblemNone = 0,
    TapeDriveReadWriteWarning = 1,
    TapeDriveReadWriteError = 2,
    TapeDriveReadWarning = 3,
    TapeDriveWriteWarning = 4,
    TapeDriveReadError = 5,
    TapeDriveWriteError = 6,
    TapeDriveHardwareError = 7,
    TapeDriveUnsupportedMedia = 8,
    TapeDriveScsiConnectionError = 9,
    TapeDriveTimetoClean = 10,
    TapeDriveCleanDriveNow = 11,
    TapeDriveMediaLifeExpired = 12,
    TapeDriveSnappedTape = 13,
}
pub use self::_TAPE_DRIVE_PROBLEM_TYPE as TAPE_DRIVE_PROBLEM_TYPE;
pub type UOW = GUID;
pub type PUOW = *mut GUID;
pub type CRM_PROTOCOL_ID = GUID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
    pub TransactionKey: PVOID,
    pub TransactionNotification: ULONG,
    pub TmVirtualClock: LARGE_INTEGER,
    pub ArgumentLength: ULONG,
}
pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    pub EnlistmentId: GUID,
    pub UOW: UOW,
}
pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    pub TmIdentity: GUID,
    pub Flags: ULONG,
}
pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    pub SavepointId: SAVEPOINT_ID,
}
pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    pub PropagationCookie: ULONG,
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub BufferLength: ULONG,
}
pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    pub MarshalCookie: ULONG,
    pub UOW: GUID,
}
pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
    *mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_MARSHAL_HEADER {
    pub VersionMajor: ULONG,
    pub VersionMinor: ULONG,
    pub NumProtocols: ULONG,
    pub Unused: ULONG,
}
pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_TRANSACTION_BLOB {
    pub UOW: UOW,
    pub TmIdentity: GUID,
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: ULONG,
    pub Description: [WCHAR; 64usize],
}
pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_PROTOCOL_BLOB {
    pub ProtocolId: CRM_PROTOCOL_ID,
    pub StaticInfoLength: ULONG,
    pub TransactionIdInfoLength: ULONG,
    pub Unused1: ULONG,
    pub Unused2: ULONG,
}
pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted = 2,
    TransactionOutcomeAborted = 3,
}
pub use self::_TRANSACTION_OUTCOME as TRANSACTION_OUTCOME;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt = 2,
    TransactionStateCommittedNotify = 3,
}
pub use self::_TRANSACTION_STATE as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: GUID,
    pub State: DWORD,
    pub Outcome: DWORD,
}
pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: GUID,
    pub VirtualClock: LARGE_INTEGER,
}
pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: GUID,
}
pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION = *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: DWORD,
    pub LogPath: [WCHAR; 1usize],
}
pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: ULONGLONG,
}
pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    pub OldestTransactionGuid: GUID,
}
pub type TRANSACTIONMANAGER_OLDEST_INFORMATION = _TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub type PTRANSACTIONMANAGER_OLDEST_INFORMATION = *mut _TRANSACTIONMANAGER_OLDEST_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: DWORD,
    pub IsolationFlags: DWORD,
    pub Timeout: LARGE_INTEGER,
    pub Outcome: DWORD,
    pub DescriptionLength: DWORD,
    pub Description: [WCHAR; 1usize],
}
pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION = *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BIND_INFORMATION {
    pub TmHandle: HANDLE,
}
pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: GUID,
    pub ResourceManagerId: GUID,
}
pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: DWORD,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION = *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
    *mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: GUID,
    pub DescriptionLength: DWORD,
    pub Description: [WCHAR; 1usize],
}
pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION = *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: HANDLE,
    pub CompletionKey: ULONG_PTR,
}
pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation = 0,
    TransactionPropertiesInformation = 1,
    TransactionEnlistmentInformation = 2,
    TransactionSuperiorEnlistmentInformation = 3,
    TransactionBindInformation = 4,
    TransactionDTCPrivateInformation = 5,
}
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation = 0,
    TransactionManagerLogInformation = 1,
    TransactionManagerLogPathInformation = 2,
    TransactionManagerRecoveryInformation = 4,
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5,
}
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation = 0,
    ResourceManagerCompletionInformation = 1,
}
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: GUID,
    pub TransactionId: GUID,
    pub ResourceManagerId: GUID,
}
pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: GUID,
    pub CrmResourceManagerId: GUID,
    pub CrmEnlistmentId: GUID,
}
pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation = 0,
    EnlistmentRecoveryInformation = 1,
    EnlistmentCrmInformation = 2,
}
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_ENTRY {
    pub UOW: UOW,
}
pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: DWORD,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _KTMOBJECT_TYPE {
    KTMOBJECT_TRANSACTION = 0,
    KTMOBJECT_TRANSACTION_MANAGER = 1,
    KTMOBJECT_RESOURCE_MANAGER = 2,
    KTMOBJECT_ENLISTMENT = 3,
    KTMOBJECT_INVALID = 4,
}
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
    pub LastQuery: GUID,
    pub ObjectIdCount: DWORD,
    pub ObjectIds: [GUID; 1usize],
}
pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
pub type TP_VERSION = DWORD;
pub type PTP_VERSION = *mut DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {
    _unused: [u8; 0],
}
pub type TP_CALLBACK_INSTANCE = _TP_CALLBACK_INSTANCE;
pub type PTP_CALLBACK_INSTANCE = *mut _TP_CALLBACK_INSTANCE;
pub type PTP_SIMPLE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL {
    _unused: [u8; 0],
}
pub type TP_POOL = _TP_POOL;
pub type PTP_POOL = *mut _TP_POOL;
impl _TP_CALLBACK_PRIORITY {
    pub const TP_CALLBACK_PRIORITY_COUNT: _TP_CALLBACK_PRIORITY =
        _TP_CALLBACK_PRIORITY::TP_CALLBACK_PRIORITY_INVALID;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH = 0,
    TP_CALLBACK_PRIORITY_NORMAL = 1,
    TP_CALLBACK_PRIORITY_LOW = 2,
    TP_CALLBACK_PRIORITY_INVALID = 3,
}
pub use self::_TP_CALLBACK_PRIORITY as TP_CALLBACK_PRIORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL_STACK_INFORMATION {
    pub StackReserve: SIZE_T,
    pub StackCommit: SIZE_T,
}
pub type TP_POOL_STACK_INFORMATION = _TP_POOL_STACK_INFORMATION;
pub type PTP_POOL_STACK_INFORMATION = *mut _TP_POOL_STACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {
    _unused: [u8; 0],
}
pub type TP_CLEANUP_GROUP = _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP = *mut _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(ObjectContext: PVOID, CleanupContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
    pub Version: TP_VERSION,
    pub Pool: PTP_POOL,
    pub CleanupGroup: PTP_CLEANUP_GROUP,
    pub CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    pub RaceDll: PVOID,
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    pub FinalizationCallback: PTP_SIMPLE_CALLBACK,
    pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
    pub CallbackPriority: TP_CALLBACK_PRIORITY,
    pub Size: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
    pub Flags: DWORD,
    pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LongFunction(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongFunction(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Persistent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Persistent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Private(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Private(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LongFunction: DWORD,
        Persistent: DWORD,
        Private: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LongFunction: u32 = unsafe { ::std::mem::transmute(LongFunction) };
            LongFunction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Persistent: u32 = unsafe { ::std::mem::transmute(Persistent) };
            Persistent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Private: u32 = unsafe { ::std::mem::transmute(Private) };
            Private as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3;
pub type TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3;
pub type PTP_CALLBACK_ENVIRON = *mut TP_CALLBACK_ENVIRON_V3;
extern "C" {
    pub fn TpInitializeCallbackEnviron(CallbackEnviron: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn TpSetCallbackThreadpool(CallbackEnviron: PTP_CALLBACK_ENVIRON, Pool: PTP_POOL);
}
extern "C" {
    pub fn TpSetCallbackCleanupGroup(
        CallbackEnviron: PTP_CALLBACK_ENVIRON,
        CleanupGroup: PTP_CLEANUP_GROUP,
        CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    );
}
extern "C" {
    pub fn TpSetCallbackActivationContext(
        CallbackEnviron: PTP_CALLBACK_ENVIRON,
        ActivationContext: *mut _ACTIVATION_CONTEXT,
    );
}
extern "C" {
    pub fn TpSetCallbackNoActivationContext(CallbackEnviron: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn TpSetCallbackLongFunction(CallbackEnviron: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn TpSetCallbackRaceWithDll(CallbackEnviron: PTP_CALLBACK_ENVIRON, DllHandle: PVOID);
}
extern "C" {
    pub fn TpSetCallbackFinalizationCallback(
        CallbackEnviron: PTP_CALLBACK_ENVIRON,
        FinalizationCallback: PTP_SIMPLE_CALLBACK,
    );
}
extern "C" {
    pub fn TpSetCallbackPriority(
        CallbackEnviron: PTP_CALLBACK_ENVIRON,
        Priority: TP_CALLBACK_PRIORITY,
    );
}
extern "C" {
    pub fn TpSetCallbackPersistent(CallbackEnviron: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn TpDestroyCallbackEnviron(CallbackEnviron: PTP_CALLBACK_ENVIRON);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WORK {
    _unused: [u8; 0],
}
pub type TP_WORK = _TP_WORK;
pub type PTP_WORK = *mut _TP_WORK;
pub type PTP_WORK_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Work: PTP_WORK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_TIMER {
    _unused: [u8; 0],
}
pub type TP_TIMER = _TP_TIMER;
pub type PTP_TIMER = *mut _TP_TIMER;
pub type PTP_TIMER_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Timer: PTP_TIMER),
>;
pub type TP_WAIT_RESULT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WAIT {
    _unused: [u8; 0],
}
pub type TP_WAIT = _TP_WAIT;
pub type PTP_WAIT = *mut _TP_WAIT;
pub type PTP_WAIT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Instance: PTP_CALLBACK_INSTANCE,
        Context: PVOID,
        Wait: PTP_WAIT,
        WaitResult: TP_WAIT_RESULT,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_IO {
    _unused: [u8; 0],
}
pub type TP_IO = _TP_IO;
pub type PTP_IO = *mut _TP_IO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB {
    _unused: [u8; 0],
}
extern "C" {
    pub fn NtCurrentTeb() -> *mut _TEB;
}
extern "C" {
    pub fn GetCurrentFiber() -> PVOID;
}
extern "C" {
    pub fn GetFiberData() -> PVOID;
}
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
pub type SPHANDLE = *mut HANDLE;
pub type LPHANDLE = *mut HANDLE;
pub type HGLOBAL = HANDLE;
pub type HLOCAL = HANDLE;
pub type GLOBALHANDLE = HANDLE;
pub type LOCALHANDLE = HANDLE;
pub type FARPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type NEARPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type PROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type ATOM = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKEY__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HKEY = *mut HKEY__;
pub type PHKEY = *mut HKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMETAFILE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMETAFILE = *mut HMETAFILE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HINSTANCE = *mut HINSTANCE__;
pub type HMODULE = HINSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRGN__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HRGN = *mut HRGN__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRSRC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HRSRC = *mut HRSRC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSPRITE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HSPRITE = *mut HSPRITE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HLSURF__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HLSURF = *mut HLSURF__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSTR__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HSTR = *mut HSTR__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTASK__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HTASK = *mut HTASK__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWINSTA__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWINSTA = *mut HWINSTA__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKL__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HKL = *mut HKL__;
pub type HFILE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
pub type FILETIME = _FILETIME;
pub type PFILETIME = *mut _FILETIME;
pub type LPFILETIME = *mut _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HHOOK__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HHOOK = *mut HHOOK__;
pub type HGDIOBJ = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HACCEL__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HACCEL = *mut HACCEL__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBITMAP__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBRUSH__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HBRUSH = *mut HBRUSH__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HCOLORSPACE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HCOLORSPACE = *mut HCOLORSPACE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDC = *mut HDC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HGLRC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HGLRC = *mut HGLRC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDESK__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDESK = *mut HDESK__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HENHMETAFILE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HENHMETAFILE = *mut HENHMETAFILE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFONT__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HFONT = *mut HFONT__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMENU__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMENU = *mut HMENU__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPALETTE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HPALETTE = *mut HPALETTE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPEN__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HPEN = *mut HPEN__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWINEVENTHOOK__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWINEVENTHOOK = *mut HWINEVENTHOOK__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMONITOR__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMONITOR = *mut HMONITOR__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HUMPD__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HUMPD = *mut HUMPD__;
pub type HCURSOR = HICON;
pub type COLORREF = DWORD;
pub type LPCOLORREF = *mut DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRECT {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
pub type RECT = tagRECT;
pub type PRECT = *mut tagRECT;
pub type NPRECT = *mut tagRECT;
pub type LPRECT = *mut tagRECT;
pub type LPCRECT = *const RECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RECTL {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
pub type RECTL = _RECTL;
pub type PRECTL = *mut _RECTL;
pub type LPRECTL = *mut _RECTL;
pub type LPCRECTL = *const RECTL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINT {
    pub x: LONG,
    pub y: LONG,
}
pub type POINT = tagPOINT;
pub type PPOINT = *mut tagPOINT;
pub type NPPOINT = *mut tagPOINT;
pub type LPPOINT = *mut tagPOINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POINTL {
    pub x: LONG,
    pub y: LONG,
}
pub type POINTL = _POINTL;
pub type PPOINTL = *mut _POINTL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSIZE {
    pub cx: LONG,
    pub cy: LONG,
}
pub type SIZE = tagSIZE;
pub type PSIZE = *mut tagSIZE;
pub type LPSIZE = *mut tagSIZE;
pub type SIZEL = SIZE;
pub type PSIZEL = *mut SIZE;
pub type LPSIZEL = *mut SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTS {
    pub x: SHORT,
    pub y: SHORT,
}
pub type POINTS = tagPOINTS;
pub type PPOINTS = *mut tagPOINTS;
pub type LPPOINTS = *mut tagPOINTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct APP_LOCAL_DEVICE_ID {
    pub value: [BYTE; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPI_AWARENESS_CONTEXT__ {
    pub unused: ::std::os::raw::c_int,
}
pub type DPI_AWARENESS_CONTEXT = *mut DPI_AWARENESS_CONTEXT__;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DPI_HOSTING_BEHAVIOR {
    DPI_HOSTING_BEHAVIOR_INVALID = -1,
    DPI_HOSTING_BEHAVIOR_DEFAULT = 0,
    DPI_HOSTING_BEHAVIOR_MIXED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_ATTRIBUTES {
    pub nLength: DWORD,
    pub lpSecurityDescriptor: LPVOID,
    pub bInheritHandle: BOOL,
}
pub type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
pub type PSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
pub type LPSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
    pub Internal: ULONG_PTR,
    pub InternalHigh: ULONG_PTR,
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
    pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
    pub Pointer: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
    pub Offset: DWORD,
    pub OffsetHigh: DWORD,
}
pub type OVERLAPPED = _OVERLAPPED;
pub type LPOVERLAPPED = *mut _OVERLAPPED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OVERLAPPED_ENTRY {
    pub lpCompletionKey: ULONG_PTR,
    pub lpOverlapped: LPOVERLAPPED,
    pub Internal: ULONG_PTR,
    pub dwNumberOfBytesTransferred: DWORD,
}
pub type OVERLAPPED_ENTRY = _OVERLAPPED_ENTRY;
pub type LPOVERLAPPED_ENTRY = *mut _OVERLAPPED_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEMTIME {
    pub wYear: WORD,
    pub wMonth: WORD,
    pub wDayOfWeek: WORD,
    pub wDay: WORD,
    pub wHour: WORD,
    pub wMinute: WORD,
    pub wSecond: WORD,
    pub wMilliseconds: WORD,
}
pub type SYSTEMTIME = _SYSTEMTIME;
pub type PSYSTEMTIME = *mut _SYSTEMTIME;
pub type LPSYSTEMTIME = *mut _SYSTEMTIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FIND_DATAA {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
    pub dwReserved0: DWORD,
    pub dwReserved1: DWORD,
    pub cFileName: [CHAR; 260usize],
    pub cAlternateFileName: [CHAR; 14usize],
}
pub type WIN32_FIND_DATAA = _WIN32_FIND_DATAA;
pub type PWIN32_FIND_DATAA = *mut _WIN32_FIND_DATAA;
pub type LPWIN32_FIND_DATAA = *mut _WIN32_FIND_DATAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FIND_DATAW {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
    pub dwReserved0: DWORD,
    pub dwReserved1: DWORD,
    pub cFileName: [WCHAR; 260usize],
    pub cAlternateFileName: [WCHAR; 14usize],
}
pub type WIN32_FIND_DATAW = _WIN32_FIND_DATAW;
pub type PWIN32_FIND_DATAW = *mut _WIN32_FIND_DATAW;
pub type LPWIN32_FIND_DATAW = *mut _WIN32_FIND_DATAW;
pub type WIN32_FIND_DATA = WIN32_FIND_DATAA;
pub type PWIN32_FIND_DATA = PWIN32_FIND_DATAA;
pub type LPWIN32_FIND_DATA = LPWIN32_FIND_DATAA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard = 0,
    FindExInfoBasic = 1,
    FindExInfoMaxInfoLevel = 2,
}
pub use self::_FINDEX_INFO_LEVELS as FINDEX_INFO_LEVELS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch = 0,
    FindExSearchLimitToDirectories = 1,
    FindExSearchLimitToDevices = 2,
    FindExSearchMaxSearchOp = 3,
}
pub use self::_FINDEX_SEARCH_OPS as FINDEX_SEARCH_OPS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
    ReadDirectoryNotifyInformation = 1,
    ReadDirectoryNotifyExtendedInformation = 2,
    ReadDirectoryNotifyFullInformation = 3,
    ReadDirectoryNotifyMaximumInformation = 4,
}
pub use self::_READ_DIRECTORY_NOTIFY_INFORMATION_CLASS as READ_DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub type PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS = *mut _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard = 0,
    GetFileExMaxInfoLevel = 1,
}
pub use self::_GET_FILEEX_INFO_LEVELS as GET_FILEEX_INFO_LEVELS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo = 0,
    FileStandardInfo = 1,
    FileNameInfo = 2,
    FileRenameInfo = 3,
    FileDispositionInfo = 4,
    FileAllocationInfo = 5,
    FileEndOfFileInfo = 6,
    FileStreamInfo = 7,
    FileCompressionInfo = 8,
    FileAttributeTagInfo = 9,
    FileIdBothDirectoryInfo = 10,
    FileIdBothDirectoryRestartInfo = 11,
    FileIoPriorityHintInfo = 12,
    FileRemoteProtocolInfo = 13,
    FileFullDirectoryInfo = 14,
    FileFullDirectoryRestartInfo = 15,
    FileStorageInfo = 16,
    FileAlignmentInfo = 17,
    FileIdInfo = 18,
    FileIdExtdDirectoryInfo = 19,
    FileIdExtdDirectoryRestartInfo = 20,
    FileDispositionInfoEx = 21,
    FileRenameInfoEx = 22,
    FileCaseSensitiveInfo = 23,
    FileNormalizedNameInfo = 24,
    MaximumFileInfoByHandleClass = 25,
}
pub use self::_FILE_INFO_BY_HANDLE_CLASS as FILE_INFO_BY_HANDLE_CLASS;
pub type PFILE_INFO_BY_HANDLE_CLASS = *mut _FILE_INFO_BY_HANDLE_CLASS;
pub type CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub type PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub type LPCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub type CRITICAL_SECTION_DEBUG = RTL_CRITICAL_SECTION_DEBUG;
pub type PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
pub type LPCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
pub type LPOVERLAPPED_COMPLETION_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        dwErrorCode: DWORD,
        dwNumberOfBytesTransfered: DWORD,
        lpOverlapped: LPOVERLAPPED,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_HEAP_ENTRY {
    pub lpData: PVOID,
    pub cbData: DWORD,
    pub cbOverhead: BYTE,
    pub iRegionIndex: BYTE,
    pub wFlags: WORD,
    pub __bindgen_anon_1: _PROCESS_HEAP_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_HEAP_ENTRY__bindgen_ty_1 {
    pub Block: _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Region: _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub hMem: HANDLE,
    pub dwReserved: [DWORD; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_HEAP_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub dwCommittedSize: DWORD,
    pub dwUnCommittedSize: DWORD,
    pub lpFirstBlock: LPVOID,
    pub lpLastBlock: LPVOID,
}
pub type PROCESS_HEAP_ENTRY = _PROCESS_HEAP_ENTRY;
pub type LPPROCESS_HEAP_ENTRY = *mut _PROCESS_HEAP_ENTRY;
pub type PPROCESS_HEAP_ENTRY = *mut _PROCESS_HEAP_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REASON_CONTEXT {
    pub Version: ULONG,
    pub Flags: DWORD,
    pub Reason: _REASON_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _REASON_CONTEXT__bindgen_ty_1 {
    pub Detailed: _REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub SimpleReasonString: LPWSTR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REASON_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub LocalizedReasonModule: HMODULE,
    pub LocalizedReasonId: ULONG,
    pub ReasonStringCount: ULONG,
    pub ReasonStrings: *mut LPWSTR,
}
pub type REASON_CONTEXT = _REASON_CONTEXT;
pub type PREASON_CONTEXT = *mut _REASON_CONTEXT;
pub type PTHREAD_START_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> DWORD>;
pub type LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE;
pub type PENCLAVE_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(lpThreadParameter: LPVOID) -> LPVOID>;
pub type LPENCLAVE_ROUTINE = PENCLAVE_ROUTINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_DEBUG_INFO {
    pub ExceptionRecord: EXCEPTION_RECORD,
    pub dwFirstChance: DWORD,
}
pub type EXCEPTION_DEBUG_INFO = _EXCEPTION_DEBUG_INFO;
pub type LPEXCEPTION_DEBUG_INFO = *mut _EXCEPTION_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_THREAD_DEBUG_INFO {
    pub hThread: HANDLE,
    pub lpThreadLocalBase: LPVOID,
    pub lpStartAddress: LPTHREAD_START_ROUTINE,
}
pub type CREATE_THREAD_DEBUG_INFO = _CREATE_THREAD_DEBUG_INFO;
pub type LPCREATE_THREAD_DEBUG_INFO = *mut _CREATE_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_PROCESS_DEBUG_INFO {
    pub hFile: HANDLE,
    pub hProcess: HANDLE,
    pub hThread: HANDLE,
    pub lpBaseOfImage: LPVOID,
    pub dwDebugInfoFileOffset: DWORD,
    pub nDebugInfoSize: DWORD,
    pub lpThreadLocalBase: LPVOID,
    pub lpStartAddress: LPTHREAD_START_ROUTINE,
    pub lpImageName: LPVOID,
    pub fUnicode: WORD,
}
pub type CREATE_PROCESS_DEBUG_INFO = _CREATE_PROCESS_DEBUG_INFO;
pub type LPCREATE_PROCESS_DEBUG_INFO = *mut _CREATE_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXIT_THREAD_DEBUG_INFO {
    pub dwExitCode: DWORD,
}
pub type EXIT_THREAD_DEBUG_INFO = _EXIT_THREAD_DEBUG_INFO;
pub type LPEXIT_THREAD_DEBUG_INFO = *mut _EXIT_THREAD_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXIT_PROCESS_DEBUG_INFO {
    pub dwExitCode: DWORD,
}
pub type EXIT_PROCESS_DEBUG_INFO = _EXIT_PROCESS_DEBUG_INFO;
pub type LPEXIT_PROCESS_DEBUG_INFO = *mut _EXIT_PROCESS_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOAD_DLL_DEBUG_INFO {
    pub hFile: HANDLE,
    pub lpBaseOfDll: LPVOID,
    pub dwDebugInfoFileOffset: DWORD,
    pub nDebugInfoSize: DWORD,
    pub lpImageName: LPVOID,
    pub fUnicode: WORD,
}
pub type LOAD_DLL_DEBUG_INFO = _LOAD_DLL_DEBUG_INFO;
pub type LPLOAD_DLL_DEBUG_INFO = *mut _LOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNLOAD_DLL_DEBUG_INFO {
    pub lpBaseOfDll: LPVOID,
}
pub type UNLOAD_DLL_DEBUG_INFO = _UNLOAD_DLL_DEBUG_INFO;
pub type LPUNLOAD_DLL_DEBUG_INFO = *mut _UNLOAD_DLL_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OUTPUT_DEBUG_STRING_INFO {
    pub lpDebugStringData: LPSTR,
    pub fUnicode: WORD,
    pub nDebugStringLength: WORD,
}
pub type OUTPUT_DEBUG_STRING_INFO = _OUTPUT_DEBUG_STRING_INFO;
pub type LPOUTPUT_DEBUG_STRING_INFO = *mut _OUTPUT_DEBUG_STRING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RIP_INFO {
    pub dwError: DWORD,
    pub dwType: DWORD,
}
pub type RIP_INFO = _RIP_INFO;
pub type LPRIP_INFO = *mut _RIP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEBUG_EVENT {
    pub dwDebugEventCode: DWORD,
    pub dwProcessId: DWORD,
    pub dwThreadId: DWORD,
    pub u: _DEBUG_EVENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEBUG_EVENT__bindgen_ty_1 {
    pub Exception: EXCEPTION_DEBUG_INFO,
    pub CreateThread: CREATE_THREAD_DEBUG_INFO,
    pub CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
    pub ExitThread: EXIT_THREAD_DEBUG_INFO,
    pub ExitProcess: EXIT_PROCESS_DEBUG_INFO,
    pub LoadDll: LOAD_DLL_DEBUG_INFO,
    pub UnloadDll: UNLOAD_DLL_DEBUG_INFO,
    pub DebugString: OUTPUT_DEBUG_STRING_INFO,
    pub RipInfo: RIP_INFO,
}
pub type DEBUG_EVENT = _DEBUG_EVENT;
pub type LPDEBUG_EVENT = *mut _DEBUG_EVENT;
pub type LPCONTEXT = PCONTEXT;
extern "C" {
    pub fn IsApiSetImplemented(Contract: PCSTR) -> BOOL;
}
extern "C" {
    pub fn SetEnvironmentStringsW(NewEnvironment: LPWCH) -> BOOL;
}
extern "C" {
    pub fn GetStdHandle(nStdHandle: DWORD) -> HANDLE;
}
extern "C" {
    pub fn SetStdHandle(nStdHandle: DWORD, hHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetStdHandleEx(nStdHandle: DWORD, hHandle: HANDLE, phPrevValue: PHANDLE) -> BOOL;
}
extern "C" {
    pub fn GetCommandLineA() -> LPSTR;
}
extern "C" {
    pub fn GetCommandLineW() -> LPWSTR;
}
extern "C" {
    pub fn GetEnvironmentStrings() -> LPCH;
}
extern "C" {
    pub fn GetEnvironmentStringsW() -> LPWCH;
}
extern "C" {
    pub fn FreeEnvironmentStringsA(penv: LPCH) -> BOOL;
}
extern "C" {
    pub fn FreeEnvironmentStringsW(penv: LPWCH) -> BOOL;
}
extern "C" {
    pub fn GetEnvironmentVariableA(lpName: LPCSTR, lpBuffer: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetEnvironmentVariableW(lpName: LPCWSTR, lpBuffer: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn SetEnvironmentVariableA(lpName: LPCSTR, lpValue: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetEnvironmentVariableW(lpName: LPCWSTR, lpValue: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn ExpandEnvironmentStringsA(lpSrc: LPCSTR, lpDst: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn ExpandEnvironmentStringsW(lpSrc: LPCWSTR, lpDst: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn SetCurrentDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetCurrentDirectoryA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn SearchPathW(
        lpPath: LPCWSTR,
        lpFileName: LPCWSTR,
        lpExtension: LPCWSTR,
        nBufferLength: DWORD,
        lpBuffer: LPWSTR,
        lpFilePart: *mut LPWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn SearchPathA(
        lpPath: LPCSTR,
        lpFileName: LPCSTR,
        lpExtension: LPCSTR,
        nBufferLength: DWORD,
        lpBuffer: LPSTR,
        lpFilePart: *mut LPSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn NeedCurrentDirectoryForExePathA(ExeName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn NeedCurrentDirectoryForExePathW(ExeName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn CompareFileTime(lpFileTime1: *const FILETIME, lpFileTime2: *const FILETIME) -> LONG;
}
extern "C" {
    pub fn CreateDirectoryA(
        lpPathName: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryW(
        lpPathName: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateFileA(
        lpFileName: LPCSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreationDisposition: DWORD,
        dwFlagsAndAttributes: DWORD,
        hTemplateFile: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateFileW(
        lpFileName: LPCWSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreationDisposition: DWORD,
        dwFlagsAndAttributes: DWORD,
        hTemplateFile: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn DefineDosDeviceW(dwFlags: DWORD, lpDeviceName: LPCWSTR, lpTargetPath: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn DeleteFileA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn DeleteFileW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn DeleteVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn FileTimeToLocalFileTime(
        lpFileTime: *const FILETIME,
        lpLocalFileTime: LPFILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn FindClose(hFindFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn FindCloseChangeNotification(hChangeHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn FindFirstChangeNotificationA(
        lpPathName: LPCSTR,
        bWatchSubtree: BOOL,
        dwNotifyFilter: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstChangeNotificationW(
        lpPathName: LPCWSTR,
        bWatchSubtree: BOOL,
        dwNotifyFilter: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstFileA(lpFileName: LPCSTR, lpFindFileData: LPWIN32_FIND_DATAA) -> HANDLE;
}
extern "C" {
    pub fn FindFirstFileW(lpFileName: LPCWSTR, lpFindFileData: LPWIN32_FIND_DATAW) -> HANDLE;
}
extern "C" {
    pub fn FindFirstFileExA(
        lpFileName: LPCSTR,
        fInfoLevelId: FINDEX_INFO_LEVELS,
        lpFindFileData: LPVOID,
        fSearchOp: FINDEX_SEARCH_OPS,
        lpSearchFilter: LPVOID,
        dwAdditionalFlags: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstFileExW(
        lpFileName: LPCWSTR,
        fInfoLevelId: FINDEX_INFO_LEVELS,
        lpFindFileData: LPVOID,
        fSearchOp: FINDEX_SEARCH_OPS,
        lpSearchFilter: LPVOID,
        dwAdditionalFlags: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstVolumeW(lpszVolumeName: LPWSTR, cchBufferLength: DWORD) -> HANDLE;
}
extern "C" {
    pub fn FindNextChangeNotification(hChangeHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn FindNextFileA(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAA) -> BOOL;
}
extern "C" {
    pub fn FindNextFileW(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAW) -> BOOL;
}
extern "C" {
    pub fn FindNextVolumeW(
        hFindVolume: HANDLE,
        lpszVolumeName: LPWSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FindVolumeClose(hFindVolume: HANDLE) -> BOOL;
}
extern "C" {
    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetDiskFreeSpaceA(
        lpRootPathName: LPCSTR,
        lpSectorsPerCluster: LPDWORD,
        lpBytesPerSector: LPDWORD,
        lpNumberOfFreeClusters: LPDWORD,
        lpTotalNumberOfClusters: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDiskFreeSpaceW(
        lpRootPathName: LPCWSTR,
        lpSectorsPerCluster: LPDWORD,
        lpBytesPerSector: LPDWORD,
        lpNumberOfFreeClusters: LPDWORD,
        lpTotalNumberOfClusters: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDiskFreeSpaceExA(
        lpDirectoryName: LPCSTR,
        lpFreeBytesAvailableToCaller: PULARGE_INTEGER,
        lpTotalNumberOfBytes: PULARGE_INTEGER,
        lpTotalNumberOfFreeBytes: PULARGE_INTEGER,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDiskFreeSpaceExW(
        lpDirectoryName: LPCWSTR,
        lpFreeBytesAvailableToCaller: PULARGE_INTEGER,
        lpTotalNumberOfBytes: PULARGE_INTEGER,
        lpTotalNumberOfFreeBytes: PULARGE_INTEGER,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISK_SPACE_INFORMATION {
    pub ActualTotalAllocationUnits: ULONGLONG,
    pub ActualAvailableAllocationUnits: ULONGLONG,
    pub ActualPoolUnavailableAllocationUnits: ULONGLONG,
    pub CallerTotalAllocationUnits: ULONGLONG,
    pub CallerAvailableAllocationUnits: ULONGLONG,
    pub CallerPoolUnavailableAllocationUnits: ULONGLONG,
    pub UsedAllocationUnits: ULONGLONG,
    pub TotalReservedAllocationUnits: ULONGLONG,
    pub VolumeStorageReserveAllocationUnits: ULONGLONG,
    pub AvailableCommittedAllocationUnits: ULONGLONG,
    pub PoolAvailableAllocationUnits: ULONGLONG,
    pub SectorsPerAllocationUnit: DWORD,
    pub BytesPerSector: DWORD,
}
extern "C" {
    pub fn GetDiskSpaceInformationA(
        rootPath: LPCSTR,
        diskSpaceInfo: *mut DISK_SPACE_INFORMATION,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetDiskSpaceInformationW(
        rootPath: LPCWSTR,
        diskSpaceInfo: *mut DISK_SPACE_INFORMATION,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetDriveTypeA(lpRootPathName: LPCSTR) -> UINT;
}
extern "C" {
    pub fn GetDriveTypeW(lpRootPathName: LPCWSTR) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FILE_ATTRIBUTE_DATA {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
}
pub type WIN32_FILE_ATTRIBUTE_DATA = _WIN32_FILE_ATTRIBUTE_DATA;
pub type LPWIN32_FILE_ATTRIBUTE_DATA = *mut _WIN32_FILE_ATTRIBUTE_DATA;
extern "C" {
    pub fn GetFileAttributesA(lpFileName: LPCSTR) -> DWORD;
}
extern "C" {
    pub fn GetFileAttributesW(lpFileName: LPCWSTR) -> DWORD;
}
extern "C" {
    pub fn GetFileAttributesExA(
        lpFileName: LPCSTR,
        fInfoLevelId: GET_FILEEX_INFO_LEVELS,
        lpFileInformation: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileAttributesExW(
        lpFileName: LPCWSTR,
        fInfoLevelId: GET_FILEEX_INFO_LEVELS,
        lpFileInformation: LPVOID,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BY_HANDLE_FILE_INFORMATION {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub dwVolumeSerialNumber: DWORD,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
    pub nNumberOfLinks: DWORD,
    pub nFileIndexHigh: DWORD,
    pub nFileIndexLow: DWORD,
}
pub type BY_HANDLE_FILE_INFORMATION = _BY_HANDLE_FILE_INFORMATION;
pub type PBY_HANDLE_FILE_INFORMATION = *mut _BY_HANDLE_FILE_INFORMATION;
pub type LPBY_HANDLE_FILE_INFORMATION = *mut _BY_HANDLE_FILE_INFORMATION;
extern "C" {
    pub fn GetFileInformationByHandle(
        hFile: HANDLE,
        lpFileInformation: LPBY_HANDLE_FILE_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileSize(hFile: HANDLE, lpFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn GetFileSizeEx(hFile: HANDLE, lpFileSize: PLARGE_INTEGER) -> BOOL;
}
extern "C" {
    pub fn GetFileType(hFile: HANDLE) -> DWORD;
}
extern "C" {
    pub fn GetFinalPathNameByHandleA(
        hFile: HANDLE,
        lpszFilePath: LPSTR,
        cchFilePath: DWORD,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFinalPathNameByHandleW(
        hFile: HANDLE,
        lpszFilePath: LPWSTR,
        cchFilePath: DWORD,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFileTime(
        hFile: HANDLE,
        lpCreationTime: LPFILETIME,
        lpLastAccessTime: LPFILETIME,
        lpLastWriteTime: LPFILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFullPathNameW(
        lpFileName: LPCWSTR,
        nBufferLength: DWORD,
        lpBuffer: LPWSTR,
        lpFilePart: *mut LPWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFullPathNameA(
        lpFileName: LPCSTR,
        nBufferLength: DWORD,
        lpBuffer: LPSTR,
        lpFilePart: *mut LPSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetLogicalDrives() -> DWORD;
}
extern "C" {
    pub fn GetLogicalDriveStringsW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn GetLongPathNameA(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetLongPathNameW(
        lpszShortPath: LPCWSTR,
        lpszLongPath: LPWSTR,
        cchBuffer: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn AreShortNamesEnabled(Handle: HANDLE, Enabled: *mut BOOL) -> BOOL;
}
extern "C" {
    pub fn GetShortPathNameW(
        lpszLongPath: LPCWSTR,
        lpszShortPath: LPWSTR,
        cchBuffer: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetTempFileNameW(
        lpPathName: LPCWSTR,
        lpPrefixString: LPCWSTR,
        uUnique: UINT,
        lpTempFileName: LPWSTR,
    ) -> UINT;
}
extern "C" {
    pub fn GetVolumeInformationByHandleW(
        hFile: HANDLE,
        lpVolumeNameBuffer: LPWSTR,
        nVolumeNameSize: DWORD,
        lpVolumeSerialNumber: LPDWORD,
        lpMaximumComponentLength: LPDWORD,
        lpFileSystemFlags: LPDWORD,
        lpFileSystemNameBuffer: LPWSTR,
        nFileSystemNameSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetVolumeInformationW(
        lpRootPathName: LPCWSTR,
        lpVolumeNameBuffer: LPWSTR,
        nVolumeNameSize: DWORD,
        lpVolumeSerialNumber: LPDWORD,
        lpMaximumComponentLength: LPDWORD,
        lpFileSystemFlags: LPDWORD,
        lpFileSystemNameBuffer: LPWSTR,
        nFileSystemNameSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetVolumePathNameW(
        lpszFileName: LPCWSTR,
        lpszVolumePathName: LPWSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LocalFileTimeToFileTime(
        lpLocalFileTime: *const FILETIME,
        lpFileTime: LPFILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn LockFile(
        hFile: HANDLE,
        dwFileOffsetLow: DWORD,
        dwFileOffsetHigh: DWORD,
        nNumberOfBytesToLockLow: DWORD,
        nNumberOfBytesToLockHigh: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LockFileEx(
        hFile: HANDLE,
        dwFlags: DWORD,
        dwReserved: DWORD,
        nNumberOfBytesToLockLow: DWORD,
        nNumberOfBytesToLockHigh: DWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryDosDeviceW(lpDeviceName: LPCWSTR, lpTargetPath: LPWSTR, ucchMax: DWORD) -> DWORD;
}
extern "C" {
    pub fn ReadFile(
        hFile: HANDLE,
        lpBuffer: LPVOID,
        nNumberOfBytesToRead: DWORD,
        lpNumberOfBytesRead: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadFileEx(
        hFile: HANDLE,
        lpBuffer: LPVOID,
        nNumberOfBytesToRead: DWORD,
        lpOverlapped: LPOVERLAPPED,
        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadFileScatter(
        hFile: HANDLE,
        aSegmentArray: *mut FILE_SEGMENT_ELEMENT,
        nNumberOfBytesToRead: DWORD,
        lpReserved: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn RemoveDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn SetEndOfFile(hFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetFileAttributesA(lpFileName: LPCSTR, dwFileAttributes: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetFileInformationByHandle(
        hFile: HANDLE,
        FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
        lpFileInformation: LPVOID,
        dwBufferSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFilePointer(
        hFile: HANDLE,
        lDistanceToMove: LONG,
        lpDistanceToMoveHigh: PLONG,
        dwMoveMethod: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetFilePointerEx(
        hFile: HANDLE,
        liDistanceToMove: LARGE_INTEGER,
        lpNewFilePointer: PLARGE_INTEGER,
        dwMoveMethod: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileTime(
        hFile: HANDLE,
        lpCreationTime: *const FILETIME,
        lpLastAccessTime: *const FILETIME,
        lpLastWriteTime: *const FILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileValidData(hFile: HANDLE, ValidDataLength: LONGLONG) -> BOOL;
}
extern "C" {
    pub fn UnlockFile(
        hFile: HANDLE,
        dwFileOffsetLow: DWORD,
        dwFileOffsetHigh: DWORD,
        nNumberOfBytesToUnlockLow: DWORD,
        nNumberOfBytesToUnlockHigh: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn UnlockFileEx(
        hFile: HANDLE,
        dwReserved: DWORD,
        nNumberOfBytesToUnlockLow: DWORD,
        nNumberOfBytesToUnlockHigh: DWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteFile(
        hFile: HANDLE,
        lpBuffer: LPCVOID,
        nNumberOfBytesToWrite: DWORD,
        lpNumberOfBytesWritten: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteFileEx(
        hFile: HANDLE,
        lpBuffer: LPCVOID,
        nNumberOfBytesToWrite: DWORD,
        lpOverlapped: LPOVERLAPPED,
        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteFileGather(
        hFile: HANDLE,
        aSegmentArray: *mut FILE_SEGMENT_ELEMENT,
        nNumberOfBytesToWrite: DWORD,
        lpReserved: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn GetVolumeNameForVolumeMountPointW(
        lpszVolumeMountPoint: LPCWSTR,
        lpszVolumeName: LPWSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetVolumePathNamesForVolumeNameW(
        lpszVolumeName: LPCWSTR,
        lpszVolumePathNames: LPWCH,
        cchBufferLength: DWORD,
        lpcchReturnLength: PDWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATEFILE2_EXTENDED_PARAMETERS {
    pub dwSize: DWORD,
    pub dwFileAttributes: DWORD,
    pub dwFileFlags: DWORD,
    pub dwSecurityQosFlags: DWORD,
    pub lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    pub hTemplateFile: HANDLE,
}
pub type CREATEFILE2_EXTENDED_PARAMETERS = _CREATEFILE2_EXTENDED_PARAMETERS;
pub type PCREATEFILE2_EXTENDED_PARAMETERS = *mut _CREATEFILE2_EXTENDED_PARAMETERS;
pub type LPCREATEFILE2_EXTENDED_PARAMETERS = *mut _CREATEFILE2_EXTENDED_PARAMETERS;
extern "C" {
    pub fn CreateFile2(
        lpFileName: LPCWSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        dwCreationDisposition: DWORD,
        pCreateExParams: LPCREATEFILE2_EXTENDED_PARAMETERS,
    ) -> HANDLE;
}
extern "C" {
    pub fn SetFileIoOverlappedRange(
        FileHandle: HANDLE,
        OverlappedRangeStart: PUCHAR,
        Length: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCompressedFileSizeA(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn GetCompressedFileSizeW(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STREAM_INFO_LEVELS {
    FindStreamInfoStandard = 0,
    FindStreamInfoMaxInfoLevel = 1,
}
pub use self::_STREAM_INFO_LEVELS as STREAM_INFO_LEVELS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIN32_FIND_STREAM_DATA {
    pub StreamSize: LARGE_INTEGER,
    pub cStreamName: [WCHAR; 296usize],
}
pub type WIN32_FIND_STREAM_DATA = _WIN32_FIND_STREAM_DATA;
pub type PWIN32_FIND_STREAM_DATA = *mut _WIN32_FIND_STREAM_DATA;
extern "C" {
    pub fn FindFirstStreamW(
        lpFileName: LPCWSTR,
        InfoLevel: STREAM_INFO_LEVELS,
        lpFindStreamData: LPVOID,
        dwFlags: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindNextStreamW(hFindStream: HANDLE, lpFindStreamData: LPVOID) -> BOOL;
}
extern "C" {
    pub fn AreFileApisANSI() -> BOOL;
}
extern "C" {
    pub fn GetTempPathA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
    pub fn FindFirstFileNameW(
        lpFileName: LPCWSTR,
        dwFlags: DWORD,
        StringLength: LPDWORD,
        LinkName: PWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindNextFileNameW(hFindStream: HANDLE, StringLength: LPDWORD, LinkName: PWSTR) -> BOOL;
}
extern "C" {
    pub fn GetVolumeInformationA(
        lpRootPathName: LPCSTR,
        lpVolumeNameBuffer: LPSTR,
        nVolumeNameSize: DWORD,
        lpVolumeSerialNumber: LPDWORD,
        lpMaximumComponentLength: LPDWORD,
        lpFileSystemFlags: LPDWORD,
        lpFileSystemNameBuffer: LPSTR,
        nFileSystemNameSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTempFileNameA(
        lpPathName: LPCSTR,
        lpPrefixString: LPCSTR,
        uUnique: UINT,
        lpTempFileName: LPSTR,
    ) -> UINT;
}
extern "C" {
    pub fn SetFileApisToOEM();
}
extern "C" {
    pub fn SetFileApisToANSI();
}
extern "C" {
    pub fn GetTempPath2W(BufferLength: DWORD, Buffer: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn GetTempPath2A(BufferLength: DWORD, Buffer: LPSTR) -> DWORD;
}
extern "C" {
    pub fn CopyFileFromAppW(
        lpExistingFileName: LPCWSTR,
        lpNewFileName: LPCWSTR,
        bFailIfExists: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryFromAppW(
        lpPathName: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateFileFromAppW(
        lpFileName: LPCWSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreationDisposition: DWORD,
        dwFlagsAndAttributes: DWORD,
        hTemplateFile: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateFile2FromAppW(
        lpFileName: LPCWSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        dwCreationDisposition: DWORD,
        pCreateExParams: LPCREATEFILE2_EXTENDED_PARAMETERS,
    ) -> HANDLE;
}
extern "C" {
    pub fn DeleteFileFromAppW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn FindFirstFileExFromAppW(
        lpFileName: LPCWSTR,
        fInfoLevelId: FINDEX_INFO_LEVELS,
        lpFindFileData: LPVOID,
        fSearchOp: FINDEX_SEARCH_OPS,
        lpSearchFilter: LPVOID,
        dwAdditionalFlags: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetFileAttributesExFromAppW(
        lpFileName: LPCWSTR,
        fInfoLevelId: GET_FILEEX_INFO_LEVELS,
        lpFileInformation: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn MoveFileFromAppW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn RemoveDirectoryFromAppW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn ReplaceFileFromAppW(
        lpReplacedFileName: LPCWSTR,
        lpReplacementFileName: LPCWSTR,
        lpBackupFileName: LPCWSTR,
        dwReplaceFlags: DWORD,
        lpExclude: LPVOID,
        lpReserved: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileAttributesFromAppW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;
}
extern "C" {
    pub fn IsDebuggerPresent() -> BOOL;
}
extern "C" {
    pub fn DebugBreak();
}
extern "C" {
    pub fn OutputDebugStringA(lpOutputString: LPCSTR);
}
extern "C" {
    pub fn OutputDebugStringW(lpOutputString: LPCWSTR);
}
extern "C" {
    pub fn ContinueDebugEvent(
        dwProcessId: DWORD,
        dwThreadId: DWORD,
        dwContinueStatus: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WaitForDebugEvent(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;
}
extern "C" {
    pub fn DebugActiveProcess(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
    pub fn DebugActiveProcessStop(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
    pub fn CheckRemoteDebuggerPresent(hProcess: HANDLE, pbDebuggerPresent: PBOOL) -> BOOL;
}
extern "C" {
    pub fn WaitForDebugEventEx(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;
}
extern "C" {
    pub fn EncodePointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
    pub fn DecodePointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
    pub fn EncodeSystemPointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
    pub fn DecodeSystemPointer(Ptr: PVOID) -> PVOID;
}
extern "C" {
    pub fn EncodeRemotePointer(
        ProcessHandle: HANDLE,
        Ptr: PVOID,
        EncodedPtr: *mut PVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn DecodeRemotePointer(
        ProcessHandle: HANDLE,
        Ptr: PVOID,
        DecodedPtr: *mut PVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn Beep(dwFreq: DWORD, dwDuration: DWORD) -> BOOL;
}
extern "C" {
    pub fn CloseHandle(hObject: HANDLE) -> BOOL;
}
extern "C" {
    pub fn DuplicateHandle(
        hSourceProcessHandle: HANDLE,
        hSourceHandle: HANDLE,
        hTargetProcessHandle: HANDLE,
        lpTargetHandle: LPHANDLE,
        dwDesiredAccess: DWORD,
        bInheritHandle: BOOL,
        dwOptions: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CompareObjectHandles(hFirstObjectHandle: HANDLE, hSecondObjectHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetHandleInformation(hObject: HANDLE, lpdwFlags: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;
}
pub type PTOP_LEVEL_EXCEPTION_FILTER =
    ::std::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
pub type LPTOP_LEVEL_EXCEPTION_FILTER = PTOP_LEVEL_EXCEPTION_FILTER;
extern "C" {
    pub fn RaiseException(
        dwExceptionCode: DWORD,
        dwExceptionFlags: DWORD,
        nNumberOfArguments: DWORD,
        lpArguments: *const ULONG_PTR,
    );
}
extern "C" {
    pub fn UnhandledExceptionFilter(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG;
}
extern "C" {
    pub fn SetUnhandledExceptionFilter(
        lpTopLevelExceptionFilter: LPTOP_LEVEL_EXCEPTION_FILTER,
    ) -> LPTOP_LEVEL_EXCEPTION_FILTER;
}
extern "C" {
    pub fn GetLastError() -> DWORD;
}
extern "C" {
    pub fn SetLastError(dwErrCode: DWORD);
}
extern "C" {
    pub fn GetErrorMode() -> UINT;
}
extern "C" {
    pub fn SetErrorMode(uMode: UINT) -> UINT;
}
extern "C" {
    pub fn AddVectoredExceptionHandler(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER)
        -> PVOID;
}
extern "C" {
    pub fn RemoveVectoredExceptionHandler(Handle: PVOID) -> ULONG;
}
extern "C" {
    pub fn AddVectoredContinueHandler(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER) -> PVOID;
}
extern "C" {
    pub fn RemoveVectoredContinueHandler(Handle: PVOID) -> ULONG;
}
extern "C" {
    pub fn RaiseFailFastException(
        pExceptionRecord: PEXCEPTION_RECORD,
        pContextRecord: PCONTEXT,
        dwFlags: DWORD,
    );
}
extern "C" {
    pub fn FatalAppExitA(uAction: UINT, lpMessageText: LPCSTR);
}
extern "C" {
    pub fn FatalAppExitW(uAction: UINT, lpMessageText: LPCWSTR);
}
extern "C" {
    pub fn GetThreadErrorMode() -> DWORD;
}
extern "C" {
    pub fn SetThreadErrorMode(dwNewMode: DWORD, lpOldMode: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn TerminateProcessOnMemoryExhaustion(FailedAllocationSize: SIZE_T);
}
extern "C" {
    pub fn FlsAlloc(lpCallback: PFLS_CALLBACK_FUNCTION) -> DWORD;
}
extern "C" {
    pub fn FlsGetValue(dwFlsIndex: DWORD) -> PVOID;
}
extern "C" {
    pub fn FlsSetValue(dwFlsIndex: DWORD, lpFlsData: PVOID) -> BOOL;
}
extern "C" {
    pub fn FlsFree(dwFlsIndex: DWORD) -> BOOL;
}
extern "C" {
    pub fn IsThreadAFiber() -> BOOL;
}
extern "C" {
    pub fn CreatePipe(
        hReadPipe: PHANDLE,
        hWritePipe: PHANDLE,
        lpPipeAttributes: LPSECURITY_ATTRIBUTES,
        nSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ConnectNamedPipe(hNamedPipe: HANDLE, lpOverlapped: LPOVERLAPPED) -> BOOL;
}
extern "C" {
    pub fn DisconnectNamedPipe(hNamedPipe: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetNamedPipeHandleState(
        hNamedPipe: HANDLE,
        lpMode: LPDWORD,
        lpMaxCollectionCount: LPDWORD,
        lpCollectDataTimeout: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PeekNamedPipe(
        hNamedPipe: HANDLE,
        lpBuffer: LPVOID,
        nBufferSize: DWORD,
        lpBytesRead: LPDWORD,
        lpTotalBytesAvail: LPDWORD,
        lpBytesLeftThisMessage: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn TransactNamedPipe(
        hNamedPipe: HANDLE,
        lpInBuffer: LPVOID,
        nInBufferSize: DWORD,
        lpOutBuffer: LPVOID,
        nOutBufferSize: DWORD,
        lpBytesRead: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateNamedPipeW(
        lpName: LPCWSTR,
        dwOpenMode: DWORD,
        dwPipeMode: DWORD,
        nMaxInstances: DWORD,
        nOutBufferSize: DWORD,
        nInBufferSize: DWORD,
        nDefaultTimeOut: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> HANDLE;
}
extern "C" {
    pub fn WaitNamedPipeW(lpNamedPipeName: LPCWSTR, nTimeOut: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeClientComputerNameW(
        Pipe: HANDLE,
        ClientComputerName: LPWSTR,
        ClientComputerNameLength: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn ImpersonateNamedPipeClient(hNamedPipe: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeInfo(
        hNamedPipe: HANDLE,
        lpFlags: LPDWORD,
        lpOutBufferSize: LPDWORD,
        lpInBufferSize: LPDWORD,
        lpMaxInstances: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeHandleStateW(
        hNamedPipe: HANDLE,
        lpState: LPDWORD,
        lpCurInstances: LPDWORD,
        lpMaxCollectionCount: LPDWORD,
        lpCollectDataTimeout: LPDWORD,
        lpUserName: LPWSTR,
        nMaxUserNameSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CallNamedPipeW(
        lpNamedPipeName: LPCWSTR,
        lpInBuffer: LPVOID,
        nInBufferSize: DWORD,
        lpOutBuffer: LPVOID,
        nOutBufferSize: DWORD,
        lpBytesRead: LPDWORD,
        nTimeOut: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;
}
extern "C" {
    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_SUMMARY {
    pub cb: DWORD,
    pub cbAllocated: SIZE_T,
    pub cbCommitted: SIZE_T,
    pub cbReserved: SIZE_T,
    pub cbMaxReserve: SIZE_T,
}
pub type HEAP_SUMMARY = _HEAP_SUMMARY;
pub type PHEAP_SUMMARY = *mut _HEAP_SUMMARY;
pub type LPHEAP_SUMMARY = PHEAP_SUMMARY;
extern "C" {
    pub fn HeapCreate(flOptions: DWORD, dwInitialSize: SIZE_T, dwMaximumSize: SIZE_T) -> HANDLE;
}
extern "C" {
    pub fn HeapDestroy(hHeap: HANDLE) -> BOOL;
}
extern "C" {
    pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;
}
extern "C" {
    pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;
}
extern "C" {
    pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;
}
extern "C" {
    pub fn HeapSize(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID) -> SIZE_T;
}
extern "C" {
    pub fn GetProcessHeap() -> HANDLE;
}
extern "C" {
    pub fn HeapCompact(hHeap: HANDLE, dwFlags: DWORD) -> SIZE_T;
}
extern "C" {
    pub fn HeapSetInformation(
        HeapHandle: HANDLE,
        HeapInformationClass: HEAP_INFORMATION_CLASS,
        HeapInformation: PVOID,
        HeapInformationLength: SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn HeapValidate(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID) -> BOOL;
}
extern "C" {
    pub fn HeapSummary(hHeap: HANDLE, dwFlags: DWORD, lpSummary: LPHEAP_SUMMARY) -> BOOL;
}
extern "C" {
    pub fn GetProcessHeaps(NumberOfHeaps: DWORD, ProcessHeaps: PHANDLE) -> DWORD;
}
extern "C" {
    pub fn HeapLock(hHeap: HANDLE) -> BOOL;
}
extern "C" {
    pub fn HeapUnlock(hHeap: HANDLE) -> BOOL;
}
extern "C" {
    pub fn HeapWalk(hHeap: HANDLE, lpEntry: LPPROCESS_HEAP_ENTRY) -> BOOL;
}
extern "C" {
    pub fn HeapQueryInformation(
        HeapHandle: HANDLE,
        HeapInformationClass: HEAP_INFORMATION_CLASS,
        HeapInformation: PVOID,
        HeapInformationLength: SIZE_T,
        ReturnLength: PSIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateIoCompletionPort(
        FileHandle: HANDLE,
        ExistingCompletionPort: HANDLE,
        CompletionKey: ULONG_PTR,
        NumberOfConcurrentThreads: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetQueuedCompletionStatus(
        CompletionPort: HANDLE,
        lpNumberOfBytesTransferred: LPDWORD,
        lpCompletionKey: PULONG_PTR,
        lpOverlapped: *mut LPOVERLAPPED,
        dwMilliseconds: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetQueuedCompletionStatusEx(
        CompletionPort: HANDLE,
        lpCompletionPortEntries: LPOVERLAPPED_ENTRY,
        ulCount: ULONG,
        ulNumEntriesRemoved: PULONG,
        dwMilliseconds: DWORD,
        fAlertable: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PostQueuedCompletionStatus(
        CompletionPort: HANDLE,
        dwNumberOfBytesTransferred: DWORD,
        dwCompletionKey: ULONG_PTR,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn DeviceIoControl(
        hDevice: HANDLE,
        dwIoControlCode: DWORD,
        lpInBuffer: LPVOID,
        nInBufferSize: DWORD,
        lpOutBuffer: LPVOID,
        nOutBufferSize: DWORD,
        lpBytesReturned: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn GetOverlappedResult(
        hFile: HANDLE,
        lpOverlapped: LPOVERLAPPED,
        lpNumberOfBytesTransferred: LPDWORD,
        bWait: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CancelIoEx(hFile: HANDLE, lpOverlapped: LPOVERLAPPED) -> BOOL;
}
extern "C" {
    pub fn CancelIo(hFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetOverlappedResultEx(
        hFile: HANDLE,
        lpOverlapped: LPOVERLAPPED,
        lpNumberOfBytesTransferred: LPDWORD,
        dwMilliseconds: DWORD,
        bAlertable: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CancelSynchronousIo(hThread: HANDLE) -> BOOL;
}
pub type SRWLOCK = RTL_SRWLOCK;
pub type PSRWLOCK = *mut RTL_SRWLOCK;
extern "C" {
    pub fn InitializeSRWLock(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn InitializeCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn InitializeCriticalSectionAndSpinCount(
        lpCriticalSection: LPCRITICAL_SECTION,
        dwSpinCount: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitializeCriticalSectionEx(
        lpCriticalSection: LPCRITICAL_SECTION,
        dwSpinCount: DWORD,
        Flags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetCriticalSectionSpinCount(
        lpCriticalSection: LPCRITICAL_SECTION,
        dwSpinCount: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;
}
extern "C" {
    pub fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
pub type INIT_ONCE = RTL_RUN_ONCE;
pub type PINIT_ONCE = PRTL_RUN_ONCE;
pub type LPINIT_ONCE = PRTL_RUN_ONCE;
pub type PINIT_ONCE_FN = ::std::option::Option<
    unsafe extern "C" fn(InitOnce: PINIT_ONCE, Parameter: PVOID, Context: *mut PVOID) -> BOOL,
>;
extern "C" {
    pub fn InitOnceInitialize(InitOnce: PINIT_ONCE);
}
extern "C" {
    pub fn InitOnceExecuteOnce(
        InitOnce: PINIT_ONCE,
        InitFn: PINIT_ONCE_FN,
        Parameter: PVOID,
        Context: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn InitOnceBeginInitialize(
        lpInitOnce: LPINIT_ONCE,
        dwFlags: DWORD,
        fPending: PBOOL,
        lpContext: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) -> BOOL;
}
pub type CONDITION_VARIABLE = RTL_CONDITION_VARIABLE;
pub type PCONDITION_VARIABLE = *mut RTL_CONDITION_VARIABLE;
extern "C" {
    pub fn InitializeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn SleepConditionVariableCS(
        ConditionVariable: PCONDITION_VARIABLE,
        CriticalSection: PCRITICAL_SECTION,
        dwMilliseconds: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SleepConditionVariableSRW(
        ConditionVariable: PCONDITION_VARIABLE,
        SRWLock: PSRWLOCK,
        dwMilliseconds: DWORD,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ResetEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ReleaseSemaphore(
        hSemaphore: HANDLE,
        lReleaseCount: LONG,
        lpPreviousCount: LPLONG,
    ) -> BOOL;
}
extern "C" {
    pub fn ReleaseMutex(hMutex: HANDLE) -> BOOL;
}
extern "C" {
    pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
}
extern "C" {
    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;
}
extern "C" {
    pub fn WaitForSingleObjectEx(hHandle: HANDLE, dwMilliseconds: DWORD, bAlertable: BOOL)
        -> DWORD;
}
extern "C" {
    pub fn WaitForMultipleObjectsEx(
        nCount: DWORD,
        lpHandles: *const HANDLE,
        bWaitAll: BOOL,
        dwMilliseconds: DWORD,
        bAlertable: BOOL,
    ) -> DWORD;
}
extern "C" {
    pub fn CreateMutexA(
        lpMutexAttributes: LPSECURITY_ATTRIBUTES,
        bInitialOwner: BOOL,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateMutexW(
        lpMutexAttributes: LPSECURITY_ATTRIBUTES,
        bInitialOwner: BOOL,
        lpName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenMutexW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn CreateEventA(
        lpEventAttributes: LPSECURITY_ATTRIBUTES,
        bManualReset: BOOL,
        bInitialState: BOOL,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateEventW(
        lpEventAttributes: LPSECURITY_ATTRIBUTES,
        bManualReset: BOOL,
        bInitialState: BOOL,
        lpName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenEventA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn OpenEventW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn OpenSemaphoreW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
pub type PTIMERAPCROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        lpArgToCompletionRoutine: LPVOID,
        dwTimerLowValue: DWORD,
        dwTimerHighValue: DWORD,
    ),
>;
extern "C" {
    pub fn OpenWaitableTimerW(
        dwDesiredAccess: DWORD,
        bInheritHandle: BOOL,
        lpTimerName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn SetWaitableTimerEx(
        hTimer: HANDLE,
        lpDueTime: *const LARGE_INTEGER,
        lPeriod: LONG,
        pfnCompletionRoutine: PTIMERAPCROUTINE,
        lpArgToCompletionRoutine: LPVOID,
        WakeContext: PREASON_CONTEXT,
        TolerableDelay: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetWaitableTimer(
        hTimer: HANDLE,
        lpDueTime: *const LARGE_INTEGER,
        lPeriod: LONG,
        pfnCompletionRoutine: PTIMERAPCROUTINE,
        lpArgToCompletionRoutine: LPVOID,
        fResume: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CancelWaitableTimer(hTimer: HANDLE) -> BOOL;
}
extern "C" {
    pub fn CreateMutexExA(
        lpMutexAttributes: LPSECURITY_ATTRIBUTES,
        lpName: LPCSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateMutexExW(
        lpMutexAttributes: LPSECURITY_ATTRIBUTES,
        lpName: LPCWSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateEventExA(
        lpEventAttributes: LPSECURITY_ATTRIBUTES,
        lpName: LPCSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateEventExW(
        lpEventAttributes: LPSECURITY_ATTRIBUTES,
        lpName: LPCWSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateSemaphoreExW(
        lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES,
        lInitialCount: LONG,
        lMaximumCount: LONG,
        lpName: LPCWSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateWaitableTimerExW(
        lpTimerAttributes: LPSECURITY_ATTRIBUTES,
        lpTimerName: LPCWSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
pub type SYNCHRONIZATION_BARRIER = RTL_BARRIER;
pub type PSYNCHRONIZATION_BARRIER = PRTL_BARRIER;
pub type LPSYNCHRONIZATION_BARRIER = PRTL_BARRIER;
extern "C" {
    pub fn EnterSynchronizationBarrier(
        lpBarrier: LPSYNCHRONIZATION_BARRIER,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitializeSynchronizationBarrier(
        lpBarrier: LPSYNCHRONIZATION_BARRIER,
        lTotalThreads: LONG,
        lSpinCount: LONG,
    ) -> BOOL;
}
extern "C" {
    pub fn DeleteSynchronizationBarrier(lpBarrier: LPSYNCHRONIZATION_BARRIER) -> BOOL;
}
extern "C" {
    pub fn Sleep(dwMilliseconds: DWORD);
}
extern "C" {
    pub fn WaitOnAddress(
        Address: *mut ::std::os::raw::c_void,
        CompareAddress: PVOID,
        AddressSize: SIZE_T,
        dwMilliseconds: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WakeByAddressSingle(Address: PVOID);
}
extern "C" {
    pub fn WakeByAddressAll(Address: PVOID);
}
extern "C" {
    pub fn SignalObjectAndWait(
        hObjectToSignal: HANDLE,
        hObjectToWaitOn: HANDLE,
        dwMilliseconds: DWORD,
        bAlertable: BOOL,
    ) -> DWORD;
}
extern "C" {
    pub fn WaitForMultipleObjects(
        nCount: DWORD,
        lpHandles: *const HANDLE,
        bWaitAll: BOOL,
        dwMilliseconds: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CreateSemaphoreW(
        lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES,
        lInitialCount: LONG,
        lMaximumCount: LONG,
        lpName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateWaitableTimerW(
        lpTimerAttributes: LPSECURITY_ATTRIBUTES,
        bManualReset: BOOL,
        lpTimerName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn InitializeSListHead(ListHead: PSLIST_HEADER);
}
extern "C" {
    pub fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn InterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSLIST_ENTRY,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn InterlockedPushListSListEx(
        ListHead: PSLIST_HEADER,
        List: PSLIST_ENTRY,
        ListEnd: PSLIST_ENTRY,
        Count: ULONG,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn InterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn QueryDepthSList(ListHead: PSLIST_HEADER) -> USHORT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_INFORMATION {
    pub hProcess: HANDLE,
    pub hThread: HANDLE,
    pub dwProcessId: DWORD,
    pub dwThreadId: DWORD,
}
pub type PROCESS_INFORMATION = _PROCESS_INFORMATION;
pub type PPROCESS_INFORMATION = *mut _PROCESS_INFORMATION;
pub type LPPROCESS_INFORMATION = *mut _PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOA {
    pub cb: DWORD,
    pub lpReserved: LPSTR,
    pub lpDesktop: LPSTR,
    pub lpTitle: LPSTR,
    pub dwX: DWORD,
    pub dwY: DWORD,
    pub dwXSize: DWORD,
    pub dwYSize: DWORD,
    pub dwXCountChars: DWORD,
    pub dwYCountChars: DWORD,
    pub dwFillAttribute: DWORD,
    pub dwFlags: DWORD,
    pub wShowWindow: WORD,
    pub cbReserved2: WORD,
    pub lpReserved2: LPBYTE,
    pub hStdInput: HANDLE,
    pub hStdOutput: HANDLE,
    pub hStdError: HANDLE,
}
pub type STARTUPINFOA = _STARTUPINFOA;
pub type LPSTARTUPINFOA = *mut _STARTUPINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOW {
    pub cb: DWORD,
    pub lpReserved: LPWSTR,
    pub lpDesktop: LPWSTR,
    pub lpTitle: LPWSTR,
    pub dwX: DWORD,
    pub dwY: DWORD,
    pub dwXSize: DWORD,
    pub dwYSize: DWORD,
    pub dwXCountChars: DWORD,
    pub dwYCountChars: DWORD,
    pub dwFillAttribute: DWORD,
    pub dwFlags: DWORD,
    pub wShowWindow: WORD,
    pub cbReserved2: WORD,
    pub lpReserved2: LPBYTE,
    pub hStdInput: HANDLE,
    pub hStdOutput: HANDLE,
    pub hStdError: HANDLE,
}
pub type STARTUPINFOW = _STARTUPINFOW;
pub type LPSTARTUPINFOW = *mut _STARTUPINFOW;
pub type STARTUPINFO = STARTUPINFOA;
pub type LPSTARTUPINFO = LPSTARTUPINFOA;
extern "C" {
    pub fn QueueUserAPC(pfnAPC: PAPCFUNC, hThread: HANDLE, dwData: ULONG_PTR) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _QUEUE_USER_APC_FLAGS {
    QUEUE_USER_APC_FLAGS_NONE = 0,
    QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = 1,
    QUEUE_USER_APC_CALLBACK_DATA_CONTEXT = 65536,
}
pub use self::_QUEUE_USER_APC_FLAGS as QUEUE_USER_APC_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _APC_CALLBACK_DATA {
    pub Parameter: ULONG_PTR,
    pub ContextRecord: PCONTEXT,
    pub Reserved0: ULONG_PTR,
    pub Reserved1: ULONG_PTR,
}
pub type APC_CALLBACK_DATA = _APC_CALLBACK_DATA;
pub type PAPC_CALLBACK_DATA = *mut _APC_CALLBACK_DATA;
extern "C" {
    pub fn QueueUserAPC2(
        ApcRoutine: PAPCFUNC,
        Thread: HANDLE,
        Data: ULONG_PTR,
        Flags: QUEUE_USER_APC_FLAGS,
    ) -> BOOL;
}
extern "C" {
    pub fn GetProcessTimes(
        hProcess: HANDLE,
        lpCreationTime: LPFILETIME,
        lpExitTime: LPFILETIME,
        lpKernelTime: LPFILETIME,
        lpUserTime: LPFILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCurrentProcess() -> HANDLE;
}
extern "C" {
    pub fn GetCurrentProcessId() -> DWORD;
}
extern "C" {
    pub fn ExitProcess(uExitCode: UINT) -> !;
}
extern "C" {
    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;
}
extern "C" {
    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SwitchToThread() -> BOOL;
}
extern "C" {
    pub fn CreateThread(
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        dwStackSize: SIZE_T,
        lpStartAddress: LPTHREAD_START_ROUTINE,
        lpParameter: LPVOID,
        dwCreationFlags: DWORD,
        lpThreadId: LPDWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateRemoteThread(
        hProcess: HANDLE,
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        dwStackSize: SIZE_T,
        lpStartAddress: LPTHREAD_START_ROUTINE,
        lpParameter: LPVOID,
        dwCreationFlags: DWORD,
        lpThreadId: LPDWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetCurrentThread() -> HANDLE;
}
extern "C" {
    pub fn GetCurrentThreadId() -> DWORD;
}
extern "C" {
    pub fn OpenThread(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwThreadId: DWORD) -> HANDLE;
}
extern "C" {
    pub fn SetThreadPriority(hThread: HANDLE, nPriority: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn SetThreadPriorityBoost(hThread: HANDLE, bDisablePriorityBoost: BOOL) -> BOOL;
}
extern "C" {
    pub fn GetThreadPriorityBoost(hThread: HANDLE, pDisablePriorityBoost: PBOOL) -> BOOL;
}
extern "C" {
    pub fn GetThreadPriority(hThread: HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExitThread(dwExitCode: DWORD) -> !;
}
extern "C" {
    pub fn TerminateThread(hThread: HANDLE, dwExitCode: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetExitCodeThread(hThread: HANDLE, lpExitCode: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SuspendThread(hThread: HANDLE) -> DWORD;
}
extern "C" {
    pub fn ResumeThread(hThread: HANDLE) -> DWORD;
}
extern "C" {
    pub fn TlsAlloc() -> DWORD;
}
extern "C" {
    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
}
extern "C" {
    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsValue: LPVOID) -> BOOL;
}
extern "C" {
    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
}
extern "C" {
    pub fn CreateProcessA(
        lpApplicationName: LPCSTR,
        lpCommandLine: LPSTR,
        lpProcessAttributes: LPSECURITY_ATTRIBUTES,
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: DWORD,
        lpEnvironment: LPVOID,
        lpCurrentDirectory: LPCSTR,
        lpStartupInfo: LPSTARTUPINFOA,
        lpProcessInformation: LPPROCESS_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateProcessW(
        lpApplicationName: LPCWSTR,
        lpCommandLine: LPWSTR,
        lpProcessAttributes: LPSECURITY_ATTRIBUTES,
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: DWORD,
        lpEnvironment: LPVOID,
        lpCurrentDirectory: LPCWSTR,
        lpStartupInfo: LPSTARTUPINFOW,
        lpProcessInformation: LPPROCESS_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessShutdownParameters(dwLevel: DWORD, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetProcessVersion(ProcessId: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetStartupInfoW(lpStartupInfo: LPSTARTUPINFOW);
}
extern "C" {
    pub fn CreateProcessAsUserW(
        hToken: HANDLE,
        lpApplicationName: LPCWSTR,
        lpCommandLine: LPWSTR,
        lpProcessAttributes: LPSECURITY_ATTRIBUTES,
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: DWORD,
        lpEnvironment: LPVOID,
        lpCurrentDirectory: LPCWSTR,
        lpStartupInfo: LPSTARTUPINFOW,
        lpProcessInformation: LPPROCESS_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCurrentProcessToken() -> HANDLE;
}
extern "C" {
    pub fn GetCurrentThreadToken() -> HANDLE;
}
extern "C" {
    pub fn GetCurrentThreadEffectiveToken() -> HANDLE;
}
extern "C" {
    pub fn SetThreadToken(Thread: PHANDLE, Token: HANDLE) -> BOOL;
}
extern "C" {
    pub fn OpenProcessToken(
        ProcessHandle: HANDLE,
        DesiredAccess: DWORD,
        TokenHandle: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn OpenThreadToken(
        ThreadHandle: HANDLE,
        DesiredAccess: DWORD,
        OpenAsSelf: BOOL,
        TokenHandle: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetPriorityClass(hProcess: HANDLE, dwPriorityClass: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetPriorityClass(hProcess: HANDLE) -> DWORD;
}
extern "C" {
    pub fn SetThreadStackGuarantee(StackSizeInBytes: PULONG) -> BOOL;
}
extern "C" {
    pub fn ProcessIdToSessionId(dwProcessId: DWORD, pSessionId: *mut DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE_LIST {
    _unused: [u8; 0],
}
pub type PPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
pub type LPPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
extern "C" {
    pub fn GetProcessId(Process: HANDLE) -> DWORD;
}
extern "C" {
    pub fn GetThreadId(Thread: HANDLE) -> DWORD;
}
extern "C" {
    pub fn FlushProcessWriteBuffers();
}
extern "C" {
    pub fn GetProcessIdOfThread(Thread: HANDLE) -> DWORD;
}
extern "C" {
    pub fn InitializeProcThreadAttributeList(
        lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
        dwAttributeCount: DWORD,
        dwFlags: DWORD,
        lpSize: PSIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn DeleteProcThreadAttributeList(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST);
}
extern "C" {
    pub fn UpdateProcThreadAttribute(
        lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
        dwFlags: DWORD,
        Attribute: DWORD_PTR,
        lpValue: PVOID,
        cbSize: SIZE_T,
        lpPreviousValue: PVOID,
        lpReturnSize: PSIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessDynamicEHContinuationTargets(
        Process: HANDLE,
        NumberOfTargets: USHORT,
        Targets: PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessDynamicEnforcedCetCompatibleRanges(
        Process: HANDLE,
        NumberOfRanges: USHORT,
        Ranges: PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessAffinityUpdateMode(hProcess: HANDLE, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn QueryProcessAffinityUpdateMode(hProcess: HANDLE, lpdwFlags: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn CreateRemoteThreadEx(
        hProcess: HANDLE,
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        dwStackSize: SIZE_T,
        lpStartAddress: LPTHREAD_START_ROUTINE,
        lpParameter: LPVOID,
        dwCreationFlags: DWORD,
        lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
        lpThreadId: LPDWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetCurrentThreadStackLimits(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR);
}
extern "C" {
    pub fn GetThreadContext(hThread: HANDLE, lpContext: LPCONTEXT) -> BOOL;
}
extern "C" {
    pub fn GetProcessMitigationPolicy(
        hProcess: HANDLE,
        MitigationPolicy: PROCESS_MITIGATION_POLICY,
        lpBuffer: PVOID,
        dwLength: SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadContext(hThread: HANDLE, lpContext: *const CONTEXT) -> BOOL;
}
extern "C" {
    pub fn SetProcessMitigationPolicy(
        MitigationPolicy: PROCESS_MITIGATION_POLICY,
        lpBuffer: PVOID,
        dwLength: SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn FlushInstructionCache(hProcess: HANDLE, lpBaseAddress: LPCVOID, dwSize: SIZE_T) -> BOOL;
}
extern "C" {
    pub fn GetThreadTimes(
        hThread: HANDLE,
        lpCreationTime: LPFILETIME,
        lpExitTime: LPFILETIME,
        lpKernelTime: LPFILETIME,
        lpUserTime: LPFILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) -> HANDLE;
}
extern "C" {
    pub fn IsProcessorFeaturePresent(ProcessorFeature: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetProcessHandleCount(hProcess: HANDLE, pdwHandleCount: PDWORD) -> BOOL;
}
extern "C" {
    pub fn GetCurrentProcessorNumber() -> DWORD;
}
extern "C" {
    pub fn SetThreadIdealProcessorEx(
        hThread: HANDLE,
        lpIdealProcessor: PPROCESSOR_NUMBER,
        lpPreviousIdealProcessor: PPROCESSOR_NUMBER,
    ) -> BOOL;
}
extern "C" {
    pub fn GetThreadIdealProcessorEx(hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER) -> BOOL;
}
extern "C" {
    pub fn GetCurrentProcessorNumberEx(ProcNumber: PPROCESSOR_NUMBER);
}
extern "C" {
    pub fn GetProcessPriorityBoost(hProcess: HANDLE, pDisablePriorityBoost: PBOOL) -> BOOL;
}
extern "C" {
    pub fn SetProcessPriorityBoost(hProcess: HANDLE, bDisablePriorityBoost: BOOL) -> BOOL;
}
extern "C" {
    pub fn GetThreadIOPendingFlag(hThread: HANDLE, lpIOIsPending: PBOOL) -> BOOL;
}
extern "C" {
    pub fn GetSystemTimes(
        lpIdleTime: PFILETIME,
        lpKernelTime: PFILETIME,
        lpUserTime: PFILETIME,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority = 0,
    ThreadAbsoluteCpuPriority = 1,
    ThreadDynamicCodePolicy = 2,
    ThreadPowerThrottling = 3,
    ThreadInformationClassMax = 4,
}
pub use self::_THREAD_INFORMATION_CLASS as THREAD_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PRIORITY_INFORMATION {
    pub MemoryPriority: ULONG,
}
pub type MEMORY_PRIORITY_INFORMATION = _MEMORY_PRIORITY_INFORMATION;
pub type PMEMORY_PRIORITY_INFORMATION = *mut _MEMORY_PRIORITY_INFORMATION;
extern "C" {
    pub fn GetThreadInformation(
        hThread: HANDLE,
        ThreadInformationClass: THREAD_INFORMATION_CLASS,
        ThreadInformation: LPVOID,
        ThreadInformationSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadInformation(
        hThread: HANDLE,
        ThreadInformationClass: THREAD_INFORMATION_CLASS,
        ThreadInformation: LPVOID,
        ThreadInformationSize: DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_POWER_THROTTLING_STATE {
    pub Version: ULONG,
    pub ControlMask: ULONG,
    pub StateMask: ULONG,
}
pub type THREAD_POWER_THROTTLING_STATE = _THREAD_POWER_THROTTLING_STATE;
extern "C" {
    pub fn IsProcessCritical(hProcess: HANDLE, Critical: PBOOL) -> BOOL;
}
extern "C" {
    pub fn SetProtectedPolicy(
        PolicyGuid: LPCGUID,
        PolicyValue: ULONG_PTR,
        OldPolicyValue: PULONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryProtectedPolicy(PolicyGuid: LPCGUID, PolicyValue: PULONG_PTR) -> BOOL;
}
extern "C" {
    pub fn SetThreadIdealProcessor(hThread: HANDLE, dwIdealProcessor: DWORD) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority = 0,
    ProcessMemoryExhaustionInfo = 1,
    ProcessAppMemoryInfo = 2,
    ProcessInPrivateInfo = 3,
    ProcessPowerThrottling = 4,
    ProcessReservedValue1 = 5,
    ProcessTelemetryCoverageInfo = 6,
    ProcessProtectionLevelInfo = 7,
    ProcessLeapSecondInfo = 8,
    ProcessMachineTypeInfo = 9,
    ProcessInformationClassMax = 10,
}
pub use self::_PROCESS_INFORMATION_CLASS as PROCESS_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _APP_MEMORY_INFORMATION {
    pub AvailableCommit: ULONG64,
    pub PrivateCommitUsage: ULONG64,
    pub PeakPrivateCommitUsage: ULONG64,
    pub TotalCommitUsage: ULONG64,
}
pub type APP_MEMORY_INFORMATION = _APP_MEMORY_INFORMATION;
pub type PAPP_MEMORY_INFORMATION = *mut _APP_MEMORY_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MACHINE_ATTRIBUTES {
    UserEnabled = 1,
    KernelEnabled = 2,
    Wow64Container = 4,
}
pub use self::_MACHINE_ATTRIBUTES as MACHINE_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MACHINE_INFORMATION {
    pub ProcessMachine: USHORT,
    pub Res0: USHORT,
    pub MachineAttributes: MACHINE_ATTRIBUTES,
}
pub type PROCESS_MACHINE_INFORMATION = _PROCESS_MACHINE_INFORMATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure = 0,
    PMETypeMax = 1,
}
pub use self::_PROCESS_MEMORY_EXHAUSTION_TYPE as PROCESS_MEMORY_EXHAUSTION_TYPE;
pub type PPROCESS_MEMORY_EXHAUSTION_TYPE = *mut _PROCESS_MEMORY_EXHAUSTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MEMORY_EXHAUSTION_INFO {
    pub Version: USHORT,
    pub Reserved: USHORT,
    pub Type: PROCESS_MEMORY_EXHAUSTION_TYPE,
    pub Value: ULONG_PTR,
}
pub type PROCESS_MEMORY_EXHAUSTION_INFO = _PROCESS_MEMORY_EXHAUSTION_INFO;
pub type PPROCESS_MEMORY_EXHAUSTION_INFO = *mut _PROCESS_MEMORY_EXHAUSTION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_POWER_THROTTLING_STATE {
    pub Version: ULONG,
    pub ControlMask: ULONG,
    pub StateMask: ULONG,
}
pub type PROCESS_POWER_THROTTLING_STATE = _PROCESS_POWER_THROTTLING_STATE;
pub type PPROCESS_POWER_THROTTLING_STATE = *mut _PROCESS_POWER_THROTTLING_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESS_PROTECTION_LEVEL_INFORMATION {
    pub ProtectionLevel: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_LEAP_SECOND_INFO {
    pub Flags: ULONG,
    pub Reserved: ULONG,
}
pub type PROCESS_LEAP_SECOND_INFO = _PROCESS_LEAP_SECOND_INFO;
pub type PPROCESS_LEAP_SECOND_INFO = *mut _PROCESS_LEAP_SECOND_INFO;
extern "C" {
    pub fn SetProcessInformation(
        hProcess: HANDLE,
        ProcessInformationClass: PROCESS_INFORMATION_CLASS,
        ProcessInformation: LPVOID,
        ProcessInformationSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetProcessInformation(
        hProcess: HANDLE,
        ProcessInformationClass: PROCESS_INFORMATION_CLASS,
        ProcessInformation: LPVOID,
        ProcessInformationSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSystemCpuSetInformation(
        Information: PSYSTEM_CPU_SET_INFORMATION,
        BufferLength: ULONG,
        ReturnedLength: PULONG,
        Process: HANDLE,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetProcessDefaultCpuSets(
        Process: HANDLE,
        CpuSetIds: PULONG,
        CpuSetIdCount: ULONG,
        RequiredIdCount: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessDefaultCpuSets(
        Process: HANDLE,
        CpuSetIds: *const ULONG,
        CpuSetIdCount: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetThreadSelectedCpuSets(
        Thread: HANDLE,
        CpuSetIds: PULONG,
        CpuSetIdCount: ULONG,
        RequiredIdCount: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadSelectedCpuSets(
        Thread: HANDLE,
        CpuSetIds: *const ULONG,
        CpuSetIdCount: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateProcessAsUserA(
        hToken: HANDLE,
        lpApplicationName: LPCSTR,
        lpCommandLine: LPSTR,
        lpProcessAttributes: LPSECURITY_ATTRIBUTES,
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: DWORD,
        lpEnvironment: LPVOID,
        lpCurrentDirectory: LPCSTR,
        lpStartupInfo: LPSTARTUPINFOA,
        lpProcessInformation: LPPROCESS_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn GetProcessShutdownParameters(lpdwLevel: LPDWORD, lpdwFlags: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetProcessDefaultCpuSetMasks(
        Process: HANDLE,
        CpuSetMasks: PGROUP_AFFINITY,
        CpuSetMaskCount: USHORT,
        RequiredMaskCount: PUSHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessDefaultCpuSetMasks(
        Process: HANDLE,
        CpuSetMasks: PGROUP_AFFINITY,
        CpuSetMaskCount: USHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetThreadSelectedCpuSetMasks(
        Thread: HANDLE,
        CpuSetMasks: PGROUP_AFFINITY,
        CpuSetMaskCount: USHORT,
        RequiredMaskCount: PUSHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadSelectedCpuSetMasks(
        Thread: HANDLE,
        CpuSetMasks: PGROUP_AFFINITY,
        CpuSetMaskCount: USHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetMachineTypeAttributes(
        Machine: USHORT,
        MachineTypeAttributes: *mut MACHINE_ATTRIBUTES,
    ) -> HRESULT;
}
extern "C" {
    pub fn SetThreadDescription(hThread: HANDLE, lpThreadDescription: PCWSTR) -> HRESULT;
}
extern "C" {
    pub fn GetThreadDescription(hThread: HANDLE, ppszThreadDescription: *mut PWSTR) -> HRESULT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_INFO {
    pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1,
    pub dwPageSize: DWORD,
    pub lpMinimumApplicationAddress: LPVOID,
    pub lpMaximumApplicationAddress: LPVOID,
    pub dwActiveProcessorMask: DWORD_PTR,
    pub dwNumberOfProcessors: DWORD,
    pub dwProcessorType: DWORD,
    pub dwAllocationGranularity: DWORD,
    pub wProcessorLevel: WORD,
    pub wProcessorRevision: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INFO__bindgen_ty_1 {
    pub dwOemId: DWORD,
    pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub wProcessorArchitecture: WORD,
    pub wReserved: WORD,
}
pub type SYSTEM_INFO = _SYSTEM_INFO;
pub type LPSYSTEM_INFO = *mut _SYSTEM_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORYSTATUSEX {
    pub dwLength: DWORD,
    pub dwMemoryLoad: DWORD,
    pub ullTotalPhys: DWORDLONG,
    pub ullAvailPhys: DWORDLONG,
    pub ullTotalPageFile: DWORDLONG,
    pub ullAvailPageFile: DWORDLONG,
    pub ullTotalVirtual: DWORDLONG,
    pub ullAvailVirtual: DWORDLONG,
    pub ullAvailExtendedVirtual: DWORDLONG,
}
pub type MEMORYSTATUSEX = _MEMORYSTATUSEX;
pub type LPMEMORYSTATUSEX = *mut _MEMORYSTATUSEX;
extern "C" {
    pub fn GlobalMemoryStatusEx(lpBuffer: LPMEMORYSTATUSEX) -> BOOL;
}
extern "C" {
    pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
}
extern "C" {
    pub fn GetSystemTime(lpSystemTime: LPSYSTEMTIME);
}
extern "C" {
    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
}
extern "C" {
    pub fn GetLocalTime(lpSystemTime: LPSYSTEMTIME);
}
extern "C" {
    pub fn IsUserCetAvailableInEnvironment(UserCetEnvironment: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetSystemLeapSecondInformation(Enabled: PBOOL, Flags: PDWORD) -> BOOL;
}
extern "C" {
    pub fn GetVersion() -> DWORD;
}
extern "C" {
    pub fn SetLocalTime(lpSystemTime: *const SYSTEMTIME) -> BOOL;
}
extern "C" {
    pub fn GetTickCount() -> DWORD;
}
extern "C" {
    pub fn GetTickCount64() -> ULONGLONG;
}
extern "C" {
    pub fn GetSystemTimeAdjustment(
        lpTimeAdjustment: PDWORD,
        lpTimeIncrement: PDWORD,
        lpTimeAdjustmentDisabled: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSystemTimeAdjustmentPrecise(
        lpTimeAdjustment: PDWORD64,
        lpTimeIncrement: PDWORD64,
        lpTimeAdjustmentDisabled: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSystemDirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn GetWindowsDirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn GetSystemWindowsDirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn GetSystemWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS = 0,
    ComputerNameDnsHostname = 1,
    ComputerNameDnsDomain = 2,
    ComputerNameDnsFullyQualified = 3,
    ComputerNamePhysicalNetBIOS = 4,
    ComputerNamePhysicalDnsHostname = 5,
    ComputerNamePhysicalDnsDomain = 6,
    ComputerNamePhysicalDnsFullyQualified = 7,
    ComputerNameMax = 8,
}
pub use self::_COMPUTER_NAME_FORMAT as COMPUTER_NAME_FORMAT;
extern "C" {
    pub fn GetComputerNameExA(
        NameType: COMPUTER_NAME_FORMAT,
        lpBuffer: LPSTR,
        nSize: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetComputerNameExW(
        NameType: COMPUTER_NAME_FORMAT,
        lpBuffer: LPWSTR,
        nSize: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetComputerNameExW(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn SetSystemTime(lpSystemTime: *const SYSTEMTIME) -> BOOL;
}
extern "C" {
    pub fn GetVersionExA(lpVersionInformation: LPOSVERSIONINFOA) -> BOOL;
}
extern "C" {
    pub fn GetVersionExW(lpVersionInformation: LPOSVERSIONINFOW) -> BOOL;
}
extern "C" {
    pub fn GetLogicalProcessorInformation(
        Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,
        ReturnedLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetLogicalProcessorInformationEx(
        RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
        Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
        ReturnedLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetNativeSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
}
extern "C" {
    pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
}
extern "C" {
    pub fn GetProductInfo(
        dwOSMajorVersion: DWORD,
        dwOSMinorVersion: DWORD,
        dwSpMajorVersion: DWORD,
        dwSpMinorVersion: DWORD,
        pdwReturnedProductType: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetOsSafeBootMode(Flags: PDWORD) -> BOOL;
}
extern "C" {
    pub fn EnumSystemFirmwareTables(
        FirmwareTableProviderSignature: DWORD,
        pFirmwareTableEnumBuffer: PVOID,
        BufferSize: DWORD,
    ) -> UINT;
}
extern "C" {
    pub fn GetSystemFirmwareTable(
        FirmwareTableProviderSignature: DWORD,
        FirmwareTableID: DWORD,
        pFirmwareTableBuffer: PVOID,
        BufferSize: DWORD,
    ) -> UINT;
}
extern "C" {
    pub fn DnsHostnameToComputerNameExW(
        Hostname: LPCWSTR,
        ComputerName: LPWSTR,
        nSize: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPhysicallyInstalledSystemMemory(TotalMemoryInKilobytes: PULONGLONG) -> BOOL;
}
extern "C" {
    pub fn SetComputerNameEx2W(
        NameType: COMPUTER_NAME_FORMAT,
        Flags: DWORD,
        lpBuffer: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSystemTimeAdjustment(dwTimeAdjustment: DWORD, bTimeAdjustmentDisabled: BOOL) -> BOOL;
}
extern "C" {
    pub fn SetSystemTimeAdjustmentPrecise(
        dwTimeAdjustment: DWORD64,
        bTimeAdjustmentDisabled: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn InstallELAMCertificateInfo(ELAMFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetProcessorSystemCycleTime(
        Group: USHORT,
        Buffer: PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION,
        ReturnedLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetOsManufacturingMode(pbEnabled: PBOOL) -> BOOL;
}
extern "C" {
    pub fn GetIntegratedDisplaySize(sizeInInches: *mut f64) -> HRESULT;
}
extern "C" {
    pub fn SetComputerNameA(lpComputerName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetComputerNameW(lpComputerName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn SetComputerNameExA(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn VirtualAlloc(
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        flAllocationType: DWORD,
        flProtect: DWORD,
    ) -> LPVOID;
}
extern "C" {
    pub fn VirtualProtect(
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        flNewProtect: DWORD,
        lpflOldProtect: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn VirtualFree(lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD) -> BOOL;
}
extern "C" {
    pub fn VirtualQuery(
        lpAddress: LPCVOID,
        lpBuffer: PMEMORY_BASIC_INFORMATION,
        dwLength: SIZE_T,
    ) -> SIZE_T;
}
extern "C" {
    pub fn VirtualAllocEx(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        flAllocationType: DWORD,
        flProtect: DWORD,
    ) -> LPVOID;
}
extern "C" {
    pub fn VirtualProtectEx(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        flNewProtect: DWORD,
        lpflOldProtect: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn VirtualQueryEx(
        hProcess: HANDLE,
        lpAddress: LPCVOID,
        lpBuffer: PMEMORY_BASIC_INFORMATION,
        dwLength: SIZE_T,
    ) -> SIZE_T;
}
extern "C" {
    pub fn ReadProcessMemory(
        hProcess: HANDLE,
        lpBaseAddress: LPCVOID,
        lpBuffer: LPVOID,
        nSize: SIZE_T,
        lpNumberOfBytesRead: *mut SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteProcessMemory(
        hProcess: HANDLE,
        lpBaseAddress: LPVOID,
        lpBuffer: LPCVOID,
        nSize: SIZE_T,
        lpNumberOfBytesWritten: *mut SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateFileMappingW(
        hFile: HANDLE,
        lpFileMappingAttributes: LPSECURITY_ATTRIBUTES,
        flProtect: DWORD,
        dwMaximumSizeHigh: DWORD,
        dwMaximumSizeLow: DWORD,
        lpName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenFileMappingW(
        dwDesiredAccess: DWORD,
        bInheritHandle: BOOL,
        lpName: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn MapViewOfFile(
        hFileMappingObject: HANDLE,
        dwDesiredAccess: DWORD,
        dwFileOffsetHigh: DWORD,
        dwFileOffsetLow: DWORD,
        dwNumberOfBytesToMap: SIZE_T,
    ) -> LPVOID;
}
extern "C" {
    pub fn MapViewOfFileEx(
        hFileMappingObject: HANDLE,
        dwDesiredAccess: DWORD,
        dwFileOffsetHigh: DWORD,
        dwFileOffsetLow: DWORD,
        dwNumberOfBytesToMap: SIZE_T,
        lpBaseAddress: LPVOID,
    ) -> LPVOID;
}
extern "C" {
    pub fn VirtualFreeEx(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        dwFreeType: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FlushViewOfFile(lpBaseAddress: LPCVOID, dwNumberOfBytesToFlush: SIZE_T) -> BOOL;
}
extern "C" {
    pub fn UnmapViewOfFile(lpBaseAddress: LPCVOID) -> BOOL;
}
extern "C" {
    pub fn GetLargePageMinimum() -> SIZE_T;
}
extern "C" {
    pub fn GetProcessWorkingSetSize(
        hProcess: HANDLE,
        lpMinimumWorkingSetSize: PSIZE_T,
        lpMaximumWorkingSetSize: PSIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn GetProcessWorkingSetSizeEx(
        hProcess: HANDLE,
        lpMinimumWorkingSetSize: PSIZE_T,
        lpMaximumWorkingSetSize: PSIZE_T,
        Flags: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessWorkingSetSize(
        hProcess: HANDLE,
        dwMinimumWorkingSetSize: SIZE_T,
        dwMaximumWorkingSetSize: SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessWorkingSetSizeEx(
        hProcess: HANDLE,
        dwMinimumWorkingSetSize: SIZE_T,
        dwMaximumWorkingSetSize: SIZE_T,
        Flags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn VirtualLock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;
}
extern "C" {
    pub fn VirtualUnlock(lpAddress: LPVOID, dwSize: SIZE_T) -> BOOL;
}
extern "C" {
    pub fn GetWriteWatch(
        dwFlags: DWORD,
        lpBaseAddress: PVOID,
        dwRegionSize: SIZE_T,
        lpAddresses: *mut PVOID,
        lpdwCount: *mut ULONG_PTR,
        lpdwGranularity: LPDWORD,
    ) -> UINT;
}
extern "C" {
    pub fn ResetWriteWatch(lpBaseAddress: LPVOID, dwRegionSize: SIZE_T) -> UINT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification = 0,
    HighMemoryResourceNotification = 1,
}
pub use self::_MEMORY_RESOURCE_NOTIFICATION_TYPE as MEMORY_RESOURCE_NOTIFICATION_TYPE;
extern "C" {
    pub fn CreateMemoryResourceNotification(
        NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE,
    ) -> HANDLE;
}
extern "C" {
    pub fn QueryMemoryResourceNotification(
        ResourceNotificationHandle: HANDLE,
        ResourceState: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSystemFileCacheSize(
        lpMinimumFileCacheSize: PSIZE_T,
        lpMaximumFileCacheSize: PSIZE_T,
        lpFlags: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSystemFileCacheSize(
        MinimumFileCacheSize: SIZE_T,
        MaximumFileCacheSize: SIZE_T,
        Flags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateFileMappingNumaW(
        hFile: HANDLE,
        lpFileMappingAttributes: LPSECURITY_ATTRIBUTES,
        flProtect: DWORD,
        dwMaximumSizeHigh: DWORD,
        dwMaximumSizeLow: DWORD,
        lpName: LPCWSTR,
        nndPreferred: DWORD,
    ) -> HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_MEMORY_RANGE_ENTRY {
    pub VirtualAddress: PVOID,
    pub NumberOfBytes: SIZE_T,
}
pub type WIN32_MEMORY_RANGE_ENTRY = _WIN32_MEMORY_RANGE_ENTRY;
pub type PWIN32_MEMORY_RANGE_ENTRY = *mut _WIN32_MEMORY_RANGE_ENTRY;
extern "C" {
    pub fn PrefetchVirtualMemory(
        hProcess: HANDLE,
        NumberOfEntries: ULONG_PTR,
        VirtualAddresses: PWIN32_MEMORY_RANGE_ENTRY,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateFileMappingFromApp(
        hFile: HANDLE,
        SecurityAttributes: PSECURITY_ATTRIBUTES,
        PageProtection: ULONG,
        MaximumSize: ULONG64,
        Name: PCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn MapViewOfFileFromApp(
        hFileMappingObject: HANDLE,
        DesiredAccess: ULONG,
        FileOffset: ULONG64,
        NumberOfBytesToMap: SIZE_T,
    ) -> PVOID;
}
extern "C" {
    pub fn UnmapViewOfFileEx(BaseAddress: PVOID, UnmapFlags: ULONG) -> BOOL;
}
extern "C" {
    pub fn AllocateUserPhysicalPages(
        hProcess: HANDLE,
        NumberOfPages: PULONG_PTR,
        PageArray: PULONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeUserPhysicalPages(
        hProcess: HANDLE,
        NumberOfPages: PULONG_PTR,
        PageArray: PULONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn MapUserPhysicalPages(
        VirtualAddress: PVOID,
        NumberOfPages: ULONG_PTR,
        PageArray: PULONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn AllocateUserPhysicalPagesNuma(
        hProcess: HANDLE,
        NumberOfPages: PULONG_PTR,
        PageArray: PULONG_PTR,
        nndPreferred: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn VirtualAllocExNuma(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        flAllocationType: DWORD,
        flProtect: DWORD,
        nndPreferred: DWORD,
    ) -> LPVOID;
}
extern "C" {
    pub fn GetMemoryErrorHandlingCapabilities(Capabilities: PULONG) -> BOOL;
}
pub type PBAD_MEMORY_CALLBACK_ROUTINE = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn RegisterBadMemoryNotification(Callback: PBAD_MEMORY_CALLBACK_ROUTINE) -> PVOID;
}
extern "C" {
    pub fn UnregisterBadMemoryNotification(RegistrationHandle: PVOID) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OFFER_PRIORITY {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow = 2,
    VmOfferPriorityBelowNormal = 3,
    VmOfferPriorityNormal = 4,
}
extern "C" {
    pub fn OfferVirtualMemory(
        VirtualAddress: PVOID,
        Size: SIZE_T,
        Priority: OFFER_PRIORITY,
    ) -> DWORD;
}
extern "C" {
    pub fn ReclaimVirtualMemory(
        VirtualAddress: *const ::std::os::raw::c_void,
        Size: SIZE_T,
    ) -> DWORD;
}
extern "C" {
    pub fn DiscardVirtualMemory(VirtualAddress: PVOID, Size: SIZE_T) -> DWORD;
}
extern "C" {
    pub fn SetProcessValidCallTargets(
        hProcess: HANDLE,
        VirtualAddress: PVOID,
        RegionSize: SIZE_T,
        NumberOfOffsets: ULONG,
        OffsetInformation: PCFG_CALL_TARGET_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessValidCallTargetsForMappedView(
        Process: HANDLE,
        VirtualAddress: PVOID,
        RegionSize: SIZE_T,
        NumberOfOffsets: ULONG,
        OffsetInformation: PCFG_CALL_TARGET_INFO,
        Section: HANDLE,
        ExpectedFileOffset: ULONG64,
    ) -> BOOL;
}
extern "C" {
    pub fn VirtualAllocFromApp(
        BaseAddress: PVOID,
        Size: SIZE_T,
        AllocationType: ULONG,
        Protection: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn VirtualProtectFromApp(
        Address: PVOID,
        Size: SIZE_T,
        NewProtection: ULONG,
        OldProtection: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn OpenFileMappingFromApp(
        DesiredAccess: ULONG,
        InheritHandle: BOOL,
        Name: PCWSTR,
    ) -> HANDLE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WIN32_MEMORY_INFORMATION_CLASS {
    MemoryRegionInfo = 0,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WIN32_MEMORY_REGION_INFORMATION {
    pub AllocationBase: PVOID,
    pub AllocationProtect: ULONG,
    pub __bindgen_anon_1: WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1,
    pub RegionSize: SIZE_T,
    pub CommitSize: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1 {
    pub Flags: ULONG,
    pub __bindgen_anon_1: WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl WIN32_MEMORY_REGION_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Private(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Private(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MappedDataFile(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MappedDataFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MappedImage(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MappedImage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MappedPageFile(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MappedPageFile(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MappedPhysical(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MappedPhysical(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectMapped(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectMapped(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Private: ULONG,
        MappedDataFile: ULONG,
        MappedImage: ULONG,
        MappedPageFile: ULONG,
        MappedPhysical: ULONG,
        DirectMapped: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Private: u32 = unsafe { ::std::mem::transmute(Private) };
            Private as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MappedDataFile: u32 = unsafe { ::std::mem::transmute(MappedDataFile) };
            MappedDataFile as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MappedImage: u32 = unsafe { ::std::mem::transmute(MappedImage) };
            MappedImage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MappedPageFile: u32 = unsafe { ::std::mem::transmute(MappedPageFile) };
            MappedPageFile as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MappedPhysical: u32 = unsafe { ::std::mem::transmute(MappedPhysical) };
            MappedPhysical as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DirectMapped: u32 = unsafe { ::std::mem::transmute(DirectMapped) };
            DirectMapped as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn QueryVirtualMemoryInformation(
        Process: HANDLE,
        VirtualAddress: *const ::std::os::raw::c_void,
        MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS,
        MemoryInformation: PVOID,
        MemoryInformationSize: SIZE_T,
        ReturnSize: PSIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn MapViewOfFileNuma2(
        FileMappingHandle: HANDLE,
        ProcessHandle: HANDLE,
        Offset: ULONG64,
        BaseAddress: PVOID,
        ViewSize: SIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        PreferredNode: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn MapViewOfFile2(
        FileMappingHandle: HANDLE,
        ProcessHandle: HANDLE,
        Offset: ULONG64,
        BaseAddress: PVOID,
        ViewSize: SIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn UnmapViewOfFile2(Process: HANDLE, BaseAddress: PVOID, UnmapFlags: ULONG) -> BOOL;
}
extern "C" {
    pub fn VirtualUnlockEx(Process: HANDLE, Address: LPVOID, Size: SIZE_T) -> BOOL;
}
extern "C" {
    pub fn VirtualAlloc2(
        Process: HANDLE,
        BaseAddress: PVOID,
        Size: SIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        ExtendedParameters: *mut MEM_EXTENDED_PARAMETER,
        ParameterCount: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn MapViewOfFile3(
        FileMapping: HANDLE,
        Process: HANDLE,
        BaseAddress: PVOID,
        Offset: ULONG64,
        ViewSize: SIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        ExtendedParameters: *mut MEM_EXTENDED_PARAMETER,
        ParameterCount: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn VirtualAlloc2FromApp(
        Process: HANDLE,
        BaseAddress: PVOID,
        Size: SIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        ExtendedParameters: *mut MEM_EXTENDED_PARAMETER,
        ParameterCount: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn MapViewOfFile3FromApp(
        FileMapping: HANDLE,
        Process: HANDLE,
        BaseAddress: PVOID,
        Offset: ULONG64,
        ViewSize: SIZE_T,
        AllocationType: ULONG,
        PageProtection: ULONG,
        ExtendedParameters: *mut MEM_EXTENDED_PARAMETER,
        ParameterCount: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn CreateFileMapping2(
        File: HANDLE,
        SecurityAttributes: *mut SECURITY_ATTRIBUTES,
        DesiredAccess: ULONG,
        PageProtection: ULONG,
        AllocationAttributes: ULONG,
        MaximumSize: ULONG64,
        Name: PCWSTR,
        ExtendedParameters: *mut MEM_EXTENDED_PARAMETER,
        ParameterCount: ULONG,
    ) -> HANDLE;
}
extern "C" {
    pub fn AllocateUserPhysicalPages2(
        ObjectHandle: HANDLE,
        NumberOfPages: PULONG_PTR,
        PageArray: PULONG_PTR,
        ExtendedParameters: PMEM_EXTENDED_PARAMETER,
        ExtendedParameterCount: ULONG,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WIN32_MEMORY_PARTITION_INFORMATION_CLASS {
    MemoryPartitionInfo = 0,
    MemoryPartitionDedicatedMemoryInfo = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WIN32_MEMORY_PARTITION_INFORMATION {
    pub Flags: ULONG,
    pub NumaNode: ULONG,
    pub Channel: ULONG,
    pub NumberOfNumaNodes: ULONG,
    pub ResidentAvailablePages: ULONG64,
    pub CommittedPages: ULONG64,
    pub CommitLimit: ULONG64,
    pub PeakCommitment: ULONG64,
    pub TotalNumberOfPages: ULONG64,
    pub AvailablePages: ULONG64,
    pub ZeroPages: ULONG64,
    pub FreePages: ULONG64,
    pub StandbyPages: ULONG64,
    pub Reserved: [ULONG64; 16usize],
    pub MaximumCommitLimit: ULONG64,
    pub Reserved2: ULONG64,
    pub PartitionId: ULONG,
}
extern "C" {
    pub fn OpenDedicatedMemoryPartition(
        Partition: HANDLE,
        DedicatedMemoryTypeId: ULONG64,
        DesiredAccess: ACCESS_MASK,
        InheritHandle: BOOL,
    ) -> HANDLE;
}
extern "C" {
    pub fn QueryPartitionInformation(
        Partition: HANDLE,
        PartitionInformationClass: WIN32_MEMORY_PARTITION_INFORMATION_CLASS,
        PartitionInformation: PVOID,
        PartitionInformationLength: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn IsEnclaveTypeSupported(flEnclaveType: DWORD) -> BOOL;
}
extern "C" {
    pub fn CreateEnclave(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        dwInitialCommitment: SIZE_T,
        flEnclaveType: DWORD,
        lpEnclaveInformation: LPCVOID,
        dwInfoLength: DWORD,
        lpEnclaveError: LPDWORD,
    ) -> LPVOID;
}
extern "C" {
    pub fn LoadEnclaveData(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        lpBuffer: LPCVOID,
        nSize: SIZE_T,
        flProtect: DWORD,
        lpPageInformation: LPCVOID,
        dwInfoLength: DWORD,
        lpNumberOfBytesWritten: PSIZE_T,
        lpEnclaveError: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitializeEnclave(
        hProcess: HANDLE,
        lpAddress: LPVOID,
        lpEnclaveInformation: LPCVOID,
        dwInfoLength: DWORD,
        lpEnclaveError: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LoadEnclaveImageA(lpEnclaveAddress: LPVOID, lpImageName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn LoadEnclaveImageW(lpEnclaveAddress: LPVOID, lpImageName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn CallEnclave(
        lpRoutine: LPENCLAVE_ROUTINE,
        lpParameter: LPVOID,
        fWaitForThread: BOOL,
        lpReturnValue: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn TerminateEnclave(lpAddress: LPVOID, fWait: BOOL) -> BOOL;
}
extern "C" {
    pub fn DeleteEnclave(lpAddress: LPVOID) -> BOOL;
}
extern "C" {
    pub fn QueueUserWorkItem(
        Function: LPTHREAD_START_ROUTINE,
        Context: PVOID,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn UnregisterWaitEx(WaitHandle: HANDLE, CompletionEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn CreateTimerQueue() -> HANDLE;
}
extern "C" {
    pub fn CreateTimerQueueTimer(
        phNewTimer: PHANDLE,
        TimerQueue: HANDLE,
        Callback: WAITORTIMERCALLBACK,
        Parameter: PVOID,
        DueTime: DWORD,
        Period: DWORD,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn ChangeTimerQueueTimer(
        TimerQueue: HANDLE,
        Timer: HANDLE,
        DueTime: ULONG,
        Period: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn DeleteTimerQueueTimer(
        TimerQueue: HANDLE,
        Timer: HANDLE,
        CompletionEvent: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn DeleteTimerQueue(TimerQueue: HANDLE) -> BOOL;
}
extern "C" {
    pub fn DeleteTimerQueueEx(TimerQueue: HANDLE, CompletionEvent: HANDLE) -> BOOL;
}
pub type PTP_WIN32_IO_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Instance: PTP_CALLBACK_INSTANCE,
        Context: PVOID,
        Overlapped: PVOID,
        IoResult: ULONG,
        NumberOfBytesTransferred: ULONG_PTR,
        Io: PTP_IO,
    ),
>;
extern "C" {
    pub fn CreateThreadpool(reserved: PVOID) -> PTP_POOL;
}
extern "C" {
    pub fn SetThreadpoolThreadMaximum(ptpp: PTP_POOL, cthrdMost: DWORD);
}
extern "C" {
    pub fn SetThreadpoolThreadMinimum(ptpp: PTP_POOL, cthrdMic: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetThreadpoolStackInformation(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION)
        -> BOOL;
}
extern "C" {
    pub fn QueryThreadpoolStackInformation(
        ptpp: PTP_POOL,
        ptpsi: PTP_POOL_STACK_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn CloseThreadpool(ptpp: PTP_POOL);
}
extern "C" {
    pub fn CreateThreadpoolCleanupGroup() -> PTP_CLEANUP_GROUP;
}
extern "C" {
    pub fn CloseThreadpoolCleanupGroupMembers(
        ptpcg: PTP_CLEANUP_GROUP,
        fCancelPendingCallbacks: BOOL,
        pvCleanupContext: PVOID,
    );
}
extern "C" {
    pub fn CloseThreadpoolCleanupGroup(ptpcg: PTP_CLEANUP_GROUP);
}
extern "C" {
    pub fn SetEventWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, evt: HANDLE);
}
extern "C" {
    pub fn ReleaseSemaphoreWhenCallbackReturns(
        pci: PTP_CALLBACK_INSTANCE,
        sem: HANDLE,
        crel: DWORD,
    );
}
extern "C" {
    pub fn ReleaseMutexWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, mut_: HANDLE);
}
extern "C" {
    pub fn LeaveCriticalSectionWhenCallbackReturns(
        pci: PTP_CALLBACK_INSTANCE,
        pcs: PCRITICAL_SECTION,
    );
}
extern "C" {
    pub fn FreeLibraryWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, mod_: HMODULE);
}
extern "C" {
    pub fn CallbackMayRunLong(pci: PTP_CALLBACK_INSTANCE) -> BOOL;
}
extern "C" {
    pub fn DisassociateCurrentThreadFromCallback(pci: PTP_CALLBACK_INSTANCE);
}
extern "C" {
    pub fn TrySubmitThreadpoolCallback(
        pfns: PTP_SIMPLE_CALLBACK,
        pv: PVOID,
        pcbe: PTP_CALLBACK_ENVIRON,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateThreadpoolWork(
        pfnwk: PTP_WORK_CALLBACK,
        pv: PVOID,
        pcbe: PTP_CALLBACK_ENVIRON,
    ) -> PTP_WORK;
}
extern "C" {
    pub fn SubmitThreadpoolWork(pwk: PTP_WORK);
}
extern "C" {
    pub fn WaitForThreadpoolWorkCallbacks(pwk: PTP_WORK, fCancelPendingCallbacks: BOOL);
}
extern "C" {
    pub fn CloseThreadpoolWork(pwk: PTP_WORK);
}
extern "C" {
    pub fn CreateThreadpoolTimer(
        pfnti: PTP_TIMER_CALLBACK,
        pv: PVOID,
        pcbe: PTP_CALLBACK_ENVIRON,
    ) -> PTP_TIMER;
}
extern "C" {
    pub fn SetThreadpoolTimer(
        pti: PTP_TIMER,
        pftDueTime: PFILETIME,
        msPeriod: DWORD,
        msWindowLength: DWORD,
    );
}
extern "C" {
    pub fn IsThreadpoolTimerSet(pti: PTP_TIMER) -> BOOL;
}
extern "C" {
    pub fn WaitForThreadpoolTimerCallbacks(pti: PTP_TIMER, fCancelPendingCallbacks: BOOL);
}
extern "C" {
    pub fn CloseThreadpoolTimer(pti: PTP_TIMER);
}
extern "C" {
    pub fn CreateThreadpoolWait(
        pfnwa: PTP_WAIT_CALLBACK,
        pv: PVOID,
        pcbe: PTP_CALLBACK_ENVIRON,
    ) -> PTP_WAIT;
}
extern "C" {
    pub fn SetThreadpoolWait(pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME);
}
extern "C" {
    pub fn WaitForThreadpoolWaitCallbacks(pwa: PTP_WAIT, fCancelPendingCallbacks: BOOL);
}
extern "C" {
    pub fn CloseThreadpoolWait(pwa: PTP_WAIT);
}
extern "C" {
    pub fn CreateThreadpoolIo(
        fl: HANDLE,
        pfnio: PTP_WIN32_IO_CALLBACK,
        pv: PVOID,
        pcbe: PTP_CALLBACK_ENVIRON,
    ) -> PTP_IO;
}
extern "C" {
    pub fn StartThreadpoolIo(pio: PTP_IO);
}
extern "C" {
    pub fn CancelThreadpoolIo(pio: PTP_IO);
}
extern "C" {
    pub fn WaitForThreadpoolIoCallbacks(pio: PTP_IO, fCancelPendingCallbacks: BOOL);
}
extern "C" {
    pub fn CloseThreadpoolIo(pio: PTP_IO);
}
extern "C" {
    pub fn SetThreadpoolTimerEx(
        pti: PTP_TIMER,
        pftDueTime: PFILETIME,
        msPeriod: DWORD,
        msWindowLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadpoolWaitEx(
        pwa: PTP_WAIT,
        h: HANDLE,
        pftTimeout: PFILETIME,
        Reserved: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn IsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE, Result: PBOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PCWSTR,
    pub BaseIoSize: ULONG,
    pub ControlFlags: ULONG,
}
extern "C" {
    pub fn CreateJobObjectW(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn FreeMemoryJobObject(Buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn OpenJobObjectW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;
}
extern "C" {
    pub fn TerminateJobObject(hJob: HANDLE, uExitCode: UINT) -> BOOL;
}
extern "C" {
    pub fn SetInformationJobObject(
        hJob: HANDLE,
        JobObjectInformationClass: JOBOBJECTINFOCLASS,
        lpJobObjectInformation: LPVOID,
        cbJobObjectInformationLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetIoRateControlInformationJobObject(
        hJob: HANDLE,
        IoRateControlInfo: *mut JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
    ) -> DWORD;
}
extern "C" {
    pub fn QueryInformationJobObject(
        hJob: HANDLE,
        JobObjectInformationClass: JOBOBJECTINFOCLASS,
        lpJobObjectInformation: LPVOID,
        cbJobObjectInformationLength: DWORD,
        lpReturnLength: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryIoRateControlInformationJobObject(
        hJob: HANDLE,
        VolumeName: PCWSTR,
        InfoBlocks: *mut *mut JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
        InfoBlockCount: *mut ULONG,
    ) -> DWORD;
}
extern "C" {
    pub fn Wow64EnableWow64FsRedirection(Wow64FsEnableRedirection: BOOLEAN) -> BOOLEAN;
}
extern "C" {
    pub fn Wow64DisableWow64FsRedirection(OldValue: *mut PVOID) -> BOOL;
}
extern "C" {
    pub fn Wow64RevertWow64FsRedirection(OlValue: PVOID) -> BOOL;
}
extern "C" {
    pub fn IsWow64Process(hProcess: HANDLE, Wow64Process: PBOOL) -> BOOL;
}
extern "C" {
    pub fn GetSystemWow64DirectoryA(lpBuffer: LPSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn GetSystemWow64DirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;
}
extern "C" {
    pub fn Wow64SetThreadDefaultGuestMachine(Machine: USHORT) -> USHORT;
}
extern "C" {
    pub fn IsWow64Process2(
        hProcess: HANDLE,
        pProcessMachine: *mut USHORT,
        pNativeMachine: *mut USHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSystemWow64Directory2A(
        lpBuffer: LPSTR,
        uSize: UINT,
        ImageFileMachineType: WORD,
    ) -> UINT;
}
extern "C" {
    pub fn GetSystemWow64Directory2W(
        lpBuffer: LPWSTR,
        uSize: UINT,
        ImageFileMachineType: WORD,
    ) -> UINT;
}
extern "C" {
    pub fn IsWow64GuestMachineSupported(
        WowGuestMachine: USHORT,
        MachineIsSupported: *mut BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn Wow64GetThreadContext(hThread: HANDLE, lpContext: PWOW64_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn Wow64SetThreadContext(hThread: HANDLE, lpContext: *const WOW64_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn Wow64SuspendThread(hThread: HANDLE) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMUILANG {
    pub NumOfEnumUILang: ULONG,
    pub SizeOfEnumUIBuffer: ULONG,
    pub pEnumUIBuffer: *mut LANGID,
}
pub type ENUMUILANG = tagENUMUILANG;
pub type PENUMUILANG = *mut tagENUMUILANG;
pub type ENUMRESLANGPROCA = ::std::option::Option<
    unsafe extern "C" fn(
        hModule: HMODULE,
        lpType: LPCSTR,
        lpName: LPCSTR,
        wLanguage: WORD,
        lParam: LONG_PTR,
    ) -> BOOL,
>;
pub type ENUMRESLANGPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpName: LPCWSTR,
        wLanguage: WORD,
        lParam: LONG_PTR,
    ) -> BOOL,
>;
pub type ENUMRESNAMEPROCA = ::std::option::Option<
    unsafe extern "C" fn(hModule: HMODULE, lpType: LPCSTR, lpName: LPSTR, lParam: LONG_PTR) -> BOOL,
>;
pub type ENUMRESNAMEPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpName: LPWSTR,
        lParam: LONG_PTR,
    ) -> BOOL,
>;
pub type ENUMRESTYPEPROCA = ::std::option::Option<
    unsafe extern "C" fn(hModule: HMODULE, lpType: LPSTR, lParam: LONG_PTR) -> BOOL,
>;
pub type ENUMRESTYPEPROCW = ::std::option::Option<
    unsafe extern "C" fn(hModule: HMODULE, lpType: LPWSTR, lParam: LONG_PTR) -> BOOL,
>;
extern "C" {
    pub fn DisableThreadLibraryCalls(hLibModule: HMODULE) -> BOOL;
}
extern "C" {
    pub fn FindResourceExW(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpName: LPCWSTR,
        wLanguage: WORD,
    ) -> HRSRC;
}
extern "C" {
    pub fn FindStringOrdinal(
        dwFindStringOrdinalFlags: DWORD,
        lpStringSource: LPCWSTR,
        cchSource: ::std::os::raw::c_int,
        lpStringValue: LPCWSTR,
        cchValue: ::std::os::raw::c_int,
        bIgnoreCase: BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeLibrary(hLibModule: HMODULE) -> BOOL;
}
extern "C" {
    pub fn FreeLibraryAndExitThread(hLibModule: HMODULE, dwExitCode: DWORD) -> !;
}
extern "C" {
    pub fn FreeResource(hResData: HGLOBAL) -> BOOL;
}
extern "C" {
    pub fn GetModuleFileNameA(hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetModuleFileNameW(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;
}
extern "C" {
    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
}
pub type PGET_MODULE_HANDLE_EXA = ::std::option::Option<
    unsafe extern "C" fn(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: *mut HMODULE) -> BOOL,
>;
pub type PGET_MODULE_HANDLE_EXW = ::std::option::Option<
    unsafe extern "C" fn(dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: *mut HMODULE) -> BOOL,
>;
extern "C" {
    pub fn GetModuleHandleExA(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: *mut HMODULE)
        -> BOOL;
}
extern "C" {
    pub fn GetModuleHandleExW(
        dwFlags: DWORD,
        lpModuleName: LPCWSTR,
        phModule: *mut HMODULE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> FARPROC;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REDIRECTION_FUNCTION_DESCRIPTOR {
    pub DllName: PCSTR,
    pub FunctionName: PCSTR,
    pub RedirectionTarget: PVOID,
}
pub type REDIRECTION_FUNCTION_DESCRIPTOR = _REDIRECTION_FUNCTION_DESCRIPTOR;
pub type PREDIRECTION_FUNCTION_DESCRIPTOR = *mut _REDIRECTION_FUNCTION_DESCRIPTOR;
pub type PCREDIRECTION_FUNCTION_DESCRIPTOR = *const REDIRECTION_FUNCTION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REDIRECTION_DESCRIPTOR {
    pub Version: ULONG,
    pub FunctionCount: ULONG,
    pub Redirections: PCREDIRECTION_FUNCTION_DESCRIPTOR,
}
pub type REDIRECTION_DESCRIPTOR = _REDIRECTION_DESCRIPTOR;
pub type PREDIRECTION_DESCRIPTOR = *mut _REDIRECTION_DESCRIPTOR;
pub type PCREDIRECTION_DESCRIPTOR = *const REDIRECTION_DESCRIPTOR;
extern "C" {
    pub fn LoadLibraryExA(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD) -> HMODULE;
}
extern "C" {
    pub fn LoadLibraryExW(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD) -> HMODULE;
}
extern "C" {
    pub fn LoadResource(hModule: HMODULE, hResInfo: HRSRC) -> HGLOBAL;
}
extern "C" {
    pub fn LoadStringA(
        hInstance: HINSTANCE,
        uID: UINT,
        lpBuffer: LPSTR,
        cchBufferMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LoadStringW(
        hInstance: HINSTANCE,
        uID: UINT,
        lpBuffer: LPWSTR,
        cchBufferMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LockResource(hResData: HGLOBAL) -> LPVOID;
}
extern "C" {
    pub fn SizeofResource(hModule: HMODULE, hResInfo: HRSRC) -> DWORD;
}
pub type DLL_DIRECTORY_COOKIE = PVOID;
pub type PDLL_DIRECTORY_COOKIE = *mut PVOID;
extern "C" {
    pub fn AddDllDirectory(NewDirectory: PCWSTR) -> DLL_DIRECTORY_COOKIE;
}
extern "C" {
    pub fn RemoveDllDirectory(Cookie: DLL_DIRECTORY_COOKIE) -> BOOL;
}
extern "C" {
    pub fn SetDefaultDllDirectories(DirectoryFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn EnumResourceLanguagesExA(
        hModule: HMODULE,
        lpType: LPCSTR,
        lpName: LPCSTR,
        lpEnumFunc: ENUMRESLANGPROCA,
        lParam: LONG_PTR,
        dwFlags: DWORD,
        LangId: LANGID,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceLanguagesExW(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpName: LPCWSTR,
        lpEnumFunc: ENUMRESLANGPROCW,
        lParam: LONG_PTR,
        dwFlags: DWORD,
        LangId: LANGID,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceNamesExA(
        hModule: HMODULE,
        lpType: LPCSTR,
        lpEnumFunc: ENUMRESNAMEPROCA,
        lParam: LONG_PTR,
        dwFlags: DWORD,
        LangId: LANGID,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceNamesExW(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpEnumFunc: ENUMRESNAMEPROCW,
        lParam: LONG_PTR,
        dwFlags: DWORD,
        LangId: LANGID,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceTypesExA(
        hModule: HMODULE,
        lpEnumFunc: ENUMRESTYPEPROCA,
        lParam: LONG_PTR,
        dwFlags: DWORD,
        LangId: LANGID,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceTypesExW(
        hModule: HMODULE,
        lpEnumFunc: ENUMRESTYPEPROCW,
        lParam: LONG_PTR,
        dwFlags: DWORD,
        LangId: LANGID,
    ) -> BOOL;
}
extern "C" {
    pub fn FindResourceW(hModule: HMODULE, lpName: LPCWSTR, lpType: LPCWSTR) -> HRSRC;
}
extern "C" {
    pub fn LoadLibraryA(lpLibFileName: LPCSTR) -> HMODULE;
}
extern "C" {
    pub fn LoadLibraryW(lpLibFileName: LPCWSTR) -> HMODULE;
}
extern "C" {
    pub fn EnumResourceNamesW(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpEnumFunc: ENUMRESNAMEPROCW,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceNamesA(
        hModule: HMODULE,
        lpType: LPCSTR,
        lpEnumFunc: ENUMRESNAMEPROCA,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheck(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        PrivilegeSet: PPRIVILEGE_SET,
        PrivilegeSetLength: LPDWORD,
        GrantedAccess: LPDWORD,
        AccessStatus: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckAndAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPWSTR,
        ObjectName: LPWSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        DesiredAccess: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccess: LPDWORD,
        AccessStatus: LPBOOL,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByType(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        PrivilegeSet: PPRIVILEGE_SET,
        PrivilegeSetLength: LPDWORD,
        GrantedAccess: LPDWORD,
        AccessStatus: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeResultList(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        PrivilegeSet: PPRIVILEGE_SET,
        PrivilegeSetLength: LPDWORD,
        GrantedAccessList: LPDWORD,
        AccessStatusList: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeAndAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPCWSTR,
        ObjectName: LPCWSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: DWORD,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccess: LPDWORD,
        AccessStatus: LPBOOL,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeResultListAndAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPCWSTR,
        ObjectName: LPCWSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: DWORD,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccessList: LPDWORD,
        AccessStatusList: LPDWORD,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeResultListAndAuditAlarmByHandleW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        ClientToken: HANDLE,
        ObjectTypeName: LPCWSTR,
        ObjectName: LPCWSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: DWORD,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccessList: LPDWORD,
        AccessStatusList: LPDWORD,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAccessAllowedAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AccessMask: DWORD,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAccessAllowedAceEx(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAccessAllowedObjectAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        ObjectTypeGuid: *mut GUID,
        InheritedObjectTypeGuid: *mut GUID,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAccessDeniedAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AccessMask: DWORD,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAccessDeniedAceEx(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAccessDeniedObjectAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        ObjectTypeGuid: *mut GUID,
        InheritedObjectTypeGuid: *mut GUID,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        dwStartingAceIndex: DWORD,
        pAceList: LPVOID,
        nAceListLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAuditAccessAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        dwAccessMask: DWORD,
        pSid: PSID,
        bAuditSuccess: BOOL,
        bAuditFailure: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAuditAccessAceEx(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        dwAccessMask: DWORD,
        pSid: PSID,
        bAuditSuccess: BOOL,
        bAuditFailure: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AddAuditAccessObjectAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        ObjectTypeGuid: *mut GUID,
        InheritedObjectTypeGuid: *mut GUID,
        pSid: PSID,
        bAuditSuccess: BOOL,
        bAuditFailure: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AddMandatoryAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        MandatoryPolicy: DWORD,
        pLabelSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddResourceAttributeAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        pSid: PSID,
        pAttributeInfo: PCLAIM_SECURITY_ATTRIBUTES_INFORMATION,
        pReturnLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddScopedPolicyIDAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AccessMask: DWORD,
        pSid: PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AdjustTokenGroups(
        TokenHandle: HANDLE,
        ResetToDefault: BOOL,
        NewState: PTOKEN_GROUPS,
        BufferLength: DWORD,
        PreviousState: PTOKEN_GROUPS,
        ReturnLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AdjustTokenPrivileges(
        TokenHandle: HANDLE,
        DisableAllPrivileges: BOOL,
        NewState: PTOKEN_PRIVILEGES,
        BufferLength: DWORD,
        PreviousState: PTOKEN_PRIVILEGES,
        ReturnLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AllocateAndInitializeSid(
        pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
        nSubAuthorityCount: BYTE,
        nSubAuthority0: DWORD,
        nSubAuthority1: DWORD,
        nSubAuthority2: DWORD,
        nSubAuthority3: DWORD,
        nSubAuthority4: DWORD,
        nSubAuthority5: DWORD,
        nSubAuthority6: DWORD,
        nSubAuthority7: DWORD,
        pSid: *mut PSID,
    ) -> BOOL;
}
extern "C" {
    pub fn AllocateLocallyUniqueId(Luid: PLUID) -> BOOL;
}
extern "C" {
    pub fn AreAllAccessesGranted(GrantedAccess: DWORD, DesiredAccess: DWORD) -> BOOL;
}
extern "C" {
    pub fn AreAnyAccessesGranted(GrantedAccess: DWORD, DesiredAccess: DWORD) -> BOOL;
}
extern "C" {
    pub fn CheckTokenMembership(TokenHandle: HANDLE, SidToCheck: PSID, IsMember: PBOOL) -> BOOL;
}
extern "C" {
    pub fn CheckTokenCapability(
        TokenHandle: HANDLE,
        CapabilitySidToCheck: PSID,
        HasCapability: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetAppContainerAce(
        Acl: PACL,
        StartingAceIndex: DWORD,
        AppContainerAce: *mut PVOID,
        AppContainerAceIndex: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CheckTokenMembershipEx(
        TokenHandle: HANDLE,
        SidToCheck: PSID,
        Flags: DWORD,
        IsMember: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ConvertToAutoInheritPrivateObjectSecurity(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        CurrentSecurityDescriptor: PSECURITY_DESCRIPTOR,
        NewSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        ObjectType: *mut GUID,
        IsDirectoryObject: BOOLEAN,
        GenericMapping: PGENERIC_MAPPING,
    ) -> BOOL;
}
extern "C" {
    pub fn CopySid(nDestinationSidLength: DWORD, pDestinationSid: PSID, pSourceSid: PSID) -> BOOL;
}
extern "C" {
    pub fn CreatePrivateObjectSecurity(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        CreatorDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        IsDirectoryObject: BOOL,
        Token: HANDLE,
        GenericMapping: PGENERIC_MAPPING,
    ) -> BOOL;
}
extern "C" {
    pub fn CreatePrivateObjectSecurityEx(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        CreatorDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        ObjectType: *mut GUID,
        IsContainerObject: BOOL,
        AutoInheritFlags: ULONG,
        Token: HANDLE,
        GenericMapping: PGENERIC_MAPPING,
    ) -> BOOL;
}
extern "C" {
    pub fn CreatePrivateObjectSecurityWithMultipleInheritance(
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        CreatorDescriptor: PSECURITY_DESCRIPTOR,
        NewDescriptor: *mut PSECURITY_DESCRIPTOR,
        ObjectTypes: *mut *mut GUID,
        GuidCount: ULONG,
        IsContainerObject: BOOL,
        AutoInheritFlags: ULONG,
        Token: HANDLE,
        GenericMapping: PGENERIC_MAPPING,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateRestrictedToken(
        ExistingTokenHandle: HANDLE,
        Flags: DWORD,
        DisableSidCount: DWORD,
        SidsToDisable: PSID_AND_ATTRIBUTES,
        DeletePrivilegeCount: DWORD,
        PrivilegesToDelete: PLUID_AND_ATTRIBUTES,
        RestrictedSidCount: DWORD,
        SidsToRestrict: PSID_AND_ATTRIBUTES,
        NewTokenHandle: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateWellKnownSid(
        WellKnownSidType: WELL_KNOWN_SID_TYPE,
        DomainSid: PSID,
        pSid: PSID,
        cbSid: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EqualDomainSid(pSid1: PSID, pSid2: PSID, pfEqual: *mut BOOL) -> BOOL;
}
extern "C" {
    pub fn DeleteAce(pAcl: PACL, dwAceIndex: DWORD) -> BOOL;
}
extern "C" {
    pub fn DestroyPrivateObjectSecurity(ObjectDescriptor: *mut PSECURITY_DESCRIPTOR) -> BOOL;
}
extern "C" {
    pub fn DuplicateToken(
        ExistingTokenHandle: HANDLE,
        ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
        DuplicateTokenHandle: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn DuplicateTokenEx(
        hExistingToken: HANDLE,
        dwDesiredAccess: DWORD,
        lpTokenAttributes: LPSECURITY_ATTRIBUTES,
        ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
        TokenType: TOKEN_TYPE,
        phNewToken: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn EqualPrefixSid(pSid1: PSID, pSid2: PSID) -> BOOL;
}
extern "C" {
    pub fn EqualSid(pSid1: PSID, pSid2: PSID) -> BOOL;
}
extern "C" {
    pub fn FindFirstFreeAce(pAcl: PACL, pAce: *mut LPVOID) -> BOOL;
}
extern "C" {
    pub fn FreeSid(pSid: PSID) -> PVOID;
}
extern "C" {
    pub fn GetAce(pAcl: PACL, dwAceIndex: DWORD, pAce: *mut LPVOID) -> BOOL;
}
extern "C" {
    pub fn GetAclInformation(
        pAcl: PACL,
        pAclInformation: LPVOID,
        nAclInformationLength: DWORD,
        dwAclInformationClass: ACL_INFORMATION_CLASS,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileSecurityW(
        lpFileName: LPCWSTR,
        RequestedInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        nLength: DWORD,
        lpnLengthNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetKernelObjectSecurity(
        Handle: HANDLE,
        RequestedInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        nLength: DWORD,
        lpnLengthNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetLengthSid(pSid: PSID) -> DWORD;
}
extern "C" {
    pub fn GetPrivateObjectSecurity(
        ObjectDescriptor: PSECURITY_DESCRIPTOR,
        SecurityInformation: SECURITY_INFORMATION,
        ResultantDescriptor: PSECURITY_DESCRIPTOR,
        DescriptorLength: DWORD,
        ReturnLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSecurityDescriptorControl(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pControl: PSECURITY_DESCRIPTOR_CONTROL,
        lpdwRevision: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSecurityDescriptorDacl(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        lpbDaclPresent: LPBOOL,
        pDacl: *mut PACL,
        lpbDaclDefaulted: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSecurityDescriptorGroup(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pGroup: *mut PSID,
        lpbGroupDefaulted: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSecurityDescriptorLength(pSecurityDescriptor: PSECURITY_DESCRIPTOR) -> DWORD;
}
extern "C" {
    pub fn GetSecurityDescriptorOwner(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pOwner: *mut PSID,
        lpbOwnerDefaulted: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSecurityDescriptorRMControl(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        RMControl: PUCHAR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetSecurityDescriptorSacl(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        lpbSaclPresent: LPBOOL,
        pSacl: *mut PACL,
        lpbSaclDefaulted: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSidIdentifierAuthority(pSid: PSID) -> PSID_IDENTIFIER_AUTHORITY;
}
extern "C" {
    pub fn GetSidLengthRequired(nSubAuthorityCount: UCHAR) -> DWORD;
}
extern "C" {
    pub fn GetSidSubAuthority(pSid: PSID, nSubAuthority: DWORD) -> PDWORD;
}
extern "C" {
    pub fn GetSidSubAuthorityCount(pSid: PSID) -> PUCHAR;
}
extern "C" {
    pub fn GetTokenInformation(
        TokenHandle: HANDLE,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: LPVOID,
        TokenInformationLength: DWORD,
        ReturnLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetWindowsAccountDomainSid(
        pSid: PSID,
        pDomainSid: PSID,
        cbDomainSid: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ImpersonateAnonymousToken(ThreadHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ImpersonateLoggedOnUser(hToken: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ImpersonateSelf(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL) -> BOOL;
}
extern "C" {
    pub fn InitializeAcl(pAcl: PACL, nAclLength: DWORD, dwAclRevision: DWORD) -> BOOL;
}
extern "C" {
    pub fn InitializeSecurityDescriptor(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        dwRevision: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitializeSid(
        Sid: PSID,
        pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY,
        nSubAuthorityCount: BYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn IsTokenRestricted(TokenHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn IsValidAcl(pAcl: PACL) -> BOOL;
}
extern "C" {
    pub fn IsValidSecurityDescriptor(pSecurityDescriptor: PSECURITY_DESCRIPTOR) -> BOOL;
}
extern "C" {
    pub fn IsValidSid(pSid: PSID) -> BOOL;
}
extern "C" {
    pub fn IsWellKnownSid(pSid: PSID, WellKnownSidType: WELL_KNOWN_SID_TYPE) -> BOOL;
}
extern "C" {
    pub fn MakeAbsoluteSD(
        pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
        lpdwAbsoluteSecurityDescriptorSize: LPDWORD,
        pDacl: PACL,
        lpdwDaclSize: LPDWORD,
        pSacl: PACL,
        lpdwSaclSize: LPDWORD,
        pOwner: PSID,
        lpdwOwnerSize: LPDWORD,
        pPrimaryGroup: PSID,
        lpdwPrimaryGroupSize: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn MakeSelfRelativeSD(
        pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR,
        lpdwBufferLength: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn MapGenericMask(AccessMask: PDWORD, GenericMapping: PGENERIC_MAPPING);
}
extern "C" {
    pub fn ObjectCloseAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        GenerateOnClose: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectDeleteAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        GenerateOnClose: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectOpenAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPWSTR,
        ObjectName: LPWSTR,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        GrantedAccess: DWORD,
        Privileges: PPRIVILEGE_SET,
        ObjectCreation: BOOL,
        AccessGranted: BOOL,
        GenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectPrivilegeAuditAlarmW(
        SubsystemName: LPCWSTR,
        HandleId: LPVOID,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegeCheck(
        ClientToken: HANDLE,
        RequiredPrivileges: PPRIVILEGE_SET,
        pfResult: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegedServiceAuditAlarmW(
        SubsystemName: LPCWSTR,
        ServiceName: LPCWSTR,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn QuerySecurityAccessMask(
        SecurityInformation: SECURITY_INFORMATION,
        DesiredAccess: LPDWORD,
    );
}
extern "C" {
    pub fn RevertToSelf() -> BOOL;
}
extern "C" {
    pub fn SetAclInformation(
        pAcl: PACL,
        pAclInformation: LPVOID,
        nAclInformationLength: DWORD,
        dwAclInformationClass: ACL_INFORMATION_CLASS,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileSecurityW(
        lpFileName: LPCWSTR,
        SecurityInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetKernelObjectSecurity(
        Handle: HANDLE,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetPrivateObjectSecurity(
        SecurityInformation: SECURITY_INFORMATION,
        ModificationDescriptor: PSECURITY_DESCRIPTOR,
        ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        GenericMapping: PGENERIC_MAPPING,
        Token: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetPrivateObjectSecurityEx(
        SecurityInformation: SECURITY_INFORMATION,
        ModificationDescriptor: PSECURITY_DESCRIPTOR,
        ObjectsSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        AutoInheritFlags: ULONG,
        GenericMapping: PGENERIC_MAPPING,
        Token: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSecurityAccessMask(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD);
}
extern "C" {
    pub fn SetSecurityDescriptorControl(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        ControlBitsOfInterest: SECURITY_DESCRIPTOR_CONTROL,
        ControlBitsToSet: SECURITY_DESCRIPTOR_CONTROL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSecurityDescriptorDacl(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        bDaclPresent: BOOL,
        pDacl: PACL,
        bDaclDefaulted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSecurityDescriptorGroup(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pGroup: PSID,
        bGroupDefaulted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSecurityDescriptorOwner(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        pOwner: PSID,
        bOwnerDefaulted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSecurityDescriptorRMControl(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        RMControl: PUCHAR,
    ) -> DWORD;
}
extern "C" {
    pub fn SetSecurityDescriptorSacl(
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        bSaclPresent: BOOL,
        pSacl: PACL,
        bSaclDefaulted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetTokenInformation(
        TokenHandle: HANDLE,
        TokenInformationClass: TOKEN_INFORMATION_CLASS,
        TokenInformation: LPVOID,
        TokenInformationLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetCachedSigningLevel(
        SourceFiles: PHANDLE,
        SourceFileCount: ULONG,
        Flags: ULONG,
        TargetFile: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCachedSigningLevel(
        File: HANDLE,
        Flags: PULONG,
        SigningLevel: PULONG,
        Thumbprint: PUCHAR,
        ThumbprintSize: PULONG,
        ThumbprintAlgorithm: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn CveEventWrite(CveId: PCWSTR, AdditionalDetails: PCWSTR) -> LONG;
}
extern "C" {
    pub fn DeriveCapabilitySidsFromName(
        CapName: LPCWSTR,
        CapabilityGroupSids: *mut *mut PSID,
        CapabilityGroupSidCount: *mut DWORD,
        CapabilitySids: *mut *mut PSID,
        CapabilitySidCount: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CreatePrivateNamespaceW(
        lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES,
        lpBoundaryDescriptor: LPVOID,
        lpAliasPrefix: LPCWSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenPrivateNamespaceW(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn ClosePrivateNamespace(Handle: HANDLE, Flags: ULONG) -> BOOLEAN;
}
extern "C" {
    pub fn CreateBoundaryDescriptorW(Name: LPCWSTR, Flags: ULONG) -> HANDLE;
}
extern "C" {
    pub fn AddSIDToBoundaryDescriptor(BoundaryDescriptor: *mut HANDLE, RequiredSid: PSID) -> BOOL;
}
extern "C" {
    pub fn DeleteBoundaryDescriptor(BoundaryDescriptor: HANDLE);
}
extern "C" {
    pub fn GetNumaHighestNodeNumber(HighestNodeNumber: PULONG) -> BOOL;
}
extern "C" {
    pub fn GetNumaNodeProcessorMaskEx(Node: USHORT, ProcessorMask: PGROUP_AFFINITY) -> BOOL;
}
extern "C" {
    pub fn GetNumaNodeProcessorMask2(
        NodeNumber: USHORT,
        ProcessorMasks: PGROUP_AFFINITY,
        ProcessorMaskCount: USHORT,
        RequiredMaskCount: PUSHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetNumaProximityNodeEx(ProximityId: ULONG, NodeNumber: PUSHORT) -> BOOL;
}
extern "C" {
    pub fn GetProcessGroupAffinity(
        hProcess: HANDLE,
        GroupCount: PUSHORT,
        GroupArray: PUSHORT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetThreadGroupAffinity(hThread: HANDLE, GroupAffinity: PGROUP_AFFINITY) -> BOOL;
}
extern "C" {
    pub fn SetThreadGroupAffinity(
        hThread: HANDLE,
        GroupAffinity: *const GROUP_AFFINITY,
        PreviousGroupAffinity: PGROUP_AFFINITY,
    ) -> BOOL;
}
extern "C" {
    pub fn GetAppContainerNamedObjectPath(
        Token: HANDLE,
        AppContainerSid: PSID,
        ObjectPathLength: ULONG,
        ObjectPath: LPWSTR,
        ReturnLength: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryThreadCycleTime(ThreadHandle: HANDLE, CycleTime: PULONG64) -> BOOL;
}
extern "C" {
    pub fn QueryProcessCycleTime(ProcessHandle: HANDLE, CycleTime: PULONG64) -> BOOL;
}
extern "C" {
    pub fn QueryIdleProcessorCycleTime(
        BufferLength: PULONG,
        ProcessorIdleCycleTime: PULONG64,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryIdleProcessorCycleTimeEx(
        Group: USHORT,
        BufferLength: PULONG,
        ProcessorIdleCycleTime: PULONG64,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryInterruptTimePrecise(lpInterruptTimePrecise: PULONGLONG);
}
extern "C" {
    pub fn QueryUnbiasedInterruptTimePrecise(lpUnbiasedInterruptTimePrecise: PULONGLONG);
}
extern "C" {
    pub fn QueryInterruptTime(lpInterruptTime: PULONGLONG);
}
extern "C" {
    pub fn QueryUnbiasedInterruptTime(UnbiasedTime: PULONGLONG) -> BOOL;
}
extern "C" {
    pub fn QueryAuxiliaryCounterFrequency(lpAuxiliaryCounterFrequency: PULONGLONG) -> HRESULT;
}
extern "C" {
    pub fn ConvertAuxiliaryCounterToPerformanceCounter(
        ullAuxiliaryCounterValue: ULONGLONG,
        lpPerformanceCounterValue: PULONGLONG,
        lpConversionError: PULONGLONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ConvertPerformanceCounterToAuxiliaryCounter(
        ullPerformanceCounterValue: ULONGLONG,
        lpAuxiliaryCounterValue: PULONGLONG,
        lpConversionError: PULONGLONG,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FILE_WRITE_FLAGS {
    FILE_WRITE_FLAGS_NONE = 0,
    FILE_WRITE_FLAGS_WRITE_THROUGH = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FILE_FLUSH_MODE {
    FILE_FLUSH_DEFAULT = 0,
    FILE_FLUSH_DATA = 1,
    FILE_FLUSH_MIN_METADATA = 2,
    FILE_FLUSH_NO_SYNC = 3,
}
pub type PFIBER_START_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(lpFiberParameter: LPVOID)>;
pub type LPFIBER_START_ROUTINE = PFIBER_START_ROUTINE;
pub type PFIBER_CALLOUT_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(lpParameter: LPVOID) -> LPVOID>;
pub type LPLDT_ENTRY = LPVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMMPROP {
    pub wPacketLength: WORD,
    pub wPacketVersion: WORD,
    pub dwServiceMask: DWORD,
    pub dwReserved1: DWORD,
    pub dwMaxTxQueue: DWORD,
    pub dwMaxRxQueue: DWORD,
    pub dwMaxBaud: DWORD,
    pub dwProvSubType: DWORD,
    pub dwProvCapabilities: DWORD,
    pub dwSettableParams: DWORD,
    pub dwSettableBaud: DWORD,
    pub wSettableData: WORD,
    pub wSettableStopParity: WORD,
    pub dwCurrentTxQueue: DWORD,
    pub dwCurrentRxQueue: DWORD,
    pub dwProvSpec1: DWORD,
    pub dwProvSpec2: DWORD,
    pub wcProvChar: [WCHAR; 1usize],
}
pub type COMMPROP = _COMMPROP;
pub type LPCOMMPROP = *mut _COMMPROP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMSTAT {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cbInQue: DWORD,
    pub cbOutQue: DWORD,
}
impl _COMSTAT {
    #[inline]
    pub fn fCtsHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fCtsHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDsrHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDsrHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fRlsdHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fRlsdHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fXoffHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fXoffHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fXoffSent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fXoffSent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fEof(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fEof(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fTxim(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fTxim(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fReserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_fReserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fCtsHold: DWORD,
        fDsrHold: DWORD,
        fRlsdHold: DWORD,
        fXoffHold: DWORD,
        fXoffSent: DWORD,
        fEof: DWORD,
        fTxim: DWORD,
        fReserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fCtsHold: u32 = unsafe { ::std::mem::transmute(fCtsHold) };
            fCtsHold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fDsrHold: u32 = unsafe { ::std::mem::transmute(fDsrHold) };
            fDsrHold as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fRlsdHold: u32 = unsafe { ::std::mem::transmute(fRlsdHold) };
            fRlsdHold as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fXoffHold: u32 = unsafe { ::std::mem::transmute(fXoffHold) };
            fXoffHold as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fXoffSent: u32 = unsafe { ::std::mem::transmute(fXoffSent) };
            fXoffSent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fEof: u32 = unsafe { ::std::mem::transmute(fEof) };
            fEof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fTxim: u32 = unsafe { ::std::mem::transmute(fTxim) };
            fTxim as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let fReserved: u32 = unsafe { ::std::mem::transmute(fReserved) };
            fReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type COMSTAT = _COMSTAT;
pub type LPCOMSTAT = *mut _COMSTAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DCB {
    pub DCBlength: DWORD,
    pub BaudRate: DWORD,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub wReserved: WORD,
    pub XonLim: WORD,
    pub XoffLim: WORD,
    pub ByteSize: BYTE,
    pub Parity: BYTE,
    pub StopBits: BYTE,
    pub XonChar: ::std::os::raw::c_char,
    pub XoffChar: ::std::os::raw::c_char,
    pub ErrorChar: ::std::os::raw::c_char,
    pub EofChar: ::std::os::raw::c_char,
    pub EvtChar: ::std::os::raw::c_char,
    pub wReserved1: WORD,
}
impl _DCB {
    #[inline]
    pub fn fBinary(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fBinary(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fParity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fParity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fOutxCtsFlow(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fOutxCtsFlow(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fOutxDsrFlow(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fOutxDsrFlow(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDtrControl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fDtrControl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fDsrSensitivity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDsrSensitivity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fTXContinueOnXoff(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fTXContinueOnXoff(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fOutX(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fOutX(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fInX(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fInX(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fErrorChar(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fErrorChar(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fNull(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fNull(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fRtsControl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fRtsControl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fAbortOnError(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fAbortOnError(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDummy2(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_fDummy2(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fBinary: DWORD,
        fParity: DWORD,
        fOutxCtsFlow: DWORD,
        fOutxDsrFlow: DWORD,
        fDtrControl: DWORD,
        fDsrSensitivity: DWORD,
        fTXContinueOnXoff: DWORD,
        fOutX: DWORD,
        fInX: DWORD,
        fErrorChar: DWORD,
        fNull: DWORD,
        fRtsControl: DWORD,
        fAbortOnError: DWORD,
        fDummy2: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fBinary: u32 = unsafe { ::std::mem::transmute(fBinary) };
            fBinary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fParity: u32 = unsafe { ::std::mem::transmute(fParity) };
            fParity as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fOutxCtsFlow: u32 = unsafe { ::std::mem::transmute(fOutxCtsFlow) };
            fOutxCtsFlow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fOutxDsrFlow: u32 = unsafe { ::std::mem::transmute(fOutxDsrFlow) };
            fOutxDsrFlow as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fDtrControl: u32 = unsafe { ::std::mem::transmute(fDtrControl) };
            fDtrControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fDsrSensitivity: u32 = unsafe { ::std::mem::transmute(fDsrSensitivity) };
            fDsrSensitivity as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fTXContinueOnXoff: u32 = unsafe { ::std::mem::transmute(fTXContinueOnXoff) };
            fTXContinueOnXoff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fOutX: u32 = unsafe { ::std::mem::transmute(fOutX) };
            fOutX as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fInX: u32 = unsafe { ::std::mem::transmute(fInX) };
            fInX as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let fErrorChar: u32 = unsafe { ::std::mem::transmute(fErrorChar) };
            fErrorChar as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fNull: u32 = unsafe { ::std::mem::transmute(fNull) };
            fNull as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let fRtsControl: u32 = unsafe { ::std::mem::transmute(fRtsControl) };
            fRtsControl as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fAbortOnError: u32 = unsafe { ::std::mem::transmute(fAbortOnError) };
            fAbortOnError as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let fDummy2: u32 = unsafe { ::std::mem::transmute(fDummy2) };
            fDummy2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DCB = _DCB;
pub type LPDCB = *mut _DCB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMMTIMEOUTS {
    pub ReadIntervalTimeout: DWORD,
    pub ReadTotalTimeoutMultiplier: DWORD,
    pub ReadTotalTimeoutConstant: DWORD,
    pub WriteTotalTimeoutMultiplier: DWORD,
    pub WriteTotalTimeoutConstant: DWORD,
}
pub type COMMTIMEOUTS = _COMMTIMEOUTS;
pub type LPCOMMTIMEOUTS = *mut _COMMTIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMMCONFIG {
    pub dwSize: DWORD,
    pub wVersion: WORD,
    pub wReserved: WORD,
    pub dcb: DCB,
    pub dwProviderSubType: DWORD,
    pub dwProviderOffset: DWORD,
    pub dwProviderSize: DWORD,
    pub wcProviderData: [WCHAR; 1usize],
}
pub type COMMCONFIG = _COMMCONFIG;
pub type LPCOMMCONFIG = *mut _COMMCONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORYSTATUS {
    pub dwLength: DWORD,
    pub dwMemoryLoad: DWORD,
    pub dwTotalPhys: SIZE_T,
    pub dwAvailPhys: SIZE_T,
    pub dwTotalPageFile: SIZE_T,
    pub dwAvailPageFile: SIZE_T,
    pub dwTotalVirtual: SIZE_T,
    pub dwAvailVirtual: SIZE_T,
}
pub type MEMORYSTATUS = _MEMORYSTATUS;
pub type LPMEMORYSTATUS = *mut _MEMORYSTATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JIT_DEBUG_INFO {
    pub dwSize: DWORD,
    pub dwProcessorArchitecture: DWORD,
    pub dwThreadID: DWORD,
    pub dwReserved0: DWORD,
    pub lpExceptionAddress: ULONG64,
    pub lpExceptionRecord: ULONG64,
    pub lpContextRecord: ULONG64,
}
pub type JIT_DEBUG_INFO = _JIT_DEBUG_INFO;
pub type LPJIT_DEBUG_INFO = *mut _JIT_DEBUG_INFO;
pub type JIT_DEBUG_INFO32 = JIT_DEBUG_INFO;
pub type LPJIT_DEBUG_INFO32 = *mut JIT_DEBUG_INFO;
pub type JIT_DEBUG_INFO64 = JIT_DEBUG_INFO;
pub type LPJIT_DEBUG_INFO64 = *mut JIT_DEBUG_INFO;
pub type LPEXCEPTION_RECORD = PEXCEPTION_RECORD;
pub type LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OFSTRUCT {
    pub cBytes: BYTE,
    pub fFixedDisk: BYTE,
    pub nErrCode: WORD,
    pub Reserved1: WORD,
    pub Reserved2: WORD,
    pub szPathName: [CHAR; 128usize],
}
pub type OFSTRUCT = _OFSTRUCT;
pub type LPOFSTRUCT = *mut _OFSTRUCT;
pub type POFSTRUCT = *mut _OFSTRUCT;
extern "C" {
    pub fn WinMain(
        hInstance: HINSTANCE,
        hPrevInstance: HINSTANCE,
        lpCmdLine: LPSTR,
        nShowCmd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wWinMain(
        hInstance: HINSTANCE,
        hPrevInstance: HINSTANCE,
        lpCmdLine: LPWSTR,
        nShowCmd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GlobalAlloc(uFlags: UINT, dwBytes: SIZE_T) -> HGLOBAL;
}
extern "C" {
    pub fn GlobalReAlloc(hMem: HGLOBAL, dwBytes: SIZE_T, uFlags: UINT) -> HGLOBAL;
}
extern "C" {
    pub fn GlobalSize(hMem: HGLOBAL) -> SIZE_T;
}
extern "C" {
    pub fn GlobalUnlock(hMem: HGLOBAL) -> BOOL;
}
extern "C" {
    pub fn GlobalLock(hMem: HGLOBAL) -> LPVOID;
}
extern "C" {
    pub fn GlobalFlags(hMem: HGLOBAL) -> UINT;
}
extern "C" {
    pub fn GlobalHandle(pMem: LPCVOID) -> HGLOBAL;
}
extern "C" {
    pub fn GlobalFree(hMem: HGLOBAL) -> HGLOBAL;
}
extern "C" {
    pub fn GlobalCompact(dwMinFree: DWORD) -> SIZE_T;
}
extern "C" {
    pub fn GlobalFix(hMem: HGLOBAL);
}
extern "C" {
    pub fn GlobalUnfix(hMem: HGLOBAL);
}
extern "C" {
    pub fn GlobalWire(hMem: HGLOBAL) -> LPVOID;
}
extern "C" {
    pub fn GlobalUnWire(hMem: HGLOBAL) -> BOOL;
}
extern "C" {
    pub fn GlobalMemoryStatus(lpBuffer: LPMEMORYSTATUS);
}
extern "C" {
    pub fn LocalAlloc(uFlags: UINT, uBytes: SIZE_T) -> HLOCAL;
}
extern "C" {
    pub fn LocalReAlloc(hMem: HLOCAL, uBytes: SIZE_T, uFlags: UINT) -> HLOCAL;
}
extern "C" {
    pub fn LocalLock(hMem: HLOCAL) -> LPVOID;
}
extern "C" {
    pub fn LocalHandle(pMem: LPCVOID) -> HLOCAL;
}
extern "C" {
    pub fn LocalUnlock(hMem: HLOCAL) -> BOOL;
}
extern "C" {
    pub fn LocalSize(hMem: HLOCAL) -> SIZE_T;
}
extern "C" {
    pub fn LocalFlags(hMem: HLOCAL) -> UINT;
}
extern "C" {
    pub fn LocalFree(hMem: HLOCAL) -> HLOCAL;
}
extern "C" {
    pub fn LocalShrink(hMem: HLOCAL, cbNewSize: UINT) -> SIZE_T;
}
extern "C" {
    pub fn LocalCompact(uMinFree: UINT) -> SIZE_T;
}
extern "C" {
    pub fn GetBinaryTypeA(lpApplicationName: LPCSTR, lpBinaryType: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetBinaryTypeW(lpApplicationName: LPCWSTR, lpBinaryType: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetShortPathNameA(lpszLongPath: LPCSTR, lpszShortPath: LPSTR, cchBuffer: DWORD)
        -> DWORD;
}
extern "C" {
    pub fn GetLongPathNameTransactedA(
        lpszShortPath: LPCSTR,
        lpszLongPath: LPSTR,
        cchBuffer: DWORD,
        hTransaction: HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn GetLongPathNameTransactedW(
        lpszShortPath: LPCWSTR,
        lpszLongPath: LPWSTR,
        cchBuffer: DWORD,
        hTransaction: HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn GetProcessAffinityMask(
        hProcess: HANDLE,
        lpProcessAffinityMask: PDWORD_PTR,
        lpSystemAffinityMask: PDWORD_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessAffinityMask(hProcess: HANDLE, dwProcessAffinityMask: DWORD_PTR) -> BOOL;
}
extern "C" {
    pub fn GetProcessIoCounters(hProcess: HANDLE, lpIoCounters: PIO_COUNTERS) -> BOOL;
}
extern "C" {
    pub fn FatalExit(ExitCode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SetEnvironmentStringsA(NewEnvironment: LPCH) -> BOOL;
}
extern "C" {
    pub fn SwitchToFiber(lpFiber: LPVOID);
}
extern "C" {
    pub fn DeleteFiber(lpFiber: LPVOID);
}
extern "C" {
    pub fn ConvertFiberToThread() -> BOOL;
}
extern "C" {
    pub fn CreateFiberEx(
        dwStackCommitSize: SIZE_T,
        dwStackReserveSize: SIZE_T,
        dwFlags: DWORD,
        lpStartAddress: LPFIBER_START_ROUTINE,
        lpParameter: LPVOID,
    ) -> LPVOID;
}
extern "C" {
    pub fn ConvertThreadToFiberEx(lpParameter: LPVOID, dwFlags: DWORD) -> LPVOID;
}
extern "C" {
    pub fn CreateFiber(
        dwStackSize: SIZE_T,
        lpStartAddress: LPFIBER_START_ROUTINE,
        lpParameter: LPVOID,
    ) -> LPVOID;
}
extern "C" {
    pub fn ConvertThreadToFiber(lpParameter: LPVOID) -> LPVOID;
}
pub type PUMS_CONTEXT = *mut ::std::os::raw::c_void;
pub type PUMS_COMPLETION_LIST = *mut ::std::os::raw::c_void;
pub use self::_RTL_UMS_THREAD_INFO_CLASS as UMS_THREAD_INFO_CLASS;
pub type PUMS_THREAD_INFO_CLASS = *mut _RTL_UMS_THREAD_INFO_CLASS;
pub use self::_RTL_UMS_SCHEDULER_REASON as UMS_SCHEDULER_REASON;
pub type PUMS_SCHEDULER_ENTRY_POINT = PRTL_UMS_SCHEDULER_ENTRY_POINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UMS_SCHEDULER_STARTUP_INFO {
    pub UmsVersion: ULONG,
    pub CompletionList: PUMS_COMPLETION_LIST,
    pub SchedulerProc: PUMS_SCHEDULER_ENTRY_POINT,
    pub SchedulerParam: PVOID,
}
pub type UMS_SCHEDULER_STARTUP_INFO = _UMS_SCHEDULER_STARTUP_INFO;
pub type PUMS_SCHEDULER_STARTUP_INFO = *mut _UMS_SCHEDULER_STARTUP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _UMS_SYSTEM_THREAD_INFORMATION {
    pub UmsVersion: ULONG,
    pub __bindgen_anon_1: _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub ThreadUmsFlags: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _UMS_SYSTEM_THREAD_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IsUmsSchedulerThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsUmsSchedulerThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsUmsWorkerThread(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsUmsWorkerThread(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsUmsSchedulerThread: ULONG,
        IsUmsWorkerThread: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsUmsSchedulerThread: u32 = unsafe { ::std::mem::transmute(IsUmsSchedulerThread) };
            IsUmsSchedulerThread as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsUmsWorkerThread: u32 = unsafe { ::std::mem::transmute(IsUmsWorkerThread) };
            IsUmsWorkerThread as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type UMS_SYSTEM_THREAD_INFORMATION = _UMS_SYSTEM_THREAD_INFORMATION;
pub type PUMS_SYSTEM_THREAD_INFORMATION = *mut _UMS_SYSTEM_THREAD_INFORMATION;
extern "C" {
    pub fn CreateUmsCompletionList(UmsCompletionList: *mut PUMS_COMPLETION_LIST) -> BOOL;
}
extern "C" {
    pub fn DequeueUmsCompletionListItems(
        UmsCompletionList: PUMS_COMPLETION_LIST,
        WaitTimeOut: DWORD,
        UmsThreadList: *mut PUMS_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUmsCompletionListEvent(
        UmsCompletionList: PUMS_COMPLETION_LIST,
        UmsCompletionEvent: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn ExecuteUmsThread(UmsThread: PUMS_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn UmsThreadYield(SchedulerParam: PVOID) -> BOOL;
}
extern "C" {
    pub fn DeleteUmsCompletionList(UmsCompletionList: PUMS_COMPLETION_LIST) -> BOOL;
}
extern "C" {
    pub fn GetCurrentUmsThread() -> PUMS_CONTEXT;
}
extern "C" {
    pub fn GetNextUmsListItem(UmsContext: PUMS_CONTEXT) -> PUMS_CONTEXT;
}
extern "C" {
    pub fn QueryUmsThreadInformation(
        UmsThread: PUMS_CONTEXT,
        UmsThreadInfoClass: UMS_THREAD_INFO_CLASS,
        UmsThreadInformation: PVOID,
        UmsThreadInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetUmsThreadInformation(
        UmsThread: PUMS_CONTEXT,
        UmsThreadInfoClass: UMS_THREAD_INFO_CLASS,
        UmsThreadInformation: PVOID,
        UmsThreadInformationLength: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn DeleteUmsThreadContext(UmsThread: PUMS_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CreateUmsThreadContext(lpUmsThread: *mut PUMS_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn EnterUmsSchedulingMode(SchedulerStartupInfo: PUMS_SCHEDULER_STARTUP_INFO) -> BOOL;
}
extern "C" {
    pub fn GetUmsSystemThreadInformation(
        ThreadHandle: HANDLE,
        SystemThreadInfo: PUMS_SYSTEM_THREAD_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadAffinityMask(hThread: HANDLE, dwThreadAffinityMask: DWORD_PTR) -> DWORD_PTR;
}
extern "C" {
    pub fn SetProcessDEPPolicy(dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetProcessDEPPolicy(hProcess: HANDLE, lpFlags: LPDWORD, lpPermanent: PBOOL) -> BOOL;
}
extern "C" {
    pub fn RequestWakeupLatency(latency: LATENCY_TIME) -> BOOL;
}
extern "C" {
    pub fn IsSystemResumeAutomatic() -> BOOL;
}
extern "C" {
    pub fn GetThreadSelectorEntry(
        hThread: HANDLE,
        dwSelector: DWORD,
        lpSelectorEntry: LPLDT_ENTRY,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadExecutionState(esFlags: EXECUTION_STATE) -> EXECUTION_STATE;
}
pub type POWER_REQUEST_CONTEXT = REASON_CONTEXT;
pub type PPOWER_REQUEST_CONTEXT = *mut REASON_CONTEXT;
pub type LPPOWER_REQUEST_CONTEXT = *mut REASON_CONTEXT;
extern "C" {
    pub fn PowerCreateRequest(Context: PREASON_CONTEXT) -> HANDLE;
}
extern "C" {
    pub fn PowerSetRequest(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE) -> BOOL;
}
extern "C" {
    pub fn PowerClearRequest(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE) -> BOOL;
}
extern "C" {
    pub fn SetFileCompletionNotificationModes(FileHandle: HANDLE, Flags: UCHAR) -> BOOL;
}
extern "C" {
    pub fn Wow64GetThreadSelectorEntry(
        hThread: HANDLE,
        dwSelector: DWORD,
        lpSelectorEntry: PWOW64_LDT_ENTRY,
    ) -> BOOL;
}
extern "C" {
    pub fn DebugSetProcessKillOnExit(KillOnExit: BOOL) -> BOOL;
}
extern "C" {
    pub fn DebugBreakProcess(Process: HANDLE) -> BOOL;
}
extern "C" {
    pub fn PulseEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GlobalDeleteAtom(nAtom: ATOM) -> ATOM;
}
extern "C" {
    pub fn InitAtomTable(nSize: DWORD) -> BOOL;
}
extern "C" {
    pub fn DeleteAtom(nAtom: ATOM) -> ATOM;
}
extern "C" {
    pub fn SetHandleCount(uNumber: UINT) -> UINT;
}
extern "C" {
    pub fn RequestDeviceWakeup(hDevice: HANDLE) -> BOOL;
}
extern "C" {
    pub fn CancelDeviceWakeupRequest(hDevice: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetDevicePowerState(hDevice: HANDLE, pfOn: *mut BOOL) -> BOOL;
}
extern "C" {
    pub fn SetMessageWaitingIndicator(hMsgIndicator: HANDLE, ulMsgCount: ULONG) -> BOOL;
}
extern "C" {
    pub fn SetFileShortNameA(hFile: HANDLE, lpShortName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetFileShortNameW(hFile: HANDLE, lpShortName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn LoadModule(lpModuleName: LPCSTR, lpParameterBlock: LPVOID) -> DWORD;
}
extern "C" {
    pub fn WinExec(lpCmdLine: LPCSTR, uCmdShow: UINT) -> UINT;
}
extern "C" {
    pub fn ClearCommBreak(hFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ClearCommError(hFile: HANDLE, lpErrors: LPDWORD, lpStat: LPCOMSTAT) -> BOOL;
}
extern "C" {
    pub fn SetupComm(hFile: HANDLE, dwInQueue: DWORD, dwOutQueue: DWORD) -> BOOL;
}
extern "C" {
    pub fn EscapeCommFunction(hFile: HANDLE, dwFunc: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetCommConfig(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetCommMask(hFile: HANDLE, lpEvtMask: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetCommProperties(hFile: HANDLE, lpCommProp: LPCOMMPROP) -> BOOL;
}
extern "C" {
    pub fn GetCommModemStatus(hFile: HANDLE, lpModemStat: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetCommState(hFile: HANDLE, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
    pub fn GetCommTimeouts(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS) -> BOOL;
}
extern "C" {
    pub fn PurgeComm(hFile: HANDLE, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetCommBreak(hFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetCommConfig(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, dwSize: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetCommMask(hFile: HANDLE, dwEvtMask: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetCommState(hFile: HANDLE, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
    pub fn SetCommTimeouts(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS) -> BOOL;
}
extern "C" {
    pub fn TransmitCommChar(hFile: HANDLE, cChar: ::std::os::raw::c_char) -> BOOL;
}
extern "C" {
    pub fn WaitCommEvent(hFile: HANDLE, lpEvtMask: LPDWORD, lpOverlapped: LPOVERLAPPED) -> BOOL;
}
extern "C" {
    pub fn OpenCommPort(
        uPortNumber: ULONG,
        dwDesiredAccess: DWORD,
        dwFlagsAndAttributes: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetCommPorts(
        lpPortNumbers: PULONG,
        uPortNumbersCount: ULONG,
        puPortNumbersFound: PULONG,
    ) -> ULONG;
}
extern "C" {
    pub fn SetTapePosition(
        hDevice: HANDLE,
        dwPositionMethod: DWORD,
        dwPartition: DWORD,
        dwOffsetLow: DWORD,
        dwOffsetHigh: DWORD,
        bImmediate: BOOL,
    ) -> DWORD;
}
extern "C" {
    pub fn GetTapePosition(
        hDevice: HANDLE,
        dwPositionType: DWORD,
        lpdwPartition: LPDWORD,
        lpdwOffsetLow: LPDWORD,
        lpdwOffsetHigh: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn PrepareTape(hDevice: HANDLE, dwOperation: DWORD, bImmediate: BOOL) -> DWORD;
}
extern "C" {
    pub fn EraseTape(hDevice: HANDLE, dwEraseType: DWORD, bImmediate: BOOL) -> DWORD;
}
extern "C" {
    pub fn CreateTapePartition(
        hDevice: HANDLE,
        dwPartitionMethod: DWORD,
        dwCount: DWORD,
        dwSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WriteTapemark(
        hDevice: HANDLE,
        dwTapemarkType: DWORD,
        dwTapemarkCount: DWORD,
        bImmediate: BOOL,
    ) -> DWORD;
}
extern "C" {
    pub fn GetTapeStatus(hDevice: HANDLE) -> DWORD;
}
extern "C" {
    pub fn GetTapeParameters(
        hDevice: HANDLE,
        dwOperation: DWORD,
        lpdwSize: LPDWORD,
        lpTapeInformation: LPVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn SetTapeParameters(
        hDevice: HANDLE,
        dwOperation: DWORD,
        lpTapeInformation: LPVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn MulDiv(
        nNumber: ::std::os::raw::c_int,
        nNumerator: ::std::os::raw::c_int,
        nDenominator: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn = 1,
    DEPPolicyOptIn = 2,
    DEPPolicyOptOut = 3,
    DEPTotalPolicyCount = 4,
}
pub use self::_DEP_SYSTEM_POLICY_TYPE as DEP_SYSTEM_POLICY_TYPE;
extern "C" {
    pub fn GetSystemDEPPolicy() -> DEP_SYSTEM_POLICY_TYPE;
}
extern "C" {
    pub fn GetSystemRegistryQuota(pdwQuotaAllowed: PDWORD, pdwQuotaUsed: PDWORD) -> BOOL;
}
extern "C" {
    pub fn FileTimeToDosDateTime(
        lpFileTime: *const FILETIME,
        lpFatDate: LPWORD,
        lpFatTime: LPWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn DosDateTimeToFileTime(wFatDate: WORD, wFatTime: WORD, lpFileTime: LPFILETIME) -> BOOL;
}
extern "C" {
    pub fn FormatMessageA(
        dwFlags: DWORD,
        lpSource: LPCVOID,
        dwMessageId: DWORD,
        dwLanguageId: DWORD,
        lpBuffer: LPSTR,
        nSize: DWORD,
        Arguments: *mut va_list,
    ) -> DWORD;
}
extern "C" {
    pub fn FormatMessageW(
        dwFlags: DWORD,
        lpSource: LPCVOID,
        dwMessageId: DWORD,
        dwLanguageId: DWORD,
        lpBuffer: LPWSTR,
        nSize: DWORD,
        Arguments: *mut va_list,
    ) -> DWORD;
}
extern "C" {
    pub fn CreateMailslotA(
        lpName: LPCSTR,
        nMaxMessageSize: DWORD,
        lReadTimeout: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateMailslotW(
        lpName: LPCWSTR,
        nMaxMessageSize: DWORD,
        lReadTimeout: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetMailslotInfo(
        hMailslot: HANDLE,
        lpMaxMessageSize: LPDWORD,
        lpNextSize: LPDWORD,
        lpMessageCount: LPDWORD,
        lpReadTimeout: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetMailslotInfo(hMailslot: HANDLE, lReadTimeout: DWORD) -> BOOL;
}
extern "C" {
    pub fn EncryptFileA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn EncryptFileW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn DecryptFileA(lpFileName: LPCSTR, dwReserved: DWORD) -> BOOL;
}
extern "C" {
    pub fn DecryptFileW(lpFileName: LPCWSTR, dwReserved: DWORD) -> BOOL;
}
extern "C" {
    pub fn FileEncryptionStatusA(lpFileName: LPCSTR, lpStatus: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn FileEncryptionStatusW(lpFileName: LPCWSTR, lpStatus: LPDWORD) -> BOOL;
}
pub type PFE_EXPORT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pbData: PBYTE, pvCallbackContext: PVOID, ulLength: ULONG) -> DWORD,
>;
pub type PFE_IMPORT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pbData: PBYTE, pvCallbackContext: PVOID, ulLength: PULONG) -> DWORD,
>;
extern "C" {
    pub fn OpenEncryptedFileRawA(
        lpFileName: LPCSTR,
        ulFlags: ULONG,
        pvContext: *mut PVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn OpenEncryptedFileRawW(
        lpFileName: LPCWSTR,
        ulFlags: ULONG,
        pvContext: *mut PVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn ReadEncryptedFileRaw(
        pfExportCallback: PFE_EXPORT_FUNC,
        pvCallbackContext: PVOID,
        pvContext: PVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn WriteEncryptedFileRaw(
        pfImportCallback: PFE_IMPORT_FUNC,
        pvCallbackContext: PVOID,
        pvContext: PVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn CloseEncryptedFileRaw(pvContext: PVOID);
}
extern "C" {
    pub fn lstrcmpA(lpString1: LPCSTR, lpString2: LPCSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstrcmpW(lpString1: LPCWSTR, lpString2: LPCWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstrcmpiA(lpString1: LPCSTR, lpString2: LPCSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstrcmpiW(lpString1: LPCWSTR, lpString2: LPCWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstrcpynA(
        lpString1: LPSTR,
        lpString2: LPCSTR,
        iMaxLength: ::std::os::raw::c_int,
    ) -> LPSTR;
}
extern "C" {
    pub fn lstrcpynW(
        lpString1: LPWSTR,
        lpString2: LPCWSTR,
        iMaxLength: ::std::os::raw::c_int,
    ) -> LPWSTR;
}
extern "C" {
    pub fn lstrcpyA(lpString1: LPSTR, lpString2: LPCSTR) -> LPSTR;
}
extern "C" {
    pub fn lstrcpyW(lpString1: LPWSTR, lpString2: LPCWSTR) -> LPWSTR;
}
extern "C" {
    pub fn lstrcatA(lpString1: LPSTR, lpString2: LPCSTR) -> LPSTR;
}
extern "C" {
    pub fn lstrcatW(lpString1: LPWSTR, lpString2: LPCWSTR) -> LPWSTR;
}
extern "C" {
    pub fn lstrlenA(lpString: LPCSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstrlenW(lpString: LPCWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OpenFile(lpFileName: LPCSTR, lpReOpenBuff: LPOFSTRUCT, uStyle: UINT) -> HFILE;
}
extern "C" {
    pub fn _lopen(lpPathName: LPCSTR, iReadWrite: ::std::os::raw::c_int) -> HFILE;
}
extern "C" {
    pub fn _lcreat(lpPathName: LPCSTR, iAttribute: ::std::os::raw::c_int) -> HFILE;
}
extern "C" {
    pub fn _lread(hFile: HFILE, lpBuffer: LPVOID, uBytes: UINT) -> UINT;
}
extern "C" {
    pub fn _lwrite(hFile: HFILE, lpBuffer: LPCCH, uBytes: UINT) -> UINT;
}
extern "C" {
    pub fn _hread(
        hFile: HFILE,
        lpBuffer: LPVOID,
        lBytes: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _hwrite(
        hFile: HFILE,
        lpBuffer: LPCCH,
        lBytes: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _lclose(hFile: HFILE) -> HFILE;
}
extern "C" {
    pub fn _llseek(hFile: HFILE, lOffset: LONG, iOrigin: ::std::os::raw::c_int) -> LONG;
}
extern "C" {
    pub fn IsTextUnicode(
        lpv: *const ::std::os::raw::c_void,
        iSize: ::std::os::raw::c_int,
        lpiResult: LPINT,
    ) -> BOOL;
}
extern "C" {
    pub fn BackupRead(
        hFile: HANDLE,
        lpBuffer: LPBYTE,
        nNumberOfBytesToRead: DWORD,
        lpNumberOfBytesRead: LPDWORD,
        bAbort: BOOL,
        bProcessSecurity: BOOL,
        lpContext: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn BackupSeek(
        hFile: HANDLE,
        dwLowBytesToSeek: DWORD,
        dwHighBytesToSeek: DWORD,
        lpdwLowByteSeeked: LPDWORD,
        lpdwHighByteSeeked: LPDWORD,
        lpContext: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn BackupWrite(
        hFile: HANDLE,
        lpBuffer: LPBYTE,
        nNumberOfBytesToWrite: DWORD,
        lpNumberOfBytesWritten: LPDWORD,
        bAbort: BOOL,
        bProcessSecurity: BOOL,
        lpContext: *mut LPVOID,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIN32_STREAM_ID {
    pub dwStreamId: DWORD,
    pub dwStreamAttributes: DWORD,
    pub Size: LARGE_INTEGER,
    pub dwStreamNameSize: DWORD,
    pub cStreamName: [WCHAR; 1usize],
}
pub type WIN32_STREAM_ID = _WIN32_STREAM_ID;
pub type LPWIN32_STREAM_ID = *mut _WIN32_STREAM_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOEXA {
    pub StartupInfo: STARTUPINFOA,
    pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
pub type STARTUPINFOEXA = _STARTUPINFOEXA;
pub type LPSTARTUPINFOEXA = *mut _STARTUPINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOEXW {
    pub StartupInfo: STARTUPINFOW,
    pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
pub type STARTUPINFOEXW = _STARTUPINFOEXW;
pub type LPSTARTUPINFOEXW = *mut _STARTUPINFOEXW;
pub type STARTUPINFOEX = STARTUPINFOEXA;
pub type LPSTARTUPINFOEX = LPSTARTUPINFOEXA;
extern "C" {
    pub fn OpenMutexA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn CreateSemaphoreA(
        lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES,
        lInitialCount: LONG,
        lMaximumCount: LONG,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenSemaphoreA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn CreateWaitableTimerA(
        lpTimerAttributes: LPSECURITY_ATTRIBUTES,
        bManualReset: BOOL,
        lpTimerName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenWaitableTimerA(
        dwDesiredAccess: DWORD,
        bInheritHandle: BOOL,
        lpTimerName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateSemaphoreExA(
        lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES,
        lInitialCount: LONG,
        lMaximumCount: LONG,
        lpName: LPCSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateWaitableTimerExA(
        lpTimerAttributes: LPSECURITY_ATTRIBUTES,
        lpTimerName: LPCSTR,
        dwFlags: DWORD,
        dwDesiredAccess: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateFileMappingA(
        hFile: HANDLE,
        lpFileMappingAttributes: LPSECURITY_ATTRIBUTES,
        flProtect: DWORD,
        dwMaximumSizeHigh: DWORD,
        dwMaximumSizeLow: DWORD,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateFileMappingNumaA(
        hFile: HANDLE,
        lpFileMappingAttributes: LPSECURITY_ATTRIBUTES,
        flProtect: DWORD,
        dwMaximumSizeHigh: DWORD,
        dwMaximumSizeLow: DWORD,
        lpName: LPCSTR,
        nndPreferred: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenFileMappingA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR)
        -> HANDLE;
}
extern "C" {
    pub fn GetLogicalDriveStringsA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
    pub fn LoadPackagedLibrary(lpwLibFileName: LPCWSTR, Reserved: DWORD) -> HMODULE;
}
extern "C" {
    pub fn QueryFullProcessImageNameA(
        hProcess: HANDLE,
        dwFlags: DWORD,
        lpExeName: LPSTR,
        lpdwSize: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryFullProcessImageNameW(
        hProcess: HANDLE,
        dwFlags: DWORD,
        lpExeName: LPWSTR,
        lpdwSize: PDWORD,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,
    ProcThreadAttributeSecurityCapabilities = 9,
    ProcThreadAttributeProtectionLevel = 11,
    ProcThreadAttributeJobList = 13,
    ProcThreadAttributeChildProcessPolicy = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter = 16,
    ProcThreadAttributeSafeOpenPromptOriginClaim = 17,
    ProcThreadAttributeDesktopAppPolicy = 18,
    ProcThreadAttributePseudoConsole = 22,
    ProcThreadAttributeMitigationAuditPolicy = 24,
    ProcThreadAttributeMachineType = 25,
    ProcThreadAttributeComponentFilter = 26,
    ProcThreadAttributeEnableOptionalXStateFeatures = 27,
    ProcThreadAttributeTrustedApp = 29,
}
pub use self::_PROC_THREAD_ATTRIBUTE_NUM as PROC_THREAD_ATTRIBUTE_NUM;
extern "C" {
    pub fn GetStartupInfoA(lpStartupInfo: LPSTARTUPINFOA);
}
extern "C" {
    pub fn GetFirmwareEnvironmentVariableA(
        lpName: LPCSTR,
        lpGuid: LPCSTR,
        pBuffer: PVOID,
        nSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFirmwareEnvironmentVariableW(
        lpName: LPCWSTR,
        lpGuid: LPCWSTR,
        pBuffer: PVOID,
        nSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFirmwareEnvironmentVariableExA(
        lpName: LPCSTR,
        lpGuid: LPCSTR,
        pBuffer: PVOID,
        nSize: DWORD,
        pdwAttribubutes: PDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFirmwareEnvironmentVariableExW(
        lpName: LPCWSTR,
        lpGuid: LPCWSTR,
        pBuffer: PVOID,
        nSize: DWORD,
        pdwAttribubutes: PDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetFirmwareEnvironmentVariableA(
        lpName: LPCSTR,
        lpGuid: LPCSTR,
        pValue: PVOID,
        nSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFirmwareEnvironmentVariableW(
        lpName: LPCWSTR,
        lpGuid: LPCWSTR,
        pValue: PVOID,
        nSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFirmwareEnvironmentVariableExA(
        lpName: LPCSTR,
        lpGuid: LPCSTR,
        pValue: PVOID,
        nSize: DWORD,
        dwAttributes: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFirmwareEnvironmentVariableExW(
        lpName: LPCWSTR,
        lpGuid: LPCWSTR,
        pValue: PVOID,
        nSize: DWORD,
        dwAttributes: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFirmwareType(FirmwareType: PFIRMWARE_TYPE) -> BOOL;
}
extern "C" {
    pub fn IsNativeVhdBoot(NativeVhdBoot: PBOOL) -> BOOL;
}
extern "C" {
    pub fn FindResourceA(hModule: HMODULE, lpName: LPCSTR, lpType: LPCSTR) -> HRSRC;
}
extern "C" {
    pub fn FindResourceExA(
        hModule: HMODULE,
        lpType: LPCSTR,
        lpName: LPCSTR,
        wLanguage: WORD,
    ) -> HRSRC;
}
extern "C" {
    pub fn EnumResourceTypesA(
        hModule: HMODULE,
        lpEnumFunc: ENUMRESTYPEPROCA,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceTypesW(
        hModule: HMODULE,
        lpEnumFunc: ENUMRESTYPEPROCW,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceLanguagesA(
        hModule: HMODULE,
        lpType: LPCSTR,
        lpName: LPCSTR,
        lpEnumFunc: ENUMRESLANGPROCA,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumResourceLanguagesW(
        hModule: HMODULE,
        lpType: LPCWSTR,
        lpName: LPCWSTR,
        lpEnumFunc: ENUMRESLANGPROCW,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn BeginUpdateResourceA(pFileName: LPCSTR, bDeleteExistingResources: BOOL) -> HANDLE;
}
extern "C" {
    pub fn BeginUpdateResourceW(pFileName: LPCWSTR, bDeleteExistingResources: BOOL) -> HANDLE;
}
extern "C" {
    pub fn UpdateResourceA(
        hUpdate: HANDLE,
        lpType: LPCSTR,
        lpName: LPCSTR,
        wLanguage: WORD,
        lpData: LPVOID,
        cb: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn UpdateResourceW(
        hUpdate: HANDLE,
        lpType: LPCWSTR,
        lpName: LPCWSTR,
        wLanguage: WORD,
        lpData: LPVOID,
        cb: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EndUpdateResourceA(hUpdate: HANDLE, fDiscard: BOOL) -> BOOL;
}
extern "C" {
    pub fn EndUpdateResourceW(hUpdate: HANDLE, fDiscard: BOOL) -> BOOL;
}
extern "C" {
    pub fn GlobalAddAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
    pub fn GlobalAddAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
    pub fn GlobalAddAtomExA(lpString: LPCSTR, Flags: DWORD) -> ATOM;
}
extern "C" {
    pub fn GlobalAddAtomExW(lpString: LPCWSTR, Flags: DWORD) -> ATOM;
}
extern "C" {
    pub fn GlobalFindAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
    pub fn GlobalFindAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
    pub fn GlobalGetAtomNameA(nAtom: ATOM, lpBuffer: LPSTR, nSize: ::std::os::raw::c_int) -> UINT;
}
extern "C" {
    pub fn GlobalGetAtomNameW(nAtom: ATOM, lpBuffer: LPWSTR, nSize: ::std::os::raw::c_int) -> UINT;
}
extern "C" {
    pub fn AddAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
    pub fn AddAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
    pub fn FindAtomA(lpString: LPCSTR) -> ATOM;
}
extern "C" {
    pub fn FindAtomW(lpString: LPCWSTR) -> ATOM;
}
extern "C" {
    pub fn GetAtomNameA(nAtom: ATOM, lpBuffer: LPSTR, nSize: ::std::os::raw::c_int) -> UINT;
}
extern "C" {
    pub fn GetAtomNameW(nAtom: ATOM, lpBuffer: LPWSTR, nSize: ::std::os::raw::c_int) -> UINT;
}
extern "C" {
    pub fn GetProfileIntA(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT) -> UINT;
}
extern "C" {
    pub fn GetProfileIntW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT) -> UINT;
}
extern "C" {
    pub fn GetProfileStringA(
        lpAppName: LPCSTR,
        lpKeyName: LPCSTR,
        lpDefault: LPCSTR,
        lpReturnedString: LPSTR,
        nSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetProfileStringW(
        lpAppName: LPCWSTR,
        lpKeyName: LPCWSTR,
        lpDefault: LPCWSTR,
        lpReturnedString: LPWSTR,
        nSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WriteProfileStringA(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn WriteProfileStringW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetProfileSectionA(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetProfileSectionW(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn WriteProfileSectionA(lpAppName: LPCSTR, lpString: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn WriteProfileSectionW(lpAppName: LPCWSTR, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetPrivateProfileIntA(
        lpAppName: LPCSTR,
        lpKeyName: LPCSTR,
        nDefault: INT,
        lpFileName: LPCSTR,
    ) -> UINT;
}
extern "C" {
    pub fn GetPrivateProfileIntW(
        lpAppName: LPCWSTR,
        lpKeyName: LPCWSTR,
        nDefault: INT,
        lpFileName: LPCWSTR,
    ) -> UINT;
}
extern "C" {
    pub fn GetPrivateProfileStringA(
        lpAppName: LPCSTR,
        lpKeyName: LPCSTR,
        lpDefault: LPCSTR,
        lpReturnedString: LPSTR,
        nSize: DWORD,
        lpFileName: LPCSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrivateProfileStringW(
        lpAppName: LPCWSTR,
        lpKeyName: LPCWSTR,
        lpDefault: LPCWSTR,
        lpReturnedString: LPWSTR,
        nSize: DWORD,
        lpFileName: LPCWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn WritePrivateProfileStringA(
        lpAppName: LPCSTR,
        lpKeyName: LPCSTR,
        lpString: LPCSTR,
        lpFileName: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn WritePrivateProfileStringW(
        lpAppName: LPCWSTR,
        lpKeyName: LPCWSTR,
        lpString: LPCWSTR,
        lpFileName: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrivateProfileSectionA(
        lpAppName: LPCSTR,
        lpReturnedString: LPSTR,
        nSize: DWORD,
        lpFileName: LPCSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrivateProfileSectionW(
        lpAppName: LPCWSTR,
        lpReturnedString: LPWSTR,
        nSize: DWORD,
        lpFileName: LPCWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn WritePrivateProfileSectionA(
        lpAppName: LPCSTR,
        lpString: LPCSTR,
        lpFileName: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn WritePrivateProfileSectionW(
        lpAppName: LPCWSTR,
        lpString: LPCWSTR,
        lpFileName: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrivateProfileSectionNamesA(
        lpszReturnBuffer: LPSTR,
        nSize: DWORD,
        lpFileName: LPCSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrivateProfileSectionNamesW(
        lpszReturnBuffer: LPWSTR,
        nSize: DWORD,
        lpFileName: LPCWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrivateProfileStructA(
        lpszSection: LPCSTR,
        lpszKey: LPCSTR,
        lpStruct: LPVOID,
        uSizeStruct: UINT,
        szFile: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrivateProfileStructW(
        lpszSection: LPCWSTR,
        lpszKey: LPCWSTR,
        lpStruct: LPVOID,
        uSizeStruct: UINT,
        szFile: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn WritePrivateProfileStructA(
        lpszSection: LPCSTR,
        lpszKey: LPCSTR,
        lpStruct: LPVOID,
        uSizeStruct: UINT,
        szFile: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn WritePrivateProfileStructW(
        lpszSection: LPCWSTR,
        lpszKey: LPCWSTR,
        lpStruct: LPVOID,
        uSizeStruct: UINT,
        szFile: LPCWSTR,
    ) -> BOOL;
}
pub type PGET_SYSTEM_WOW64_DIRECTORY_A =
    ::std::option::Option<unsafe extern "C" fn(lpBuffer: LPSTR, uSize: UINT) -> UINT>;
pub type PGET_SYSTEM_WOW64_DIRECTORY_W =
    ::std::option::Option<unsafe extern "C" fn(lpBuffer: LPWSTR, uSize: UINT) -> UINT>;
extern "C" {
    pub fn SetDllDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetDllDirectoryW(lpPathName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetDllDirectoryA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
    pub fn GetDllDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn SetSearchPathMode(Flags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryExA(
        lpTemplateDirectory: LPCSTR,
        lpNewDirectory: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryExW(
        lpTemplateDirectory: LPCWSTR,
        lpNewDirectory: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryTransactedA(
        lpTemplateDirectory: LPCSTR,
        lpNewDirectory: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryTransactedW(
        lpTemplateDirectory: LPCWSTR,
        lpNewDirectory: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn RemoveDirectoryTransactedA(lpPathName: LPCSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
    pub fn RemoveDirectoryTransactedW(lpPathName: LPCWSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetFullPathNameTransactedA(
        lpFileName: LPCSTR,
        nBufferLength: DWORD,
        lpBuffer: LPSTR,
        lpFilePart: *mut LPSTR,
        hTransaction: HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFullPathNameTransactedW(
        lpFileName: LPCWSTR,
        nBufferLength: DWORD,
        lpBuffer: LPWSTR,
        lpFilePart: *mut LPWSTR,
        hTransaction: HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn DefineDosDeviceA(dwFlags: DWORD, lpDeviceName: LPCSTR, lpTargetPath: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn QueryDosDeviceA(lpDeviceName: LPCSTR, lpTargetPath: LPSTR, ucchMax: DWORD) -> DWORD;
}
extern "C" {
    pub fn CreateFileTransactedA(
        lpFileName: LPCSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreationDisposition: DWORD,
        dwFlagsAndAttributes: DWORD,
        hTemplateFile: HANDLE,
        hTransaction: HANDLE,
        pusMiniVersion: PUSHORT,
        lpExtendedParameter: PVOID,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateFileTransactedW(
        lpFileName: LPCWSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreationDisposition: DWORD,
        dwFlagsAndAttributes: DWORD,
        hTemplateFile: HANDLE,
        hTransaction: HANDLE,
        pusMiniVersion: PUSHORT,
        lpExtendedParameter: PVOID,
    ) -> HANDLE;
}
extern "C" {
    pub fn ReOpenFile(
        hOriginalFile: HANDLE,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        dwFlagsAndAttributes: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn SetFileAttributesTransactedA(
        lpFileName: LPCSTR,
        dwFileAttributes: DWORD,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileAttributesTransactedW(
        lpFileName: LPCWSTR,
        dwFileAttributes: DWORD,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileAttributesTransactedA(
        lpFileName: LPCSTR,
        fInfoLevelId: GET_FILEEX_INFO_LEVELS,
        lpFileInformation: LPVOID,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileAttributesTransactedW(
        lpFileName: LPCWSTR,
        fInfoLevelId: GET_FILEEX_INFO_LEVELS,
        lpFileInformation: LPVOID,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCompressedFileSizeTransactedA(
        lpFileName: LPCSTR,
        lpFileSizeHigh: LPDWORD,
        hTransaction: HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn GetCompressedFileSizeTransactedW(
        lpFileName: LPCWSTR,
        lpFileSizeHigh: LPDWORD,
        hTransaction: HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn DeleteFileTransactedA(lpFileName: LPCSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
    pub fn DeleteFileTransactedW(lpFileName: LPCWSTR, hTransaction: HANDLE) -> BOOL;
}
extern "C" {
    pub fn CheckNameLegalDOS8Dot3A(
        lpName: LPCSTR,
        lpOemName: LPSTR,
        OemNameSize: DWORD,
        pbNameContainsSpaces: PBOOL,
        pbNameLegal: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CheckNameLegalDOS8Dot3W(
        lpName: LPCWSTR,
        lpOemName: LPSTR,
        OemNameSize: DWORD,
        pbNameContainsSpaces: PBOOL,
        pbNameLegal: PBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn FindFirstFileTransactedA(
        lpFileName: LPCSTR,
        fInfoLevelId: FINDEX_INFO_LEVELS,
        lpFindFileData: LPVOID,
        fSearchOp: FINDEX_SEARCH_OPS,
        lpSearchFilter: LPVOID,
        dwAdditionalFlags: DWORD,
        hTransaction: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstFileTransactedW(
        lpFileName: LPCWSTR,
        fInfoLevelId: FINDEX_INFO_LEVELS,
        lpFindFileData: LPVOID,
        fSearchOp: FINDEX_SEARCH_OPS,
        lpSearchFilter: LPVOID,
        dwAdditionalFlags: DWORD,
        hTransaction: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn CopyFileA(
        lpExistingFileName: LPCSTR,
        lpNewFileName: LPCSTR,
        bFailIfExists: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CopyFileW(
        lpExistingFileName: LPCWSTR,
        lpNewFileName: LPCWSTR,
        bFailIfExists: BOOL,
    ) -> BOOL;
}
pub type LPPROGRESS_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        TotalFileSize: LARGE_INTEGER,
        TotalBytesTransferred: LARGE_INTEGER,
        StreamSize: LARGE_INTEGER,
        StreamBytesTransferred: LARGE_INTEGER,
        dwStreamNumber: DWORD,
        dwCallbackReason: DWORD,
        hSourceFile: HANDLE,
        hDestinationFile: HANDLE,
        lpData: LPVOID,
    ) -> DWORD,
>;
extern "C" {
    pub fn CopyFileExA(
        lpExistingFileName: LPCSTR,
        lpNewFileName: LPCSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        pbCancel: LPBOOL,
        dwCopyFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CopyFileExW(
        lpExistingFileName: LPCWSTR,
        lpNewFileName: LPCWSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        pbCancel: LPBOOL,
        dwCopyFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CopyFileTransactedA(
        lpExistingFileName: LPCSTR,
        lpNewFileName: LPCSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        pbCancel: LPBOOL,
        dwCopyFlags: DWORD,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn CopyFileTransactedW(
        lpExistingFileName: LPCWSTR,
        lpNewFileName: LPCWSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        pbCancel: LPBOOL,
        dwCopyFlags: DWORD,
        hTransaction: HANDLE,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _COPYFILE2_MESSAGE_TYPE {
    COPYFILE2_CALLBACK_NONE = 0,
    COPYFILE2_CALLBACK_CHUNK_STARTED = 1,
    COPYFILE2_CALLBACK_CHUNK_FINISHED = 2,
    COPYFILE2_CALLBACK_STREAM_STARTED = 3,
    COPYFILE2_CALLBACK_STREAM_FINISHED = 4,
    COPYFILE2_CALLBACK_POLL_CONTINUE = 5,
    COPYFILE2_CALLBACK_ERROR = 6,
    COPYFILE2_CALLBACK_MAX = 7,
}
pub use self::_COPYFILE2_MESSAGE_TYPE as COPYFILE2_MESSAGE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL = 1,
    COPYFILE2_PROGRESS_STOP = 2,
    COPYFILE2_PROGRESS_QUIET = 3,
    COPYFILE2_PROGRESS_PAUSE = 4,
}
pub use self::_COPYFILE2_MESSAGE_ACTION as COPYFILE2_MESSAGE_ACTION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE = 1,
    COPYFILE2_PHASE_PREPARE_DEST = 2,
    COPYFILE2_PHASE_READ_SOURCE = 3,
    COPYFILE2_PHASE_WRITE_DESTINATION = 4,
    COPYFILE2_PHASE_SERVER_COPY = 5,
    COPYFILE2_PHASE_NAMEGRAFT_COPY = 6,
    COPYFILE2_PHASE_MAX = 7,
}
pub use self::_COPYFILE2_COPY_PHASE as COPYFILE2_COPY_PHASE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE {
    pub Type: COPYFILE2_MESSAGE_TYPE,
    pub dwPadding: DWORD,
    pub Info: COPYFILE2_MESSAGE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union COPYFILE2_MESSAGE__bindgen_ty_1 {
    pub ChunkStarted: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1,
    pub ChunkFinished: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2,
    pub StreamStarted: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3,
    pub StreamFinished: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4,
    pub PollContinue: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5,
    pub Error: COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_1 {
    pub dwStreamNumber: DWORD,
    pub dwReserved: DWORD,
    pub hSourceFile: HANDLE,
    pub hDestinationFile: HANDLE,
    pub uliChunkNumber: ULARGE_INTEGER,
    pub uliChunkSize: ULARGE_INTEGER,
    pub uliStreamSize: ULARGE_INTEGER,
    pub uliTotalFileSize: ULARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_2 {
    pub dwStreamNumber: DWORD,
    pub dwFlags: DWORD,
    pub hSourceFile: HANDLE,
    pub hDestinationFile: HANDLE,
    pub uliChunkNumber: ULARGE_INTEGER,
    pub uliChunkSize: ULARGE_INTEGER,
    pub uliStreamSize: ULARGE_INTEGER,
    pub uliStreamBytesTransferred: ULARGE_INTEGER,
    pub uliTotalFileSize: ULARGE_INTEGER,
    pub uliTotalBytesTransferred: ULARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_3 {
    pub dwStreamNumber: DWORD,
    pub dwReserved: DWORD,
    pub hSourceFile: HANDLE,
    pub hDestinationFile: HANDLE,
    pub uliStreamSize: ULARGE_INTEGER,
    pub uliTotalFileSize: ULARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_4 {
    pub dwStreamNumber: DWORD,
    pub dwReserved: DWORD,
    pub hSourceFile: HANDLE,
    pub hDestinationFile: HANDLE,
    pub uliStreamSize: ULARGE_INTEGER,
    pub uliStreamBytesTransferred: ULARGE_INTEGER,
    pub uliTotalFileSize: ULARGE_INTEGER,
    pub uliTotalBytesTransferred: ULARGE_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_5 {
    pub dwReserved: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct COPYFILE2_MESSAGE__bindgen_ty_1__bindgen_ty_6 {
    pub CopyPhase: COPYFILE2_COPY_PHASE,
    pub dwStreamNumber: DWORD,
    pub hrFailure: HRESULT,
    pub dwReserved: DWORD,
    pub uliChunkNumber: ULARGE_INTEGER,
    pub uliStreamSize: ULARGE_INTEGER,
    pub uliStreamBytesTransferred: ULARGE_INTEGER,
    pub uliTotalFileSize: ULARGE_INTEGER,
    pub uliTotalBytesTransferred: ULARGE_INTEGER,
}
pub type PCOPYFILE2_PROGRESS_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        pMessage: *const COPYFILE2_MESSAGE,
        pvCallbackContext: PVOID,
    ) -> COPYFILE2_MESSAGE_ACTION,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COPYFILE2_EXTENDED_PARAMETERS {
    pub dwSize: DWORD,
    pub dwCopyFlags: DWORD,
    pub pfCancel: *mut BOOL,
    pub pProgressRoutine: PCOPYFILE2_PROGRESS_ROUTINE,
    pub pvCallbackContext: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COPYFILE2_EXTENDED_PARAMETERS_V2 {
    pub dwSize: DWORD,
    pub dwCopyFlags: DWORD,
    pub pfCancel: *mut BOOL,
    pub pProgressRoutine: PCOPYFILE2_PROGRESS_ROUTINE,
    pub pvCallbackContext: PVOID,
    pub dwCopyFlagsV2: DWORD,
    pub ioDesiredSize: ULONG,
    pub ioDesiredRate: ULONG,
    pub reserved: [PVOID; 8usize],
}
extern "C" {
    pub fn CopyFile2(
        pwszExistingFileName: PCWSTR,
        pwszNewFileName: PCWSTR,
        pExtendedParameters: *mut COPYFILE2_EXTENDED_PARAMETERS,
    ) -> HRESULT;
}
extern "C" {
    pub fn MoveFileA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn MoveFileW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn MoveFileExA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD)
        -> BOOL;
}
extern "C" {
    pub fn MoveFileWithProgressA(
        lpExistingFileName: LPCSTR,
        lpNewFileName: LPCSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn MoveFileWithProgressW(
        lpExistingFileName: LPCWSTR,
        lpNewFileName: LPCWSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn MoveFileTransactedA(
        lpExistingFileName: LPCSTR,
        lpNewFileName: LPCSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        dwFlags: DWORD,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn MoveFileTransactedW(
        lpExistingFileName: LPCWSTR,
        lpNewFileName: LPCWSTR,
        lpProgressRoutine: LPPROGRESS_ROUTINE,
        lpData: LPVOID,
        dwFlags: DWORD,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn ReplaceFileA(
        lpReplacedFileName: LPCSTR,
        lpReplacementFileName: LPCSTR,
        lpBackupFileName: LPCSTR,
        dwReplaceFlags: DWORD,
        lpExclude: LPVOID,
        lpReserved: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn ReplaceFileW(
        lpReplacedFileName: LPCWSTR,
        lpReplacementFileName: LPCWSTR,
        lpBackupFileName: LPCWSTR,
        dwReplaceFlags: DWORD,
        lpExclude: LPVOID,
        lpReserved: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateHardLinkA(
        lpFileName: LPCSTR,
        lpExistingFileName: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateHardLinkW(
        lpFileName: LPCWSTR,
        lpExistingFileName: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateHardLinkTransactedA(
        lpFileName: LPCSTR,
        lpExistingFileName: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateHardLinkTransactedW(
        lpFileName: LPCWSTR,
        lpExistingFileName: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        hTransaction: HANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn FindFirstStreamTransactedW(
        lpFileName: LPCWSTR,
        InfoLevel: STREAM_INFO_LEVELS,
        lpFindStreamData: LPVOID,
        dwFlags: DWORD,
        hTransaction: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstFileNameTransactedW(
        lpFileName: LPCWSTR,
        dwFlags: DWORD,
        StringLength: LPDWORD,
        LinkName: PWSTR,
        hTransaction: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateNamedPipeA(
        lpName: LPCSTR,
        dwOpenMode: DWORD,
        dwPipeMode: DWORD,
        nMaxInstances: DWORD,
        nOutBufferSize: DWORD,
        nInBufferSize: DWORD,
        nDefaultTimeOut: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> HANDLE;
}
extern "C" {
    pub fn GetNamedPipeHandleStateA(
        hNamedPipe: HANDLE,
        lpState: LPDWORD,
        lpCurInstances: LPDWORD,
        lpMaxCollectionCount: LPDWORD,
        lpCollectDataTimeout: LPDWORD,
        lpUserName: LPSTR,
        nMaxUserNameSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CallNamedPipeA(
        lpNamedPipeName: LPCSTR,
        lpInBuffer: LPVOID,
        nInBufferSize: DWORD,
        lpOutBuffer: LPVOID,
        nOutBufferSize: DWORD,
        lpBytesRead: LPDWORD,
        nTimeOut: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WaitNamedPipeA(lpNamedPipeName: LPCSTR, nTimeOut: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeClientComputerNameA(
        Pipe: HANDLE,
        ClientComputerName: LPSTR,
        ClientComputerNameLength: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeClientProcessId(Pipe: HANDLE, ClientProcessId: PULONG) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeClientSessionId(Pipe: HANDLE, ClientSessionId: PULONG) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeServerProcessId(Pipe: HANDLE, ServerProcessId: PULONG) -> BOOL;
}
extern "C" {
    pub fn GetNamedPipeServerSessionId(Pipe: HANDLE, ServerSessionId: PULONG) -> BOOL;
}
extern "C" {
    pub fn SetVolumeLabelA(lpRootPathName: LPCSTR, lpVolumeName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetVolumeLabelW(lpRootPathName: LPCWSTR, lpVolumeName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn SetFileBandwidthReservation(
        hFile: HANDLE,
        nPeriodMilliseconds: DWORD,
        nBytesPerPeriod: DWORD,
        bDiscardable: BOOL,
        lpTransferSize: LPDWORD,
        lpNumOutstandingRequests: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileBandwidthReservation(
        hFile: HANDLE,
        lpPeriodMilliseconds: LPDWORD,
        lpBytesPerPeriod: LPDWORD,
        pDiscardable: LPBOOL,
        lpTransferSize: LPDWORD,
        lpNumOutstandingRequests: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ClearEventLogA(hEventLog: HANDLE, lpBackupFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn ClearEventLogW(hEventLog: HANDLE, lpBackupFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn BackupEventLogA(hEventLog: HANDLE, lpBackupFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn BackupEventLogW(hEventLog: HANDLE, lpBackupFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn CloseEventLog(hEventLog: HANDLE) -> BOOL;
}
extern "C" {
    pub fn DeregisterEventSource(hEventLog: HANDLE) -> BOOL;
}
extern "C" {
    pub fn NotifyChangeEventLog(hEventLog: HANDLE, hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetNumberOfEventLogRecords(hEventLog: HANDLE, NumberOfRecords: PDWORD) -> BOOL;
}
extern "C" {
    pub fn GetOldestEventLogRecord(hEventLog: HANDLE, OldestRecord: PDWORD) -> BOOL;
}
extern "C" {
    pub fn OpenEventLogA(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn OpenEventLogW(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn RegisterEventSourceA(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn RegisterEventSourceW(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn OpenBackupEventLogA(lpUNCServerName: LPCSTR, lpFileName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn OpenBackupEventLogW(lpUNCServerName: LPCWSTR, lpFileName: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn ReadEventLogA(
        hEventLog: HANDLE,
        dwReadFlags: DWORD,
        dwRecordOffset: DWORD,
        lpBuffer: LPVOID,
        nNumberOfBytesToRead: DWORD,
        pnBytesRead: *mut DWORD,
        pnMinNumberOfBytesNeeded: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadEventLogW(
        hEventLog: HANDLE,
        dwReadFlags: DWORD,
        dwRecordOffset: DWORD,
        lpBuffer: LPVOID,
        nNumberOfBytesToRead: DWORD,
        pnBytesRead: *mut DWORD,
        pnMinNumberOfBytesNeeded: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReportEventA(
        hEventLog: HANDLE,
        wType: WORD,
        wCategory: WORD,
        dwEventID: DWORD,
        lpUserSid: PSID,
        wNumStrings: WORD,
        dwDataSize: DWORD,
        lpStrings: *mut LPCSTR,
        lpRawData: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn ReportEventW(
        hEventLog: HANDLE,
        wType: WORD,
        wCategory: WORD,
        dwEventID: DWORD,
        lpUserSid: PSID,
        wNumStrings: WORD,
        dwDataSize: DWORD,
        lpStrings: *mut LPCWSTR,
        lpRawData: LPVOID,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENTLOG_FULL_INFORMATION {
    pub dwFull: DWORD,
}
pub type EVENTLOG_FULL_INFORMATION = _EVENTLOG_FULL_INFORMATION;
pub type LPEVENTLOG_FULL_INFORMATION = *mut _EVENTLOG_FULL_INFORMATION;
extern "C" {
    pub fn GetEventLogInformation(
        hEventLog: HANDLE,
        dwInfoLevel: DWORD,
        lpBuffer: LPVOID,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
pub type OPERATION_ID = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPERATION_START_PARAMETERS {
    pub Version: ULONG,
    pub OperationId: OPERATION_ID,
    pub Flags: ULONG,
}
pub type OPERATION_START_PARAMETERS = _OPERATION_START_PARAMETERS;
pub type POPERATION_START_PARAMETERS = *mut _OPERATION_START_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPERATION_END_PARAMETERS {
    pub Version: ULONG,
    pub OperationId: OPERATION_ID,
    pub Flags: ULONG,
}
pub type OPERATION_END_PARAMETERS = _OPERATION_END_PARAMETERS;
pub type POPERATION_END_PARAMETERS = *mut _OPERATION_END_PARAMETERS;
extern "C" {
    pub fn OperationStart(OperationStartParams: *mut OPERATION_START_PARAMETERS) -> BOOL;
}
extern "C" {
    pub fn OperationEnd(OperationEndParams: *mut OPERATION_END_PARAMETERS) -> BOOL;
}
extern "C" {
    pub fn AccessCheckAndAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPSTR,
        ObjectName: LPSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        DesiredAccess: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccess: LPDWORD,
        AccessStatus: LPBOOL,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeAndAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPCSTR,
        ObjectName: LPCSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: DWORD,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccess: LPDWORD,
        AccessStatus: LPBOOL,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeResultListAndAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPCSTR,
        ObjectName: LPCSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: DWORD,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccess: LPDWORD,
        AccessStatusList: LPDWORD,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AccessCheckByTypeResultListAndAuditAlarmByHandleA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        ClientToken: HANDLE,
        ObjectTypeName: LPCSTR,
        ObjectName: LPCSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PrincipalSelfSid: PSID,
        DesiredAccess: DWORD,
        AuditType: AUDIT_EVENT_TYPE,
        Flags: DWORD,
        ObjectTypeList: POBJECT_TYPE_LIST,
        ObjectTypeListLength: DWORD,
        GenericMapping: PGENERIC_MAPPING,
        ObjectCreation: BOOL,
        GrantedAccess: LPDWORD,
        AccessStatusList: LPDWORD,
        pfGenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectOpenAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        ObjectTypeName: LPSTR,
        ObjectName: LPSTR,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        GrantedAccess: DWORD,
        Privileges: PPRIVILEGE_SET,
        ObjectCreation: BOOL,
        AccessGranted: BOOL,
        GenerateOnClose: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectPrivilegeAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        ClientToken: HANDLE,
        DesiredAccess: DWORD,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectCloseAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        GenerateOnClose: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn ObjectDeleteAuditAlarmA(
        SubsystemName: LPCSTR,
        HandleId: LPVOID,
        GenerateOnClose: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegedServiceAuditAlarmA(
        SubsystemName: LPCSTR,
        ServiceName: LPCSTR,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AddConditionalAce(
        pAcl: PACL,
        dwAceRevision: DWORD,
        AceFlags: DWORD,
        AceType: UCHAR,
        AccessMask: DWORD,
        pSid: PSID,
        ConditionStr: PWCHAR,
        ReturnLength: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileSecurityA(
        lpFileName: LPCSTR,
        SecurityInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileSecurityA(
        lpFileName: LPCSTR,
        RequestedInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        nLength: DWORD,
        lpnLengthNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadDirectoryChangesW(
        hDirectory: HANDLE,
        lpBuffer: LPVOID,
        nBufferLength: DWORD,
        bWatchSubtree: BOOL,
        dwNotifyFilter: DWORD,
        lpBytesReturned: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadDirectoryChangesExW(
        hDirectory: HANDLE,
        lpBuffer: LPVOID,
        nBufferLength: DWORD,
        bWatchSubtree: BOOL,
        dwNotifyFilter: DWORD,
        lpBytesReturned: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,
        ReadDirectoryNotifyInformationClass: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
    ) -> BOOL;
}
extern "C" {
    pub fn MapViewOfFileExNuma(
        hFileMappingObject: HANDLE,
        dwDesiredAccess: DWORD,
        dwFileOffsetHigh: DWORD,
        dwFileOffsetLow: DWORD,
        dwNumberOfBytesToMap: SIZE_T,
        lpBaseAddress: LPVOID,
        nndPreferred: DWORD,
    ) -> LPVOID;
}
extern "C" {
    pub fn IsBadReadPtr(lp: *const ::std::os::raw::c_void, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn IsBadWritePtr(lp: LPVOID, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn IsBadHugeReadPtr(lp: *const ::std::os::raw::c_void, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn IsBadHugeWritePtr(lp: LPVOID, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn IsBadCodePtr(lpfn: FARPROC) -> BOOL;
}
extern "C" {
    pub fn IsBadStringPtrA(lpsz: LPCSTR, ucchMax: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn IsBadStringPtrW(lpsz: LPCWSTR, ucchMax: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn LookupAccountSidA(
        lpSystemName: LPCSTR,
        Sid: PSID,
        Name: LPSTR,
        cchName: LPDWORD,
        ReferencedDomainName: LPSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountSidW(
        lpSystemName: LPCWSTR,
        Sid: PSID,
        Name: LPWSTR,
        cchName: LPDWORD,
        ReferencedDomainName: LPWSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountNameA(
        lpSystemName: LPCSTR,
        lpAccountName: LPCSTR,
        Sid: PSID,
        cbSid: LPDWORD,
        ReferencedDomainName: LPSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountNameW(
        lpSystemName: LPCWSTR,
        lpAccountName: LPCWSTR,
        Sid: PSID,
        cbSid: LPDWORD,
        ReferencedDomainName: LPWSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountNameLocalA(
        lpAccountName: LPCSTR,
        Sid: PSID,
        cbSid: LPDWORD,
        ReferencedDomainName: LPSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountNameLocalW(
        lpAccountName: LPCWSTR,
        Sid: PSID,
        cbSid: LPDWORD,
        ReferencedDomainName: LPWSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountSidLocalA(
        Sid: PSID,
        Name: LPSTR,
        cchName: LPDWORD,
        ReferencedDomainName: LPSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupAccountSidLocalW(
        Sid: PSID,
        Name: LPWSTR,
        cchName: LPDWORD,
        ReferencedDomainName: LPWSTR,
        cchReferencedDomainName: LPDWORD,
        peUse: PSID_NAME_USE,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupPrivilegeValueA(lpSystemName: LPCSTR, lpName: LPCSTR, lpLuid: PLUID) -> BOOL;
}
extern "C" {
    pub fn LookupPrivilegeValueW(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpLuid: PLUID) -> BOOL;
}
extern "C" {
    pub fn LookupPrivilegeNameA(
        lpSystemName: LPCSTR,
        lpLuid: PLUID,
        lpName: LPSTR,
        cchName: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupPrivilegeNameW(
        lpSystemName: LPCWSTR,
        lpLuid: PLUID,
        lpName: LPWSTR,
        cchName: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupPrivilegeDisplayNameA(
        lpSystemName: LPCSTR,
        lpName: LPCSTR,
        lpDisplayName: LPSTR,
        cchDisplayName: LPDWORD,
        lpLanguageId: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LookupPrivilegeDisplayNameW(
        lpSystemName: LPCWSTR,
        lpName: LPCWSTR,
        lpDisplayName: LPWSTR,
        cchDisplayName: LPDWORD,
        lpLanguageId: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn BuildCommDCBA(lpDef: LPCSTR, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
    pub fn BuildCommDCBW(lpDef: LPCWSTR, lpDCB: LPDCB) -> BOOL;
}
extern "C" {
    pub fn BuildCommDCBAndTimeoutsA(
        lpDef: LPCSTR,
        lpDCB: LPDCB,
        lpCommTimeouts: LPCOMMTIMEOUTS,
    ) -> BOOL;
}
extern "C" {
    pub fn BuildCommDCBAndTimeoutsW(
        lpDef: LPCWSTR,
        lpDCB: LPDCB,
        lpCommTimeouts: LPCOMMTIMEOUTS,
    ) -> BOOL;
}
extern "C" {
    pub fn CommConfigDialogA(lpszName: LPCSTR, hWnd: HWND, lpCC: LPCOMMCONFIG) -> BOOL;
}
extern "C" {
    pub fn CommConfigDialogW(lpszName: LPCWSTR, hWnd: HWND, lpCC: LPCOMMCONFIG) -> BOOL;
}
extern "C" {
    pub fn GetDefaultCommConfigA(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetDefaultCommConfigW(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SetDefaultCommConfigA(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetDefaultCommConfigW(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetComputerNameA(lpBuffer: LPSTR, nSize: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetComputerNameW(lpBuffer: LPWSTR, nSize: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn DnsHostnameToComputerNameA(
        Hostname: LPCSTR,
        ComputerName: LPSTR,
        nSize: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn DnsHostnameToComputerNameW(
        Hostname: LPCWSTR,
        ComputerName: LPWSTR,
        nSize: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUserNameA(lpBuffer: LPSTR, pcbBuffer: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetUserNameW(lpBuffer: LPWSTR, pcbBuffer: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn LogonUserA(
        lpszUsername: LPCSTR,
        lpszDomain: LPCSTR,
        lpszPassword: LPCSTR,
        dwLogonType: DWORD,
        dwLogonProvider: DWORD,
        phToken: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn LogonUserW(
        lpszUsername: LPCWSTR,
        lpszDomain: LPCWSTR,
        lpszPassword: LPCWSTR,
        dwLogonType: DWORD,
        dwLogonProvider: DWORD,
        phToken: PHANDLE,
    ) -> BOOL;
}
extern "C" {
    pub fn LogonUserExA(
        lpszUsername: LPCSTR,
        lpszDomain: LPCSTR,
        lpszPassword: LPCSTR,
        dwLogonType: DWORD,
        dwLogonProvider: DWORD,
        phToken: PHANDLE,
        ppLogonSid: *mut PSID,
        ppProfileBuffer: *mut PVOID,
        pdwProfileLength: LPDWORD,
        pQuotaLimits: PQUOTA_LIMITS,
    ) -> BOOL;
}
extern "C" {
    pub fn LogonUserExW(
        lpszUsername: LPCWSTR,
        lpszDomain: LPCWSTR,
        lpszPassword: LPCWSTR,
        dwLogonType: DWORD,
        dwLogonProvider: DWORD,
        phToken: PHANDLE,
        ppLogonSid: *mut PSID,
        ppProfileBuffer: *mut PVOID,
        pdwProfileLength: LPDWORD,
        pQuotaLimits: PQUOTA_LIMITS,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateProcessWithLogonW(
        lpUsername: LPCWSTR,
        lpDomain: LPCWSTR,
        lpPassword: LPCWSTR,
        dwLogonFlags: DWORD,
        lpApplicationName: LPCWSTR,
        lpCommandLine: LPWSTR,
        dwCreationFlags: DWORD,
        lpEnvironment: LPVOID,
        lpCurrentDirectory: LPCWSTR,
        lpStartupInfo: LPSTARTUPINFOW,
        lpProcessInformation: LPPROCESS_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateProcessWithTokenW(
        hToken: HANDLE,
        dwLogonFlags: DWORD,
        lpApplicationName: LPCWSTR,
        lpCommandLine: LPWSTR,
        dwCreationFlags: DWORD,
        lpEnvironment: LPVOID,
        lpCurrentDirectory: LPCWSTR,
        lpStartupInfo: LPSTARTUPINFOW,
        lpProcessInformation: LPPROCESS_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn IsTokenUntrusted(TokenHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn RegisterWaitForSingleObject(
        phNewWaitObject: PHANDLE,
        hObject: HANDLE,
        Callback: WAITORTIMERCALLBACK,
        Context: PVOID,
        dwMilliseconds: ULONG,
        dwFlags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn UnregisterWait(WaitHandle: HANDLE) -> BOOL;
}
extern "C" {
    pub fn BindIoCompletionCallback(
        FileHandle: HANDLE,
        Function: LPOVERLAPPED_COMPLETION_ROUTINE,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetTimerQueueTimer(
        TimerQueue: HANDLE,
        Callback: WAITORTIMERCALLBACK,
        Parameter: PVOID,
        DueTime: DWORD,
        Period: DWORD,
        PreferIo: BOOL,
    ) -> HANDLE;
}
extern "C" {
    pub fn CancelTimerQueueTimer(TimerQueue: HANDLE, Timer: HANDLE) -> BOOL;
}
extern "C" {
    pub fn InitializeThreadpoolEnvironment(pcbe: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn SetThreadpoolCallbackPool(pcbe: PTP_CALLBACK_ENVIRON, ptpp: PTP_POOL);
}
extern "C" {
    pub fn SetThreadpoolCallbackCleanupGroup(
        pcbe: PTP_CALLBACK_ENVIRON,
        ptpcg: PTP_CLEANUP_GROUP,
        pfng: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    );
}
extern "C" {
    pub fn SetThreadpoolCallbackRunsLong(pcbe: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn SetThreadpoolCallbackLibrary(pcbe: PTP_CALLBACK_ENVIRON, mod_: PVOID);
}
extern "C" {
    pub fn SetThreadpoolCallbackPriority(
        pcbe: PTP_CALLBACK_ENVIRON,
        Priority: TP_CALLBACK_PRIORITY,
    );
}
extern "C" {
    pub fn DestroyThreadpoolEnvironment(pcbe: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn SetThreadpoolCallbackPersistent(pcbe: PTP_CALLBACK_ENVIRON);
}
extern "C" {
    pub fn CreatePrivateNamespaceA(
        lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES,
        lpBoundaryDescriptor: LPVOID,
        lpAliasPrefix: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn OpenPrivateNamespaceA(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn CreateBoundaryDescriptorA(Name: LPCSTR, Flags: ULONG) -> HANDLE;
}
extern "C" {
    pub fn AddIntegrityLabelToBoundaryDescriptor(
        BoundaryDescriptor: *mut HANDLE,
        IntegrityLabel: PSID,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHW_PROFILE_INFOA {
    pub dwDockInfo: DWORD,
    pub szHwProfileGuid: [CHAR; 39usize],
    pub szHwProfileName: [CHAR; 80usize],
}
pub type HW_PROFILE_INFOA = tagHW_PROFILE_INFOA;
pub type LPHW_PROFILE_INFOA = *mut tagHW_PROFILE_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHW_PROFILE_INFOW {
    pub dwDockInfo: DWORD,
    pub szHwProfileGuid: [WCHAR; 39usize],
    pub szHwProfileName: [WCHAR; 80usize],
}
pub type HW_PROFILE_INFOW = tagHW_PROFILE_INFOW;
pub type LPHW_PROFILE_INFOW = *mut tagHW_PROFILE_INFOW;
pub type HW_PROFILE_INFO = HW_PROFILE_INFOA;
pub type LPHW_PROFILE_INFO = LPHW_PROFILE_INFOA;
extern "C" {
    pub fn GetCurrentHwProfileA(lpHwProfileInfo: LPHW_PROFILE_INFOA) -> BOOL;
}
extern "C" {
    pub fn GetCurrentHwProfileW(lpHwProfileInfo: LPHW_PROFILE_INFOW) -> BOOL;
}
extern "C" {
    pub fn VerifyVersionInfoA(
        lpVersionInformation: LPOSVERSIONINFOEXA,
        dwTypeMask: DWORD,
        dwlConditionMask: DWORDLONG,
    ) -> BOOL;
}
extern "C" {
    pub fn VerifyVersionInfoW(
        lpVersionInformation: LPOSVERSIONINFOEXW,
        dwTypeMask: DWORD,
        dwlConditionMask: DWORDLONG,
    ) -> BOOL;
}
extern "C" {
    pub fn HRESULT_FROM_WIN32(x: ::std::os::raw::c_ulong) -> HRESULT;
}
extern "C" {
    pub fn HRESULT_FROM_SETUPAPI(x: ::std::os::raw::c_ulong) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_ZONE_INFORMATION {
    pub Bias: LONG,
    pub StandardName: [WCHAR; 32usize],
    pub StandardDate: SYSTEMTIME,
    pub StandardBias: LONG,
    pub DaylightName: [WCHAR; 32usize],
    pub DaylightDate: SYSTEMTIME,
    pub DaylightBias: LONG,
}
pub type TIME_ZONE_INFORMATION = _TIME_ZONE_INFORMATION;
pub type PTIME_ZONE_INFORMATION = *mut _TIME_ZONE_INFORMATION;
pub type LPTIME_ZONE_INFORMATION = *mut _TIME_ZONE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_DYNAMIC_ZONE_INFORMATION {
    pub Bias: LONG,
    pub StandardName: [WCHAR; 32usize],
    pub StandardDate: SYSTEMTIME,
    pub StandardBias: LONG,
    pub DaylightName: [WCHAR; 32usize],
    pub DaylightDate: SYSTEMTIME,
    pub DaylightBias: LONG,
    pub TimeZoneKeyName: [WCHAR; 128usize],
    pub DynamicDaylightTimeDisabled: BOOLEAN,
}
pub type DYNAMIC_TIME_ZONE_INFORMATION = _TIME_DYNAMIC_ZONE_INFORMATION;
pub type PDYNAMIC_TIME_ZONE_INFORMATION = *mut _TIME_DYNAMIC_ZONE_INFORMATION;
extern "C" {
    pub fn SystemTimeToTzSpecificLocalTime(
        lpTimeZoneInformation: *const TIME_ZONE_INFORMATION,
        lpUniversalTime: *const SYSTEMTIME,
        lpLocalTime: LPSYSTEMTIME,
    ) -> BOOL;
}
extern "C" {
    pub fn TzSpecificLocalTimeToSystemTime(
        lpTimeZoneInformation: *const TIME_ZONE_INFORMATION,
        lpLocalTime: *const SYSTEMTIME,
        lpUniversalTime: LPSYSTEMTIME,
    ) -> BOOL;
}
extern "C" {
    pub fn FileTimeToSystemTime(lpFileTime: *const FILETIME, lpSystemTime: LPSYSTEMTIME) -> BOOL;
}
extern "C" {
    pub fn SystemTimeToFileTime(lpSystemTime: *const SYSTEMTIME, lpFileTime: LPFILETIME) -> BOOL;
}
extern "C" {
    pub fn GetTimeZoneInformation(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION) -> DWORD;
}
extern "C" {
    pub fn SetTimeZoneInformation(lpTimeZoneInformation: *const TIME_ZONE_INFORMATION) -> BOOL;
}
extern "C" {
    pub fn SetDynamicTimeZoneInformation(
        lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDynamicTimeZoneInformation(
        pTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION,
    ) -> DWORD;
}
extern "C" {
    pub fn GetTimeZoneInformationForYear(
        wYear: USHORT,
        pdtzi: PDYNAMIC_TIME_ZONE_INFORMATION,
        ptzi: LPTIME_ZONE_INFORMATION,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDynamicTimeZoneInformation(
        dwIndex: DWORD,
        lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION,
    ) -> DWORD;
}
extern "C" {
    pub fn GetDynamicTimeZoneInformationEffectiveYears(
        lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION,
        FirstYear: LPDWORD,
        LastYear: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SystemTimeToTzSpecificLocalTimeEx(
        lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
        lpUniversalTime: *const SYSTEMTIME,
        lpLocalTime: LPSYSTEMTIME,
    ) -> BOOL;
}
extern "C" {
    pub fn TzSpecificLocalTimeToSystemTimeEx(
        lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
        lpLocalTime: *const SYSTEMTIME,
        lpUniversalTime: LPSYSTEMTIME,
    ) -> BOOL;
}
extern "C" {
    pub fn LocalFileTimeToLocalSystemTime(
        timeZoneInformation: *const TIME_ZONE_INFORMATION,
        localFileTime: *const FILETIME,
        localSystemTime: *mut SYSTEMTIME,
    ) -> BOOL;
}
extern "C" {
    pub fn LocalSystemTimeToLocalFileTime(
        timeZoneInformation: *const TIME_ZONE_INFORMATION,
        localSystemTime: *const SYSTEMTIME,
        localFileTime: *mut FILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn SetSystemPowerState(fSuspend: BOOL, fForce: BOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATUS {
    pub ACLineStatus: BYTE,
    pub BatteryFlag: BYTE,
    pub BatteryLifePercent: BYTE,
    pub SystemStatusFlag: BYTE,
    pub BatteryLifeTime: DWORD,
    pub BatteryFullLifeTime: DWORD,
}
pub type SYSTEM_POWER_STATUS = _SYSTEM_POWER_STATUS;
pub type LPSYSTEM_POWER_STATUS = *mut _SYSTEM_POWER_STATUS;
extern "C" {
    pub fn GetSystemPowerStatus(lpSystemPowerStatus: LPSYSTEM_POWER_STATUS) -> BOOL;
}
extern "C" {
    pub fn MapUserPhysicalPagesScatter(
        VirtualAddresses: *mut PVOID,
        NumberOfPages: ULONG_PTR,
        PageArray: PULONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateJobObjectA(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn OpenJobObjectA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn CreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) -> BOOL;
}
extern "C" {
    pub fn FindFirstVolumeA(lpszVolumeName: LPSTR, cchBufferLength: DWORD) -> HANDLE;
}
extern "C" {
    pub fn FindNextVolumeA(
        hFindVolume: HANDLE,
        lpszVolumeName: LPSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FindFirstVolumeMountPointA(
        lpszRootPathName: LPCSTR,
        lpszVolumeMountPoint: LPSTR,
        cchBufferLength: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindFirstVolumeMountPointW(
        lpszRootPathName: LPCWSTR,
        lpszVolumeMountPoint: LPWSTR,
        cchBufferLength: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindNextVolumeMountPointA(
        hFindVolumeMountPoint: HANDLE,
        lpszVolumeMountPoint: LPSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FindNextVolumeMountPointW(
        hFindVolumeMountPoint: HANDLE,
        lpszVolumeMountPoint: LPWSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FindVolumeMountPointClose(hFindVolumeMountPoint: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetVolumeMountPointA(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn DeleteVolumeMountPointA(lpszVolumeMountPoint: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn GetVolumeNameForVolumeMountPointA(
        lpszVolumeMountPoint: LPCSTR,
        lpszVolumeName: LPSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetVolumePathNameA(
        lpszFileName: LPCSTR,
        lpszVolumePathName: LPSTR,
        cchBufferLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetVolumePathNamesForVolumeNameA(
        lpszVolumeName: LPCSTR,
        lpszVolumePathNames: LPCH,
        cchBufferLength: DWORD,
        lpcchReturnLength: PDWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTXA {
    pub cbSize: ULONG,
    pub dwFlags: DWORD,
    pub lpSource: LPCSTR,
    pub wProcessorArchitecture: USHORT,
    pub wLangId: LANGID,
    pub lpAssemblyDirectory: LPCSTR,
    pub lpResourceName: LPCSTR,
    pub lpApplicationName: LPCSTR,
    pub hModule: HMODULE,
}
pub type ACTCTXA = tagACTCTXA;
pub type PACTCTXA = *mut tagACTCTXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTXW {
    pub cbSize: ULONG,
    pub dwFlags: DWORD,
    pub lpSource: LPCWSTR,
    pub wProcessorArchitecture: USHORT,
    pub wLangId: LANGID,
    pub lpAssemblyDirectory: LPCWSTR,
    pub lpResourceName: LPCWSTR,
    pub lpApplicationName: LPCWSTR,
    pub hModule: HMODULE,
}
pub type ACTCTXW = tagACTCTXW;
pub type PACTCTXW = *mut tagACTCTXW;
pub type ACTCTX = ACTCTXA;
pub type PACTCTX = PACTCTXA;
pub type PCACTCTXA = *const ACTCTXA;
pub type PCACTCTXW = *const ACTCTXW;
pub type PCACTCTX = PCACTCTXA;
extern "C" {
    pub fn CreateActCtxA(pActCtx: PCACTCTXA) -> HANDLE;
}
extern "C" {
    pub fn CreateActCtxW(pActCtx: PCACTCTXW) -> HANDLE;
}
extern "C" {
    pub fn AddRefActCtx(hActCtx: HANDLE);
}
extern "C" {
    pub fn ReleaseActCtx(hActCtx: HANDLE);
}
extern "C" {
    pub fn ZombifyActCtx(hActCtx: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ActivateActCtx(hActCtx: HANDLE, lpCookie: *mut ULONG_PTR) -> BOOL;
}
extern "C" {
    pub fn DeactivateActCtx(dwFlags: DWORD, ulCookie: ULONG_PTR) -> BOOL;
}
extern "C" {
    pub fn GetCurrentActCtx(lphActCtx: *mut HANDLE) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    pub cbSize: ULONG,
    pub ulDataFormatVersion: ULONG,
    pub lpData: PVOID,
    pub ulLength: ULONG,
    pub lpSectionGlobalData: PVOID,
    pub ulSectionGlobalDataLength: ULONG,
    pub lpSectionBase: PVOID,
    pub ulSectionTotalLength: ULONG,
    pub hActCtx: HANDLE,
    pub ulAssemblyRosterIndex: ULONG,
}
pub type ACTCTX_SECTION_KEYED_DATA_2600 = tagACTCTX_SECTION_KEYED_DATA_2600;
pub type PACTCTX_SECTION_KEYED_DATA_2600 = *mut tagACTCTX_SECTION_KEYED_DATA_2600;
pub type PCACTCTX_SECTION_KEYED_DATA_2600 = *const ACTCTX_SECTION_KEYED_DATA_2600;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    pub lpInformation: PVOID,
    pub lpSectionBase: PVOID,
    pub ulSectionLength: ULONG,
    pub lpSectionGlobalDataBase: PVOID,
    pub ulSectionGlobalDataLength: ULONG,
}
pub type ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
    tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub type PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
    *mut tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub type PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA =
    *const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACTCTX_SECTION_KEYED_DATA {
    pub cbSize: ULONG,
    pub ulDataFormatVersion: ULONG,
    pub lpData: PVOID,
    pub ulLength: ULONG,
    pub lpSectionGlobalData: PVOID,
    pub ulSectionGlobalDataLength: ULONG,
    pub lpSectionBase: PVOID,
    pub ulSectionTotalLength: ULONG,
    pub hActCtx: HANDLE,
    pub ulAssemblyRosterIndex: ULONG,
    pub ulFlags: ULONG,
    pub AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
}
pub type ACTCTX_SECTION_KEYED_DATA = tagACTCTX_SECTION_KEYED_DATA;
pub type PACTCTX_SECTION_KEYED_DATA = *mut tagACTCTX_SECTION_KEYED_DATA;
pub type PCACTCTX_SECTION_KEYED_DATA = *const ACTCTX_SECTION_KEYED_DATA;
extern "C" {
    pub fn FindActCtxSectionStringA(
        dwFlags: DWORD,
        lpExtensionGuid: *const GUID,
        ulSectionId: ULONG,
        lpStringToFind: LPCSTR,
        ReturnedData: PACTCTX_SECTION_KEYED_DATA,
    ) -> BOOL;
}
extern "C" {
    pub fn FindActCtxSectionStringW(
        dwFlags: DWORD,
        lpExtensionGuid: *const GUID,
        ulSectionId: ULONG,
        lpStringToFind: LPCWSTR,
        ReturnedData: PACTCTX_SECTION_KEYED_DATA,
    ) -> BOOL;
}
extern "C" {
    pub fn FindActCtxSectionGuid(
        dwFlags: DWORD,
        lpExtensionGuid: *const GUID,
        ulSectionId: ULONG,
        lpGuidToFind: *const GUID,
        ReturnedData: PACTCTX_SECTION_KEYED_DATA,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    pub hActCtx: HANDLE,
    pub dwFlags: DWORD,
}
pub type ACTIVATION_CONTEXT_BASIC_INFORMATION = _ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub type PACTIVATION_CONTEXT_BASIC_INFORMATION = *mut _ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub type PCACTIVATION_CONTEXT_BASIC_INFORMATION = *const _ACTIVATION_CONTEXT_BASIC_INFORMATION;
extern "C" {
    pub fn QueryActCtxW(
        dwFlags: DWORD,
        hActCtx: HANDLE,
        pvSubInstance: PVOID,
        ulInfoClass: ULONG,
        pvBuffer: PVOID,
        cbBuffer: SIZE_T,
        pcbWrittenOrRequired: *mut SIZE_T,
    ) -> BOOL;
}
pub type PQUERYACTCTXW_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwFlags: DWORD,
        hActCtx: HANDLE,
        pvSubInstance: PVOID,
        ulInfoClass: ULONG,
        pvBuffer: PVOID,
        cbBuffer: SIZE_T,
        pcbWrittenOrRequired: *mut SIZE_T,
    ) -> BOOL,
>;
extern "C" {
    pub fn WTSGetActiveConsoleSessionId() -> DWORD;
}
extern "C" {
    pub fn WTSGetServiceSessionId() -> DWORD;
}
extern "C" {
    pub fn WTSIsServerContainer() -> BOOLEAN;
}
extern "C" {
    pub fn GetActiveProcessorGroupCount() -> WORD;
}
extern "C" {
    pub fn GetMaximumProcessorGroupCount() -> WORD;
}
extern "C" {
    pub fn GetActiveProcessorCount(GroupNumber: WORD) -> DWORD;
}
extern "C" {
    pub fn GetMaximumProcessorCount(GroupNumber: WORD) -> DWORD;
}
extern "C" {
    pub fn GetNumaProcessorNode(Processor: UCHAR, NodeNumber: PUCHAR) -> BOOL;
}
extern "C" {
    pub fn GetNumaNodeNumberFromHandle(hFile: HANDLE, NodeNumber: PUSHORT) -> BOOL;
}
extern "C" {
    pub fn GetNumaProcessorNodeEx(Processor: PPROCESSOR_NUMBER, NodeNumber: PUSHORT) -> BOOL;
}
extern "C" {
    pub fn GetNumaNodeProcessorMask(Node: UCHAR, ProcessorMask: PULONGLONG) -> BOOL;
}
extern "C" {
    pub fn GetNumaAvailableMemoryNode(Node: UCHAR, AvailableBytes: PULONGLONG) -> BOOL;
}
extern "C" {
    pub fn GetNumaAvailableMemoryNodeEx(Node: USHORT, AvailableBytes: PULONGLONG) -> BOOL;
}
extern "C" {
    pub fn GetNumaProximityNode(ProximityId: ULONG, NodeNumber: PUCHAR) -> BOOL;
}
pub type APPLICATION_RECOVERY_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(pvParameter: PVOID) -> DWORD>;
extern "C" {
    pub fn RegisterApplicationRecoveryCallback(
        pRecoveyCallback: APPLICATION_RECOVERY_CALLBACK,
        pvParameter: PVOID,
        dwPingInterval: DWORD,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn UnregisterApplicationRecoveryCallback() -> HRESULT;
}
extern "C" {
    pub fn RegisterApplicationRestart(pwzCommandline: PCWSTR, dwFlags: DWORD) -> HRESULT;
}
extern "C" {
    pub fn UnregisterApplicationRestart() -> HRESULT;
}
extern "C" {
    pub fn GetApplicationRecoveryCallback(
        hProcess: HANDLE,
        pRecoveryCallback: *mut APPLICATION_RECOVERY_CALLBACK,
        ppvParameter: *mut PVOID,
        pdwPingInterval: PDWORD,
        pdwFlags: PDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetApplicationRestartSettings(
        hProcess: HANDLE,
        pwzCommandline: PWSTR,
        pcchSize: PDWORD,
        pdwFlags: PDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn ApplicationRecoveryInProgress(pbCancelled: PBOOL) -> HRESULT;
}
extern "C" {
    pub fn ApplicationRecoveryFinished(bSuccess: BOOL);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFO {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: DWORD,
}
pub type FILE_BASIC_INFO = _FILE_BASIC_INFO;
pub type PFILE_BASIC_INFO = *mut _FILE_BASIC_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFO {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: DWORD,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
pub type FILE_STANDARD_INFO = _FILE_STANDARD_INFO;
pub type PFILE_STANDARD_INFO = *mut _FILE_STANDARD_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFO {
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_NAME_INFO = _FILE_NAME_INFO;
pub type PFILE_NAME_INFO = *mut _FILE_NAME_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_CASE_SENSITIVE_INFO {
    pub Flags: ULONG,
}
pub type FILE_CASE_SENSITIVE_INFO = _FILE_CASE_SENSITIVE_INFO;
pub type PFILE_CASE_SENSITIVE_INFO = *mut _FILE_CASE_SENSITIVE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_RENAME_INFO {
    pub __bindgen_anon_1: _FILE_RENAME_INFO__bindgen_ty_1,
    pub RootDirectory: HANDLE,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_RENAME_INFO__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub Flags: DWORD,
}
pub type FILE_RENAME_INFO = _FILE_RENAME_INFO;
pub type PFILE_RENAME_INFO = *mut _FILE_RENAME_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFO {
    pub AllocationSize: LARGE_INTEGER,
}
pub type FILE_ALLOCATION_INFO = _FILE_ALLOCATION_INFO;
pub type PFILE_ALLOCATION_INFO = *mut _FILE_ALLOCATION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFO {
    pub EndOfFile: LARGE_INTEGER,
}
pub type FILE_END_OF_FILE_INFO = _FILE_END_OF_FILE_INFO;
pub type PFILE_END_OF_FILE_INFO = *mut _FILE_END_OF_FILE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFO {
    pub NextEntryOffset: DWORD,
    pub StreamNameLength: DWORD,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [WCHAR; 1usize],
}
pub type FILE_STREAM_INFO = _FILE_STREAM_INFO;
pub type PFILE_STREAM_INFO = *mut _FILE_STREAM_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFO {
    pub CompressedFileSize: LARGE_INTEGER,
    pub CompressionFormat: WORD,
    pub CompressionUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
pub type FILE_COMPRESSION_INFO = _FILE_COMPRESSION_INFO;
pub type PFILE_COMPRESSION_INFO = *mut _FILE_COMPRESSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFO {
    pub FileAttributes: DWORD,
    pub ReparseTag: DWORD,
}
pub type FILE_ATTRIBUTE_TAG_INFO = _FILE_ATTRIBUTE_TAG_INFO;
pub type PFILE_ATTRIBUTE_TAG_INFO = *mut _FILE_ATTRIBUTE_TAG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFO {
    pub DeleteFileA: BOOLEAN,
}
pub type FILE_DISPOSITION_INFO = _FILE_DISPOSITION_INFO;
pub type PFILE_DISPOSITION_INFO = *mut _FILE_DISPOSITION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFO_EX {
    pub Flags: DWORD,
}
pub type FILE_DISPOSITION_INFO_EX = _FILE_DISPOSITION_INFO_EX;
pub type PFILE_DISPOSITION_INFO_EX = *mut _FILE_DISPOSITION_INFO_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFO {
    pub NextEntryOffset: DWORD,
    pub FileIndex: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub FileNameLength: DWORD,
    pub EaSize: DWORD,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_BOTH_DIR_INFO = _FILE_ID_BOTH_DIR_INFO;
pub type PFILE_ID_BOTH_DIR_INFO = *mut _FILE_ID_BOTH_DIR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFO {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_FULL_DIR_INFO = _FILE_FULL_DIR_INFO;
pub type PFILE_FULL_DIR_INFO = *mut _FILE_FULL_DIR_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PRIORITY_HINT {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow = 1,
    IoPriorityHintNormal = 2,
    MaximumIoPriorityHintType = 3,
}
pub use self::_PRIORITY_HINT as PRIORITY_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFO {
    pub PriorityHint: PRIORITY_HINT,
}
pub type FILE_IO_PRIORITY_HINT_INFO = _FILE_IO_PRIORITY_HINT_INFO;
pub type PFILE_IO_PRIORITY_HINT_INFO = *mut _FILE_IO_PRIORITY_HINT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFO {
    pub AlignmentRequirement: ULONG,
}
pub type FILE_ALIGNMENT_INFO = _FILE_ALIGNMENT_INFO;
pub type PFILE_ALIGNMENT_INFO = *mut _FILE_ALIGNMENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_INFO {
    pub LogicalBytesPerSector: ULONG,
    pub PhysicalBytesPerSectorForAtomicity: ULONG,
    pub PhysicalBytesPerSectorForPerformance: ULONG,
    pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
    pub Flags: ULONG,
    pub ByteOffsetForSectorAlignment: ULONG,
    pub ByteOffsetForPartitionAlignment: ULONG,
}
pub type FILE_STORAGE_INFO = _FILE_STORAGE_INFO;
pub type PFILE_STORAGE_INFO = *mut _FILE_STORAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_INFO {
    pub VolumeSerialNumber: ULONGLONG,
    pub FileId: FILE_ID_128,
}
pub type FILE_ID_INFO = _FILE_ID_INFO;
pub type PFILE_ID_INFO = *mut _FILE_ID_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_DIR_INFO {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: FILE_ID_128,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_ID_EXTD_DIR_INFO = _FILE_ID_EXTD_DIR_INFO;
pub type PFILE_ID_EXTD_DIR_INFO = *mut _FILE_ID_EXTD_DIR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO {
    pub StructureVersion: USHORT,
    pub StructureSize: USHORT,
    pub Protocol: ULONG,
    pub ProtocolMajorVersion: USHORT,
    pub ProtocolMinorVersion: USHORT,
    pub ProtocolRevision: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub GenericReserved: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1,
    pub ProtocolSpecific: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1 {
    pub Reserved: [ULONG; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2 {
    pub Smb2: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1,
    pub Reserved: [ULONG; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1 {
    pub Server: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Share: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub Capabilities: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub Capabilities: ULONG,
    pub ShareFlags: ULONG,
}
pub type FILE_REMOTE_PROTOCOL_INFO = _FILE_REMOTE_PROTOCOL_INFO;
pub type PFILE_REMOTE_PROTOCOL_INFO = *mut _FILE_REMOTE_PROTOCOL_INFO;
extern "C" {
    pub fn GetFileInformationByHandleEx(
        hFile: HANDLE,
        FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,
        lpFileInformation: LPVOID,
        dwBufferSize: DWORD,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_ID_TYPE {
    FileIdType = 0,
    ObjectIdType = 1,
    ExtendedFileIdType = 2,
    MaximumFileIdType = 3,
}
pub use self::_FILE_ID_TYPE as FILE_ID_TYPE;
pub type PFILE_ID_TYPE = *mut _FILE_ID_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FILE_ID_DESCRIPTOR {
    pub dwSize: DWORD,
    pub Type: FILE_ID_TYPE,
    pub __bindgen_anon_1: FILE_ID_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FILE_ID_DESCRIPTOR__bindgen_ty_1 {
    pub FileId: LARGE_INTEGER,
    pub ObjectId: GUID,
    pub ExtendedFileId: FILE_ID_128,
}
pub type LPFILE_ID_DESCRIPTOR = *mut FILE_ID_DESCRIPTOR;
extern "C" {
    pub fn OpenFileById(
        hVolumeHint: HANDLE,
        lpFileId: LPFILE_ID_DESCRIPTOR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwFlagsAndAttributes: DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn CreateSymbolicLinkA(
        lpSymlinkFileName: LPCSTR,
        lpTargetFileName: LPCSTR,
        dwFlags: DWORD,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn CreateSymbolicLinkW(
        lpSymlinkFileName: LPCWSTR,
        lpTargetFileName: LPCWSTR,
        dwFlags: DWORD,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn QueryActCtxSettingsW(
        dwFlags: DWORD,
        hActCtx: HANDLE,
        settingsNameSpace: PCWSTR,
        settingName: PCWSTR,
        pvBuffer: PWSTR,
        dwBuffer: SIZE_T,
        pdwWrittenOrRequired: *mut SIZE_T,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateSymbolicLinkTransactedA(
        lpSymlinkFileName: LPCSTR,
        lpTargetFileName: LPCSTR,
        dwFlags: DWORD,
        hTransaction: HANDLE,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn CreateSymbolicLinkTransactedW(
        lpSymlinkFileName: LPCWSTR,
        lpTargetFileName: LPCWSTR,
        dwFlags: DWORD,
        hTransaction: HANDLE,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn ReplacePartitionUnit(
        TargetPartition: PWSTR,
        SparePartition: PWSTR,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn AddSecureMemoryCacheCallback(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK) -> BOOL;
}
extern "C" {
    pub fn RemoveSecureMemoryCacheCallback(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK) -> BOOL;
}
extern "C" {
    pub fn CopyContext(Destination: PCONTEXT, ContextFlags: DWORD, Source: PCONTEXT) -> BOOL;
}
extern "C" {
    pub fn InitializeContext(
        Buffer: PVOID,
        ContextFlags: DWORD,
        Context: *mut PCONTEXT,
        ContextLength: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitializeContext2(
        Buffer: PVOID,
        ContextFlags: DWORD,
        Context: *mut PCONTEXT,
        ContextLength: PDWORD,
        XStateCompactionMask: ULONG64,
    ) -> BOOL;
}
extern "C" {
    pub fn GetEnabledXStateFeatures() -> DWORD64;
}
extern "C" {
    pub fn GetXStateFeaturesMask(Context: PCONTEXT, FeatureMask: PDWORD64) -> BOOL;
}
extern "C" {
    pub fn LocateXStateFeature(Context: PCONTEXT, FeatureId: DWORD, Length: PDWORD) -> PVOID;
}
extern "C" {
    pub fn SetXStateFeaturesMask(Context: PCONTEXT, FeatureMask: DWORD64) -> BOOL;
}
extern "C" {
    pub fn GetThreadEnabledXStateFeatures() -> DWORD64;
}
extern "C" {
    pub fn EnableProcessOptionalXStateFeatures(Features: DWORD64) -> BOOL;
}
extern "C" {
    pub fn EnableThreadProfiling(
        ThreadHandle: HANDLE,
        Flags: DWORD,
        HardwareCounters: DWORD64,
        PerformanceDataHandle: *mut HANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn DisableThreadProfiling(PerformanceDataHandle: HANDLE) -> DWORD;
}
extern "C" {
    pub fn QueryThreadProfiling(ThreadHandle: HANDLE, Enabled: PBOOLEAN) -> DWORD;
}
extern "C" {
    pub fn ReadThreadProfilingData(
        PerformanceDataHandle: HANDLE,
        Flags: DWORD,
        PerformanceData: PPERFORMANCE_DATA,
    ) -> DWORD;
}
extern "C" {
    pub fn RaiseCustomSystemEventTrigger(
        CustomSystemEventTriggerConfig: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
    ) -> DWORD;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedIncrement@@YAIPECI@Z"]
    pub fn _InterlockedIncrement1(Addend: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedIncrement@@YAKPECK@Z"]
    pub fn _InterlockedIncrement2(Addend: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedIncrement@@YA_KPEC_K@Z"]
    pub fn _InterlockedIncrement3(
        Addend: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedDecrement@@YAIPECI@Z"]
    pub fn _InterlockedDecrement1(Addend: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedDecrement@@YAKPECK@Z"]
    pub fn _InterlockedDecrement2(Addend: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedDecrement@@YA_KPEC_K@Z"]
    pub fn _InterlockedDecrement3(
        Addend: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedExchange@@YAIPECII@Z"]
    pub fn _InterlockedExchange1(
        Target: *mut ::std::os::raw::c_uint,
        Value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedExchange@@YAKPECKK@Z"]
    pub fn _InterlockedExchange2(
        Target: *mut ::std::os::raw::c_ulong,
        Value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedExchange@@YA_KPEC_K_K@Z"]
    pub fn _InterlockedExchange3(
        Target: *mut ::std::os::raw::c_ulonglong,
        Value: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedExchangeAdd@@YAIPECII@Z"]
    pub fn _InterlockedExchangeAdd1(
        Addend: *mut ::std::os::raw::c_uint,
        Value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?InterlockedExchangeSubtract@@YAIPECII@Z"]
    pub fn InterlockedExchangeSubtract(
        Addend: *mut ::std::os::raw::c_uint,
        Value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedExchangeAdd@@YAKPECKK@Z"]
    pub fn _InterlockedExchangeAdd2(
        Addend: *mut ::std::os::raw::c_ulong,
        Value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?InterlockedExchangeSubtract@@YAKPECKK@Z"]
    pub fn InterlockedExchangeSubtract1(
        Addend: *mut ::std::os::raw::c_ulong,
        Value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedExchangeAdd@@YA_KPEC_K_K@Z"]
    pub fn _InterlockedExchangeAdd3(
        Addend: *mut ::std::os::raw::c_ulonglong,
        Value: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?InterlockedExchangeSubtract@@YA_KPEC_K_K@Z"]
    pub fn InterlockedExchangeSubtract2(
        Addend: *mut ::std::os::raw::c_ulonglong,
        Value: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedCompareExchange@@YAIPECIII@Z"]
    pub fn _InterlockedCompareExchange1(
        Destination: *mut ::std::os::raw::c_uint,
        Exchange: ::std::os::raw::c_uint,
        Comperand: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedCompareExchange@@YAKPECKKK@Z"]
    pub fn _InterlockedCompareExchange2(
        Destination: *mut ::std::os::raw::c_ulong,
        Exchange: ::std::os::raw::c_ulong,
        Comperand: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedCompareExchange@@YA_KPEC_K_K1@Z"]
    pub fn _InterlockedCompareExchange3(
        Destination: *mut ::std::os::raw::c_ulonglong,
        Exchange: ::std::os::raw::c_ulonglong,
        Comperand: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedAnd@@YA_KPEC_K_K@Z"]
    pub fn _InterlockedAnd1(
        Destination: *mut ::std::os::raw::c_ulonglong,
        Value: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedOr@@YA_KPEC_K_K@Z"]
    pub fn _InterlockedOr1(
        Destination: *mut ::std::os::raw::c_ulonglong,
        Value: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}?_InterlockedXor@@YA_KPEC_K_K@Z"]
    pub fn _InterlockedXor1(
        Destination: *mut ::std::os::raw::c_ulonglong,
        Value: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRAWPATRECT {
    pub ptPosition: POINT,
    pub ptSize: POINT,
    pub wStyle: WORD,
    pub wPattern: WORD,
}
pub type DRAWPATRECT = _DRAWPATRECT;
pub type PDRAWPATRECT = *mut _DRAWPATRECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSINJECTDATA {
    pub DataBytes: DWORD,
    pub InjectionPoint: WORD,
    pub PageNumber: WORD,
}
pub type PSINJECTDATA = _PSINJECTDATA;
pub type PPSINJECTDATA = *mut _PSINJECTDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSFEATURE_OUTPUT {
    pub bPageIndependent: BOOL,
    pub bSetPageDevice: BOOL,
}
pub type PSFEATURE_OUTPUT = _PSFEATURE_OUTPUT;
pub type PPSFEATURE_OUTPUT = *mut _PSFEATURE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSFEATURE_CUSTPAPER {
    pub lOrientation: LONG,
    pub lWidth: LONG,
    pub lHeight: LONG,
    pub lWidthOffset: LONG,
    pub lHeightOffset: LONG,
}
pub type PSFEATURE_CUSTPAPER = _PSFEATURE_CUSTPAPER;
pub type PPSFEATURE_CUSTPAPER = *mut _PSFEATURE_CUSTPAPER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagXFORM {
    pub eM11: FLOAT,
    pub eM12: FLOAT,
    pub eM21: FLOAT,
    pub eM22: FLOAT,
    pub eDx: FLOAT,
    pub eDy: FLOAT,
}
pub type XFORM = tagXFORM;
pub type PXFORM = *mut tagXFORM;
pub type LPXFORM = *mut tagXFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAP {
    pub bmType: LONG,
    pub bmWidth: LONG,
    pub bmHeight: LONG,
    pub bmWidthBytes: LONG,
    pub bmPlanes: WORD,
    pub bmBitsPixel: WORD,
    pub bmBits: LPVOID,
}
pub type BITMAP = tagBITMAP;
pub type PBITMAP = *mut tagBITMAP;
pub type NPBITMAP = *mut tagBITMAP;
pub type LPBITMAP = *mut tagBITMAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRGBTRIPLE {
    pub rgbtBlue: BYTE,
    pub rgbtGreen: BYTE,
    pub rgbtRed: BYTE,
}
pub type RGBTRIPLE = tagRGBTRIPLE;
pub type PRGBTRIPLE = *mut tagRGBTRIPLE;
pub type NPRGBTRIPLE = *mut tagRGBTRIPLE;
pub type LPRGBTRIPLE = *mut tagRGBTRIPLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRGBQUAD {
    pub rgbBlue: BYTE,
    pub rgbGreen: BYTE,
    pub rgbRed: BYTE,
    pub rgbReserved: BYTE,
}
pub type RGBQUAD = tagRGBQUAD;
pub type LPRGBQUAD = *mut RGBQUAD;
pub type LCSCSTYPE = LONG;
pub type LCSGAMUTMATCH = LONG;
pub type FXPT16DOT16 = ::std::os::raw::c_long;
pub type LPFXPT16DOT16 = *mut ::std::os::raw::c_long;
pub type FXPT2DOT30 = ::std::os::raw::c_long;
pub type LPFXPT2DOT30 = *mut ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCIEXYZ {
    pub ciexyzX: FXPT2DOT30,
    pub ciexyzY: FXPT2DOT30,
    pub ciexyzZ: FXPT2DOT30,
}
pub type CIEXYZ = tagCIEXYZ;
pub type LPCIEXYZ = *mut CIEXYZ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagICEXYZTRIPLE {
    pub ciexyzRed: CIEXYZ,
    pub ciexyzGreen: CIEXYZ,
    pub ciexyzBlue: CIEXYZ,
}
pub type CIEXYZTRIPLE = tagICEXYZTRIPLE;
pub type LPCIEXYZTRIPLE = *mut CIEXYZTRIPLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGCOLORSPACEA {
    pub lcsSignature: DWORD,
    pub lcsVersion: DWORD,
    pub lcsSize: DWORD,
    pub lcsCSType: LCSCSTYPE,
    pub lcsIntent: LCSGAMUTMATCH,
    pub lcsEndpoints: CIEXYZTRIPLE,
    pub lcsGammaRed: DWORD,
    pub lcsGammaGreen: DWORD,
    pub lcsGammaBlue: DWORD,
    pub lcsFilename: [CHAR; 260usize],
}
pub type LOGCOLORSPACEA = tagLOGCOLORSPACEA;
pub type LPLOGCOLORSPACEA = *mut tagLOGCOLORSPACEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGCOLORSPACEW {
    pub lcsSignature: DWORD,
    pub lcsVersion: DWORD,
    pub lcsSize: DWORD,
    pub lcsCSType: LCSCSTYPE,
    pub lcsIntent: LCSGAMUTMATCH,
    pub lcsEndpoints: CIEXYZTRIPLE,
    pub lcsGammaRed: DWORD,
    pub lcsGammaGreen: DWORD,
    pub lcsGammaBlue: DWORD,
    pub lcsFilename: [WCHAR; 260usize],
}
pub type LOGCOLORSPACEW = tagLOGCOLORSPACEW;
pub type LPLOGCOLORSPACEW = *mut tagLOGCOLORSPACEW;
pub type LOGCOLORSPACE = LOGCOLORSPACEA;
pub type LPLOGCOLORSPACE = LPLOGCOLORSPACEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPCOREHEADER {
    pub bcSize: DWORD,
    pub bcWidth: WORD,
    pub bcHeight: WORD,
    pub bcPlanes: WORD,
    pub bcBitCount: WORD,
}
pub type BITMAPCOREHEADER = tagBITMAPCOREHEADER;
pub type LPBITMAPCOREHEADER = *mut tagBITMAPCOREHEADER;
pub type PBITMAPCOREHEADER = *mut tagBITMAPCOREHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPINFOHEADER {
    pub biSize: DWORD,
    pub biWidth: LONG,
    pub biHeight: LONG,
    pub biPlanes: WORD,
    pub biBitCount: WORD,
    pub biCompression: DWORD,
    pub biSizeImage: DWORD,
    pub biXPelsPerMeter: LONG,
    pub biYPelsPerMeter: LONG,
    pub biClrUsed: DWORD,
    pub biClrImportant: DWORD,
}
pub type BITMAPINFOHEADER = tagBITMAPINFOHEADER;
pub type LPBITMAPINFOHEADER = *mut tagBITMAPINFOHEADER;
pub type PBITMAPINFOHEADER = *mut tagBITMAPINFOHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BITMAPV4HEADER {
    pub bV4Size: DWORD,
    pub bV4Width: LONG,
    pub bV4Height: LONG,
    pub bV4Planes: WORD,
    pub bV4BitCount: WORD,
    pub bV4V4Compression: DWORD,
    pub bV4SizeImage: DWORD,
    pub bV4XPelsPerMeter: LONG,
    pub bV4YPelsPerMeter: LONG,
    pub bV4ClrUsed: DWORD,
    pub bV4ClrImportant: DWORD,
    pub bV4RedMask: DWORD,
    pub bV4GreenMask: DWORD,
    pub bV4BlueMask: DWORD,
    pub bV4AlphaMask: DWORD,
    pub bV4CSType: DWORD,
    pub bV4Endpoints: CIEXYZTRIPLE,
    pub bV4GammaRed: DWORD,
    pub bV4GammaGreen: DWORD,
    pub bV4GammaBlue: DWORD,
}
pub type LPBITMAPV4HEADER = *mut BITMAPV4HEADER;
pub type PBITMAPV4HEADER = *mut BITMAPV4HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BITMAPV5HEADER {
    pub bV5Size: DWORD,
    pub bV5Width: LONG,
    pub bV5Height: LONG,
    pub bV5Planes: WORD,
    pub bV5BitCount: WORD,
    pub bV5Compression: DWORD,
    pub bV5SizeImage: DWORD,
    pub bV5XPelsPerMeter: LONG,
    pub bV5YPelsPerMeter: LONG,
    pub bV5ClrUsed: DWORD,
    pub bV5ClrImportant: DWORD,
    pub bV5RedMask: DWORD,
    pub bV5GreenMask: DWORD,
    pub bV5BlueMask: DWORD,
    pub bV5AlphaMask: DWORD,
    pub bV5CSType: DWORD,
    pub bV5Endpoints: CIEXYZTRIPLE,
    pub bV5GammaRed: DWORD,
    pub bV5GammaGreen: DWORD,
    pub bV5GammaBlue: DWORD,
    pub bV5Intent: DWORD,
    pub bV5ProfileData: DWORD,
    pub bV5ProfileSize: DWORD,
    pub bV5Reserved: DWORD,
}
pub type LPBITMAPV5HEADER = *mut BITMAPV5HEADER;
pub type PBITMAPV5HEADER = *mut BITMAPV5HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPINFO {
    pub bmiHeader: BITMAPINFOHEADER,
    pub bmiColors: [RGBQUAD; 1usize],
}
pub type BITMAPINFO = tagBITMAPINFO;
pub type LPBITMAPINFO = *mut tagBITMAPINFO;
pub type PBITMAPINFO = *mut tagBITMAPINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPCOREINFO {
    pub bmciHeader: BITMAPCOREHEADER,
    pub bmciColors: [RGBTRIPLE; 1usize],
}
pub type BITMAPCOREINFO = tagBITMAPCOREINFO;
pub type LPBITMAPCOREINFO = *mut tagBITMAPCOREINFO;
pub type PBITMAPCOREINFO = *mut tagBITMAPCOREINFO;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPFILEHEADER {
    pub bfType: WORD,
    pub bfSize: DWORD,
    pub bfReserved1: WORD,
    pub bfReserved2: WORD,
    pub bfOffBits: DWORD,
}
pub type BITMAPFILEHEADER = tagBITMAPFILEHEADER;
pub type LPBITMAPFILEHEADER = *mut tagBITMAPFILEHEADER;
pub type PBITMAPFILEHEADER = *mut tagBITMAPFILEHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFONTSIGNATURE {
    pub fsUsb: [DWORD; 4usize],
    pub fsCsb: [DWORD; 2usize],
}
pub type FONTSIGNATURE = tagFONTSIGNATURE;
pub type PFONTSIGNATURE = *mut tagFONTSIGNATURE;
pub type LPFONTSIGNATURE = *mut tagFONTSIGNATURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCHARSETINFO {
    pub ciCharset: UINT,
    pub ciACP: UINT,
    pub fs: FONTSIGNATURE,
}
pub type CHARSETINFO = tagCHARSETINFO;
pub type PCHARSETINFO = *mut tagCHARSETINFO;
pub type NPCHARSETINFO = *mut tagCHARSETINFO;
pub type LPCHARSETINFO = *mut tagCHARSETINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOCALESIGNATURE {
    pub lsUsb: [DWORD; 4usize],
    pub lsCsbDefault: [DWORD; 2usize],
    pub lsCsbSupported: [DWORD; 2usize],
}
pub type LOCALESIGNATURE = tagLOCALESIGNATURE;
pub type PLOCALESIGNATURE = *mut tagLOCALESIGNATURE;
pub type LPLOCALESIGNATURE = *mut tagLOCALESIGNATURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHANDLETABLE {
    pub objectHandle: [HGDIOBJ; 1usize],
}
pub type HANDLETABLE = tagHANDLETABLE;
pub type PHANDLETABLE = *mut tagHANDLETABLE;
pub type LPHANDLETABLE = *mut tagHANDLETABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMETARECORD {
    pub rdSize: DWORD,
    pub rdFunction: WORD,
    pub rdParm: [WORD; 1usize],
}
pub type METARECORD = tagMETARECORD;
pub type PMETARECORD = *mut tagMETARECORD;
pub type LPMETARECORD = *mut tagMETARECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMETAFILEPICT {
    pub mm: LONG,
    pub xExt: LONG,
    pub yExt: LONG,
    pub hMF: HMETAFILE,
}
pub type METAFILEPICT = tagMETAFILEPICT;
pub type LPMETAFILEPICT = *mut tagMETAFILEPICT;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct tagMETAHEADER {
    pub mtType: WORD,
    pub mtHeaderSize: WORD,
    pub mtVersion: WORD,
    pub mtSize: DWORD,
    pub mtNoObjects: WORD,
    pub mtMaxRecord: DWORD,
    pub mtNoParameters: WORD,
}
pub type METAHEADER = tagMETAHEADER;
pub type PMETAHEADER = *mut tagMETAHEADER;
pub type LPMETAHEADER = *mut tagMETAHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENHMETARECORD {
    pub iType: DWORD,
    pub nSize: DWORD,
    pub dParm: [DWORD; 1usize],
}
pub type ENHMETARECORD = tagENHMETARECORD;
pub type PENHMETARECORD = *mut tagENHMETARECORD;
pub type LPENHMETARECORD = *mut tagENHMETARECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENHMETAHEADER {
    pub iType: DWORD,
    pub nSize: DWORD,
    pub rclBounds: RECTL,
    pub rclFrame: RECTL,
    pub dSignature: DWORD,
    pub nVersion: DWORD,
    pub nBytes: DWORD,
    pub nRecords: DWORD,
    pub nHandles: WORD,
    pub sReserved: WORD,
    pub nDescription: DWORD,
    pub offDescription: DWORD,
    pub nPalEntries: DWORD,
    pub szlDevice: SIZEL,
    pub szlMillimeters: SIZEL,
    pub cbPixelFormat: DWORD,
    pub offPixelFormat: DWORD,
    pub bOpenGL: DWORD,
    pub szlMicrometers: SIZEL,
}
pub type ENHMETAHEADER = tagENHMETAHEADER;
pub type PENHMETAHEADER = *mut tagENHMETAHEADER;
pub type LPENHMETAHEADER = *mut tagENHMETAHEADER;
pub type BCHAR = BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTEXTMETRICA {
    pub tmHeight: LONG,
    pub tmAscent: LONG,
    pub tmDescent: LONG,
    pub tmInternalLeading: LONG,
    pub tmExternalLeading: LONG,
    pub tmAveCharWidth: LONG,
    pub tmMaxCharWidth: LONG,
    pub tmWeight: LONG,
    pub tmOverhang: LONG,
    pub tmDigitizedAspectX: LONG,
    pub tmDigitizedAspectY: LONG,
    pub tmFirstChar: BYTE,
    pub tmLastChar: BYTE,
    pub tmDefaultChar: BYTE,
    pub tmBreakChar: BYTE,
    pub tmItalic: BYTE,
    pub tmUnderlined: BYTE,
    pub tmStruckOut: BYTE,
    pub tmPitchAndFamily: BYTE,
    pub tmCharSet: BYTE,
}
pub type TEXTMETRICA = tagTEXTMETRICA;
pub type PTEXTMETRICA = *mut tagTEXTMETRICA;
pub type NPTEXTMETRICA = *mut tagTEXTMETRICA;
pub type LPTEXTMETRICA = *mut tagTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTEXTMETRICW {
    pub tmHeight: LONG,
    pub tmAscent: LONG,
    pub tmDescent: LONG,
    pub tmInternalLeading: LONG,
    pub tmExternalLeading: LONG,
    pub tmAveCharWidth: LONG,
    pub tmMaxCharWidth: LONG,
    pub tmWeight: LONG,
    pub tmOverhang: LONG,
    pub tmDigitizedAspectX: LONG,
    pub tmDigitizedAspectY: LONG,
    pub tmFirstChar: WCHAR,
    pub tmLastChar: WCHAR,
    pub tmDefaultChar: WCHAR,
    pub tmBreakChar: WCHAR,
    pub tmItalic: BYTE,
    pub tmUnderlined: BYTE,
    pub tmStruckOut: BYTE,
    pub tmPitchAndFamily: BYTE,
    pub tmCharSet: BYTE,
}
pub type TEXTMETRICW = tagTEXTMETRICW;
pub type PTEXTMETRICW = *mut tagTEXTMETRICW;
pub type NPTEXTMETRICW = *mut tagTEXTMETRICW;
pub type LPTEXTMETRICW = *mut tagTEXTMETRICW;
pub type TEXTMETRIC = TEXTMETRICA;
pub type PTEXTMETRIC = PTEXTMETRICA;
pub type NPTEXTMETRIC = NPTEXTMETRICA;
pub type LPTEXTMETRIC = LPTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNEWTEXTMETRICA {
    pub tmHeight: LONG,
    pub tmAscent: LONG,
    pub tmDescent: LONG,
    pub tmInternalLeading: LONG,
    pub tmExternalLeading: LONG,
    pub tmAveCharWidth: LONG,
    pub tmMaxCharWidth: LONG,
    pub tmWeight: LONG,
    pub tmOverhang: LONG,
    pub tmDigitizedAspectX: LONG,
    pub tmDigitizedAspectY: LONG,
    pub tmFirstChar: BYTE,
    pub tmLastChar: BYTE,
    pub tmDefaultChar: BYTE,
    pub tmBreakChar: BYTE,
    pub tmItalic: BYTE,
    pub tmUnderlined: BYTE,
    pub tmStruckOut: BYTE,
    pub tmPitchAndFamily: BYTE,
    pub tmCharSet: BYTE,
    pub ntmFlags: DWORD,
    pub ntmSizeEM: UINT,
    pub ntmCellHeight: UINT,
    pub ntmAvgWidth: UINT,
}
pub type NEWTEXTMETRICA = tagNEWTEXTMETRICA;
pub type PNEWTEXTMETRICA = *mut tagNEWTEXTMETRICA;
pub type NPNEWTEXTMETRICA = *mut tagNEWTEXTMETRICA;
pub type LPNEWTEXTMETRICA = *mut tagNEWTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNEWTEXTMETRICW {
    pub tmHeight: LONG,
    pub tmAscent: LONG,
    pub tmDescent: LONG,
    pub tmInternalLeading: LONG,
    pub tmExternalLeading: LONG,
    pub tmAveCharWidth: LONG,
    pub tmMaxCharWidth: LONG,
    pub tmWeight: LONG,
    pub tmOverhang: LONG,
    pub tmDigitizedAspectX: LONG,
    pub tmDigitizedAspectY: LONG,
    pub tmFirstChar: WCHAR,
    pub tmLastChar: WCHAR,
    pub tmDefaultChar: WCHAR,
    pub tmBreakChar: WCHAR,
    pub tmItalic: BYTE,
    pub tmUnderlined: BYTE,
    pub tmStruckOut: BYTE,
    pub tmPitchAndFamily: BYTE,
    pub tmCharSet: BYTE,
    pub ntmFlags: DWORD,
    pub ntmSizeEM: UINT,
    pub ntmCellHeight: UINT,
    pub ntmAvgWidth: UINT,
}
pub type NEWTEXTMETRICW = tagNEWTEXTMETRICW;
pub type PNEWTEXTMETRICW = *mut tagNEWTEXTMETRICW;
pub type NPNEWTEXTMETRICW = *mut tagNEWTEXTMETRICW;
pub type LPNEWTEXTMETRICW = *mut tagNEWTEXTMETRICW;
pub type NEWTEXTMETRIC = NEWTEXTMETRICA;
pub type PNEWTEXTMETRIC = PNEWTEXTMETRICA;
pub type NPNEWTEXTMETRIC = NPNEWTEXTMETRICA;
pub type LPNEWTEXTMETRIC = LPNEWTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNEWTEXTMETRICEXA {
    pub ntmTm: NEWTEXTMETRICA,
    pub ntmFontSig: FONTSIGNATURE,
}
pub type NEWTEXTMETRICEXA = tagNEWTEXTMETRICEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNEWTEXTMETRICEXW {
    pub ntmTm: NEWTEXTMETRICW,
    pub ntmFontSig: FONTSIGNATURE,
}
pub type NEWTEXTMETRICEXW = tagNEWTEXTMETRICEXW;
pub type NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPELARRAY {
    pub paXCount: LONG,
    pub paYCount: LONG,
    pub paXExt: LONG,
    pub paYExt: LONG,
    pub paRGBs: BYTE,
}
pub type PELARRAY = tagPELARRAY;
pub type PPELARRAY = *mut tagPELARRAY;
pub type NPPELARRAY = *mut tagPELARRAY;
pub type LPPELARRAY = *mut tagPELARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGBRUSH {
    pub lbStyle: UINT,
    pub lbColor: COLORREF,
    pub lbHatch: ULONG_PTR,
}
pub type LOGBRUSH = tagLOGBRUSH;
pub type PLOGBRUSH = *mut tagLOGBRUSH;
pub type NPLOGBRUSH = *mut tagLOGBRUSH;
pub type LPLOGBRUSH = *mut tagLOGBRUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGBRUSH32 {
    pub lbStyle: UINT,
    pub lbColor: COLORREF,
    pub lbHatch: ULONG,
}
pub type LOGBRUSH32 = tagLOGBRUSH32;
pub type PLOGBRUSH32 = *mut tagLOGBRUSH32;
pub type NPLOGBRUSH32 = *mut tagLOGBRUSH32;
pub type LPLOGBRUSH32 = *mut tagLOGBRUSH32;
pub type PATTERN = LOGBRUSH;
pub type PPATTERN = *mut PATTERN;
pub type NPPATTERN = *mut PATTERN;
pub type LPPATTERN = *mut PATTERN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGPEN {
    pub lopnStyle: UINT,
    pub lopnWidth: POINT,
    pub lopnColor: COLORREF,
}
pub type LOGPEN = tagLOGPEN;
pub type PLOGPEN = *mut tagLOGPEN;
pub type NPLOGPEN = *mut tagLOGPEN;
pub type LPLOGPEN = *mut tagLOGPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXTLOGPEN {
    pub elpPenStyle: DWORD,
    pub elpWidth: DWORD,
    pub elpBrushStyle: UINT,
    pub elpColor: COLORREF,
    pub elpHatch: ULONG_PTR,
    pub elpNumEntries: DWORD,
    pub elpStyleEntry: [DWORD; 1usize],
}
pub type EXTLOGPEN = tagEXTLOGPEN;
pub type PEXTLOGPEN = *mut tagEXTLOGPEN;
pub type NPEXTLOGPEN = *mut tagEXTLOGPEN;
pub type LPEXTLOGPEN = *mut tagEXTLOGPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXTLOGPEN32 {
    pub elpPenStyle: DWORD,
    pub elpWidth: DWORD,
    pub elpBrushStyle: UINT,
    pub elpColor: COLORREF,
    pub elpHatch: ULONG,
    pub elpNumEntries: DWORD,
    pub elpStyleEntry: [DWORD; 1usize],
}
pub type EXTLOGPEN32 = tagEXTLOGPEN32;
pub type PEXTLOGPEN32 = *mut tagEXTLOGPEN32;
pub type NPEXTLOGPEN32 = *mut tagEXTLOGPEN32;
pub type LPEXTLOGPEN32 = *mut tagEXTLOGPEN32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPALETTEENTRY {
    pub peRed: BYTE,
    pub peGreen: BYTE,
    pub peBlue: BYTE,
    pub peFlags: BYTE,
}
pub type PALETTEENTRY = tagPALETTEENTRY;
pub type PPALETTEENTRY = *mut tagPALETTEENTRY;
pub type LPPALETTEENTRY = *mut tagPALETTEENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGPALETTE {
    pub palVersion: WORD,
    pub palNumEntries: WORD,
    pub palPalEntry: [PALETTEENTRY; 1usize],
}
pub type LOGPALETTE = tagLOGPALETTE;
pub type PLOGPALETTE = *mut tagLOGPALETTE;
pub type NPLOGPALETTE = *mut tagLOGPALETTE;
pub type LPLOGPALETTE = *mut tagLOGPALETTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGFONTA {
    pub lfHeight: LONG,
    pub lfWidth: LONG,
    pub lfEscapement: LONG,
    pub lfOrientation: LONG,
    pub lfWeight: LONG,
    pub lfItalic: BYTE,
    pub lfUnderline: BYTE,
    pub lfStrikeOut: BYTE,
    pub lfCharSet: BYTE,
    pub lfOutPrecision: BYTE,
    pub lfClipPrecision: BYTE,
    pub lfQuality: BYTE,
    pub lfPitchAndFamily: BYTE,
    pub lfFaceName: [CHAR; 32usize],
}
pub type LOGFONTA = tagLOGFONTA;
pub type PLOGFONTA = *mut tagLOGFONTA;
pub type NPLOGFONTA = *mut tagLOGFONTA;
pub type LPLOGFONTA = *mut tagLOGFONTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLOGFONTW {
    pub lfHeight: LONG,
    pub lfWidth: LONG,
    pub lfEscapement: LONG,
    pub lfOrientation: LONG,
    pub lfWeight: LONG,
    pub lfItalic: BYTE,
    pub lfUnderline: BYTE,
    pub lfStrikeOut: BYTE,
    pub lfCharSet: BYTE,
    pub lfOutPrecision: BYTE,
    pub lfClipPrecision: BYTE,
    pub lfQuality: BYTE,
    pub lfPitchAndFamily: BYTE,
    pub lfFaceName: [WCHAR; 32usize],
}
pub type LOGFONTW = tagLOGFONTW;
pub type PLOGFONTW = *mut tagLOGFONTW;
pub type NPLOGFONTW = *mut tagLOGFONTW;
pub type LPLOGFONTW = *mut tagLOGFONTW;
pub type LOGFONT = LOGFONTA;
pub type PLOGFONT = PLOGFONTA;
pub type NPLOGFONT = NPLOGFONTA;
pub type LPLOGFONT = LPLOGFONTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMLOGFONTA {
    pub elfLogFont: LOGFONTA,
    pub elfFullName: [BYTE; 64usize],
    pub elfStyle: [BYTE; 32usize],
}
pub type ENUMLOGFONTA = tagENUMLOGFONTA;
pub type LPENUMLOGFONTA = *mut tagENUMLOGFONTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMLOGFONTW {
    pub elfLogFont: LOGFONTW,
    pub elfFullName: [WCHAR; 64usize],
    pub elfStyle: [WCHAR; 32usize],
}
pub type ENUMLOGFONTW = tagENUMLOGFONTW;
pub type LPENUMLOGFONTW = *mut tagENUMLOGFONTW;
pub type ENUMLOGFONT = ENUMLOGFONTA;
pub type LPENUMLOGFONT = LPENUMLOGFONTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMLOGFONTEXA {
    pub elfLogFont: LOGFONTA,
    pub elfFullName: [BYTE; 64usize],
    pub elfStyle: [BYTE; 32usize],
    pub elfScript: [BYTE; 32usize],
}
pub type ENUMLOGFONTEXA = tagENUMLOGFONTEXA;
pub type LPENUMLOGFONTEXA = *mut tagENUMLOGFONTEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMLOGFONTEXW {
    pub elfLogFont: LOGFONTW,
    pub elfFullName: [WCHAR; 64usize],
    pub elfStyle: [WCHAR; 32usize],
    pub elfScript: [WCHAR; 32usize],
}
pub type ENUMLOGFONTEXW = tagENUMLOGFONTEXW;
pub type LPENUMLOGFONTEXW = *mut tagENUMLOGFONTEXW;
pub type ENUMLOGFONTEX = ENUMLOGFONTEXA;
pub type LPENUMLOGFONTEX = LPENUMLOGFONTEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPANOSE {
    pub bFamilyType: BYTE,
    pub bSerifStyle: BYTE,
    pub bWeight: BYTE,
    pub bProportion: BYTE,
    pub bContrast: BYTE,
    pub bStrokeVariation: BYTE,
    pub bArmStyle: BYTE,
    pub bLetterform: BYTE,
    pub bMidline: BYTE,
    pub bXHeight: BYTE,
}
pub type PANOSE = tagPANOSE;
pub type LPPANOSE = *mut tagPANOSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXTLOGFONTA {
    pub elfLogFont: LOGFONTA,
    pub elfFullName: [BYTE; 64usize],
    pub elfStyle: [BYTE; 32usize],
    pub elfVersion: DWORD,
    pub elfStyleSize: DWORD,
    pub elfMatch: DWORD,
    pub elfReserved: DWORD,
    pub elfVendorId: [BYTE; 4usize],
    pub elfCulture: DWORD,
    pub elfPanose: PANOSE,
}
pub type EXTLOGFONTA = tagEXTLOGFONTA;
pub type PEXTLOGFONTA = *mut tagEXTLOGFONTA;
pub type NPEXTLOGFONTA = *mut tagEXTLOGFONTA;
pub type LPEXTLOGFONTA = *mut tagEXTLOGFONTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXTLOGFONTW {
    pub elfLogFont: LOGFONTW,
    pub elfFullName: [WCHAR; 64usize],
    pub elfStyle: [WCHAR; 32usize],
    pub elfVersion: DWORD,
    pub elfStyleSize: DWORD,
    pub elfMatch: DWORD,
    pub elfReserved: DWORD,
    pub elfVendorId: [BYTE; 4usize],
    pub elfCulture: DWORD,
    pub elfPanose: PANOSE,
}
pub type EXTLOGFONTW = tagEXTLOGFONTW;
pub type PEXTLOGFONTW = *mut tagEXTLOGFONTW;
pub type NPEXTLOGFONTW = *mut tagEXTLOGFONTW;
pub type LPEXTLOGFONTW = *mut tagEXTLOGFONTW;
pub type EXTLOGFONT = EXTLOGFONTA;
pub type PEXTLOGFONT = PEXTLOGFONTA;
pub type NPEXTLOGFONT = NPEXTLOGFONTA;
pub type LPEXTLOGFONT = LPEXTLOGFONTA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _devicemodeA {
    pub dmDeviceName: [BYTE; 32usize],
    pub dmSpecVersion: WORD,
    pub dmDriverVersion: WORD,
    pub dmSize: WORD,
    pub dmDriverExtra: WORD,
    pub dmFields: DWORD,
    pub __bindgen_anon_1: _devicemodeA__bindgen_ty_1,
    pub dmColor: ::std::os::raw::c_short,
    pub dmDuplex: ::std::os::raw::c_short,
    pub dmYResolution: ::std::os::raw::c_short,
    pub dmTTOption: ::std::os::raw::c_short,
    pub dmCollate: ::std::os::raw::c_short,
    pub dmFormName: [BYTE; 32usize],
    pub dmLogPixels: WORD,
    pub dmBitsPerPel: DWORD,
    pub dmPelsWidth: DWORD,
    pub dmPelsHeight: DWORD,
    pub __bindgen_anon_2: _devicemodeA__bindgen_ty_2,
    pub dmDisplayFrequency: DWORD,
    pub dmICMMethod: DWORD,
    pub dmICMIntent: DWORD,
    pub dmMediaType: DWORD,
    pub dmDitherType: DWORD,
    pub dmReserved1: DWORD,
    pub dmReserved2: DWORD,
    pub dmPanningWidth: DWORD,
    pub dmPanningHeight: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeA__bindgen_ty_1 {
    pub __bindgen_anon_1: _devicemodeA__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _devicemodeA__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _devicemodeA__bindgen_ty_1__bindgen_ty_1 {
    pub dmOrientation: ::std::os::raw::c_short,
    pub dmPaperSize: ::std::os::raw::c_short,
    pub dmPaperLength: ::std::os::raw::c_short,
    pub dmPaperWidth: ::std::os::raw::c_short,
    pub dmScale: ::std::os::raw::c_short,
    pub dmCopies: ::std::os::raw::c_short,
    pub dmDefaultSource: ::std::os::raw::c_short,
    pub dmPrintQuality: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _devicemodeA__bindgen_ty_1__bindgen_ty_2 {
    pub dmPosition: POINTL,
    pub dmDisplayOrientation: DWORD,
    pub dmDisplayFixedOutput: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeA__bindgen_ty_2 {
    pub dmDisplayFlags: DWORD,
    pub dmNup: DWORD,
}
pub type DEVMODEA = _devicemodeA;
pub type PDEVMODEA = *mut _devicemodeA;
pub type NPDEVMODEA = *mut _devicemodeA;
pub type LPDEVMODEA = *mut _devicemodeA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _devicemodeW {
    pub dmDeviceName: [WCHAR; 32usize],
    pub dmSpecVersion: WORD,
    pub dmDriverVersion: WORD,
    pub dmSize: WORD,
    pub dmDriverExtra: WORD,
    pub dmFields: DWORD,
    pub __bindgen_anon_1: _devicemodeW__bindgen_ty_1,
    pub dmColor: ::std::os::raw::c_short,
    pub dmDuplex: ::std::os::raw::c_short,
    pub dmYResolution: ::std::os::raw::c_short,
    pub dmTTOption: ::std::os::raw::c_short,
    pub dmCollate: ::std::os::raw::c_short,
    pub dmFormName: [WCHAR; 32usize],
    pub dmLogPixels: WORD,
    pub dmBitsPerPel: DWORD,
    pub dmPelsWidth: DWORD,
    pub dmPelsHeight: DWORD,
    pub __bindgen_anon_2: _devicemodeW__bindgen_ty_2,
    pub dmDisplayFrequency: DWORD,
    pub dmICMMethod: DWORD,
    pub dmICMIntent: DWORD,
    pub dmMediaType: DWORD,
    pub dmDitherType: DWORD,
    pub dmReserved1: DWORD,
    pub dmReserved2: DWORD,
    pub dmPanningWidth: DWORD,
    pub dmPanningHeight: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeW__bindgen_ty_1 {
    pub __bindgen_anon_1: _devicemodeW__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _devicemodeW__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _devicemodeW__bindgen_ty_1__bindgen_ty_1 {
    pub dmOrientation: ::std::os::raw::c_short,
    pub dmPaperSize: ::std::os::raw::c_short,
    pub dmPaperLength: ::std::os::raw::c_short,
    pub dmPaperWidth: ::std::os::raw::c_short,
    pub dmScale: ::std::os::raw::c_short,
    pub dmCopies: ::std::os::raw::c_short,
    pub dmDefaultSource: ::std::os::raw::c_short,
    pub dmPrintQuality: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _devicemodeW__bindgen_ty_1__bindgen_ty_2 {
    pub dmPosition: POINTL,
    pub dmDisplayOrientation: DWORD,
    pub dmDisplayFixedOutput: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _devicemodeW__bindgen_ty_2 {
    pub dmDisplayFlags: DWORD,
    pub dmNup: DWORD,
}
pub type DEVMODEW = _devicemodeW;
pub type PDEVMODEW = *mut _devicemodeW;
pub type NPDEVMODEW = *mut _devicemodeW;
pub type LPDEVMODEW = *mut _devicemodeW;
pub type DEVMODE = DEVMODEA;
pub type PDEVMODE = PDEVMODEA;
pub type NPDEVMODE = NPDEVMODEA;
pub type LPDEVMODE = LPDEVMODEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAY_DEVICEA {
    pub cb: DWORD,
    pub DeviceName: [CHAR; 32usize],
    pub DeviceString: [CHAR; 128usize],
    pub StateFlags: DWORD,
    pub DeviceID: [CHAR; 128usize],
    pub DeviceKey: [CHAR; 128usize],
}
pub type DISPLAY_DEVICEA = _DISPLAY_DEVICEA;
pub type PDISPLAY_DEVICEA = *mut _DISPLAY_DEVICEA;
pub type LPDISPLAY_DEVICEA = *mut _DISPLAY_DEVICEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAY_DEVICEW {
    pub cb: DWORD,
    pub DeviceName: [WCHAR; 32usize],
    pub DeviceString: [WCHAR; 128usize],
    pub StateFlags: DWORD,
    pub DeviceID: [WCHAR; 128usize],
    pub DeviceKey: [WCHAR; 128usize],
}
pub type DISPLAY_DEVICEW = _DISPLAY_DEVICEW;
pub type PDISPLAY_DEVICEW = *mut _DISPLAY_DEVICEW;
pub type LPDISPLAY_DEVICEW = *mut _DISPLAY_DEVICEW;
pub type DISPLAY_DEVICE = DISPLAY_DEVICEA;
pub type PDISPLAY_DEVICE = PDISPLAY_DEVICEA;
pub type LPDISPLAY_DEVICE = LPDISPLAY_DEVICEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_RATIONAL {
    pub Numerator: UINT32,
    pub Denominator: UINT32,
}
impl DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY {
    pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY =
        DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY::DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY {
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL = 18,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648,
}
impl DISPLAYCONFIG_SCANLINE_ORDERING {
    pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST:
        DISPLAYCONFIG_SCANLINE_ORDERING =
        DISPLAYCONFIG_SCANLINE_ORDERING::DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_SCANLINE_ORDERING {
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_2DREGION {
    pub cx: UINT32,
    pub cy: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
    pub pixelRate: UINT64,
    pub hSyncFreq: DISPLAYCONFIG_RATIONAL,
    pub vSyncFreq: DISPLAYCONFIG_RATIONAL,
    pub activeSize: DISPLAYCONFIG_2DREGION,
    pub totalSize: DISPLAYCONFIG_2DREGION,
    pub __bindgen_anon_1: DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1,
    pub scanLineOrdering: DISPLAYCONFIG_SCANLINE_ORDERING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1 {
    pub AdditionalSignalInfo: DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1,
    pub videoStandard: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl DISPLAYCONFIG_VIDEO_SIGNAL_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn videoStandard(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_videoStandard(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn vSyncFreqDivider(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_vSyncFreqDivider(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        videoStandard: UINT32,
        vSyncFreqDivider: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let videoStandard: u32 = unsafe { ::std::mem::transmute(videoStandard) };
            videoStandard as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let vSyncFreqDivider: u32 = unsafe { ::std::mem::transmute(vSyncFreqDivider) };
            vSyncFreqDivider as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_SCALING {
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_ROTATION {
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_MODE_INFO_TYPE {
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_PIXELFORMAT {
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_SOURCE_MODE {
    pub width: UINT32,
    pub height: UINT32,
    pub pixelFormat: DISPLAYCONFIG_PIXELFORMAT,
    pub position: POINTL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_MODE {
    pub targetVideoSignalInfo: DISPLAYCONFIG_VIDEO_SIGNAL_INFO,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO {
    pub PathSourceSize: POINTL,
    pub DesktopImageRegion: RECTL,
    pub DesktopImageClip: RECTL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_MODE_INFO {
    pub infoType: DISPLAYCONFIG_MODE_INFO_TYPE,
    pub id: UINT32,
    pub adapterId: LUID,
    pub __bindgen_anon_1: DISPLAYCONFIG_MODE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_MODE_INFO__bindgen_ty_1 {
    pub targetMode: DISPLAYCONFIG_TARGET_MODE,
    pub sourceMode: DISPLAYCONFIG_SOURCE_MODE,
    pub desktopImageInfo: DISPLAYCONFIG_DESKTOP_IMAGE_INFO,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_SOURCE_INFO {
    pub adapterId: LUID,
    pub id: UINT32,
    pub __bindgen_anon_1: DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1,
    pub statusFlags: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1 {
    pub modeInfoIdx: UINT32,
    pub __bindgen_anon_1: DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl DISPLAYCONFIG_PATH_SOURCE_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cloneGroupId(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cloneGroupId(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sourceModeInfoIdx(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sourceModeInfoIdx(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloneGroupId: UINT32,
        sourceModeInfoIdx: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let cloneGroupId: u32 = unsafe { ::std::mem::transmute(cloneGroupId) };
            cloneGroupId as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let sourceModeInfoIdx: u32 = unsafe { ::std::mem::transmute(sourceModeInfoIdx) };
            sourceModeInfoIdx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_TARGET_INFO {
    pub adapterId: LUID,
    pub id: UINT32,
    pub __bindgen_anon_1: DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1,
    pub outputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY,
    pub rotation: DISPLAYCONFIG_ROTATION,
    pub scaling: DISPLAYCONFIG_SCALING,
    pub refreshRate: DISPLAYCONFIG_RATIONAL,
    pub scanLineOrdering: DISPLAYCONFIG_SCANLINE_ORDERING,
    pub targetAvailable: BOOL,
    pub statusFlags: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1 {
    pub modeInfoIdx: UINT32,
    pub __bindgen_anon_1: DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl DISPLAYCONFIG_PATH_TARGET_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn desktopModeInfoIdx(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_desktopModeInfoIdx(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn targetModeInfoIdx(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_targetModeInfoIdx(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        desktopModeInfoIdx: UINT32,
        targetModeInfoIdx: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let desktopModeInfoIdx: u32 = unsafe { ::std::mem::transmute(desktopModeInfoIdx) };
            desktopModeInfoIdx as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let targetModeInfoIdx: u32 = unsafe { ::std::mem::transmute(targetModeInfoIdx) };
            targetModeInfoIdx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_PATH_INFO {
    pub sourceInfo: DISPLAYCONFIG_PATH_SOURCE_INFO,
    pub targetInfo: DISPLAYCONFIG_PATH_TARGET_INFO,
    pub flags: UINT32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_TOPOLOGY_ID {
    DISPLAYCONFIG_TOPOLOGY_INTERNAL = 1,
    DISPLAYCONFIG_TOPOLOGY_CLONE = 2,
    DISPLAYCONFIG_TOPOLOGY_EXTEND = 4,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 8,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = -1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISPLAYCONFIG_DEVICE_INFO_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
    DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6,
    DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7,
    DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9,
    DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10,
    DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11,
    DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION = 12,
    DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION = 13,
    DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_DEVICE_INFO_HEADER {
    pub type_: DISPLAYCONFIG_DEVICE_INFO_TYPE,
    pub size: UINT32,
    pub adapterId: LUID,
    pub id: UINT32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_SOURCE_DEVICE_NAME {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub viewGdiDeviceName: [WCHAR; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
    pub __bindgen_anon_1: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1 {
    pub __bindgen_anon_1: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn friendlyNameFromEdid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_friendlyNameFromEdid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn friendlyNameForced(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_friendlyNameForced(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edidIdsValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_edidIdsValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        friendlyNameFromEdid: UINT32,
        friendlyNameForced: UINT32,
        edidIdsValid: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let friendlyNameFromEdid: u32 = unsafe { ::std::mem::transmute(friendlyNameFromEdid) };
            friendlyNameFromEdid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let friendlyNameForced: u32 = unsafe { ::std::mem::transmute(friendlyNameForced) };
            friendlyNameForced as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let edidIdsValid: u32 = unsafe { ::std::mem::transmute(edidIdsValid) };
            edidIdsValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_DEVICE_NAME {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub flags: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS,
    pub outputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY,
    pub edidManufactureId: UINT16,
    pub edidProductCodeId: UINT16,
    pub connectorInstance: UINT32,
    pub monitorFriendlyDeviceName: [WCHAR; 64usize],
    pub monitorDevicePath: [WCHAR; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_PREFERRED_MODE {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub width: UINT32,
    pub height: UINT32,
    pub targetMode: DISPLAYCONFIG_TARGET_MODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_ADAPTER_NAME {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub adapterDevicePath: [WCHAR; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_TARGET_BASE_TYPE {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub baseOutputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub __bindgen_anon_1: DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1 {
    pub __bindgen_anon_1: DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl DISPLAYCONFIG_SET_TARGET_PERSISTENCE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn bootPersistenceOn(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bootPersistenceOn(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bootPersistenceOn: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bootPersistenceOn: u32 = unsafe { ::std::mem::transmute(bootPersistenceOn) };
            bootPersistenceOn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub __bindgen_anon_1: DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1 {
    pub __bindgen_anon_1: DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn disableMonitorVirtualResolution(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableMonitorVirtualResolution(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disableMonitorVirtualResolution: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disableMonitorVirtualResolution: u32 =
                unsafe { ::std::mem::transmute(disableMonitorVirtualResolution) };
            disableMonitorVirtualResolution as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DISPLAYCONFIG_COLOR_ENCODING {
    DISPLAYCONFIG_COLOR_ENCODING_RGB = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = -1,
}
pub use self::_DISPLAYCONFIG_COLOR_ENCODING as DISPLAYCONFIG_COLOR_ENCODING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub __bindgen_anon_1: _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1,
    pub colorEncoding: DISPLAYCONFIG_COLOR_ENCODING,
    pub bitsPerColorChannel: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn advancedColorSupported(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_advancedColorSupported(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn advancedColorEnabled(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_advancedColorEnabled(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wideColorEnforced(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wideColorEnforced(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn advancedColorForceDisabled(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_advancedColorForceDisabled(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        advancedColorSupported: UINT32,
        advancedColorEnabled: UINT32,
        wideColorEnforced: UINT32,
        advancedColorForceDisabled: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let advancedColorSupported: u32 =
                unsafe { ::std::mem::transmute(advancedColorSupported) };
            advancedColorSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let advancedColorEnabled: u32 = unsafe { ::std::mem::transmute(advancedColorEnabled) };
            advancedColorEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wideColorEnforced: u32 = unsafe { ::std::mem::transmute(wideColorEnforced) };
            wideColorEnforced as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let advancedColorForceDisabled: u32 =
                unsafe { ::std::mem::transmute(advancedColorForceDisabled) };
            advancedColorForceDisabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO = _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub __bindgen_anon_1: _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn enableAdvancedColor(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAdvancedColor(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableAdvancedColor: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableAdvancedColor: u32 = unsafe { ::std::mem::transmute(enableAdvancedColor) };
            enableAdvancedColor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE = _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAYCONFIG_SDR_WHITE_LEVEL {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub SDRWhiteLevel: ULONG,
}
pub type DISPLAYCONFIG_SDR_WHITE_LEVEL = _DISPLAYCONFIG_SDR_WHITE_LEVEL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub __bindgen_anon_1: _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn isSpecializationEnabled(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSpecializationEnabled(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSpecializationAvailableForMonitor(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSpecializationAvailableForMonitor(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isSpecializationAvailableForSystem(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSpecializationAvailableForSystem(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isSpecializationEnabled: UINT32,
        isSpecializationAvailableForMonitor: UINT32,
        isSpecializationAvailableForSystem: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSpecializationEnabled: u32 =
                unsafe { ::std::mem::transmute(isSpecializationEnabled) };
            isSpecializationEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isSpecializationAvailableForMonitor: u32 =
                unsafe { ::std::mem::transmute(isSpecializationAvailableForMonitor) };
            isSpecializationAvailableForMonitor as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let isSpecializationAvailableForSystem: u32 =
                unsafe { ::std::mem::transmute(isSpecializationAvailableForSystem) };
            isSpecializationAvailableForSystem as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION = _DISPLAYCONFIG_GET_MONITOR_SPECIALIZATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION {
    pub header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    pub __bindgen_anon_1: _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION__bindgen_ty_1,
    pub specializationType: GUID,
    pub specializationSubType: GUID,
    pub specializationApplicationName: [WCHAR; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION__bindgen_ty_1__bindgen_ty_1,
    pub value: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn isSpecializationEnabled(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isSpecializationEnabled(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        isSpecializationEnabled: UINT32,
        reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isSpecializationEnabled: u32 =
                unsafe { ::std::mem::transmute(isSpecializationEnabled) };
            isSpecializationEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION = _DISPLAYCONFIG_SET_MONITOR_SPECIALIZATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RGNDATAHEADER {
    pub dwSize: DWORD,
    pub iType: DWORD,
    pub nCount: DWORD,
    pub nRgnSize: DWORD,
    pub rcBound: RECT,
}
pub type RGNDATAHEADER = _RGNDATAHEADER;
pub type PRGNDATAHEADER = *mut _RGNDATAHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RGNDATA {
    pub rdh: RGNDATAHEADER,
    pub Buffer: [::std::os::raw::c_char; 1usize],
}
pub type RGNDATA = _RGNDATA;
pub type PRGNDATA = *mut _RGNDATA;
pub type NPRGNDATA = *mut _RGNDATA;
pub type LPRGNDATA = *mut _RGNDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ABC {
    pub abcA: ::std::os::raw::c_int,
    pub abcB: UINT,
    pub abcC: ::std::os::raw::c_int,
}
pub type ABC = _ABC;
pub type PABC = *mut _ABC;
pub type NPABC = *mut _ABC;
pub type LPABC = *mut _ABC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ABCFLOAT {
    pub abcfA: FLOAT,
    pub abcfB: FLOAT,
    pub abcfC: FLOAT,
}
pub type ABCFLOAT = _ABCFLOAT;
pub type PABCFLOAT = *mut _ABCFLOAT;
pub type NPABCFLOAT = *mut _ABCFLOAT;
pub type LPABCFLOAT = *mut _ABCFLOAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OUTLINETEXTMETRICA {
    pub otmSize: UINT,
    pub otmTextMetrics: TEXTMETRICA,
    pub otmFiller: BYTE,
    pub otmPanoseNumber: PANOSE,
    pub otmfsSelection: UINT,
    pub otmfsType: UINT,
    pub otmsCharSlopeRise: ::std::os::raw::c_int,
    pub otmsCharSlopeRun: ::std::os::raw::c_int,
    pub otmItalicAngle: ::std::os::raw::c_int,
    pub otmEMSquare: UINT,
    pub otmAscent: ::std::os::raw::c_int,
    pub otmDescent: ::std::os::raw::c_int,
    pub otmLineGap: UINT,
    pub otmsCapEmHeight: UINT,
    pub otmsXHeight: UINT,
    pub otmrcFontBox: RECT,
    pub otmMacAscent: ::std::os::raw::c_int,
    pub otmMacDescent: ::std::os::raw::c_int,
    pub otmMacLineGap: UINT,
    pub otmusMinimumPPEM: UINT,
    pub otmptSubscriptSize: POINT,
    pub otmptSubscriptOffset: POINT,
    pub otmptSuperscriptSize: POINT,
    pub otmptSuperscriptOffset: POINT,
    pub otmsStrikeoutSize: UINT,
    pub otmsStrikeoutPosition: ::std::os::raw::c_int,
    pub otmsUnderscoreSize: ::std::os::raw::c_int,
    pub otmsUnderscorePosition: ::std::os::raw::c_int,
    pub otmpFamilyName: PSTR,
    pub otmpFaceName: PSTR,
    pub otmpStyleName: PSTR,
    pub otmpFullName: PSTR,
}
pub type OUTLINETEXTMETRICA = _OUTLINETEXTMETRICA;
pub type POUTLINETEXTMETRICA = *mut _OUTLINETEXTMETRICA;
pub type NPOUTLINETEXTMETRICA = *mut _OUTLINETEXTMETRICA;
pub type LPOUTLINETEXTMETRICA = *mut _OUTLINETEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OUTLINETEXTMETRICW {
    pub otmSize: UINT,
    pub otmTextMetrics: TEXTMETRICW,
    pub otmFiller: BYTE,
    pub otmPanoseNumber: PANOSE,
    pub otmfsSelection: UINT,
    pub otmfsType: UINT,
    pub otmsCharSlopeRise: ::std::os::raw::c_int,
    pub otmsCharSlopeRun: ::std::os::raw::c_int,
    pub otmItalicAngle: ::std::os::raw::c_int,
    pub otmEMSquare: UINT,
    pub otmAscent: ::std::os::raw::c_int,
    pub otmDescent: ::std::os::raw::c_int,
    pub otmLineGap: UINT,
    pub otmsCapEmHeight: UINT,
    pub otmsXHeight: UINT,
    pub otmrcFontBox: RECT,
    pub otmMacAscent: ::std::os::raw::c_int,
    pub otmMacDescent: ::std::os::raw::c_int,
    pub otmMacLineGap: UINT,
    pub otmusMinimumPPEM: UINT,
    pub otmptSubscriptSize: POINT,
    pub otmptSubscriptOffset: POINT,
    pub otmptSuperscriptSize: POINT,
    pub otmptSuperscriptOffset: POINT,
    pub otmsStrikeoutSize: UINT,
    pub otmsStrikeoutPosition: ::std::os::raw::c_int,
    pub otmsUnderscoreSize: ::std::os::raw::c_int,
    pub otmsUnderscorePosition: ::std::os::raw::c_int,
    pub otmpFamilyName: PSTR,
    pub otmpFaceName: PSTR,
    pub otmpStyleName: PSTR,
    pub otmpFullName: PSTR,
}
pub type OUTLINETEXTMETRICW = _OUTLINETEXTMETRICW;
pub type POUTLINETEXTMETRICW = *mut _OUTLINETEXTMETRICW;
pub type NPOUTLINETEXTMETRICW = *mut _OUTLINETEXTMETRICW;
pub type LPOUTLINETEXTMETRICW = *mut _OUTLINETEXTMETRICW;
pub type OUTLINETEXTMETRIC = OUTLINETEXTMETRICA;
pub type POUTLINETEXTMETRIC = POUTLINETEXTMETRICA;
pub type NPOUTLINETEXTMETRIC = NPOUTLINETEXTMETRICA;
pub type LPOUTLINETEXTMETRIC = LPOUTLINETEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOLYTEXTA {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub n: UINT,
    pub lpstr: LPCSTR,
    pub uiFlags: UINT,
    pub rcl: RECT,
    pub pdx: *mut ::std::os::raw::c_int,
}
pub type POLYTEXTA = tagPOLYTEXTA;
pub type PPOLYTEXTA = *mut tagPOLYTEXTA;
pub type NPPOLYTEXTA = *mut tagPOLYTEXTA;
pub type LPPOLYTEXTA = *mut tagPOLYTEXTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOLYTEXTW {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub n: UINT,
    pub lpstr: LPCWSTR,
    pub uiFlags: UINT,
    pub rcl: RECT,
    pub pdx: *mut ::std::os::raw::c_int,
}
pub type POLYTEXTW = tagPOLYTEXTW;
pub type PPOLYTEXTW = *mut tagPOLYTEXTW;
pub type NPPOLYTEXTW = *mut tagPOLYTEXTW;
pub type LPPOLYTEXTW = *mut tagPOLYTEXTW;
pub type POLYTEXT = POLYTEXTA;
pub type PPOLYTEXT = PPOLYTEXTA;
pub type NPPOLYTEXT = NPPOLYTEXTA;
pub type LPPOLYTEXT = LPPOLYTEXTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FIXED {
    pub fract: WORD,
    pub value: ::std::os::raw::c_short,
}
pub type FIXED = _FIXED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MAT2 {
    pub eM11: FIXED,
    pub eM12: FIXED,
    pub eM21: FIXED,
    pub eM22: FIXED,
}
pub type MAT2 = _MAT2;
pub type LPMAT2 = *mut _MAT2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLYPHMETRICS {
    pub gmBlackBoxX: UINT,
    pub gmBlackBoxY: UINT,
    pub gmptGlyphOrigin: POINT,
    pub gmCellIncX: ::std::os::raw::c_short,
    pub gmCellIncY: ::std::os::raw::c_short,
}
pub type GLYPHMETRICS = _GLYPHMETRICS;
pub type LPGLYPHMETRICS = *mut _GLYPHMETRICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTFX {
    pub x: FIXED,
    pub y: FIXED,
}
pub type POINTFX = tagPOINTFX;
pub type LPPOINTFX = *mut tagPOINTFX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTTPOLYCURVE {
    pub wType: WORD,
    pub cpfx: WORD,
    pub apfx: [POINTFX; 1usize],
}
pub type TTPOLYCURVE = tagTTPOLYCURVE;
pub type LPTTPOLYCURVE = *mut tagTTPOLYCURVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTTPOLYGONHEADER {
    pub cb: DWORD,
    pub dwType: DWORD,
    pub pfxStart: POINTFX,
}
pub type TTPOLYGONHEADER = tagTTPOLYGONHEADER;
pub type LPTTPOLYGONHEADER = *mut tagTTPOLYGONHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGCP_RESULTSA {
    pub lStructSize: DWORD,
    pub lpOutString: LPSTR,
    pub lpOrder: *mut UINT,
    pub lpDx: *mut ::std::os::raw::c_int,
    pub lpCaretPos: *mut ::std::os::raw::c_int,
    pub lpClass: LPSTR,
    pub lpGlyphs: LPWSTR,
    pub nGlyphs: UINT,
    pub nMaxFit: ::std::os::raw::c_int,
}
pub type GCP_RESULTSA = tagGCP_RESULTSA;
pub type LPGCP_RESULTSA = *mut tagGCP_RESULTSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGCP_RESULTSW {
    pub lStructSize: DWORD,
    pub lpOutString: LPWSTR,
    pub lpOrder: *mut UINT,
    pub lpDx: *mut ::std::os::raw::c_int,
    pub lpCaretPos: *mut ::std::os::raw::c_int,
    pub lpClass: LPSTR,
    pub lpGlyphs: LPWSTR,
    pub nGlyphs: UINT,
    pub nMaxFit: ::std::os::raw::c_int,
}
pub type GCP_RESULTSW = tagGCP_RESULTSW;
pub type LPGCP_RESULTSW = *mut tagGCP_RESULTSW;
pub type GCP_RESULTS = GCP_RESULTSA;
pub type LPGCP_RESULTS = LPGCP_RESULTSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RASTERIZER_STATUS {
    pub nSize: ::std::os::raw::c_short,
    pub wFlags: ::std::os::raw::c_short,
    pub nLanguageID: ::std::os::raw::c_short,
}
pub type RASTERIZER_STATUS = _RASTERIZER_STATUS;
pub type LPRASTERIZER_STATUS = *mut _RASTERIZER_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPIXELFORMATDESCRIPTOR {
    pub nSize: WORD,
    pub nVersion: WORD,
    pub dwFlags: DWORD,
    pub iPixelType: BYTE,
    pub cColorBits: BYTE,
    pub cRedBits: BYTE,
    pub cRedShift: BYTE,
    pub cGreenBits: BYTE,
    pub cGreenShift: BYTE,
    pub cBlueBits: BYTE,
    pub cBlueShift: BYTE,
    pub cAlphaBits: BYTE,
    pub cAlphaShift: BYTE,
    pub cAccumBits: BYTE,
    pub cAccumRedBits: BYTE,
    pub cAccumGreenBits: BYTE,
    pub cAccumBlueBits: BYTE,
    pub cAccumAlphaBits: BYTE,
    pub cDepthBits: BYTE,
    pub cStencilBits: BYTE,
    pub cAuxBuffers: BYTE,
    pub iLayerType: BYTE,
    pub bReserved: BYTE,
    pub dwLayerMask: DWORD,
    pub dwVisibleMask: DWORD,
    pub dwDamageMask: DWORD,
}
pub type PIXELFORMATDESCRIPTOR = tagPIXELFORMATDESCRIPTOR;
pub type PPIXELFORMATDESCRIPTOR = *mut tagPIXELFORMATDESCRIPTOR;
pub type LPPIXELFORMATDESCRIPTOR = *mut tagPIXELFORMATDESCRIPTOR;
pub type OLDFONTENUMPROCA = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const LOGFONTA,
        arg2: *const TEXTMETRICA,
        arg3: DWORD,
        arg4: LPARAM,
    ) -> ::std::os::raw::c_int,
>;
pub type OLDFONTENUMPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const LOGFONTW,
        arg2: *const TEXTMETRICW,
        arg3: DWORD,
        arg4: LPARAM,
    ) -> ::std::os::raw::c_int,
>;
pub type FONTENUMPROCA = OLDFONTENUMPROCA;
pub type FONTENUMPROCW = OLDFONTENUMPROCW;
pub type FONTENUMPROC = FONTENUMPROCA;
pub type GOBJENUMPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: LPVOID, arg2: LPARAM) -> ::std::os::raw::c_int,
>;
pub type LINEDDAPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int, arg3: LPARAM),
>;
extern "C" {
    pub fn AddFontResourceA(arg1: LPCSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AddFontResourceW(arg1: LPCWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AnimatePalette(
        hPal: HPALETTE,
        iStartIndex: UINT,
        cEntries: UINT,
        ppe: *const PALETTEENTRY,
    ) -> BOOL;
}
extern "C" {
    pub fn Arc(
        hdc: HDC,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        x3: ::std::os::raw::c_int,
        y3: ::std::os::raw::c_int,
        x4: ::std::os::raw::c_int,
        y4: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn BitBlt(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        hdcSrc: HDC,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        rop: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CancelDC(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn Chord(
        hdc: HDC,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        x3: ::std::os::raw::c_int,
        y3: ::std::os::raw::c_int,
        x4: ::std::os::raw::c_int,
        y4: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn ChoosePixelFormat(hdc: HDC, ppfd: *const PIXELFORMATDESCRIPTOR)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CloseMetaFile(hdc: HDC) -> HMETAFILE;
}
extern "C" {
    pub fn CombineRgn(
        hrgnDst: HRGN,
        hrgnSrc1: HRGN,
        hrgnSrc2: HRGN,
        iMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CopyMetaFileA(arg1: HMETAFILE, arg2: LPCSTR) -> HMETAFILE;
}
extern "C" {
    pub fn CopyMetaFileW(arg1: HMETAFILE, arg2: LPCWSTR) -> HMETAFILE;
}
extern "C" {
    pub fn CreateBitmap(
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nPlanes: UINT,
        nBitCount: UINT,
        lpBits: *const ::std::os::raw::c_void,
    ) -> HBITMAP;
}
extern "C" {
    pub fn CreateBitmapIndirect(pbm: *const BITMAP) -> HBITMAP;
}
extern "C" {
    pub fn CreateBrushIndirect(plbrush: *const LOGBRUSH) -> HBRUSH;
}
extern "C" {
    pub fn CreateCompatibleBitmap(
        hdc: HDC,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
    ) -> HBITMAP;
}
extern "C" {
    pub fn CreateDiscardableBitmap(
        hdc: HDC,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
    ) -> HBITMAP;
}
extern "C" {
    pub fn CreateCompatibleDC(hdc: HDC) -> HDC;
}
extern "C" {
    pub fn CreateDCA(
        pwszDriver: LPCSTR,
        pwszDevice: LPCSTR,
        pszPort: LPCSTR,
        pdm: *const DEVMODEA,
    ) -> HDC;
}
extern "C" {
    pub fn CreateDCW(
        pwszDriver: LPCWSTR,
        pwszDevice: LPCWSTR,
        pszPort: LPCWSTR,
        pdm: *const DEVMODEW,
    ) -> HDC;
}
extern "C" {
    pub fn CreateDIBitmap(
        hdc: HDC,
        pbmih: *const BITMAPINFOHEADER,
        flInit: DWORD,
        pjBits: *const ::std::os::raw::c_void,
        pbmi: *const BITMAPINFO,
        iUsage: UINT,
    ) -> HBITMAP;
}
extern "C" {
    pub fn CreateDIBPatternBrush(h: HGLOBAL, iUsage: UINT) -> HBRUSH;
}
extern "C" {
    pub fn CreateDIBPatternBrushPt(
        lpPackedDIB: *const ::std::os::raw::c_void,
        iUsage: UINT,
    ) -> HBRUSH;
}
extern "C" {
    pub fn CreateEllipticRgn(
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
    ) -> HRGN;
}
extern "C" {
    pub fn CreateEllipticRgnIndirect(lprect: *const RECT) -> HRGN;
}
extern "C" {
    pub fn CreateFontIndirectA(lplf: *const LOGFONTA) -> HFONT;
}
extern "C" {
    pub fn CreateFontIndirectW(lplf: *const LOGFONTW) -> HFONT;
}
extern "C" {
    pub fn CreateFontA(
        cHeight: ::std::os::raw::c_int,
        cWidth: ::std::os::raw::c_int,
        cEscapement: ::std::os::raw::c_int,
        cOrientation: ::std::os::raw::c_int,
        cWeight: ::std::os::raw::c_int,
        bItalic: DWORD,
        bUnderline: DWORD,
        bStrikeOut: DWORD,
        iCharSet: DWORD,
        iOutPrecision: DWORD,
        iClipPrecision: DWORD,
        iQuality: DWORD,
        iPitchAndFamily: DWORD,
        pszFaceName: LPCSTR,
    ) -> HFONT;
}
extern "C" {
    pub fn CreateFontW(
        cHeight: ::std::os::raw::c_int,
        cWidth: ::std::os::raw::c_int,
        cEscapement: ::std::os::raw::c_int,
        cOrientation: ::std::os::raw::c_int,
        cWeight: ::std::os::raw::c_int,
        bItalic: DWORD,
        bUnderline: DWORD,
        bStrikeOut: DWORD,
        iCharSet: DWORD,
        iOutPrecision: DWORD,
        iClipPrecision: DWORD,
        iQuality: DWORD,
        iPitchAndFamily: DWORD,
        pszFaceName: LPCWSTR,
    ) -> HFONT;
}
extern "C" {
    pub fn CreateHatchBrush(iHatch: ::std::os::raw::c_int, color: COLORREF) -> HBRUSH;
}
extern "C" {
    pub fn CreateICA(
        pszDriver: LPCSTR,
        pszDevice: LPCSTR,
        pszPort: LPCSTR,
        pdm: *const DEVMODEA,
    ) -> HDC;
}
extern "C" {
    pub fn CreateICW(
        pszDriver: LPCWSTR,
        pszDevice: LPCWSTR,
        pszPort: LPCWSTR,
        pdm: *const DEVMODEW,
    ) -> HDC;
}
extern "C" {
    pub fn CreateMetaFileA(pszFile: LPCSTR) -> HDC;
}
extern "C" {
    pub fn CreateMetaFileW(pszFile: LPCWSTR) -> HDC;
}
extern "C" {
    pub fn CreatePalette(plpal: *const LOGPALETTE) -> HPALETTE;
}
extern "C" {
    pub fn CreatePen(
        iStyle: ::std::os::raw::c_int,
        cWidth: ::std::os::raw::c_int,
        color: COLORREF,
    ) -> HPEN;
}
extern "C" {
    pub fn CreatePenIndirect(plpen: *const LOGPEN) -> HPEN;
}
extern "C" {
    pub fn CreatePolyPolygonRgn(
        pptl: *const POINT,
        pc: *const INT,
        cPoly: ::std::os::raw::c_int,
        iMode: ::std::os::raw::c_int,
    ) -> HRGN;
}
extern "C" {
    pub fn CreatePatternBrush(hbm: HBITMAP) -> HBRUSH;
}
extern "C" {
    pub fn CreateRectRgn(
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
    ) -> HRGN;
}
extern "C" {
    pub fn CreateRectRgnIndirect(lprect: *const RECT) -> HRGN;
}
extern "C" {
    pub fn CreateRoundRectRgn(
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> HRGN;
}
extern "C" {
    pub fn CreateScalableFontResourceA(
        fdwHidden: DWORD,
        lpszFont: LPCSTR,
        lpszFile: LPCSTR,
        lpszPath: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateScalableFontResourceW(
        fdwHidden: DWORD,
        lpszFont: LPCWSTR,
        lpszFile: LPCWSTR,
        lpszPath: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateSolidBrush(color: COLORREF) -> HBRUSH;
}
extern "C" {
    pub fn DeleteDC(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn DeleteMetaFile(hmf: HMETAFILE) -> BOOL;
}
extern "C" {
    pub fn DeleteObject(ho: HGDIOBJ) -> BOOL;
}
extern "C" {
    pub fn DescribePixelFormat(
        hdc: HDC,
        iPixelFormat: ::std::os::raw::c_int,
        nBytes: UINT,
        ppfd: LPPIXELFORMATDESCRIPTOR,
    ) -> ::std::os::raw::c_int;
}
pub type LPFNDEVMODE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: HWND,
        arg2: HMODULE,
        arg3: LPDEVMODE,
        arg4: LPSTR,
        arg5: LPSTR,
        arg6: LPDEVMODE,
        arg7: LPSTR,
        arg8: UINT,
    ) -> UINT,
>;
pub type LPFNDEVCAPS = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: LPSTR,
        arg2: LPSTR,
        arg3: UINT,
        arg4: LPSTR,
        arg5: LPDEVMODE,
    ) -> DWORD,
>;
extern "C" {
    pub fn DeviceCapabilitiesA(
        pDevice: LPCSTR,
        pPort: LPCSTR,
        fwCapability: WORD,
        pOutput: LPSTR,
        pDevMode: *const DEVMODEA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DeviceCapabilitiesW(
        pDevice: LPCWSTR,
        pPort: LPCWSTR,
        fwCapability: WORD,
        pOutput: LPWSTR,
        pDevMode: *const DEVMODEW,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DrawEscape(
        hdc: HDC,
        iEscape: ::std::os::raw::c_int,
        cjIn: ::std::os::raw::c_int,
        lpIn: LPCSTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Ellipse(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumFontFamiliesExA(
        hdc: HDC,
        lpLogfont: LPLOGFONTA,
        lpProc: FONTENUMPROCA,
        lParam: LPARAM,
        dwFlags: DWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumFontFamiliesExW(
        hdc: HDC,
        lpLogfont: LPLOGFONTW,
        lpProc: FONTENUMPROCW,
        lParam: LPARAM,
        dwFlags: DWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumFontFamiliesA(
        hdc: HDC,
        lpLogfont: LPCSTR,
        lpProc: FONTENUMPROCA,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumFontFamiliesW(
        hdc: HDC,
        lpLogfont: LPCWSTR,
        lpProc: FONTENUMPROCW,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumFontsA(
        hdc: HDC,
        lpLogfont: LPCSTR,
        lpProc: FONTENUMPROCA,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumFontsW(
        hdc: HDC,
        lpLogfont: LPCWSTR,
        lpProc: FONTENUMPROCW,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumObjects(
        hdc: HDC,
        nType: ::std::os::raw::c_int,
        lpFunc: GOBJENUMPROC,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EqualRgn(hrgn1: HRGN, hrgn2: HRGN) -> BOOL;
}
extern "C" {
    pub fn Escape(
        hdc: HDC,
        iEscape: ::std::os::raw::c_int,
        cjIn: ::std::os::raw::c_int,
        pvIn: LPCSTR,
        pvOut: LPVOID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExtEscape(
        hdc: HDC,
        iEscape: ::std::os::raw::c_int,
        cjInput: ::std::os::raw::c_int,
        lpInData: LPCSTR,
        cjOutput: ::std::os::raw::c_int,
        lpOutData: LPSTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExcludeClipRect(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExtCreateRegion(lpx: *const XFORM, nCount: DWORD, lpData: *const RGNDATA) -> HRGN;
}
extern "C" {
    pub fn ExtFloodFill(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        color: COLORREF,
        type_: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn FillRgn(hdc: HDC, hrgn: HRGN, hbr: HBRUSH) -> BOOL;
}
extern "C" {
    pub fn FloodFill(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        color: COLORREF,
    ) -> BOOL;
}
extern "C" {
    pub fn FrameRgn(
        hdc: HDC,
        hrgn: HRGN,
        hbr: HBRUSH,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn GetROP2(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetAspectRatioFilterEx(hdc: HDC, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
    pub fn GetBkColor(hdc: HDC) -> COLORREF;
}
extern "C" {
    pub fn GetDCBrushColor(hdc: HDC) -> COLORREF;
}
extern "C" {
    pub fn GetDCPenColor(hdc: HDC) -> COLORREF;
}
extern "C" {
    pub fn GetBkMode(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetBitmapBits(hbit: HBITMAP, cb: LONG, lpvBits: LPVOID) -> LONG;
}
extern "C" {
    pub fn GetBitmapDimensionEx(hbit: HBITMAP, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
    pub fn GetBoundsRect(hdc: HDC, lprect: LPRECT, flags: UINT) -> UINT;
}
extern "C" {
    pub fn GetBrushOrgEx(hdc: HDC, lppt: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn GetCharWidthA(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
    pub fn GetCharWidthW(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
    pub fn GetCharWidth32A(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
    pub fn GetCharWidth32W(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) -> BOOL;
}
extern "C" {
    pub fn GetCharWidthFloatA(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: PFLOAT) -> BOOL;
}
extern "C" {
    pub fn GetCharWidthFloatW(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: PFLOAT) -> BOOL;
}
extern "C" {
    pub fn GetCharABCWidthsA(hdc: HDC, wFirst: UINT, wLast: UINT, lpABC: LPABC) -> BOOL;
}
extern "C" {
    pub fn GetCharABCWidthsW(hdc: HDC, wFirst: UINT, wLast: UINT, lpABC: LPABC) -> BOOL;
}
extern "C" {
    pub fn GetCharABCWidthsFloatA(hdc: HDC, iFirst: UINT, iLast: UINT, lpABC: LPABCFLOAT) -> BOOL;
}
extern "C" {
    pub fn GetCharABCWidthsFloatW(hdc: HDC, iFirst: UINT, iLast: UINT, lpABC: LPABCFLOAT) -> BOOL;
}
extern "C" {
    pub fn GetClipBox(hdc: HDC, lprect: LPRECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetClipRgn(hdc: HDC, hrgn: HRGN) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMetaRgn(hdc: HDC, hrgn: HRGN) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetCurrentObject(hdc: HDC, type_: UINT) -> HGDIOBJ;
}
extern "C" {
    pub fn GetCurrentPositionEx(hdc: HDC, lppt: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn GetDeviceCaps(hdc: HDC, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDIBits(
        hdc: HDC,
        hbm: HBITMAP,
        start: UINT,
        cLines: UINT,
        lpvBits: LPVOID,
        lpbmi: LPBITMAPINFO,
        usage: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetFontData(
        hdc: HDC,
        dwTable: DWORD,
        dwOffset: DWORD,
        pvBuffer: PVOID,
        cjBuffer: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetGlyphOutlineA(
        hdc: HDC,
        uChar: UINT,
        fuFormat: UINT,
        lpgm: LPGLYPHMETRICS,
        cjBuffer: DWORD,
        pvBuffer: LPVOID,
        lpmat2: *const MAT2,
    ) -> DWORD;
}
extern "C" {
    pub fn GetGlyphOutlineW(
        hdc: HDC,
        uChar: UINT,
        fuFormat: UINT,
        lpgm: LPGLYPHMETRICS,
        cjBuffer: DWORD,
        pvBuffer: LPVOID,
        lpmat2: *const MAT2,
    ) -> DWORD;
}
extern "C" {
    pub fn GetGraphicsMode(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMapMode(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMetaFileBitsEx(hMF: HMETAFILE, cbBuffer: UINT, lpData: LPVOID) -> UINT;
}
extern "C" {
    pub fn GetMetaFileA(lpName: LPCSTR) -> HMETAFILE;
}
extern "C" {
    pub fn GetMetaFileW(lpName: LPCWSTR) -> HMETAFILE;
}
extern "C" {
    pub fn GetNearestColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
    pub fn GetNearestPaletteIndex(h: HPALETTE, color: COLORREF) -> UINT;
}
extern "C" {
    pub fn GetObjectType(h: HGDIOBJ) -> DWORD;
}
extern "C" {
    pub fn GetOutlineTextMetricsA(hdc: HDC, cjCopy: UINT, potm: LPOUTLINETEXTMETRICA) -> UINT;
}
extern "C" {
    pub fn GetOutlineTextMetricsW(hdc: HDC, cjCopy: UINT, potm: LPOUTLINETEXTMETRICW) -> UINT;
}
extern "C" {
    pub fn GetPaletteEntries(
        hpal: HPALETTE,
        iStart: UINT,
        cEntries: UINT,
        pPalEntries: LPPALETTEENTRY,
    ) -> UINT;
}
extern "C" {
    pub fn GetPixel(hdc: HDC, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> COLORREF;
}
extern "C" {
    pub fn GetPixelFormat(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetPolyFillMode(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetRasterizerCaps(lpraststat: LPRASTERIZER_STATUS, cjBytes: UINT) -> BOOL;
}
extern "C" {
    pub fn GetRandomRgn(hdc: HDC, hrgn: HRGN, i: INT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetRegionData(hrgn: HRGN, nCount: DWORD, lpRgnData: LPRGNDATA) -> DWORD;
}
extern "C" {
    pub fn GetRgnBox(hrgn: HRGN, lprc: LPRECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetStockObject(i: ::std::os::raw::c_int) -> HGDIOBJ;
}
extern "C" {
    pub fn GetStretchBltMode(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetSystemPaletteEntries(
        hdc: HDC,
        iStart: UINT,
        cEntries: UINT,
        pPalEntries: LPPALETTEENTRY,
    ) -> UINT;
}
extern "C" {
    pub fn GetSystemPaletteUse(hdc: HDC) -> UINT;
}
extern "C" {
    pub fn GetTextCharacterExtra(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTextAlign(hdc: HDC) -> UINT;
}
extern "C" {
    pub fn GetTextColor(hdc: HDC) -> COLORREF;
}
extern "C" {
    pub fn GetTextExtentPointA(
        hdc: HDC,
        lpString: LPCSTR,
        c: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextExtentPointW(
        hdc: HDC,
        lpString: LPCWSTR,
        c: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextExtentPoint32A(
        hdc: HDC,
        lpString: LPCSTR,
        c: ::std::os::raw::c_int,
        psizl: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextExtentPoint32W(
        hdc: HDC,
        lpString: LPCWSTR,
        c: ::std::os::raw::c_int,
        psizl: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextExtentExPointA(
        hdc: HDC,
        lpszString: LPCSTR,
        cchString: ::std::os::raw::c_int,
        nMaxExtent: ::std::os::raw::c_int,
        lpnFit: LPINT,
        lpnDx: LPINT,
        lpSize: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextExtentExPointW(
        hdc: HDC,
        lpszString: LPCWSTR,
        cchString: ::std::os::raw::c_int,
        nMaxExtent: ::std::os::raw::c_int,
        lpnFit: LPINT,
        lpnDx: LPINT,
        lpSize: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextCharset(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTextCharsetInfo(
        hdc: HDC,
        lpSig: LPFONTSIGNATURE,
        dwFlags: DWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TranslateCharsetInfo(lpSrc: *mut DWORD, lpCs: LPCHARSETINFO, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetFontLanguageInfo(hdc: HDC) -> DWORD;
}
extern "C" {
    pub fn GetCharacterPlacementA(
        hdc: HDC,
        lpString: LPCSTR,
        nCount: ::std::os::raw::c_int,
        nMexExtent: ::std::os::raw::c_int,
        lpResults: LPGCP_RESULTSA,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetCharacterPlacementW(
        hdc: HDC,
        lpString: LPCWSTR,
        nCount: ::std::os::raw::c_int,
        nMexExtent: ::std::os::raw::c_int,
        lpResults: LPGCP_RESULTSW,
        dwFlags: DWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWCRANGE {
    pub wcLow: WCHAR,
    pub cGlyphs: USHORT,
}
pub type WCRANGE = tagWCRANGE;
pub type PWCRANGE = *mut tagWCRANGE;
pub type LPWCRANGE = *mut tagWCRANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGLYPHSET {
    pub cbThis: DWORD,
    pub flAccel: DWORD,
    pub cGlyphsSupported: DWORD,
    pub cRanges: DWORD,
    pub ranges: [WCRANGE; 1usize],
}
pub type GLYPHSET = tagGLYPHSET;
pub type PGLYPHSET = *mut tagGLYPHSET;
pub type LPGLYPHSET = *mut tagGLYPHSET;
extern "C" {
    pub fn GetFontUnicodeRanges(hdc: HDC, lpgs: LPGLYPHSET) -> DWORD;
}
extern "C" {
    pub fn GetGlyphIndicesA(
        hdc: HDC,
        lpstr: LPCSTR,
        c: ::std::os::raw::c_int,
        pgi: LPWORD,
        fl: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetGlyphIndicesW(
        hdc: HDC,
        lpstr: LPCWSTR,
        c: ::std::os::raw::c_int,
        pgi: LPWORD,
        fl: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetTextExtentPointI(
        hdc: HDC,
        pgiIn: LPWORD,
        cgi: ::std::os::raw::c_int,
        psize: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextExtentExPointI(
        hdc: HDC,
        lpwszString: LPWORD,
        cwchString: ::std::os::raw::c_int,
        nMaxExtent: ::std::os::raw::c_int,
        lpnFit: LPINT,
        lpnDx: LPINT,
        lpSize: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCharWidthI(hdc: HDC, giFirst: UINT, cgi: UINT, pgi: LPWORD, piWidths: LPINT) -> BOOL;
}
extern "C" {
    pub fn GetCharABCWidthsI(hdc: HDC, giFirst: UINT, cgi: UINT, pgi: LPWORD, pabc: LPABC) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDESIGNVECTOR {
    pub dvReserved: DWORD,
    pub dvNumAxes: DWORD,
    pub dvValues: [LONG; 16usize],
}
pub type DESIGNVECTOR = tagDESIGNVECTOR;
pub type PDESIGNVECTOR = *mut tagDESIGNVECTOR;
pub type LPDESIGNVECTOR = *mut tagDESIGNVECTOR;
extern "C" {
    pub fn AddFontResourceExA(name: LPCSTR, fl: DWORD, res: PVOID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AddFontResourceExW(name: LPCWSTR, fl: DWORD, res: PVOID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RemoveFontResourceExA(name: LPCSTR, fl: DWORD, pdv: PVOID) -> BOOL;
}
extern "C" {
    pub fn RemoveFontResourceExW(name: LPCWSTR, fl: DWORD, pdv: PVOID) -> BOOL;
}
extern "C" {
    pub fn AddFontMemResourceEx(
        pFileView: PVOID,
        cjSize: DWORD,
        pvResrved: PVOID,
        pNumFonts: *mut DWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn RemoveFontMemResourceEx(h: HANDLE) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagAXISINFOA {
    pub axMinValue: LONG,
    pub axMaxValue: LONG,
    pub axAxisName: [BYTE; 16usize],
}
pub type AXISINFOA = tagAXISINFOA;
pub type PAXISINFOA = *mut tagAXISINFOA;
pub type LPAXISINFOA = *mut tagAXISINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagAXISINFOW {
    pub axMinValue: LONG,
    pub axMaxValue: LONG,
    pub axAxisName: [WCHAR; 16usize],
}
pub type AXISINFOW = tagAXISINFOW;
pub type PAXISINFOW = *mut tagAXISINFOW;
pub type LPAXISINFOW = *mut tagAXISINFOW;
pub type AXISINFO = AXISINFOA;
pub type PAXISINFO = PAXISINFOA;
pub type LPAXISINFO = LPAXISINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagAXESLISTA {
    pub axlReserved: DWORD,
    pub axlNumAxes: DWORD,
    pub axlAxisInfo: [AXISINFOA; 16usize],
}
pub type AXESLISTA = tagAXESLISTA;
pub type PAXESLISTA = *mut tagAXESLISTA;
pub type LPAXESLISTA = *mut tagAXESLISTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagAXESLISTW {
    pub axlReserved: DWORD,
    pub axlNumAxes: DWORD,
    pub axlAxisInfo: [AXISINFOW; 16usize],
}
pub type AXESLISTW = tagAXESLISTW;
pub type PAXESLISTW = *mut tagAXESLISTW;
pub type LPAXESLISTW = *mut tagAXESLISTW;
pub type AXESLIST = AXESLISTA;
pub type PAXESLIST = PAXESLISTA;
pub type LPAXESLIST = LPAXESLISTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMLOGFONTEXDVA {
    pub elfEnumLogfontEx: ENUMLOGFONTEXA,
    pub elfDesignVector: DESIGNVECTOR,
}
pub type ENUMLOGFONTEXDVA = tagENUMLOGFONTEXDVA;
pub type PENUMLOGFONTEXDVA = *mut tagENUMLOGFONTEXDVA;
pub type LPENUMLOGFONTEXDVA = *mut tagENUMLOGFONTEXDVA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMLOGFONTEXDVW {
    pub elfEnumLogfontEx: ENUMLOGFONTEXW,
    pub elfDesignVector: DESIGNVECTOR,
}
pub type ENUMLOGFONTEXDVW = tagENUMLOGFONTEXDVW;
pub type PENUMLOGFONTEXDVW = *mut tagENUMLOGFONTEXDVW;
pub type LPENUMLOGFONTEXDVW = *mut tagENUMLOGFONTEXDVW;
pub type ENUMLOGFONTEXDV = ENUMLOGFONTEXDVA;
pub type PENUMLOGFONTEXDV = PENUMLOGFONTEXDVA;
pub type LPENUMLOGFONTEXDV = LPENUMLOGFONTEXDVA;
extern "C" {
    pub fn CreateFontIndirectExA(arg1: *const ENUMLOGFONTEXDVA) -> HFONT;
}
extern "C" {
    pub fn CreateFontIndirectExW(arg1: *const ENUMLOGFONTEXDVW) -> HFONT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMTEXTMETRICA {
    pub etmNewTextMetricEx: NEWTEXTMETRICEXA,
    pub etmAxesList: AXESLISTA,
}
pub type ENUMTEXTMETRICA = tagENUMTEXTMETRICA;
pub type PENUMTEXTMETRICA = *mut tagENUMTEXTMETRICA;
pub type LPENUMTEXTMETRICA = *mut tagENUMTEXTMETRICA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagENUMTEXTMETRICW {
    pub etmNewTextMetricEx: NEWTEXTMETRICEXW,
    pub etmAxesList: AXESLISTW,
}
pub type ENUMTEXTMETRICW = tagENUMTEXTMETRICW;
pub type PENUMTEXTMETRICW = *mut tagENUMTEXTMETRICW;
pub type LPENUMTEXTMETRICW = *mut tagENUMTEXTMETRICW;
pub type ENUMTEXTMETRIC = ENUMTEXTMETRICA;
pub type PENUMTEXTMETRIC = PENUMTEXTMETRICA;
pub type LPENUMTEXTMETRIC = LPENUMTEXTMETRICA;
extern "C" {
    pub fn GetViewportExtEx(hdc: HDC, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
    pub fn GetViewportOrgEx(hdc: HDC, lppoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn GetWindowExtEx(hdc: HDC, lpsize: LPSIZE) -> BOOL;
}
extern "C" {
    pub fn GetWindowOrgEx(hdc: HDC, lppoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn IntersectClipRect(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InvertRgn(hdc: HDC, hrgn: HRGN) -> BOOL;
}
extern "C" {
    pub fn LineDDA(
        xStart: ::std::os::raw::c_int,
        yStart: ::std::os::raw::c_int,
        xEnd: ::std::os::raw::c_int,
        yEnd: ::std::os::raw::c_int,
        lpProc: LINEDDAPROC,
        data: LPARAM,
    ) -> BOOL;
}
extern "C" {
    pub fn LineTo(hdc: HDC, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn MaskBlt(
        hdcDest: HDC,
        xDest: ::std::os::raw::c_int,
        yDest: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        hdcSrc: HDC,
        xSrc: ::std::os::raw::c_int,
        ySrc: ::std::os::raw::c_int,
        hbmMask: HBITMAP,
        xMask: ::std::os::raw::c_int,
        yMask: ::std::os::raw::c_int,
        rop: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PlgBlt(
        hdcDest: HDC,
        lpPoint: *const POINT,
        hdcSrc: HDC,
        xSrc: ::std::os::raw::c_int,
        ySrc: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        hbmMask: HBITMAP,
        xMask: ::std::os::raw::c_int,
        yMask: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn OffsetClipRgn(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OffsetRgn(
        hrgn: HRGN,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PatBlt(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        rop: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn Pie(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn PlayMetaFile(hdc: HDC, hmf: HMETAFILE) -> BOOL;
}
extern "C" {
    pub fn PaintRgn(hdc: HDC, hrgn: HRGN) -> BOOL;
}
extern "C" {
    pub fn PolyPolygon(
        hdc: HDC,
        apt: *const POINT,
        asz: *const INT,
        csz: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn PtInRegion(hrgn: HRGN, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn PtVisible(hdc: HDC, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn RectInRegion(hrgn: HRGN, lprect: *const RECT) -> BOOL;
}
extern "C" {
    pub fn RectVisible(hdc: HDC, lprect: *const RECT) -> BOOL;
}
extern "C" {
    pub fn Rectangle(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn RestoreDC(hdc: HDC, nSavedDC: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn ResetDCA(hdc: HDC, lpdm: *const DEVMODEA) -> HDC;
}
extern "C" {
    pub fn ResetDCW(hdc: HDC, lpdm: *const DEVMODEW) -> HDC;
}
extern "C" {
    pub fn RealizePalette(hdc: HDC) -> UINT;
}
extern "C" {
    pub fn RemoveFontResourceA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn RemoveFontResourceW(lpFileName: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn RoundRect(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn ResizePalette(hpal: HPALETTE, n: UINT) -> BOOL;
}
extern "C" {
    pub fn SaveDC(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SelectClipRgn(hdc: HDC, hrgn: HRGN) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExtSelectClipRgn(
        hdc: HDC,
        hrgn: HRGN,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetMetaRgn(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SelectObject(hdc: HDC, h: HGDIOBJ) -> HGDIOBJ;
}
extern "C" {
    pub fn SelectPalette(hdc: HDC, hPal: HPALETTE, bForceBkgd: BOOL) -> HPALETTE;
}
extern "C" {
    pub fn SetBkColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
    pub fn SetDCBrushColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
    pub fn SetDCPenColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
    pub fn SetBkMode(hdc: HDC, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetBitmapBits(hbm: HBITMAP, cb: DWORD, pvBits: *const ::std::os::raw::c_void) -> LONG;
}
extern "C" {
    pub fn SetBoundsRect(hdc: HDC, lprect: *const RECT, flags: UINT) -> UINT;
}
extern "C" {
    pub fn SetDIBits(
        hdc: HDC,
        hbm: HBITMAP,
        start: UINT,
        cLines: UINT,
        lpBits: *const ::std::os::raw::c_void,
        lpbmi: *const BITMAPINFO,
        ColorUse: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetDIBitsToDevice(
        hdc: HDC,
        xDest: ::std::os::raw::c_int,
        yDest: ::std::os::raw::c_int,
        w: DWORD,
        h: DWORD,
        xSrc: ::std::os::raw::c_int,
        ySrc: ::std::os::raw::c_int,
        StartScan: UINT,
        cLines: UINT,
        lpvBits: *const ::std::os::raw::c_void,
        lpbmi: *const BITMAPINFO,
        ColorUse: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetMapperFlags(hdc: HDC, flags: DWORD) -> DWORD;
}
extern "C" {
    pub fn SetGraphicsMode(hdc: HDC, iMode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetMapMode(hdc: HDC, iMode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetLayout(hdc: HDC, l: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetLayout(hdc: HDC) -> DWORD;
}
extern "C" {
    pub fn SetMetaFileBitsEx(cbBuffer: UINT, lpData: *const BYTE) -> HMETAFILE;
}
extern "C" {
    pub fn SetPaletteEntries(
        hpal: HPALETTE,
        iStart: UINT,
        cEntries: UINT,
        pPalEntries: *const PALETTEENTRY,
    ) -> UINT;
}
extern "C" {
    pub fn SetPixel(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        color: COLORREF,
    ) -> COLORREF;
}
extern "C" {
    pub fn SetPixelV(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        color: COLORREF,
    ) -> BOOL;
}
extern "C" {
    pub fn SetPixelFormat(
        hdc: HDC,
        format: ::std::os::raw::c_int,
        ppfd: *const PIXELFORMATDESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetPolyFillMode(hdc: HDC, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn StretchBlt(
        hdcDest: HDC,
        xDest: ::std::os::raw::c_int,
        yDest: ::std::os::raw::c_int,
        wDest: ::std::os::raw::c_int,
        hDest: ::std::os::raw::c_int,
        hdcSrc: HDC,
        xSrc: ::std::os::raw::c_int,
        ySrc: ::std::os::raw::c_int,
        wSrc: ::std::os::raw::c_int,
        hSrc: ::std::os::raw::c_int,
        rop: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetRectRgn(
        hrgn: HRGN,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn StretchDIBits(
        hdc: HDC,
        xDest: ::std::os::raw::c_int,
        yDest: ::std::os::raw::c_int,
        DestWidth: ::std::os::raw::c_int,
        DestHeight: ::std::os::raw::c_int,
        xSrc: ::std::os::raw::c_int,
        ySrc: ::std::os::raw::c_int,
        SrcWidth: ::std::os::raw::c_int,
        SrcHeight: ::std::os::raw::c_int,
        lpBits: *const ::std::os::raw::c_void,
        lpbmi: *const BITMAPINFO,
        iUsage: UINT,
        rop: DWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetROP2(hdc: HDC, rop2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetStretchBltMode(hdc: HDC, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetSystemPaletteUse(hdc: HDC, use_: UINT) -> UINT;
}
extern "C" {
    pub fn SetTextCharacterExtra(hdc: HDC, extra: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetTextColor(hdc: HDC, color: COLORREF) -> COLORREF;
}
extern "C" {
    pub fn SetTextAlign(hdc: HDC, align: UINT) -> UINT;
}
extern "C" {
    pub fn SetTextJustification(
        hdc: HDC,
        extra: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn UpdateColors(hdc: HDC) -> BOOL;
}
pub type COLOR16 = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRIVERTEX {
    pub x: LONG,
    pub y: LONG,
    pub Red: COLOR16,
    pub Green: COLOR16,
    pub Blue: COLOR16,
    pub Alpha: COLOR16,
}
pub type TRIVERTEX = _TRIVERTEX;
pub type PTRIVERTEX = *mut _TRIVERTEX;
pub type LPTRIVERTEX = *mut _TRIVERTEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRADIENT_TRIANGLE {
    pub Vertex1: ULONG,
    pub Vertex2: ULONG,
    pub Vertex3: ULONG,
}
pub type GRADIENT_TRIANGLE = _GRADIENT_TRIANGLE;
pub type PGRADIENT_TRIANGLE = *mut _GRADIENT_TRIANGLE;
pub type LPGRADIENT_TRIANGLE = *mut _GRADIENT_TRIANGLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRADIENT_RECT {
    pub UpperLeft: ULONG,
    pub LowerRight: ULONG,
}
pub type GRADIENT_RECT = _GRADIENT_RECT;
pub type PGRADIENT_RECT = *mut _GRADIENT_RECT;
pub type LPGRADIENT_RECT = *mut _GRADIENT_RECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BLENDFUNCTION {
    pub BlendOp: BYTE,
    pub BlendFlags: BYTE,
    pub SourceConstantAlpha: BYTE,
    pub AlphaFormat: BYTE,
}
pub type BLENDFUNCTION = _BLENDFUNCTION;
pub type PBLENDFUNCTION = *mut _BLENDFUNCTION;
extern "C" {
    pub fn AlphaBlend(
        hdcDest: HDC,
        xoriginDest: ::std::os::raw::c_int,
        yoriginDest: ::std::os::raw::c_int,
        wDest: ::std::os::raw::c_int,
        hDest: ::std::os::raw::c_int,
        hdcSrc: HDC,
        xoriginSrc: ::std::os::raw::c_int,
        yoriginSrc: ::std::os::raw::c_int,
        wSrc: ::std::os::raw::c_int,
        hSrc: ::std::os::raw::c_int,
        ftn: BLENDFUNCTION,
    ) -> BOOL;
}
extern "C" {
    pub fn TransparentBlt(
        hdcDest: HDC,
        xoriginDest: ::std::os::raw::c_int,
        yoriginDest: ::std::os::raw::c_int,
        wDest: ::std::os::raw::c_int,
        hDest: ::std::os::raw::c_int,
        hdcSrc: HDC,
        xoriginSrc: ::std::os::raw::c_int,
        yoriginSrc: ::std::os::raw::c_int,
        wSrc: ::std::os::raw::c_int,
        hSrc: ::std::os::raw::c_int,
        crTransparent: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GradientFill(
        hdc: HDC,
        pVertex: PTRIVERTEX,
        nVertex: ULONG,
        pMesh: PVOID,
        nMesh: ULONG,
        ulMode: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GdiAlphaBlend(
        hdcDest: HDC,
        xoriginDest: ::std::os::raw::c_int,
        yoriginDest: ::std::os::raw::c_int,
        wDest: ::std::os::raw::c_int,
        hDest: ::std::os::raw::c_int,
        hdcSrc: HDC,
        xoriginSrc: ::std::os::raw::c_int,
        yoriginSrc: ::std::os::raw::c_int,
        wSrc: ::std::os::raw::c_int,
        hSrc: ::std::os::raw::c_int,
        ftn: BLENDFUNCTION,
    ) -> BOOL;
}
extern "C" {
    pub fn GdiTransparentBlt(
        hdcDest: HDC,
        xoriginDest: ::std::os::raw::c_int,
        yoriginDest: ::std::os::raw::c_int,
        wDest: ::std::os::raw::c_int,
        hDest: ::std::os::raw::c_int,
        hdcSrc: HDC,
        xoriginSrc: ::std::os::raw::c_int,
        yoriginSrc: ::std::os::raw::c_int,
        wSrc: ::std::os::raw::c_int,
        hSrc: ::std::os::raw::c_int,
        crTransparent: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GdiGradientFill(
        hdc: HDC,
        pVertex: PTRIVERTEX,
        nVertex: ULONG,
        pMesh: PVOID,
        nCount: ULONG,
        ulMode: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn PlayMetaFileRecord(
        hdc: HDC,
        lpHandleTable: LPHANDLETABLE,
        lpMR: LPMETARECORD,
        noObjs: UINT,
    ) -> BOOL;
}
pub type MFENUMPROC = ::std::option::Option<
    unsafe extern "C" fn(
        hdc: HDC,
        lpht: *mut HANDLETABLE,
        lpMR: *mut METARECORD,
        nObj: ::std::os::raw::c_int,
        param: LPARAM,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn EnumMetaFile(hdc: HDC, hmf: HMETAFILE, proc_: MFENUMPROC, param: LPARAM) -> BOOL;
}
pub type ENHMFENUMPROC = ::std::option::Option<
    unsafe extern "C" fn(
        hdc: HDC,
        lpht: *mut HANDLETABLE,
        lpmr: *const ENHMETARECORD,
        nHandles: ::std::os::raw::c_int,
        data: LPARAM,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn CloseEnhMetaFile(hdc: HDC) -> HENHMETAFILE;
}
extern "C" {
    pub fn CopyEnhMetaFileA(hEnh: HENHMETAFILE, lpFileName: LPCSTR) -> HENHMETAFILE;
}
extern "C" {
    pub fn CopyEnhMetaFileW(hEnh: HENHMETAFILE, lpFileName: LPCWSTR) -> HENHMETAFILE;
}
extern "C" {
    pub fn CreateEnhMetaFileA(
        hdc: HDC,
        lpFilename: LPCSTR,
        lprc: *const RECT,
        lpDesc: LPCSTR,
    ) -> HDC;
}
extern "C" {
    pub fn CreateEnhMetaFileW(
        hdc: HDC,
        lpFilename: LPCWSTR,
        lprc: *const RECT,
        lpDesc: LPCWSTR,
    ) -> HDC;
}
extern "C" {
    pub fn DeleteEnhMetaFile(hmf: HENHMETAFILE) -> BOOL;
}
extern "C" {
    pub fn EnumEnhMetaFile(
        hdc: HDC,
        hmf: HENHMETAFILE,
        proc_: ENHMFENUMPROC,
        param: LPVOID,
        lpRect: *const RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetEnhMetaFileA(lpName: LPCSTR) -> HENHMETAFILE;
}
extern "C" {
    pub fn GetEnhMetaFileW(lpName: LPCWSTR) -> HENHMETAFILE;
}
extern "C" {
    pub fn GetEnhMetaFileBits(hEMF: HENHMETAFILE, nSize: UINT, lpData: LPBYTE) -> UINT;
}
extern "C" {
    pub fn GetEnhMetaFileDescriptionA(
        hemf: HENHMETAFILE,
        cchBuffer: UINT,
        lpDescription: LPSTR,
    ) -> UINT;
}
extern "C" {
    pub fn GetEnhMetaFileDescriptionW(
        hemf: HENHMETAFILE,
        cchBuffer: UINT,
        lpDescription: LPWSTR,
    ) -> UINT;
}
extern "C" {
    pub fn GetEnhMetaFileHeader(
        hemf: HENHMETAFILE,
        nSize: UINT,
        lpEnhMetaHeader: LPENHMETAHEADER,
    ) -> UINT;
}
extern "C" {
    pub fn GetEnhMetaFilePaletteEntries(
        hemf: HENHMETAFILE,
        nNumEntries: UINT,
        lpPaletteEntries: LPPALETTEENTRY,
    ) -> UINT;
}
extern "C" {
    pub fn GetEnhMetaFilePixelFormat(
        hemf: HENHMETAFILE,
        cbBuffer: UINT,
        ppfd: *mut PIXELFORMATDESCRIPTOR,
    ) -> UINT;
}
extern "C" {
    pub fn GetWinMetaFileBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        hdcRef: HDC,
    ) -> UINT;
}
extern "C" {
    pub fn PlayEnhMetaFile(hdc: HDC, hmf: HENHMETAFILE, lprect: *const RECT) -> BOOL;
}
extern "C" {
    pub fn PlayEnhMetaFileRecord(
        hdc: HDC,
        pht: LPHANDLETABLE,
        pmr: *const ENHMETARECORD,
        cht: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn SetEnhMetaFileBits(nSize: UINT, pb: *const BYTE) -> HENHMETAFILE;
}
extern "C" {
    pub fn SetWinMetaFileBits(
        nSize: UINT,
        lpMeta16Data: *const BYTE,
        hdcRef: HDC,
        lpMFP: *const METAFILEPICT,
    ) -> HENHMETAFILE;
}
extern "C" {
    pub fn GdiComment(hdc: HDC, nSize: UINT, lpData: *const BYTE) -> BOOL;
}
extern "C" {
    pub fn GetTextMetricsA(hdc: HDC, lptm: LPTEXTMETRICA) -> BOOL;
}
extern "C" {
    pub fn GetTextMetricsW(hdc: HDC, lptm: LPTEXTMETRICW) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDIBSECTION {
    pub dsBm: BITMAP,
    pub dsBmih: BITMAPINFOHEADER,
    pub dsBitfields: [DWORD; 3usize],
    pub dshSection: HANDLE,
    pub dsOffset: DWORD,
}
pub type DIBSECTION = tagDIBSECTION;
pub type LPDIBSECTION = *mut tagDIBSECTION;
pub type PDIBSECTION = *mut tagDIBSECTION;
extern "C" {
    pub fn AngleArc(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        r: DWORD,
        StartAngle: FLOAT,
        SweepAngle: FLOAT,
    ) -> BOOL;
}
extern "C" {
    pub fn PolyPolyline(hdc: HDC, apt: *const POINT, asz: *const DWORD, csz: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetWorldTransform(hdc: HDC, lpxf: LPXFORM) -> BOOL;
}
extern "C" {
    pub fn SetWorldTransform(hdc: HDC, lpxf: *const XFORM) -> BOOL;
}
extern "C" {
    pub fn ModifyWorldTransform(hdc: HDC, lpxf: *const XFORM, mode: DWORD) -> BOOL;
}
extern "C" {
    pub fn CombineTransform(lpxfOut: LPXFORM, lpxf1: *const XFORM, lpxf2: *const XFORM) -> BOOL;
}
extern "C" {
    pub fn CreateDIBSection(
        hdc: HDC,
        pbmi: *const BITMAPINFO,
        usage: UINT,
        ppvBits: *mut *mut ::std::os::raw::c_void,
        hSection: HANDLE,
        offset: DWORD,
    ) -> HBITMAP;
}
extern "C" {
    pub fn GetDIBColorTable(hdc: HDC, iStart: UINT, cEntries: UINT, prgbq: *mut RGBQUAD) -> UINT;
}
extern "C" {
    pub fn SetDIBColorTable(hdc: HDC, iStart: UINT, cEntries: UINT, prgbq: *const RGBQUAD) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOLORADJUSTMENT {
    pub caSize: WORD,
    pub caFlags: WORD,
    pub caIlluminantIndex: WORD,
    pub caRedGamma: WORD,
    pub caGreenGamma: WORD,
    pub caBlueGamma: WORD,
    pub caReferenceBlack: WORD,
    pub caReferenceWhite: WORD,
    pub caContrast: SHORT,
    pub caBrightness: SHORT,
    pub caColorfulness: SHORT,
    pub caRedGreenTint: SHORT,
}
pub type COLORADJUSTMENT = tagCOLORADJUSTMENT;
pub type PCOLORADJUSTMENT = *mut tagCOLORADJUSTMENT;
pub type LPCOLORADJUSTMENT = *mut tagCOLORADJUSTMENT;
extern "C" {
    pub fn SetColorAdjustment(hdc: HDC, lpca: *const COLORADJUSTMENT) -> BOOL;
}
extern "C" {
    pub fn GetColorAdjustment(hdc: HDC, lpca: LPCOLORADJUSTMENT) -> BOOL;
}
extern "C" {
    pub fn CreateHalftonePalette(hdc: HDC) -> HPALETTE;
}
pub type ABORTPROC =
    ::std::option::Option<unsafe extern "C" fn(arg1: HDC, arg2: ::std::os::raw::c_int) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOCINFOA {
    pub cbSize: ::std::os::raw::c_int,
    pub lpszDocName: LPCSTR,
    pub lpszOutput: LPCSTR,
    pub lpszDatatype: LPCSTR,
    pub fwType: DWORD,
}
pub type DOCINFOA = _DOCINFOA;
pub type LPDOCINFOA = *mut _DOCINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOCINFOW {
    pub cbSize: ::std::os::raw::c_int,
    pub lpszDocName: LPCWSTR,
    pub lpszOutput: LPCWSTR,
    pub lpszDatatype: LPCWSTR,
    pub fwType: DWORD,
}
pub type DOCINFOW = _DOCINFOW;
pub type LPDOCINFOW = *mut _DOCINFOW;
pub type DOCINFO = DOCINFOA;
pub type LPDOCINFO = LPDOCINFOA;
extern "C" {
    pub fn StartDocA(hdc: HDC, lpdi: *const DOCINFOA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn StartDocW(hdc: HDC, lpdi: *const DOCINFOW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EndDoc(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn StartPage(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EndPage(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AbortDoc(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetAbortProc(hdc: HDC, proc_: ABORTPROC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AbortPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn ArcTo(
        hdc: HDC,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn BeginPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn CloseFigure(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn EndPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn FillPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn FlattenPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn GetPath(
        hdc: HDC,
        apt: LPPOINT,
        aj: LPBYTE,
        cpt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PathToRegion(hdc: HDC) -> HRGN;
}
extern "C" {
    pub fn PolyDraw(
        hdc: HDC,
        apt: *const POINT,
        aj: *const BYTE,
        cpt: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn SelectClipPath(hdc: HDC, mode: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn SetArcDirection(hdc: HDC, dir: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetMiterLimit(hdc: HDC, limit: FLOAT, old: PFLOAT) -> BOOL;
}
extern "C" {
    pub fn StrokeAndFillPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn StrokePath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn WidenPath(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn ExtCreatePen(
        iPenStyle: DWORD,
        cWidth: DWORD,
        plbrush: *const LOGBRUSH,
        cStyle: DWORD,
        pstyle: *const DWORD,
    ) -> HPEN;
}
extern "C" {
    pub fn GetMiterLimit(hdc: HDC, plimit: PFLOAT) -> BOOL;
}
extern "C" {
    pub fn GetArcDirection(hdc: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetObjectA(h: HANDLE, c: ::std::os::raw::c_int, pv: LPVOID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetObjectW(h: HANDLE, c: ::std::os::raw::c_int, pv: LPVOID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MoveToEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lppt: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn TextOutA(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lpString: LPCSTR,
        c: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn TextOutW(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lpString: LPCWSTR,
        c: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn ExtTextOutA(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        options: UINT,
        lprect: *const RECT,
        lpString: LPCSTR,
        c: UINT,
        lpDx: *const INT,
    ) -> BOOL;
}
extern "C" {
    pub fn ExtTextOutW(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        options: UINT,
        lprect: *const RECT,
        lpString: LPCWSTR,
        c: UINT,
        lpDx: *const INT,
    ) -> BOOL;
}
extern "C" {
    pub fn PolyTextOutA(hdc: HDC, ppt: *const POLYTEXTA, nstrings: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn PolyTextOutW(hdc: HDC, ppt: *const POLYTEXTW, nstrings: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn CreatePolygonRgn(
        pptl: *const POINT,
        cPoint: ::std::os::raw::c_int,
        iMode: ::std::os::raw::c_int,
    ) -> HRGN;
}
extern "C" {
    pub fn DPtoLP(hdc: HDC, lppt: LPPOINT, c: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn LPtoDP(hdc: HDC, lppt: LPPOINT, c: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn Polygon(hdc: HDC, apt: *const POINT, cpt: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn Polyline(hdc: HDC, apt: *const POINT, cpt: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn PolyBezier(hdc: HDC, apt: *const POINT, cpt: DWORD) -> BOOL;
}
extern "C" {
    pub fn PolyBezierTo(hdc: HDC, apt: *const POINT, cpt: DWORD) -> BOOL;
}
extern "C" {
    pub fn PolylineTo(hdc: HDC, apt: *const POINT, cpt: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetViewportExtEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetViewportOrgEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lppt: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn SetWindowExtEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetWindowOrgEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lppt: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn OffsetViewportOrgEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lppt: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn OffsetWindowOrgEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lppt: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn ScaleViewportExtEx(
        hdc: HDC,
        xn: ::std::os::raw::c_int,
        dx: ::std::os::raw::c_int,
        yn: ::std::os::raw::c_int,
        yd: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn ScaleWindowExtEx(
        hdc: HDC,
        xn: ::std::os::raw::c_int,
        xd: ::std::os::raw::c_int,
        yn: ::std::os::raw::c_int,
        yd: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetBitmapDimensionEx(
        hbm: HBITMAP,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        lpsz: LPSIZE,
    ) -> BOOL;
}
extern "C" {
    pub fn SetBrushOrgEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lppt: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetTextFaceA(hdc: HDC, c: ::std::os::raw::c_int, lpName: LPSTR)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTextFaceW(
        hdc: HDC,
        c: ::std::os::raw::c_int,
        lpName: LPWSTR,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagKERNINGPAIR {
    pub wFirst: WORD,
    pub wSecond: WORD,
    pub iKernAmount: ::std::os::raw::c_int,
}
pub type KERNINGPAIR = tagKERNINGPAIR;
pub type LPKERNINGPAIR = *mut tagKERNINGPAIR;
extern "C" {
    pub fn GetKerningPairsA(hdc: HDC, nPairs: DWORD, lpKernPair: LPKERNINGPAIR) -> DWORD;
}
extern "C" {
    pub fn GetKerningPairsW(hdc: HDC, nPairs: DWORD, lpKernPair: LPKERNINGPAIR) -> DWORD;
}
extern "C" {
    pub fn GetDCOrgEx(hdc: HDC, lppt: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn FixBrushOrgEx(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ptl: LPPOINT,
    ) -> BOOL;
}
extern "C" {
    pub fn UnrealizeObject(h: HGDIOBJ) -> BOOL;
}
extern "C" {
    pub fn GdiFlush() -> BOOL;
}
extern "C" {
    pub fn GdiSetBatchLimit(dw: DWORD) -> DWORD;
}
extern "C" {
    pub fn GdiGetBatchLimit() -> DWORD;
}
pub type ICMENUMPROCA =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: LPARAM) -> ::std::os::raw::c_int>;
pub type ICMENUMPROCW = ::std::option::Option<
    unsafe extern "C" fn(arg1: LPWSTR, arg2: LPARAM) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SetICMMode(hdc: HDC, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CheckColorsInGamut(
        hdc: HDC,
        lpRGBTriple: LPRGBTRIPLE,
        dlpBuffer: LPVOID,
        nCount: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetColorSpace(hdc: HDC) -> HCOLORSPACE;
}
extern "C" {
    pub fn GetLogColorSpaceA(
        hColorSpace: HCOLORSPACE,
        lpBuffer: LPLOGCOLORSPACEA,
        nSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetLogColorSpaceW(
        hColorSpace: HCOLORSPACE,
        lpBuffer: LPLOGCOLORSPACEW,
        nSize: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateColorSpaceA(lplcs: LPLOGCOLORSPACEA) -> HCOLORSPACE;
}
extern "C" {
    pub fn CreateColorSpaceW(lplcs: LPLOGCOLORSPACEW) -> HCOLORSPACE;
}
extern "C" {
    pub fn SetColorSpace(hdc: HDC, hcs: HCOLORSPACE) -> HCOLORSPACE;
}
extern "C" {
    pub fn DeleteColorSpace(hcs: HCOLORSPACE) -> BOOL;
}
extern "C" {
    pub fn GetICMProfileA(hdc: HDC, pBufSize: LPDWORD, pszFilename: LPSTR) -> BOOL;
}
extern "C" {
    pub fn GetICMProfileW(hdc: HDC, pBufSize: LPDWORD, pszFilename: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn SetICMProfileA(hdc: HDC, lpFileName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn SetICMProfileW(hdc: HDC, lpFileName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn GetDeviceGammaRamp(hdc: HDC, lpRamp: LPVOID) -> BOOL;
}
extern "C" {
    pub fn SetDeviceGammaRamp(hdc: HDC, lpRamp: LPVOID) -> BOOL;
}
extern "C" {
    pub fn ColorMatchToTarget(hdc: HDC, hdcTarget: HDC, action: DWORD) -> BOOL;
}
extern "C" {
    pub fn EnumICMProfilesA(hdc: HDC, proc_: ICMENUMPROCA, param: LPARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumICMProfilesW(hdc: HDC, proc_: ICMENUMPROCW, param: LPARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UpdateICMRegKeyA(
        reserved: DWORD,
        lpszCMID: LPSTR,
        lpszFileName: LPSTR,
        command: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn UpdateICMRegKeyW(
        reserved: DWORD,
        lpszCMID: LPWSTR,
        lpszFileName: LPWSTR,
        command: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn ColorCorrectPalette(hdc: HDC, hPal: HPALETTE, deFirst: DWORD, num: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMR {
    pub iType: DWORD,
    pub nSize: DWORD,
}
pub type EMR = tagEMR;
pub type PEMR = *mut tagEMR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRTEXT {
    pub ptlReference: POINTL,
    pub nChars: DWORD,
    pub offString: DWORD,
    pub fOptions: DWORD,
    pub rcl: RECTL,
    pub offDx: DWORD,
}
pub type EMRTEXT = tagEMRTEXT;
pub type PEMRTEXT = *mut tagEMRTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagABORTPATH {
    pub emr: EMR,
}
pub type EMRABORTPATH = tagABORTPATH;
pub type PEMRABORTPATH = *mut tagABORTPATH;
pub type EMRBEGINPATH = tagABORTPATH;
pub type PEMRBEGINPATH = *mut tagABORTPATH;
pub type EMRENDPATH = tagABORTPATH;
pub type PEMRENDPATH = *mut tagABORTPATH;
pub type EMRCLOSEFIGURE = tagABORTPATH;
pub type PEMRCLOSEFIGURE = *mut tagABORTPATH;
pub type EMRFLATTENPATH = tagABORTPATH;
pub type PEMRFLATTENPATH = *mut tagABORTPATH;
pub type EMRWIDENPATH = tagABORTPATH;
pub type PEMRWIDENPATH = *mut tagABORTPATH;
pub type EMRSETMETARGN = tagABORTPATH;
pub type PEMRSETMETARGN = *mut tagABORTPATH;
pub type EMRSAVEDC = tagABORTPATH;
pub type PEMRSAVEDC = *mut tagABORTPATH;
pub type EMRREALIZEPALETTE = tagABORTPATH;
pub type PEMRREALIZEPALETTE = *mut tagABORTPATH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSELECTCLIPPATH {
    pub emr: EMR,
    pub iMode: DWORD,
}
pub type EMRSELECTCLIPPATH = tagEMRSELECTCLIPPATH;
pub type PEMRSELECTCLIPPATH = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETBKMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETBKMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETMAPMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETMAPMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETLAYOUT = tagEMRSELECTCLIPPATH;
pub type PEMRSETLAYOUT = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETPOLYFILLMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETPOLYFILLMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETROP2 = tagEMRSELECTCLIPPATH;
pub type PEMRSETROP2 = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETSTRETCHBLTMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETSTRETCHBLTMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETICMMODE = tagEMRSELECTCLIPPATH;
pub type PEMRSETICMMODE = *mut tagEMRSELECTCLIPPATH;
pub type EMRSETTEXTALIGN = tagEMRSELECTCLIPPATH;
pub type PEMRSETTEXTALIGN = *mut tagEMRSELECTCLIPPATH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETMITERLIMIT {
    pub emr: EMR,
    pub eMiterLimit: FLOAT,
}
pub type EMRSETMITERLIMIT = tagEMRSETMITERLIMIT;
pub type PEMRSETMITERLIMIT = *mut tagEMRSETMITERLIMIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRRESTOREDC {
    pub emr: EMR,
    pub iRelative: LONG,
}
pub type EMRRESTOREDC = tagEMRRESTOREDC;
pub type PEMRRESTOREDC = *mut tagEMRRESTOREDC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETARCDIRECTION {
    pub emr: EMR,
    pub iArcDirection: DWORD,
}
pub type EMRSETARCDIRECTION = tagEMRSETARCDIRECTION;
pub type PEMRSETARCDIRECTION = *mut tagEMRSETARCDIRECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETMAPPERFLAGS {
    pub emr: EMR,
    pub dwFlags: DWORD,
}
pub type EMRSETMAPPERFLAGS = tagEMRSETMAPPERFLAGS;
pub type PEMRSETMAPPERFLAGS = *mut tagEMRSETMAPPERFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETTEXTCOLOR {
    pub emr: EMR,
    pub crColor: COLORREF,
}
pub type EMRSETBKCOLOR = tagEMRSETTEXTCOLOR;
pub type PEMRSETBKCOLOR = *mut tagEMRSETTEXTCOLOR;
pub type EMRSETTEXTCOLOR = tagEMRSETTEXTCOLOR;
pub type PEMRSETTEXTCOLOR = *mut tagEMRSETTEXTCOLOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSELECTOBJECT {
    pub emr: EMR,
    pub ihObject: DWORD,
}
pub type EMRSELECTOBJECT = tagEMRSELECTOBJECT;
pub type PEMRSELECTOBJECT = *mut tagEMRSELECTOBJECT;
pub type EMRDELETEOBJECT = tagEMRSELECTOBJECT;
pub type PEMRDELETEOBJECT = *mut tagEMRSELECTOBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSELECTPALETTE {
    pub emr: EMR,
    pub ihPal: DWORD,
}
pub type EMRSELECTPALETTE = tagEMRSELECTPALETTE;
pub type PEMRSELECTPALETTE = *mut tagEMRSELECTPALETTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRRESIZEPALETTE {
    pub emr: EMR,
    pub ihPal: DWORD,
    pub cEntries: DWORD,
}
pub type EMRRESIZEPALETTE = tagEMRRESIZEPALETTE;
pub type PEMRRESIZEPALETTE = *mut tagEMRRESIZEPALETTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETPALETTEENTRIES {
    pub emr: EMR,
    pub ihPal: DWORD,
    pub iStart: DWORD,
    pub cEntries: DWORD,
    pub aPalEntries: [PALETTEENTRY; 1usize],
}
pub type EMRSETPALETTEENTRIES = tagEMRSETPALETTEENTRIES;
pub type PEMRSETPALETTEENTRIES = *mut tagEMRSETPALETTEENTRIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETCOLORADJUSTMENT {
    pub emr: EMR,
    pub ColorAdjustment: COLORADJUSTMENT,
}
pub type EMRSETCOLORADJUSTMENT = tagEMRSETCOLORADJUSTMENT;
pub type PEMRSETCOLORADJUSTMENT = *mut tagEMRSETCOLORADJUSTMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRGDICOMMENT {
    pub emr: EMR,
    pub cbData: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type EMRGDICOMMENT = tagEMRGDICOMMENT;
pub type PEMRGDICOMMENT = *mut tagEMRGDICOMMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREOF {
    pub emr: EMR,
    pub nPalEntries: DWORD,
    pub offPalEntries: DWORD,
    pub nSizeLast: DWORD,
}
pub type EMREOF = tagEMREOF;
pub type PEMREOF = *mut tagEMREOF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRLINETO {
    pub emr: EMR,
    pub ptl: POINTL,
}
pub type EMRLINETO = tagEMRLINETO;
pub type PEMRLINETO = *mut tagEMRLINETO;
pub type EMRMOVETOEX = tagEMRLINETO;
pub type PEMRMOVETOEX = *mut tagEMRLINETO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMROFFSETCLIPRGN {
    pub emr: EMR,
    pub ptlOffset: POINTL,
}
pub type EMROFFSETCLIPRGN = tagEMROFFSETCLIPRGN;
pub type PEMROFFSETCLIPRGN = *mut tagEMROFFSETCLIPRGN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRFILLPATH {
    pub emr: EMR,
    pub rclBounds: RECTL,
}
pub type EMRFILLPATH = tagEMRFILLPATH;
pub type PEMRFILLPATH = *mut tagEMRFILLPATH;
pub type EMRSTROKEANDFILLPATH = tagEMRFILLPATH;
pub type PEMRSTROKEANDFILLPATH = *mut tagEMRFILLPATH;
pub type EMRSTROKEPATH = tagEMRFILLPATH;
pub type PEMRSTROKEPATH = *mut tagEMRFILLPATH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXCLUDECLIPRECT {
    pub emr: EMR,
    pub rclClip: RECTL,
}
pub type EMREXCLUDECLIPRECT = tagEMREXCLUDECLIPRECT;
pub type PEMREXCLUDECLIPRECT = *mut tagEMREXCLUDECLIPRECT;
pub type EMRINTERSECTCLIPRECT = tagEMREXCLUDECLIPRECT;
pub type PEMRINTERSECTCLIPRECT = *mut tagEMREXCLUDECLIPRECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETVIEWPORTORGEX {
    pub emr: EMR,
    pub ptlOrigin: POINTL,
}
pub type EMRSETVIEWPORTORGEX = tagEMRSETVIEWPORTORGEX;
pub type PEMRSETVIEWPORTORGEX = *mut tagEMRSETVIEWPORTORGEX;
pub type EMRSETWINDOWORGEX = tagEMRSETVIEWPORTORGEX;
pub type PEMRSETWINDOWORGEX = *mut tagEMRSETVIEWPORTORGEX;
pub type EMRSETBRUSHORGEX = tagEMRSETVIEWPORTORGEX;
pub type PEMRSETBRUSHORGEX = *mut tagEMRSETVIEWPORTORGEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETVIEWPORTEXTEX {
    pub emr: EMR,
    pub szlExtent: SIZEL,
}
pub type EMRSETVIEWPORTEXTEX = tagEMRSETVIEWPORTEXTEX;
pub type PEMRSETVIEWPORTEXTEX = *mut tagEMRSETVIEWPORTEXTEX;
pub type EMRSETWINDOWEXTEX = tagEMRSETVIEWPORTEXTEX;
pub type PEMRSETWINDOWEXTEX = *mut tagEMRSETVIEWPORTEXTEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSCALEVIEWPORTEXTEX {
    pub emr: EMR,
    pub xNum: LONG,
    pub xDenom: LONG,
    pub yNum: LONG,
    pub yDenom: LONG,
}
pub type EMRSCALEVIEWPORTEXTEX = tagEMRSCALEVIEWPORTEXTEX;
pub type PEMRSCALEVIEWPORTEXTEX = *mut tagEMRSCALEVIEWPORTEXTEX;
pub type EMRSCALEWINDOWEXTEX = tagEMRSCALEVIEWPORTEXTEX;
pub type PEMRSCALEWINDOWEXTEX = *mut tagEMRSCALEVIEWPORTEXTEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETWORLDTRANSFORM {
    pub emr: EMR,
    pub xform: XFORM,
}
pub type EMRSETWORLDTRANSFORM = tagEMRSETWORLDTRANSFORM;
pub type PEMRSETWORLDTRANSFORM = *mut tagEMRSETWORLDTRANSFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRMODIFYWORLDTRANSFORM {
    pub emr: EMR,
    pub xform: XFORM,
    pub iMode: DWORD,
}
pub type EMRMODIFYWORLDTRANSFORM = tagEMRMODIFYWORLDTRANSFORM;
pub type PEMRMODIFYWORLDTRANSFORM = *mut tagEMRMODIFYWORLDTRANSFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETPIXELV {
    pub emr: EMR,
    pub ptlPixel: POINTL,
    pub crColor: COLORREF,
}
pub type EMRSETPIXELV = tagEMRSETPIXELV;
pub type PEMRSETPIXELV = *mut tagEMRSETPIXELV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXTFLOODFILL {
    pub emr: EMR,
    pub ptlStart: POINTL,
    pub crColor: COLORREF,
    pub iMode: DWORD,
}
pub type EMREXTFLOODFILL = tagEMREXTFLOODFILL;
pub type PEMREXTFLOODFILL = *mut tagEMREXTFLOODFILL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRELLIPSE {
    pub emr: EMR,
    pub rclBox: RECTL,
}
pub type EMRELLIPSE = tagEMRELLIPSE;
pub type PEMRELLIPSE = *mut tagEMRELLIPSE;
pub type EMRRECTANGLE = tagEMRELLIPSE;
pub type PEMRRECTANGLE = *mut tagEMRELLIPSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRROUNDRECT {
    pub emr: EMR,
    pub rclBox: RECTL,
    pub szlCorner: SIZEL,
}
pub type EMRROUNDRECT = tagEMRROUNDRECT;
pub type PEMRROUNDRECT = *mut tagEMRROUNDRECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRARC {
    pub emr: EMR,
    pub rclBox: RECTL,
    pub ptlStart: POINTL,
    pub ptlEnd: POINTL,
}
pub type EMRARC = tagEMRARC;
pub type PEMRARC = *mut tagEMRARC;
pub type EMRARCTO = tagEMRARC;
pub type PEMRARCTO = *mut tagEMRARC;
pub type EMRCHORD = tagEMRARC;
pub type PEMRCHORD = *mut tagEMRARC;
pub type EMRPIE = tagEMRARC;
pub type PEMRPIE = *mut tagEMRARC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRANGLEARC {
    pub emr: EMR,
    pub ptlCenter: POINTL,
    pub nRadius: DWORD,
    pub eStartAngle: FLOAT,
    pub eSweepAngle: FLOAT,
}
pub type EMRANGLEARC = tagEMRANGLEARC;
pub type PEMRANGLEARC = *mut tagEMRANGLEARC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYLINE {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cptl: DWORD,
    pub aptl: [POINTL; 1usize],
}
pub type EMRPOLYLINE = tagEMRPOLYLINE;
pub type PEMRPOLYLINE = *mut tagEMRPOLYLINE;
pub type EMRPOLYBEZIER = tagEMRPOLYLINE;
pub type PEMRPOLYBEZIER = *mut tagEMRPOLYLINE;
pub type EMRPOLYGON = tagEMRPOLYLINE;
pub type PEMRPOLYGON = *mut tagEMRPOLYLINE;
pub type EMRPOLYBEZIERTO = tagEMRPOLYLINE;
pub type PEMRPOLYBEZIERTO = *mut tagEMRPOLYLINE;
pub type EMRPOLYLINETO = tagEMRPOLYLINE;
pub type PEMRPOLYLINETO = *mut tagEMRPOLYLINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYLINE16 {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cpts: DWORD,
    pub apts: [POINTS; 1usize],
}
pub type EMRPOLYLINE16 = tagEMRPOLYLINE16;
pub type PEMRPOLYLINE16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYBEZIER16 = tagEMRPOLYLINE16;
pub type PEMRPOLYBEZIER16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYGON16 = tagEMRPOLYLINE16;
pub type PEMRPOLYGON16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYBEZIERTO16 = tagEMRPOLYLINE16;
pub type PEMRPOLYBEZIERTO16 = *mut tagEMRPOLYLINE16;
pub type EMRPOLYLINETO16 = tagEMRPOLYLINE16;
pub type PEMRPOLYLINETO16 = *mut tagEMRPOLYLINE16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYDRAW {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cptl: DWORD,
    pub aptl: [POINTL; 1usize],
    pub abTypes: [BYTE; 1usize],
}
pub type EMRPOLYDRAW = tagEMRPOLYDRAW;
pub type PEMRPOLYDRAW = *mut tagEMRPOLYDRAW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYDRAW16 {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cpts: DWORD,
    pub apts: [POINTS; 1usize],
    pub abTypes: [BYTE; 1usize],
}
pub type EMRPOLYDRAW16 = tagEMRPOLYDRAW16;
pub type PEMRPOLYDRAW16 = *mut tagEMRPOLYDRAW16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYPOLYLINE {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub nPolys: DWORD,
    pub cptl: DWORD,
    pub aPolyCounts: [DWORD; 1usize],
    pub aptl: [POINTL; 1usize],
}
pub type EMRPOLYPOLYLINE = tagEMRPOLYPOLYLINE;
pub type PEMRPOLYPOLYLINE = *mut tagEMRPOLYPOLYLINE;
pub type EMRPOLYPOLYGON = tagEMRPOLYPOLYLINE;
pub type PEMRPOLYPOLYGON = *mut tagEMRPOLYPOLYLINE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYPOLYLINE16 {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub nPolys: DWORD,
    pub cpts: DWORD,
    pub aPolyCounts: [DWORD; 1usize],
    pub apts: [POINTS; 1usize],
}
pub type EMRPOLYPOLYLINE16 = tagEMRPOLYPOLYLINE16;
pub type PEMRPOLYPOLYLINE16 = *mut tagEMRPOLYPOLYLINE16;
pub type EMRPOLYPOLYGON16 = tagEMRPOLYPOLYLINE16;
pub type PEMRPOLYPOLYGON16 = *mut tagEMRPOLYPOLYLINE16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRINVERTRGN {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cbRgnData: DWORD,
    pub RgnData: [BYTE; 1usize],
}
pub type EMRINVERTRGN = tagEMRINVERTRGN;
pub type PEMRINVERTRGN = *mut tagEMRINVERTRGN;
pub type EMRPAINTRGN = tagEMRINVERTRGN;
pub type PEMRPAINTRGN = *mut tagEMRINVERTRGN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRFILLRGN {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cbRgnData: DWORD,
    pub ihBrush: DWORD,
    pub RgnData: [BYTE; 1usize],
}
pub type EMRFILLRGN = tagEMRFILLRGN;
pub type PEMRFILLRGN = *mut tagEMRFILLRGN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRFRAMERGN {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cbRgnData: DWORD,
    pub ihBrush: DWORD,
    pub szlStroke: SIZEL,
    pub RgnData: [BYTE; 1usize],
}
pub type EMRFRAMERGN = tagEMRFRAMERGN;
pub type PEMRFRAMERGN = *mut tagEMRFRAMERGN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXTSELECTCLIPRGN {
    pub emr: EMR,
    pub cbRgnData: DWORD,
    pub iMode: DWORD,
    pub RgnData: [BYTE; 1usize],
}
pub type EMREXTSELECTCLIPRGN = tagEMREXTSELECTCLIPRGN;
pub type PEMREXTSELECTCLIPRGN = *mut tagEMREXTSELECTCLIPRGN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXTTEXTOUTA {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub iGraphicsMode: DWORD,
    pub exScale: FLOAT,
    pub eyScale: FLOAT,
    pub emrtext: EMRTEXT,
}
pub type EMREXTTEXTOUTA = tagEMREXTTEXTOUTA;
pub type PEMREXTTEXTOUTA = *mut tagEMREXTTEXTOUTA;
pub type EMREXTTEXTOUTW = tagEMREXTTEXTOUTA;
pub type PEMREXTTEXTOUTW = *mut tagEMREXTTEXTOUTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPOLYTEXTOUTA {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub iGraphicsMode: DWORD,
    pub exScale: FLOAT,
    pub eyScale: FLOAT,
    pub cStrings: LONG,
    pub aemrtext: [EMRTEXT; 1usize],
}
pub type EMRPOLYTEXTOUTA = tagEMRPOLYTEXTOUTA;
pub type PEMRPOLYTEXTOUTA = *mut tagEMRPOLYTEXTOUTA;
pub type EMRPOLYTEXTOUTW = tagEMRPOLYTEXTOUTA;
pub type PEMRPOLYTEXTOUTW = *mut tagEMRPOLYTEXTOUTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRBITBLT {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub cxDest: LONG,
    pub cyDest: LONG,
    pub dwRop: DWORD,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub xformSrc: XFORM,
    pub crBkColorSrc: COLORREF,
    pub iUsageSrc: DWORD,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
}
pub type EMRBITBLT = tagEMRBITBLT;
pub type PEMRBITBLT = *mut tagEMRBITBLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSTRETCHBLT {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub cxDest: LONG,
    pub cyDest: LONG,
    pub dwRop: DWORD,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub xformSrc: XFORM,
    pub crBkColorSrc: COLORREF,
    pub iUsageSrc: DWORD,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub cxSrc: LONG,
    pub cySrc: LONG,
}
pub type EMRSTRETCHBLT = tagEMRSTRETCHBLT;
pub type PEMRSTRETCHBLT = *mut tagEMRSTRETCHBLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRMASKBLT {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub cxDest: LONG,
    pub cyDest: LONG,
    pub dwRop: DWORD,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub xformSrc: XFORM,
    pub crBkColorSrc: COLORREF,
    pub iUsageSrc: DWORD,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub xMask: LONG,
    pub yMask: LONG,
    pub iUsageMask: DWORD,
    pub offBmiMask: DWORD,
    pub cbBmiMask: DWORD,
    pub offBitsMask: DWORD,
    pub cbBitsMask: DWORD,
}
pub type EMRMASKBLT = tagEMRMASKBLT;
pub type PEMRMASKBLT = *mut tagEMRMASKBLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPLGBLT {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub aptlDest: [POINTL; 3usize],
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub cxSrc: LONG,
    pub cySrc: LONG,
    pub xformSrc: XFORM,
    pub crBkColorSrc: COLORREF,
    pub iUsageSrc: DWORD,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub xMask: LONG,
    pub yMask: LONG,
    pub iUsageMask: DWORD,
    pub offBmiMask: DWORD,
    pub cbBmiMask: DWORD,
    pub offBitsMask: DWORD,
    pub cbBitsMask: DWORD,
}
pub type EMRPLGBLT = tagEMRPLGBLT;
pub type PEMRPLGBLT = *mut tagEMRPLGBLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETDIBITSTODEVICE {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub cxSrc: LONG,
    pub cySrc: LONG,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub iUsageSrc: DWORD,
    pub iStartScan: DWORD,
    pub cScans: DWORD,
}
pub type EMRSETDIBITSTODEVICE = tagEMRSETDIBITSTODEVICE;
pub type PEMRSETDIBITSTODEVICE = *mut tagEMRSETDIBITSTODEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSTRETCHDIBITS {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub cxSrc: LONG,
    pub cySrc: LONG,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub iUsageSrc: DWORD,
    pub dwRop: DWORD,
    pub cxDest: LONG,
    pub cyDest: LONG,
}
pub type EMRSTRETCHDIBITS = tagEMRSTRETCHDIBITS;
pub type PEMRSTRETCHDIBITS = *mut tagEMRSTRETCHDIBITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXTCREATEFONTINDIRECTW {
    pub emr: EMR,
    pub ihFont: DWORD,
    pub elfw: EXTLOGFONTW,
}
pub type EMREXTCREATEFONTINDIRECTW = tagEMREXTCREATEFONTINDIRECTW;
pub type PEMREXTCREATEFONTINDIRECTW = *mut tagEMREXTCREATEFONTINDIRECTW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATEPALETTE {
    pub emr: EMR,
    pub ihPal: DWORD,
    pub lgpl: LOGPALETTE,
}
pub type EMRCREATEPALETTE = tagEMRCREATEPALETTE;
pub type PEMRCREATEPALETTE = *mut tagEMRCREATEPALETTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATEPEN {
    pub emr: EMR,
    pub ihPen: DWORD,
    pub lopn: LOGPEN,
}
pub type EMRCREATEPEN = tagEMRCREATEPEN;
pub type PEMRCREATEPEN = *mut tagEMRCREATEPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXTCREATEPEN {
    pub emr: EMR,
    pub ihPen: DWORD,
    pub offBmi: DWORD,
    pub cbBmi: DWORD,
    pub offBits: DWORD,
    pub cbBits: DWORD,
    pub elp: EXTLOGPEN32,
}
pub type EMREXTCREATEPEN = tagEMREXTCREATEPEN;
pub type PEMREXTCREATEPEN = *mut tagEMREXTCREATEPEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATEBRUSHINDIRECT {
    pub emr: EMR,
    pub ihBrush: DWORD,
    pub lb: LOGBRUSH32,
}
pub type EMRCREATEBRUSHINDIRECT = tagEMRCREATEBRUSHINDIRECT;
pub type PEMRCREATEBRUSHINDIRECT = *mut tagEMRCREATEBRUSHINDIRECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATEMONOBRUSH {
    pub emr: EMR,
    pub ihBrush: DWORD,
    pub iUsage: DWORD,
    pub offBmi: DWORD,
    pub cbBmi: DWORD,
    pub offBits: DWORD,
    pub cbBits: DWORD,
}
pub type EMRCREATEMONOBRUSH = tagEMRCREATEMONOBRUSH;
pub type PEMRCREATEMONOBRUSH = *mut tagEMRCREATEMONOBRUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATEDIBPATTERNBRUSHPT {
    pub emr: EMR,
    pub ihBrush: DWORD,
    pub iUsage: DWORD,
    pub offBmi: DWORD,
    pub cbBmi: DWORD,
    pub offBits: DWORD,
    pub cbBits: DWORD,
}
pub type EMRCREATEDIBPATTERNBRUSHPT = tagEMRCREATEDIBPATTERNBRUSHPT;
pub type PEMRCREATEDIBPATTERNBRUSHPT = *mut tagEMRCREATEDIBPATTERNBRUSHPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRFORMAT {
    pub dSignature: DWORD,
    pub nVersion: DWORD,
    pub cbData: DWORD,
    pub offData: DWORD,
}
pub type EMRFORMAT = tagEMRFORMAT;
pub type PEMRFORMAT = *mut tagEMRFORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRGLSRECORD {
    pub emr: EMR,
    pub cbData: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type EMRGLSRECORD = tagEMRGLSRECORD;
pub type PEMRGLSRECORD = *mut tagEMRGLSRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRGLSBOUNDEDRECORD {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub cbData: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type EMRGLSBOUNDEDRECORD = tagEMRGLSBOUNDEDRECORD;
pub type PEMRGLSBOUNDEDRECORD = *mut tagEMRGLSBOUNDEDRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRPIXELFORMAT {
    pub emr: EMR,
    pub pfd: PIXELFORMATDESCRIPTOR,
}
pub type EMRPIXELFORMAT = tagEMRPIXELFORMAT;
pub type PEMRPIXELFORMAT = *mut tagEMRPIXELFORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATECOLORSPACE {
    pub emr: EMR,
    pub ihCS: DWORD,
    pub lcs: LOGCOLORSPACEA,
}
pub type EMRCREATECOLORSPACE = tagEMRCREATECOLORSPACE;
pub type PEMRCREATECOLORSPACE = *mut tagEMRCREATECOLORSPACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETCOLORSPACE {
    pub emr: EMR,
    pub ihCS: DWORD,
}
pub type EMRSETCOLORSPACE = tagEMRSETCOLORSPACE;
pub type PEMRSETCOLORSPACE = *mut tagEMRSETCOLORSPACE;
pub type EMRSELECTCOLORSPACE = tagEMRSETCOLORSPACE;
pub type PEMRSELECTCOLORSPACE = *mut tagEMRSETCOLORSPACE;
pub type EMRDELETECOLORSPACE = tagEMRSETCOLORSPACE;
pub type PEMRDELETECOLORSPACE = *mut tagEMRSETCOLORSPACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMREXTESCAPE {
    pub emr: EMR,
    pub iEscape: INT,
    pub cbEscData: INT,
    pub EscData: [BYTE; 1usize],
}
pub type EMREXTESCAPE = tagEMREXTESCAPE;
pub type PEMREXTESCAPE = *mut tagEMREXTESCAPE;
pub type EMRDRAWESCAPE = tagEMREXTESCAPE;
pub type PEMRDRAWESCAPE = *mut tagEMREXTESCAPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRNAMEDESCAPE {
    pub emr: EMR,
    pub iEscape: INT,
    pub cbDriver: INT,
    pub cbEscData: INT,
    pub EscData: [BYTE; 1usize],
}
pub type EMRNAMEDESCAPE = tagEMRNAMEDESCAPE;
pub type PEMRNAMEDESCAPE = *mut tagEMRNAMEDESCAPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRSETICMPROFILE {
    pub emr: EMR,
    pub dwFlags: DWORD,
    pub cbName: DWORD,
    pub cbData: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type EMRSETICMPROFILE = tagEMRSETICMPROFILE;
pub type PEMRSETICMPROFILE = *mut tagEMRSETICMPROFILE;
pub type EMRSETICMPROFILEA = tagEMRSETICMPROFILE;
pub type PEMRSETICMPROFILEA = *mut tagEMRSETICMPROFILE;
pub type EMRSETICMPROFILEW = tagEMRSETICMPROFILE;
pub type PEMRSETICMPROFILEW = *mut tagEMRSETICMPROFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRCREATECOLORSPACEW {
    pub emr: EMR,
    pub ihCS: DWORD,
    pub lcs: LOGCOLORSPACEW,
    pub dwFlags: DWORD,
    pub cbData: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type EMRCREATECOLORSPACEW = tagEMRCREATECOLORSPACEW;
pub type PEMRCREATECOLORSPACEW = *mut tagEMRCREATECOLORSPACEW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOLORMATCHTOTARGET {
    pub emr: EMR,
    pub dwAction: DWORD,
    pub dwFlags: DWORD,
    pub cbName: DWORD,
    pub cbData: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type EMRCOLORMATCHTOTARGET = tagCOLORMATCHTOTARGET;
pub type PEMRCOLORMATCHTOTARGET = *mut tagCOLORMATCHTOTARGET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOLORCORRECTPALETTE {
    pub emr: EMR,
    pub ihPalette: DWORD,
    pub nFirstEntry: DWORD,
    pub nPalEntries: DWORD,
    pub nReserved: DWORD,
}
pub type EMRCOLORCORRECTPALETTE = tagCOLORCORRECTPALETTE;
pub type PEMRCOLORCORRECTPALETTE = *mut tagCOLORCORRECTPALETTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRALPHABLEND {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub cxDest: LONG,
    pub cyDest: LONG,
    pub dwRop: DWORD,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub xformSrc: XFORM,
    pub crBkColorSrc: COLORREF,
    pub iUsageSrc: DWORD,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub cxSrc: LONG,
    pub cySrc: LONG,
}
pub type EMRALPHABLEND = tagEMRALPHABLEND;
pub type PEMRALPHABLEND = *mut tagEMRALPHABLEND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRGRADIENTFILL {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub nVer: DWORD,
    pub nTri: DWORD,
    pub ulMode: ULONG,
    pub Ver: [TRIVERTEX; 1usize],
}
pub type EMRGRADIENTFILL = tagEMRGRADIENTFILL;
pub type PEMRGRADIENTFILL = *mut tagEMRGRADIENTFILL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEMRTRANSPARENTBLT {
    pub emr: EMR,
    pub rclBounds: RECTL,
    pub xDest: LONG,
    pub yDest: LONG,
    pub cxDest: LONG,
    pub cyDest: LONG,
    pub dwRop: DWORD,
    pub xSrc: LONG,
    pub ySrc: LONG,
    pub xformSrc: XFORM,
    pub crBkColorSrc: COLORREF,
    pub iUsageSrc: DWORD,
    pub offBmiSrc: DWORD,
    pub cbBmiSrc: DWORD,
    pub offBitsSrc: DWORD,
    pub cbBitsSrc: DWORD,
    pub cxSrc: LONG,
    pub cySrc: LONG,
}
pub type EMRTRANSPARENTBLT = tagEMRTRANSPARENTBLT;
pub type PEMRTRANSPARENTBLT = *mut tagEMRTRANSPARENTBLT;
extern "C" {
    pub fn wglCopyContext(arg1: HGLRC, arg2: HGLRC, arg3: UINT) -> BOOL;
}
extern "C" {
    pub fn wglCreateContext(arg1: HDC) -> HGLRC;
}
extern "C" {
    pub fn wglCreateLayerContext(arg1: HDC, arg2: ::std::os::raw::c_int) -> HGLRC;
}
extern "C" {
    pub fn wglDeleteContext(arg1: HGLRC) -> BOOL;
}
extern "C" {
    pub fn wglGetCurrentContext() -> HGLRC;
}
extern "C" {
    pub fn wglGetCurrentDC() -> HDC;
}
extern "C" {
    pub fn wglGetProcAddress(arg1: LPCSTR) -> PROC;
}
extern "C" {
    pub fn wglMakeCurrent(arg1: HDC, arg2: HGLRC) -> BOOL;
}
extern "C" {
    pub fn wglShareLists(arg1: HGLRC, arg2: HGLRC) -> BOOL;
}
extern "C" {
    pub fn wglUseFontBitmapsA(arg1: HDC, arg2: DWORD, arg3: DWORD, arg4: DWORD) -> BOOL;
}
extern "C" {
    pub fn wglUseFontBitmapsW(arg1: HDC, arg2: DWORD, arg3: DWORD, arg4: DWORD) -> BOOL;
}
extern "C" {
    pub fn SwapBuffers(arg1: HDC) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POINTFLOAT {
    pub x: FLOAT,
    pub y: FLOAT,
}
pub type POINTFLOAT = _POINTFLOAT;
pub type PPOINTFLOAT = *mut _POINTFLOAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLYPHMETRICSFLOAT {
    pub gmfBlackBoxX: FLOAT,
    pub gmfBlackBoxY: FLOAT,
    pub gmfptGlyphOrigin: POINTFLOAT,
    pub gmfCellIncX: FLOAT,
    pub gmfCellIncY: FLOAT,
}
pub type GLYPHMETRICSFLOAT = _GLYPHMETRICSFLOAT;
pub type PGLYPHMETRICSFLOAT = *mut _GLYPHMETRICSFLOAT;
pub type LPGLYPHMETRICSFLOAT = *mut _GLYPHMETRICSFLOAT;
extern "C" {
    pub fn wglUseFontOutlinesA(
        arg1: HDC,
        arg2: DWORD,
        arg3: DWORD,
        arg4: DWORD,
        arg5: FLOAT,
        arg6: FLOAT,
        arg7: ::std::os::raw::c_int,
        arg8: LPGLYPHMETRICSFLOAT,
    ) -> BOOL;
}
extern "C" {
    pub fn wglUseFontOutlinesW(
        arg1: HDC,
        arg2: DWORD,
        arg3: DWORD,
        arg4: DWORD,
        arg5: FLOAT,
        arg6: FLOAT,
        arg7: ::std::os::raw::c_int,
        arg8: LPGLYPHMETRICSFLOAT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLAYERPLANEDESCRIPTOR {
    pub nSize: WORD,
    pub nVersion: WORD,
    pub dwFlags: DWORD,
    pub iPixelType: BYTE,
    pub cColorBits: BYTE,
    pub cRedBits: BYTE,
    pub cRedShift: BYTE,
    pub cGreenBits: BYTE,
    pub cGreenShift: BYTE,
    pub cBlueBits: BYTE,
    pub cBlueShift: BYTE,
    pub cAlphaBits: BYTE,
    pub cAlphaShift: BYTE,
    pub cAccumBits: BYTE,
    pub cAccumRedBits: BYTE,
    pub cAccumGreenBits: BYTE,
    pub cAccumBlueBits: BYTE,
    pub cAccumAlphaBits: BYTE,
    pub cDepthBits: BYTE,
    pub cStencilBits: BYTE,
    pub cAuxBuffers: BYTE,
    pub iLayerPlane: BYTE,
    pub bReserved: BYTE,
    pub crTransparent: COLORREF,
}
pub type LAYERPLANEDESCRIPTOR = tagLAYERPLANEDESCRIPTOR;
pub type PLAYERPLANEDESCRIPTOR = *mut tagLAYERPLANEDESCRIPTOR;
pub type LPLAYERPLANEDESCRIPTOR = *mut tagLAYERPLANEDESCRIPTOR;
extern "C" {
    pub fn wglDescribeLayerPlane(
        arg1: HDC,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: UINT,
        arg5: LPLAYERPLANEDESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn wglSetLayerPaletteEntries(
        arg1: HDC,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *const COLORREF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wglGetLayerPaletteEntries(
        arg1: HDC,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut COLORREF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wglRealizeLayerPalette(arg1: HDC, arg2: ::std::os::raw::c_int, arg3: BOOL) -> BOOL;
}
extern "C" {
    pub fn wglSwapLayerBuffers(arg1: HDC, arg2: UINT) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WGLSWAP {
    pub hdc: HDC,
    pub uiFlags: UINT,
}
pub type WGLSWAP = _WGLSWAP;
pub type PWGLSWAP = *mut _WGLSWAP;
pub type LPWGLSWAP = *mut _WGLSWAP;
extern "C" {
    pub fn wglSwapMultipleBuffers(arg1: UINT, arg2: *const WGLSWAP) -> DWORD;
}
pub type HDWP = HANDLE;
pub type MENUTEMPLATEA = ::std::os::raw::c_void;
pub type MENUTEMPLATEW = ::std::os::raw::c_void;
pub type MENUTEMPLATE = MENUTEMPLATEA;
pub type LPMENUTEMPLATEA = PVOID;
pub type LPMENUTEMPLATEW = PVOID;
pub type LPMENUTEMPLATE = LPMENUTEMPLATEA;
pub type WNDPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> LRESULT,
>;
pub type DLGPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> INT_PTR,
>;
pub type TIMERPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: UINT_PTR, arg4: DWORD),
>;
pub type GRAYSTRINGPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HDC, arg2: LPARAM, arg3: ::std::os::raw::c_int) -> BOOL,
>;
pub type WNDENUMPROC =
    ::std::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: LPARAM) -> BOOL>;
pub type HOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(code: ::std::os::raw::c_int, wParam: WPARAM, lParam: LPARAM) -> LRESULT,
>;
pub type SENDASYNCPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: ULONG_PTR, arg4: LRESULT),
>;
pub type PROPENUMPROCA =
    ::std::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: LPCSTR, arg3: HANDLE) -> BOOL>;
pub type PROPENUMPROCW =
    ::std::option::Option<unsafe extern "C" fn(arg1: HWND, arg2: LPCWSTR, arg3: HANDLE) -> BOOL>;
pub type PROPENUMPROCEXA = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: LPSTR, arg3: HANDLE, arg4: ULONG_PTR) -> BOOL,
>;
pub type PROPENUMPROCEXW = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: LPWSTR, arg3: HANDLE, arg4: ULONG_PTR) -> BOOL,
>;
pub type EDITWORDBREAKPROCA = ::std::option::Option<
    unsafe extern "C" fn(
        lpch: LPSTR,
        ichCurrent: ::std::os::raw::c_int,
        cch: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type EDITWORDBREAKPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        lpch: LPWSTR,
        ichCurrent: ::std::os::raw::c_int,
        cch: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type DRAWSTATEPROC = ::std::option::Option<
    unsafe extern "C" fn(
        hdc: HDC,
        lData: LPARAM,
        wData: WPARAM,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
    ) -> BOOL,
>;
pub type PROPENUMPROC = PROPENUMPROCA;
pub type PROPENUMPROCEX = PROPENUMPROCEXA;
pub type EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
pub type NAMEENUMPROCA =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: LPARAM) -> BOOL>;
pub type NAMEENUMPROCW =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LPARAM) -> BOOL>;
pub type WINSTAENUMPROCA = NAMEENUMPROCA;
pub type DESKTOPENUMPROCA = NAMEENUMPROCA;
pub type WINSTAENUMPROCW = NAMEENUMPROCW;
pub type DESKTOPENUMPROCW = NAMEENUMPROCW;
pub type WINSTAENUMPROC = WINSTAENUMPROCA;
pub type DESKTOPENUMPROC = DESKTOPENUMPROCA;
extern "C" {
    pub fn wvsprintfA(arg1: LPSTR, arg2: LPCSTR, arglist: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wvsprintfW(arg1: LPWSTR, arg2: LPCWSTR, arglist: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wsprintfA(arg1: LPSTR, arg2: LPCSTR, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wsprintfW(arg1: LPWSTR, arg2: LPCWSTR, ...) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCBT_CREATEWNDA {
    pub lpcs: *mut tagCREATESTRUCTA,
    pub hwndInsertAfter: HWND,
}
pub type CBT_CREATEWNDA = tagCBT_CREATEWNDA;
pub type LPCBT_CREATEWNDA = *mut tagCBT_CREATEWNDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCBT_CREATEWNDW {
    pub lpcs: *mut tagCREATESTRUCTW,
    pub hwndInsertAfter: HWND,
}
pub type CBT_CREATEWNDW = tagCBT_CREATEWNDW;
pub type LPCBT_CREATEWNDW = *mut tagCBT_CREATEWNDW;
pub type CBT_CREATEWND = CBT_CREATEWNDA;
pub type LPCBT_CREATEWND = LPCBT_CREATEWNDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCBTACTIVATESTRUCT {
    pub fMouse: BOOL,
    pub hWndActive: HWND,
}
pub type CBTACTIVATESTRUCT = tagCBTACTIVATESTRUCT;
pub type LPCBTACTIVATESTRUCT = *mut tagCBTACTIVATESTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWTSSESSION_NOTIFICATION {
    pub cbSize: DWORD,
    pub dwSessionId: DWORD,
}
pub type WTSSESSION_NOTIFICATION = tagWTSSESSION_NOTIFICATION;
pub type PWTSSESSION_NOTIFICATION = *mut tagWTSSESSION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHELLHOOKINFO {
    pub hwnd: HWND,
    pub rc: RECT,
}
pub type LPSHELLHOOKINFO = *mut SHELLHOOKINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEVENTMSG {
    pub message: UINT,
    pub paramL: UINT,
    pub paramH: UINT,
    pub time: DWORD,
    pub hwnd: HWND,
}
pub type EVENTMSG = tagEVENTMSG;
pub type PEVENTMSGMSG = *mut tagEVENTMSG;
pub type NPEVENTMSGMSG = *mut tagEVENTMSG;
pub type LPEVENTMSGMSG = *mut tagEVENTMSG;
pub type PEVENTMSG = *mut tagEVENTMSG;
pub type NPEVENTMSG = *mut tagEVENTMSG;
pub type LPEVENTMSG = *mut tagEVENTMSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCWPSTRUCT {
    pub lParam: LPARAM,
    pub wParam: WPARAM,
    pub message: UINT,
    pub hwnd: HWND,
}
pub type CWPSTRUCT = tagCWPSTRUCT;
pub type PCWPSTRUCT = *mut tagCWPSTRUCT;
pub type NPCWPSTRUCT = *mut tagCWPSTRUCT;
pub type LPCWPSTRUCT = *mut tagCWPSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCWPRETSTRUCT {
    pub lResult: LRESULT,
    pub lParam: LPARAM,
    pub wParam: WPARAM,
    pub message: UINT,
    pub hwnd: HWND,
}
pub type CWPRETSTRUCT = tagCWPRETSTRUCT;
pub type PCWPRETSTRUCT = *mut tagCWPRETSTRUCT;
pub type NPCWPRETSTRUCT = *mut tagCWPRETSTRUCT;
pub type LPCWPRETSTRUCT = *mut tagCWPRETSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagKBDLLHOOKSTRUCT {
    pub vkCode: DWORD,
    pub scanCode: DWORD,
    pub flags: DWORD,
    pub time: DWORD,
    pub dwExtraInfo: ULONG_PTR,
}
pub type KBDLLHOOKSTRUCT = tagKBDLLHOOKSTRUCT;
pub type LPKBDLLHOOKSTRUCT = *mut tagKBDLLHOOKSTRUCT;
pub type PKBDLLHOOKSTRUCT = *mut tagKBDLLHOOKSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMSLLHOOKSTRUCT {
    pub pt: POINT,
    pub mouseData: DWORD,
    pub flags: DWORD,
    pub time: DWORD,
    pub dwExtraInfo: ULONG_PTR,
}
pub type MSLLHOOKSTRUCT = tagMSLLHOOKSTRUCT;
pub type LPMSLLHOOKSTRUCT = *mut tagMSLLHOOKSTRUCT;
pub type PMSLLHOOKSTRUCT = *mut tagMSLLHOOKSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEBUGHOOKINFO {
    pub idThread: DWORD,
    pub idThreadInstaller: DWORD,
    pub lParam: LPARAM,
    pub wParam: WPARAM,
    pub code: ::std::os::raw::c_int,
}
pub type DEBUGHOOKINFO = tagDEBUGHOOKINFO;
pub type PDEBUGHOOKINFO = *mut tagDEBUGHOOKINFO;
pub type NPDEBUGHOOKINFO = *mut tagDEBUGHOOKINFO;
pub type LPDEBUGHOOKINFO = *mut tagDEBUGHOOKINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMOUSEHOOKSTRUCT {
    pub pt: POINT,
    pub hwnd: HWND,
    pub wHitTestCode: UINT,
    pub dwExtraInfo: ULONG_PTR,
}
pub type MOUSEHOOKSTRUCT = tagMOUSEHOOKSTRUCT;
pub type LPMOUSEHOOKSTRUCT = *mut tagMOUSEHOOKSTRUCT;
pub type PMOUSEHOOKSTRUCT = *mut tagMOUSEHOOKSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMOUSEHOOKSTRUCTEX {
    pub _base: tagMOUSEHOOKSTRUCT,
    pub mouseData: DWORD,
}
pub type MOUSEHOOKSTRUCTEX = tagMOUSEHOOKSTRUCTEX;
pub type LPMOUSEHOOKSTRUCTEX = *mut tagMOUSEHOOKSTRUCTEX;
pub type PMOUSEHOOKSTRUCTEX = *mut tagMOUSEHOOKSTRUCTEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHARDWAREHOOKSTRUCT {
    pub hwnd: HWND,
    pub message: UINT,
    pub wParam: WPARAM,
    pub lParam: LPARAM,
}
pub type HARDWAREHOOKSTRUCT = tagHARDWAREHOOKSTRUCT;
pub type LPHARDWAREHOOKSTRUCT = *mut tagHARDWAREHOOKSTRUCT;
pub type PHARDWAREHOOKSTRUCT = *mut tagHARDWAREHOOKSTRUCT;
extern "C" {
    pub fn LoadKeyboardLayoutA(pwszKLID: LPCSTR, Flags: UINT) -> HKL;
}
extern "C" {
    pub fn LoadKeyboardLayoutW(pwszKLID: LPCWSTR, Flags: UINT) -> HKL;
}
extern "C" {
    pub fn ActivateKeyboardLayout(hkl: HKL, Flags: UINT) -> HKL;
}
extern "C" {
    pub fn ToUnicodeEx(
        wVirtKey: UINT,
        wScanCode: UINT,
        lpKeyState: *const BYTE,
        pwszBuff: LPWSTR,
        cchBuff: ::std::os::raw::c_int,
        wFlags: UINT,
        dwhkl: HKL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UnloadKeyboardLayout(hkl: HKL) -> BOOL;
}
extern "C" {
    pub fn GetKeyboardLayoutNameA(pwszKLID: LPSTR) -> BOOL;
}
extern "C" {
    pub fn GetKeyboardLayoutNameW(pwszKLID: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn GetKeyboardLayoutList(
        nBuff: ::std::os::raw::c_int,
        lpList: *mut HKL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetKeyboardLayout(idThread: DWORD) -> HKL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMOUSEMOVEPOINT {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub time: DWORD,
    pub dwExtraInfo: ULONG_PTR,
}
pub type MOUSEMOVEPOINT = tagMOUSEMOVEPOINT;
pub type PMOUSEMOVEPOINT = *mut tagMOUSEMOVEPOINT;
pub type LPMOUSEMOVEPOINT = *mut tagMOUSEMOVEPOINT;
extern "C" {
    pub fn GetMouseMovePointsEx(
        cbSize: UINT,
        lppt: LPMOUSEMOVEPOINT,
        lpptBuf: LPMOUSEMOVEPOINT,
        nBufPoints: ::std::os::raw::c_int,
        resolution: DWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CreateDesktopA(
        lpszDesktop: LPCSTR,
        lpszDevice: LPCSTR,
        pDevmode: *mut DEVMODEA,
        dwFlags: DWORD,
        dwDesiredAccess: ACCESS_MASK,
        lpsa: LPSECURITY_ATTRIBUTES,
    ) -> HDESK;
}
extern "C" {
    pub fn CreateDesktopW(
        lpszDesktop: LPCWSTR,
        lpszDevice: LPCWSTR,
        pDevmode: *mut DEVMODEW,
        dwFlags: DWORD,
        dwDesiredAccess: ACCESS_MASK,
        lpsa: LPSECURITY_ATTRIBUTES,
    ) -> HDESK;
}
extern "C" {
    pub fn CreateDesktopExA(
        lpszDesktop: LPCSTR,
        lpszDevice: LPCSTR,
        pDevmode: *mut DEVMODEA,
        dwFlags: DWORD,
        dwDesiredAccess: ACCESS_MASK,
        lpsa: LPSECURITY_ATTRIBUTES,
        ulHeapSize: ULONG,
        pvoid: PVOID,
    ) -> HDESK;
}
extern "C" {
    pub fn CreateDesktopExW(
        lpszDesktop: LPCWSTR,
        lpszDevice: LPCWSTR,
        pDevmode: *mut DEVMODEW,
        dwFlags: DWORD,
        dwDesiredAccess: ACCESS_MASK,
        lpsa: LPSECURITY_ATTRIBUTES,
        ulHeapSize: ULONG,
        pvoid: PVOID,
    ) -> HDESK;
}
extern "C" {
    pub fn OpenDesktopA(
        lpszDesktop: LPCSTR,
        dwFlags: DWORD,
        fInherit: BOOL,
        dwDesiredAccess: ACCESS_MASK,
    ) -> HDESK;
}
extern "C" {
    pub fn OpenDesktopW(
        lpszDesktop: LPCWSTR,
        dwFlags: DWORD,
        fInherit: BOOL,
        dwDesiredAccess: ACCESS_MASK,
    ) -> HDESK;
}
extern "C" {
    pub fn OpenInputDesktop(dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) -> HDESK;
}
extern "C" {
    pub fn EnumDesktopsA(hwinsta: HWINSTA, lpEnumFunc: DESKTOPENUMPROCA, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn EnumDesktopsW(hwinsta: HWINSTA, lpEnumFunc: DESKTOPENUMPROCW, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn EnumDesktopWindows(hDesktop: HDESK, lpfn: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn SwitchDesktop(hDesktop: HDESK) -> BOOL;
}
extern "C" {
    pub fn SetThreadDesktop(hDesktop: HDESK) -> BOOL;
}
extern "C" {
    pub fn CloseDesktop(hDesktop: HDESK) -> BOOL;
}
extern "C" {
    pub fn GetThreadDesktop(dwThreadId: DWORD) -> HDESK;
}
extern "C" {
    pub fn CreateWindowStationA(
        lpwinsta: LPCSTR,
        dwFlags: DWORD,
        dwDesiredAccess: ACCESS_MASK,
        lpsa: LPSECURITY_ATTRIBUTES,
    ) -> HWINSTA;
}
extern "C" {
    pub fn CreateWindowStationW(
        lpwinsta: LPCWSTR,
        dwFlags: DWORD,
        dwDesiredAccess: ACCESS_MASK,
        lpsa: LPSECURITY_ATTRIBUTES,
    ) -> HWINSTA;
}
extern "C" {
    pub fn OpenWindowStationA(
        lpszWinSta: LPCSTR,
        fInherit: BOOL,
        dwDesiredAccess: ACCESS_MASK,
    ) -> HWINSTA;
}
extern "C" {
    pub fn OpenWindowStationW(
        lpszWinSta: LPCWSTR,
        fInherit: BOOL,
        dwDesiredAccess: ACCESS_MASK,
    ) -> HWINSTA;
}
extern "C" {
    pub fn EnumWindowStationsA(lpEnumFunc: WINSTAENUMPROCA, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn EnumWindowStationsW(lpEnumFunc: WINSTAENUMPROCW, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn CloseWindowStation(hWinSta: HWINSTA) -> BOOL;
}
extern "C" {
    pub fn SetProcessWindowStation(hWinSta: HWINSTA) -> BOOL;
}
extern "C" {
    pub fn GetProcessWindowStation() -> HWINSTA;
}
extern "C" {
    pub fn SetUserObjectSecurity(
        hObj: HANDLE,
        pSIRequested: PSECURITY_INFORMATION,
        pSID: PSECURITY_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUserObjectSecurity(
        hObj: HANDLE,
        pSIRequested: PSECURITY_INFORMATION,
        pSID: PSECURITY_DESCRIPTOR,
        nLength: DWORD,
        lpnLengthNeeded: LPDWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUSEROBJECTFLAGS {
    pub fInherit: BOOL,
    pub fReserved: BOOL,
    pub dwFlags: DWORD,
}
pub type USEROBJECTFLAGS = tagUSEROBJECTFLAGS;
pub type PUSEROBJECTFLAGS = *mut tagUSEROBJECTFLAGS;
extern "C" {
    pub fn GetUserObjectInformationA(
        hObj: HANDLE,
        nIndex: ::std::os::raw::c_int,
        pvInfo: PVOID,
        nLength: DWORD,
        lpnLengthNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUserObjectInformationW(
        hObj: HANDLE,
        nIndex: ::std::os::raw::c_int,
        pvInfo: PVOID,
        nLength: DWORD,
        lpnLengthNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetUserObjectInformationA(
        hObj: HANDLE,
        nIndex: ::std::os::raw::c_int,
        pvInfo: PVOID,
        nLength: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetUserObjectInformationW(
        hObj: HANDLE,
        nIndex: ::std::os::raw::c_int,
        pvInfo: PVOID,
        nLength: DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWNDCLASSEXA {
    pub cbSize: UINT,
    pub style: UINT,
    pub lpfnWndProc: WNDPROC,
    pub cbClsExtra: ::std::os::raw::c_int,
    pub cbWndExtra: ::std::os::raw::c_int,
    pub hInstance: HINSTANCE,
    pub hIcon: HICON,
    pub hCursor: HCURSOR,
    pub hbrBackground: HBRUSH,
    pub lpszMenuName: LPCSTR,
    pub lpszClassName: LPCSTR,
    pub hIconSm: HICON,
}
pub type WNDCLASSEXA = tagWNDCLASSEXA;
pub type PWNDCLASSEXA = *mut tagWNDCLASSEXA;
pub type NPWNDCLASSEXA = *mut tagWNDCLASSEXA;
pub type LPWNDCLASSEXA = *mut tagWNDCLASSEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWNDCLASSEXW {
    pub cbSize: UINT,
    pub style: UINT,
    pub lpfnWndProc: WNDPROC,
    pub cbClsExtra: ::std::os::raw::c_int,
    pub cbWndExtra: ::std::os::raw::c_int,
    pub hInstance: HINSTANCE,
    pub hIcon: HICON,
    pub hCursor: HCURSOR,
    pub hbrBackground: HBRUSH,
    pub lpszMenuName: LPCWSTR,
    pub lpszClassName: LPCWSTR,
    pub hIconSm: HICON,
}
pub type WNDCLASSEXW = tagWNDCLASSEXW;
pub type PWNDCLASSEXW = *mut tagWNDCLASSEXW;
pub type NPWNDCLASSEXW = *mut tagWNDCLASSEXW;
pub type LPWNDCLASSEXW = *mut tagWNDCLASSEXW;
pub type WNDCLASSEX = WNDCLASSEXA;
pub type PWNDCLASSEX = PWNDCLASSEXA;
pub type NPWNDCLASSEX = NPWNDCLASSEXA;
pub type LPWNDCLASSEX = LPWNDCLASSEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWNDCLASSA {
    pub style: UINT,
    pub lpfnWndProc: WNDPROC,
    pub cbClsExtra: ::std::os::raw::c_int,
    pub cbWndExtra: ::std::os::raw::c_int,
    pub hInstance: HINSTANCE,
    pub hIcon: HICON,
    pub hCursor: HCURSOR,
    pub hbrBackground: HBRUSH,
    pub lpszMenuName: LPCSTR,
    pub lpszClassName: LPCSTR,
}
pub type WNDCLASSA = tagWNDCLASSA;
pub type PWNDCLASSA = *mut tagWNDCLASSA;
pub type NPWNDCLASSA = *mut tagWNDCLASSA;
pub type LPWNDCLASSA = *mut tagWNDCLASSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWNDCLASSW {
    pub style: UINT,
    pub lpfnWndProc: WNDPROC,
    pub cbClsExtra: ::std::os::raw::c_int,
    pub cbWndExtra: ::std::os::raw::c_int,
    pub hInstance: HINSTANCE,
    pub hIcon: HICON,
    pub hCursor: HCURSOR,
    pub hbrBackground: HBRUSH,
    pub lpszMenuName: LPCWSTR,
    pub lpszClassName: LPCWSTR,
}
pub type WNDCLASSW = tagWNDCLASSW;
pub type PWNDCLASSW = *mut tagWNDCLASSW;
pub type NPWNDCLASSW = *mut tagWNDCLASSW;
pub type LPWNDCLASSW = *mut tagWNDCLASSW;
pub type WNDCLASS = WNDCLASSA;
pub type PWNDCLASS = PWNDCLASSA;
pub type NPWNDCLASS = NPWNDCLASSA;
pub type LPWNDCLASS = LPWNDCLASSA;
extern "C" {
    pub fn IsHungAppWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn DisableProcessWindowsGhosting();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMSG {
    pub hwnd: HWND,
    pub message: UINT,
    pub wParam: WPARAM,
    pub lParam: LPARAM,
    pub time: DWORD,
    pub pt: POINT,
}
pub type MSG = tagMSG;
pub type PMSG = *mut tagMSG;
pub type NPMSG = *mut tagMSG;
pub type LPMSG = *mut tagMSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMINMAXINFO {
    pub ptReserved: POINT,
    pub ptMaxSize: POINT,
    pub ptMaxPosition: POINT,
    pub ptMinTrackSize: POINT,
    pub ptMaxTrackSize: POINT,
}
pub type MINMAXINFO = tagMINMAXINFO;
pub type PMINMAXINFO = *mut tagMINMAXINFO;
pub type LPMINMAXINFO = *mut tagMINMAXINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOPYDATASTRUCT {
    pub dwData: ULONG_PTR,
    pub cbData: DWORD,
    pub lpData: PVOID,
}
pub type COPYDATASTRUCT = tagCOPYDATASTRUCT;
pub type PCOPYDATASTRUCT = *mut tagCOPYDATASTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMDINEXTMENU {
    pub hmenuIn: HMENU,
    pub hmenuNext: HMENU,
    pub hwndNext: HWND,
}
pub type MDINEXTMENU = tagMDINEXTMENU;
pub type PMDINEXTMENU = *mut tagMDINEXTMENU;
pub type LPMDINEXTMENU = *mut tagMDINEXTMENU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWERBROADCAST_SETTING {
    pub PowerSetting: GUID,
    pub DataLength: DWORD,
    pub Data: [UCHAR; 1usize],
}
pub type PPOWERBROADCAST_SETTING = *mut POWERBROADCAST_SETTING;
extern "C" {
    pub fn RegisterWindowMessageA(lpString: LPCSTR) -> UINT;
}
extern "C" {
    pub fn RegisterWindowMessageW(lpString: LPCWSTR) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWINDOWPOS {
    pub hwnd: HWND,
    pub hwndInsertAfter: HWND,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
    pub flags: UINT,
}
pub type WINDOWPOS = tagWINDOWPOS;
pub type LPWINDOWPOS = *mut tagWINDOWPOS;
pub type PWINDOWPOS = *mut tagWINDOWPOS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNCCALCSIZE_PARAMS {
    pub rgrc: [RECT; 3usize],
    pub lppos: PWINDOWPOS,
}
pub type NCCALCSIZE_PARAMS = tagNCCALCSIZE_PARAMS;
pub type LPNCCALCSIZE_PARAMS = *mut tagNCCALCSIZE_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTRACKMOUSEEVENT {
    pub cbSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndTrack: HWND,
    pub dwHoverTime: DWORD,
}
pub type TRACKMOUSEEVENT = tagTRACKMOUSEEVENT;
pub type LPTRACKMOUSEEVENT = *mut tagTRACKMOUSEEVENT;
extern "C" {
    pub fn TrackMouseEvent(lpEventTrack: LPTRACKMOUSEEVENT) -> BOOL;
}
extern "C" {
    pub fn DrawEdge(hdc: HDC, qrc: LPRECT, edge: UINT, grfFlags: UINT) -> BOOL;
}
extern "C" {
    pub fn DrawFrameControl(arg1: HDC, arg2: LPRECT, arg3: UINT, arg4: UINT) -> BOOL;
}
extern "C" {
    pub fn DrawCaption(hwnd: HWND, hdc: HDC, lprect: *const RECT, flags: UINT) -> BOOL;
}
extern "C" {
    pub fn DrawAnimatedRects(
        hwnd: HWND,
        idAni: ::std::os::raw::c_int,
        lprcFrom: *const RECT,
        lprcTo: *const RECT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACCEL {
    pub fVirt: BYTE,
    pub key: WORD,
    pub cmd: WORD,
}
pub type ACCEL = tagACCEL;
pub type LPACCEL = *mut tagACCEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPAINTSTRUCT {
    pub hdc: HDC,
    pub fErase: BOOL,
    pub rcPaint: RECT,
    pub fRestore: BOOL,
    pub fIncUpdate: BOOL,
    pub rgbReserved: [BYTE; 32usize],
}
pub type PAINTSTRUCT = tagPAINTSTRUCT;
pub type PPAINTSTRUCT = *mut tagPAINTSTRUCT;
pub type NPPAINTSTRUCT = *mut tagPAINTSTRUCT;
pub type LPPAINTSTRUCT = *mut tagPAINTSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCREATESTRUCTA {
    pub lpCreateParams: LPVOID,
    pub hInstance: HINSTANCE,
    pub hMenu: HMENU,
    pub hwndParent: HWND,
    pub cy: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub style: LONG,
    pub lpszName: LPCSTR,
    pub lpszClass: LPCSTR,
    pub dwExStyle: DWORD,
}
pub type CREATESTRUCTA = tagCREATESTRUCTA;
pub type LPCREATESTRUCTA = *mut tagCREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCREATESTRUCTW {
    pub lpCreateParams: LPVOID,
    pub hInstance: HINSTANCE,
    pub hMenu: HMENU,
    pub hwndParent: HWND,
    pub cy: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub style: LONG,
    pub lpszName: LPCWSTR,
    pub lpszClass: LPCWSTR,
    pub dwExStyle: DWORD,
}
pub type CREATESTRUCTW = tagCREATESTRUCTW;
pub type LPCREATESTRUCTW = *mut tagCREATESTRUCTW;
pub type CREATESTRUCT = CREATESTRUCTA;
pub type LPCREATESTRUCT = LPCREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWINDOWPLACEMENT {
    pub length: UINT,
    pub flags: UINT,
    pub showCmd: UINT,
    pub ptMinPosition: POINT,
    pub ptMaxPosition: POINT,
    pub rcNormalPosition: RECT,
}
pub type WINDOWPLACEMENT = tagWINDOWPLACEMENT;
pub type PWINDOWPLACEMENT = *mut WINDOWPLACEMENT;
pub type LPWINDOWPLACEMENT = *mut WINDOWPLACEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNMHDR {
    pub hwndFrom: HWND,
    pub idFrom: UINT_PTR,
    pub code: UINT,
}
pub type NMHDR = tagNMHDR;
pub type LPNMHDR = *mut NMHDR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLESTRUCT {
    pub styleOld: DWORD,
    pub styleNew: DWORD,
}
pub type STYLESTRUCT = tagSTYLESTRUCT;
pub type LPSTYLESTRUCT = *mut tagSTYLESTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMEASUREITEMSTRUCT {
    pub CtlType: UINT,
    pub CtlID: UINT,
    pub itemID: UINT,
    pub itemWidth: UINT,
    pub itemHeight: UINT,
    pub itemData: ULONG_PTR,
}
pub type MEASUREITEMSTRUCT = tagMEASUREITEMSTRUCT;
pub type PMEASUREITEMSTRUCT = *mut tagMEASUREITEMSTRUCT;
pub type LPMEASUREITEMSTRUCT = *mut tagMEASUREITEMSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDRAWITEMSTRUCT {
    pub CtlType: UINT,
    pub CtlID: UINT,
    pub itemID: UINT,
    pub itemAction: UINT,
    pub itemState: UINT,
    pub hwndItem: HWND,
    pub hDC: HDC,
    pub rcItem: RECT,
    pub itemData: ULONG_PTR,
}
pub type DRAWITEMSTRUCT = tagDRAWITEMSTRUCT;
pub type PDRAWITEMSTRUCT = *mut tagDRAWITEMSTRUCT;
pub type LPDRAWITEMSTRUCT = *mut tagDRAWITEMSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDELETEITEMSTRUCT {
    pub CtlType: UINT,
    pub CtlID: UINT,
    pub itemID: UINT,
    pub hwndItem: HWND,
    pub itemData: ULONG_PTR,
}
pub type DELETEITEMSTRUCT = tagDELETEITEMSTRUCT;
pub type PDELETEITEMSTRUCT = *mut tagDELETEITEMSTRUCT;
pub type LPDELETEITEMSTRUCT = *mut tagDELETEITEMSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOMPAREITEMSTRUCT {
    pub CtlType: UINT,
    pub CtlID: UINT,
    pub hwndItem: HWND,
    pub itemID1: UINT,
    pub itemData1: ULONG_PTR,
    pub itemID2: UINT,
    pub itemData2: ULONG_PTR,
    pub dwLocaleId: DWORD,
}
pub type COMPAREITEMSTRUCT = tagCOMPAREITEMSTRUCT;
pub type PCOMPAREITEMSTRUCT = *mut tagCOMPAREITEMSTRUCT;
pub type LPCOMPAREITEMSTRUCT = *mut tagCOMPAREITEMSTRUCT;
extern "C" {
    pub fn GetMessageA(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT) -> BOOL;
}
extern "C" {
    pub fn GetMessageW(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT) -> BOOL;
}
extern "C" {
    pub fn TranslateMessage(lpMsg: *const MSG) -> BOOL;
}
extern "C" {
    pub fn DispatchMessageA(lpMsg: *const MSG) -> LRESULT;
}
extern "C" {
    pub fn DispatchMessageW(lpMsg: *const MSG) -> LRESULT;
}
extern "C" {
    pub fn SetMessageQueue(cMessagesMax: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn PeekMessageA(
        lpMsg: LPMSG,
        hWnd: HWND,
        wMsgFilterMin: UINT,
        wMsgFilterMax: UINT,
        wRemoveMsg: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn PeekMessageW(
        lpMsg: LPMSG,
        hWnd: HWND,
        wMsgFilterMin: UINT,
        wMsgFilterMax: UINT,
        wRemoveMsg: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn RegisterHotKey(
        hWnd: HWND,
        id: ::std::os::raw::c_int,
        fsModifiers: UINT,
        vk: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn UnregisterHotKey(hWnd: HWND, id: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn ExitWindowsEx(uFlags: UINT, dwReason: DWORD) -> BOOL;
}
extern "C" {
    pub fn SwapMouseButton(fSwap: BOOL) -> BOOL;
}
extern "C" {
    pub fn GetMessagePos() -> DWORD;
}
extern "C" {
    pub fn GetMessageTime() -> LONG;
}
extern "C" {
    pub fn GetMessageExtraInfo() -> LPARAM;
}
extern "C" {
    pub fn GetUnpredictedMessagePos() -> DWORD;
}
extern "C" {
    pub fn IsWow64Message() -> BOOL;
}
extern "C" {
    pub fn SetMessageExtraInfo(lParam: LPARAM) -> LPARAM;
}
extern "C" {
    pub fn SendMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn SendMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn SendMessageTimeoutA(
        hWnd: HWND,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        fuFlags: UINT,
        uTimeout: UINT,
        lpdwResult: PDWORD_PTR,
    ) -> LRESULT;
}
extern "C" {
    pub fn SendMessageTimeoutW(
        hWnd: HWND,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        fuFlags: UINT,
        uTimeout: UINT,
        lpdwResult: PDWORD_PTR,
    ) -> LRESULT;
}
extern "C" {
    pub fn SendNotifyMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn SendNotifyMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn SendMessageCallbackA(
        hWnd: HWND,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        lpResultCallBack: SENDASYNCPROC,
        dwData: ULONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn SendMessageCallbackW(
        hWnd: HWND,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        lpResultCallBack: SENDASYNCPROC,
        dwData: ULONG_PTR,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BSMINFO {
    pub cbSize: UINT,
    pub hdesk: HDESK,
    pub hwnd: HWND,
    pub luid: LUID,
}
pub type PBSMINFO = *mut BSMINFO;
extern "C" {
    pub fn BroadcastSystemMessageExA(
        flags: DWORD,
        lpInfo: LPDWORD,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        pbsmInfo: PBSMINFO,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BroadcastSystemMessageExW(
        flags: DWORD,
        lpInfo: LPDWORD,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        pbsmInfo: PBSMINFO,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BroadcastSystemMessageA(
        flags: DWORD,
        lpInfo: LPDWORD,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BroadcastSystemMessageW(
        flags: DWORD,
        lpInfo: LPDWORD,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_long;
}
pub type HDEVNOTIFY = PVOID;
pub type PHDEVNOTIFY = *mut HDEVNOTIFY;
extern "C" {
    pub fn RegisterDeviceNotificationA(
        hRecipient: HANDLE,
        NotificationFilter: LPVOID,
        Flags: DWORD,
    ) -> HDEVNOTIFY;
}
extern "C" {
    pub fn RegisterDeviceNotificationW(
        hRecipient: HANDLE,
        NotificationFilter: LPVOID,
        Flags: DWORD,
    ) -> HDEVNOTIFY;
}
extern "C" {
    pub fn UnregisterDeviceNotification(Handle: HDEVNOTIFY) -> BOOL;
}
pub type HPOWERNOTIFY = PVOID;
pub type PHPOWERNOTIFY = *mut HPOWERNOTIFY;
extern "C" {
    pub fn RegisterPowerSettingNotification(
        hRecipient: HANDLE,
        PowerSettingGuid: LPCGUID,
        Flags: DWORD,
    ) -> HPOWERNOTIFY;
}
extern "C" {
    pub fn UnregisterPowerSettingNotification(Handle: HPOWERNOTIFY) -> BOOL;
}
extern "C" {
    pub fn RegisterSuspendResumeNotification(hRecipient: HANDLE, Flags: DWORD) -> HPOWERNOTIFY;
}
extern "C" {
    pub fn UnregisterSuspendResumeNotification(Handle: HPOWERNOTIFY) -> BOOL;
}
extern "C" {
    pub fn PostMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn PostMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn PostThreadMessageA(idThread: DWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn PostThreadMessageW(idThread: DWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn AttachThreadInput(idAttach: DWORD, idAttachTo: DWORD, fAttach: BOOL) -> BOOL;
}
extern "C" {
    pub fn ReplyMessage(lResult: LRESULT) -> BOOL;
}
extern "C" {
    pub fn WaitMessage() -> BOOL;
}
extern "C" {
    pub fn WaitForInputIdle(hProcess: HANDLE, dwMilliseconds: DWORD) -> DWORD;
}
extern "C" {
    pub fn DefWindowProcA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn DefWindowProcW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn PostQuitMessage(nExitCode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CallWindowProcA(
        lpPrevWndFunc: WNDPROC,
        hWnd: HWND,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn CallWindowProcW(
        lpPrevWndFunc: WNDPROC,
        hWnd: HWND,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn InSendMessage() -> BOOL;
}
extern "C" {
    pub fn InSendMessageEx(lpReserved: LPVOID) -> DWORD;
}
extern "C" {
    pub fn GetDoubleClickTime() -> UINT;
}
extern "C" {
    pub fn SetDoubleClickTime(arg1: UINT) -> BOOL;
}
extern "C" {
    pub fn RegisterClassA(lpWndClass: *const WNDCLASSA) -> ATOM;
}
extern "C" {
    pub fn RegisterClassW(lpWndClass: *const WNDCLASSW) -> ATOM;
}
extern "C" {
    pub fn UnregisterClassA(lpClassName: LPCSTR, hInstance: HINSTANCE) -> BOOL;
}
extern "C" {
    pub fn UnregisterClassW(lpClassName: LPCWSTR, hInstance: HINSTANCE) -> BOOL;
}
extern "C" {
    pub fn GetClassInfoA(
        hInstance: HINSTANCE,
        lpClassName: LPCSTR,
        lpWndClass: LPWNDCLASSA,
    ) -> BOOL;
}
extern "C" {
    pub fn GetClassInfoW(
        hInstance: HINSTANCE,
        lpClassName: LPCWSTR,
        lpWndClass: LPWNDCLASSW,
    ) -> BOOL;
}
extern "C" {
    pub fn RegisterClassExA(arg1: *const WNDCLASSEXA) -> ATOM;
}
extern "C" {
    pub fn RegisterClassExW(arg1: *const WNDCLASSEXW) -> ATOM;
}
extern "C" {
    pub fn GetClassInfoExA(hInstance: HINSTANCE, lpszClass: LPCSTR, lpwcx: LPWNDCLASSEXA) -> BOOL;
}
extern "C" {
    pub fn GetClassInfoExW(hInstance: HINSTANCE, lpszClass: LPCWSTR, lpwcx: LPWNDCLASSEXW) -> BOOL;
}
pub type PREGISTERCLASSNAMEW =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPCWSTR) -> BOOLEAN>;
extern "C" {
    pub fn CreateWindowExA(
        dwExStyle: DWORD,
        lpClassName: LPCSTR,
        lpWindowName: LPCSTR,
        dwStyle: DWORD,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        hWndParent: HWND,
        hMenu: HMENU,
        hInstance: HINSTANCE,
        lpParam: LPVOID,
    ) -> HWND;
}
extern "C" {
    pub fn CreateWindowExW(
        dwExStyle: DWORD,
        lpClassName: LPCWSTR,
        lpWindowName: LPCWSTR,
        dwStyle: DWORD,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        hWndParent: HWND,
        hMenu: HMENU,
        hInstance: HINSTANCE,
        lpParam: LPVOID,
    ) -> HWND;
}
extern "C" {
    pub fn IsWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn IsMenu(hMenu: HMENU) -> BOOL;
}
extern "C" {
    pub fn IsChild(hWndParent: HWND, hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn DestroyWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn ShowWindow(hWnd: HWND, nCmdShow: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn AnimateWindow(hWnd: HWND, dwTime: DWORD, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn UpdateLayeredWindow(
        hWnd: HWND,
        hdcDst: HDC,
        pptDst: *mut POINT,
        psize: *mut SIZE,
        hdcSrc: HDC,
        pptSrc: *mut POINT,
        crKey: COLORREF,
        pblend: *mut BLENDFUNCTION,
        dwFlags: DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUPDATELAYEREDWINDOWINFO {
    pub cbSize: DWORD,
    pub hdcDst: HDC,
    pub pptDst: *const POINT,
    pub psize: *const SIZE,
    pub hdcSrc: HDC,
    pub pptSrc: *const POINT,
    pub crKey: COLORREF,
    pub pblend: *const BLENDFUNCTION,
    pub dwFlags: DWORD,
    pub prcDirty: *const RECT,
}
pub type UPDATELAYEREDWINDOWINFO = tagUPDATELAYEREDWINDOWINFO;
pub type PUPDATELAYEREDWINDOWINFO = *mut tagUPDATELAYEREDWINDOWINFO;
extern "C" {
    pub fn UpdateLayeredWindowIndirect(
        hWnd: HWND,
        pULWInfo: *const UPDATELAYEREDWINDOWINFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetLayeredWindowAttributes(
        hwnd: HWND,
        pcrKey: *mut COLORREF,
        pbAlpha: *mut BYTE,
        pdwFlags: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PrintWindow(hwnd: HWND, hdcBlt: HDC, nFlags: UINT) -> BOOL;
}
extern "C" {
    pub fn SetLayeredWindowAttributes(
        hwnd: HWND,
        crKey: COLORREF,
        bAlpha: BYTE,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ShowWindowAsync(hWnd: HWND, nCmdShow: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn FlashWindow(hWnd: HWND, bInvert: BOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASHWINFO {
    pub cbSize: UINT,
    pub hwnd: HWND,
    pub dwFlags: DWORD,
    pub uCount: UINT,
    pub dwTimeout: DWORD,
}
pub type PFLASHWINFO = *mut FLASHWINFO;
extern "C" {
    pub fn FlashWindowEx(pfwi: PFLASHWINFO) -> BOOL;
}
extern "C" {
    pub fn ShowOwnedPopups(hWnd: HWND, fShow: BOOL) -> BOOL;
}
extern "C" {
    pub fn OpenIcon(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn CloseWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn MoveWindow(
        hWnd: HWND,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        bRepaint: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetWindowPos(
        hWnd: HWND,
        hWndInsertAfter: HWND,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        uFlags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetWindowPlacement(hWnd: HWND, lpwndpl: *mut WINDOWPLACEMENT) -> BOOL;
}
extern "C" {
    pub fn SetWindowPlacement(hWnd: HWND, lpwndpl: *const WINDOWPLACEMENT) -> BOOL;
}
extern "C" {
    pub fn GetWindowDisplayAffinity(hWnd: HWND, pdwAffinity: *mut DWORD) -> BOOL;
}
extern "C" {
    pub fn SetWindowDisplayAffinity(hWnd: HWND, dwAffinity: DWORD) -> BOOL;
}
extern "C" {
    pub fn BeginDeferWindowPos(nNumWindows: ::std::os::raw::c_int) -> HDWP;
}
extern "C" {
    pub fn DeferWindowPos(
        hWinPosInfo: HDWP,
        hWnd: HWND,
        hWndInsertAfter: HWND,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        uFlags: UINT,
    ) -> HDWP;
}
extern "C" {
    pub fn EndDeferWindowPos(hWinPosInfo: HDWP) -> BOOL;
}
extern "C" {
    pub fn IsWindowVisible(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn IsIconic(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn AnyPopup() -> BOOL;
}
extern "C" {
    pub fn BringWindowToTop(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn IsZoomed(hWnd: HWND) -> BOOL;
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct DLGTEMPLATE {
    pub style: DWORD,
    pub dwExtendedStyle: DWORD,
    pub cdit: WORD,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub cx: ::std::os::raw::c_short,
    pub cy: ::std::os::raw::c_short,
}
pub type LPDLGTEMPLATEA = *mut DLGTEMPLATE;
pub type LPDLGTEMPLATEW = *mut DLGTEMPLATE;
pub type LPDLGTEMPLATE = LPDLGTEMPLATEA;
pub type LPCDLGTEMPLATEA = *const DLGTEMPLATE;
pub type LPCDLGTEMPLATEW = *const DLGTEMPLATE;
pub type LPCDLGTEMPLATE = LPCDLGTEMPLATEA;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct DLGITEMTEMPLATE {
    pub style: DWORD,
    pub dwExtendedStyle: DWORD,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub cx: ::std::os::raw::c_short,
    pub cy: ::std::os::raw::c_short,
    pub id: WORD,
}
pub type PDLGITEMTEMPLATEA = *mut DLGITEMTEMPLATE;
pub type PDLGITEMTEMPLATEW = *mut DLGITEMTEMPLATE;
pub type PDLGITEMTEMPLATE = PDLGITEMTEMPLATEA;
pub type LPDLGITEMTEMPLATEA = *mut DLGITEMTEMPLATE;
pub type LPDLGITEMTEMPLATEW = *mut DLGITEMTEMPLATE;
pub type LPDLGITEMTEMPLATE = LPDLGITEMTEMPLATEA;
extern "C" {
    pub fn CreateDialogParamA(
        hInstance: HINSTANCE,
        lpTemplateName: LPCSTR,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> HWND;
}
extern "C" {
    pub fn CreateDialogParamW(
        hInstance: HINSTANCE,
        lpTemplateName: LPCWSTR,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> HWND;
}
extern "C" {
    pub fn CreateDialogIndirectParamA(
        hInstance: HINSTANCE,
        lpTemplate: LPCDLGTEMPLATEA,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> HWND;
}
extern "C" {
    pub fn CreateDialogIndirectParamW(
        hInstance: HINSTANCE,
        lpTemplate: LPCDLGTEMPLATEW,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> HWND;
}
extern "C" {
    pub fn DialogBoxParamA(
        hInstance: HINSTANCE,
        lpTemplateName: LPCSTR,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> INT_PTR;
}
extern "C" {
    pub fn DialogBoxParamW(
        hInstance: HINSTANCE,
        lpTemplateName: LPCWSTR,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> INT_PTR;
}
extern "C" {
    pub fn DialogBoxIndirectParamA(
        hInstance: HINSTANCE,
        hDialogTemplate: LPCDLGTEMPLATEA,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> INT_PTR;
}
extern "C" {
    pub fn DialogBoxIndirectParamW(
        hInstance: HINSTANCE,
        hDialogTemplate: LPCDLGTEMPLATEW,
        hWndParent: HWND,
        lpDialogFunc: DLGPROC,
        dwInitParam: LPARAM,
    ) -> INT_PTR;
}
extern "C" {
    pub fn EndDialog(hDlg: HWND, nResult: INT_PTR) -> BOOL;
}
extern "C" {
    pub fn GetDlgItem(hDlg: HWND, nIDDlgItem: ::std::os::raw::c_int) -> HWND;
}
extern "C" {
    pub fn SetDlgItemInt(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        uValue: UINT,
        bSigned: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDlgItemInt(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        lpTranslated: *mut BOOL,
        bSigned: BOOL,
    ) -> UINT;
}
extern "C" {
    pub fn SetDlgItemTextA(hDlg: HWND, nIDDlgItem: ::std::os::raw::c_int, lpString: LPCSTR)
        -> BOOL;
}
extern "C" {
    pub fn SetDlgItemTextW(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        lpString: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDlgItemTextA(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        lpString: LPSTR,
        cchMax: ::std::os::raw::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn GetDlgItemTextW(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        lpString: LPWSTR,
        cchMax: ::std::os::raw::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn CheckDlgButton(hDlg: HWND, nIDButton: ::std::os::raw::c_int, uCheck: UINT) -> BOOL;
}
extern "C" {
    pub fn CheckRadioButton(
        hDlg: HWND,
        nIDFirstButton: ::std::os::raw::c_int,
        nIDLastButton: ::std::os::raw::c_int,
        nIDCheckButton: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn IsDlgButtonChecked(hDlg: HWND, nIDButton: ::std::os::raw::c_int) -> UINT;
}
extern "C" {
    pub fn SendDlgItemMessageA(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn SendDlgItemMessageW(
        hDlg: HWND,
        nIDDlgItem: ::std::os::raw::c_int,
        Msg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn GetNextDlgGroupItem(hDlg: HWND, hCtl: HWND, bPrevious: BOOL) -> HWND;
}
extern "C" {
    pub fn GetNextDlgTabItem(hDlg: HWND, hCtl: HWND, bPrevious: BOOL) -> HWND;
}
extern "C" {
    pub fn GetDlgCtrlID(hWnd: HWND) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDialogBaseUnits() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DefDlgProcA(hDlg: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn DefDlgProcW(hDlg: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
    DCDC_DEFAULT = 0,
    DCDC_DISABLE_FONT_UPDATE = 1,
    DCDC_DISABLE_RELAYOUT = 2,
}
extern "C" {
    pub fn SetDialogControlDpiChangeBehavior(
        hWnd: HWND,
        mask: DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS,
        values: DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDialogControlDpiChangeBehavior(hWnd: HWND) -> DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT = 0,
    DDC_DISABLE_ALL = 1,
    DDC_DISABLE_RESIZE = 2,
    DDC_DISABLE_CONTROL_RELAYOUT = 4,
}
extern "C" {
    pub fn SetDialogDpiChangeBehavior(
        hDlg: HWND,
        mask: DIALOG_DPI_CHANGE_BEHAVIORS,
        values: DIALOG_DPI_CHANGE_BEHAVIORS,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDialogDpiChangeBehavior(hDlg: HWND) -> DIALOG_DPI_CHANGE_BEHAVIORS;
}
extern "C" {
    pub fn CallMsgFilterA(lpMsg: LPMSG, nCode: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn CallMsgFilterW(lpMsg: LPMSG, nCode: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn OpenClipboard(hWndNewOwner: HWND) -> BOOL;
}
extern "C" {
    pub fn CloseClipboard() -> BOOL;
}
extern "C" {
    pub fn GetClipboardSequenceNumber() -> DWORD;
}
extern "C" {
    pub fn GetClipboardOwner() -> HWND;
}
extern "C" {
    pub fn SetClipboardViewer(hWndNewViewer: HWND) -> HWND;
}
extern "C" {
    pub fn GetClipboardViewer() -> HWND;
}
extern "C" {
    pub fn ChangeClipboardChain(hWndRemove: HWND, hWndNewNext: HWND) -> BOOL;
}
extern "C" {
    pub fn SetClipboardData(uFormat: UINT, hMem: HANDLE) -> HANDLE;
}
extern "C" {
    pub fn GetClipboardData(uFormat: UINT) -> HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGETCLIPBMETADATA {
    pub Version: UINT,
    pub IsDelayRendered: BOOL,
    pub IsSynthetic: BOOL,
}
pub type GETCLIPBMETADATA = tagGETCLIPBMETADATA;
pub type PGETCLIPBMETADATA = *mut tagGETCLIPBMETADATA;
extern "C" {
    pub fn GetClipboardMetadata(format: UINT, metadata: PGETCLIPBMETADATA) -> BOOL;
}
extern "C" {
    pub fn RegisterClipboardFormatA(lpszFormat: LPCSTR) -> UINT;
}
extern "C" {
    pub fn RegisterClipboardFormatW(lpszFormat: LPCWSTR) -> UINT;
}
extern "C" {
    pub fn CountClipboardFormats() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumClipboardFormats(format: UINT) -> UINT;
}
extern "C" {
    pub fn GetClipboardFormatNameA(
        format: UINT,
        lpszFormatName: LPSTR,
        cchMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetClipboardFormatNameW(
        format: UINT,
        lpszFormatName: LPWSTR,
        cchMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EmptyClipboard() -> BOOL;
}
extern "C" {
    pub fn IsClipboardFormatAvailable(format: UINT) -> BOOL;
}
extern "C" {
    pub fn GetPriorityClipboardFormat(
        paFormatPriorityList: *mut UINT,
        cFormats: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetOpenClipboardWindow() -> HWND;
}
extern "C" {
    pub fn AddClipboardFormatListener(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn RemoveClipboardFormatListener(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn GetUpdatedClipboardFormats(
        lpuiFormats: PUINT,
        cFormats: UINT,
        pcFormatsOut: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn CharToOemA(pSrc: LPCSTR, pDst: LPSTR) -> BOOL;
}
extern "C" {
    pub fn CharToOemW(pSrc: LPCWSTR, pDst: LPSTR) -> BOOL;
}
extern "C" {
    pub fn OemToCharA(pSrc: LPCSTR, pDst: LPSTR) -> BOOL;
}
extern "C" {
    pub fn OemToCharW(pSrc: LPCSTR, pDst: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn CharToOemBuffA(lpszSrc: LPCSTR, lpszDst: LPSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
    pub fn CharToOemBuffW(lpszSrc: LPCWSTR, lpszDst: LPSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
    pub fn OemToCharBuffA(lpszSrc: LPCSTR, lpszDst: LPSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
    pub fn OemToCharBuffW(lpszSrc: LPCSTR, lpszDst: LPWSTR, cchDstLength: DWORD) -> BOOL;
}
extern "C" {
    pub fn CharUpperA(lpsz: LPSTR) -> LPSTR;
}
extern "C" {
    pub fn CharUpperW(lpsz: LPWSTR) -> LPWSTR;
}
extern "C" {
    pub fn CharUpperBuffA(lpsz: LPSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
    pub fn CharUpperBuffW(lpsz: LPWSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
    pub fn CharLowerA(lpsz: LPSTR) -> LPSTR;
}
extern "C" {
    pub fn CharLowerW(lpsz: LPWSTR) -> LPWSTR;
}
extern "C" {
    pub fn CharLowerBuffA(lpsz: LPSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
    pub fn CharLowerBuffW(lpsz: LPWSTR, cchLength: DWORD) -> DWORD;
}
extern "C" {
    pub fn CharNextA(lpsz: LPCSTR) -> LPSTR;
}
extern "C" {
    pub fn CharNextW(lpsz: LPCWSTR) -> LPWSTR;
}
extern "C" {
    pub fn CharPrevA(lpszStart: LPCSTR, lpszCurrent: LPCSTR) -> LPSTR;
}
extern "C" {
    pub fn CharPrevW(lpszStart: LPCWSTR, lpszCurrent: LPCWSTR) -> LPWSTR;
}
extern "C" {
    pub fn CharNextExA(CodePage: WORD, lpCurrentChar: LPCSTR, dwFlags: DWORD) -> LPSTR;
}
extern "C" {
    pub fn CharPrevExA(
        CodePage: WORD,
        lpStart: LPCSTR,
        lpCurrentChar: LPCSTR,
        dwFlags: DWORD,
    ) -> LPSTR;
}
extern "C" {
    pub fn IsCharAlphaA(ch: CHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharAlphaW(ch: WCHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharAlphaNumericA(ch: CHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharAlphaNumericW(ch: WCHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharUpperA(ch: CHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharUpperW(ch: WCHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharLowerA(ch: CHAR) -> BOOL;
}
extern "C" {
    pub fn IsCharLowerW(ch: WCHAR) -> BOOL;
}
extern "C" {
    pub fn SetFocus(hWnd: HWND) -> HWND;
}
extern "C" {
    pub fn GetActiveWindow() -> HWND;
}
extern "C" {
    pub fn GetFocus() -> HWND;
}
extern "C" {
    pub fn GetKBCodePage() -> UINT;
}
extern "C" {
    pub fn GetKeyState(nVirtKey: ::std::os::raw::c_int) -> SHORT;
}
extern "C" {
    pub fn GetAsyncKeyState(vKey: ::std::os::raw::c_int) -> SHORT;
}
extern "C" {
    pub fn GetKeyboardState(lpKeyState: PBYTE) -> BOOL;
}
extern "C" {
    pub fn SetKeyboardState(lpKeyState: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn GetKeyNameTextA(
        lParam: LONG,
        lpString: LPSTR,
        cchSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetKeyNameTextW(
        lParam: LONG,
        lpString: LPWSTR,
        cchSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetKeyboardType(nTypeFlag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ToAscii(
        uVirtKey: UINT,
        uScanCode: UINT,
        lpKeyState: *const BYTE,
        lpChar: LPWORD,
        uFlags: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ToAsciiEx(
        uVirtKey: UINT,
        uScanCode: UINT,
        lpKeyState: *const BYTE,
        lpChar: LPWORD,
        uFlags: UINT,
        dwhkl: HKL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ToUnicode(
        wVirtKey: UINT,
        wScanCode: UINT,
        lpKeyState: *const BYTE,
        pwszBuff: LPWSTR,
        cchBuff: ::std::os::raw::c_int,
        wFlags: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OemKeyScan(wOemChar: WORD) -> DWORD;
}
extern "C" {
    pub fn VkKeyScanA(ch: CHAR) -> SHORT;
}
extern "C" {
    pub fn VkKeyScanW(ch: WCHAR) -> SHORT;
}
extern "C" {
    pub fn VkKeyScanExA(ch: CHAR, dwhkl: HKL) -> SHORT;
}
extern "C" {
    pub fn VkKeyScanExW(ch: WCHAR, dwhkl: HKL) -> SHORT;
}
extern "C" {
    pub fn keybd_event(bVk: BYTE, bScan: BYTE, dwFlags: DWORD, dwExtraInfo: ULONG_PTR);
}
extern "C" {
    pub fn mouse_event(dwFlags: DWORD, dx: DWORD, dy: DWORD, dwData: DWORD, dwExtraInfo: ULONG_PTR);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMOUSEINPUT {
    pub dx: LONG,
    pub dy: LONG,
    pub mouseData: DWORD,
    pub dwFlags: DWORD,
    pub time: DWORD,
    pub dwExtraInfo: ULONG_PTR,
}
pub type MOUSEINPUT = tagMOUSEINPUT;
pub type PMOUSEINPUT = *mut tagMOUSEINPUT;
pub type LPMOUSEINPUT = *mut tagMOUSEINPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagKEYBDINPUT {
    pub wVk: WORD,
    pub wScan: WORD,
    pub dwFlags: DWORD,
    pub time: DWORD,
    pub dwExtraInfo: ULONG_PTR,
}
pub type KEYBDINPUT = tagKEYBDINPUT;
pub type PKEYBDINPUT = *mut tagKEYBDINPUT;
pub type LPKEYBDINPUT = *mut tagKEYBDINPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHARDWAREINPUT {
    pub uMsg: DWORD,
    pub wParamL: WORD,
    pub wParamH: WORD,
}
pub type HARDWAREINPUT = tagHARDWAREINPUT;
pub type PHARDWAREINPUT = *mut tagHARDWAREINPUT;
pub type LPHARDWAREINPUT = *mut tagHARDWAREINPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagINPUT {
    pub type_: DWORD,
    pub __bindgen_anon_1: tagINPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagINPUT__bindgen_ty_1 {
    pub mi: MOUSEINPUT,
    pub ki: KEYBDINPUT,
    pub hi: HARDWAREINPUT,
}
pub type INPUT = tagINPUT;
pub type PINPUT = *mut tagINPUT;
pub type LPINPUT = *mut tagINPUT;
extern "C" {
    pub fn SendInput(cInputs: UINT, pInputs: LPINPUT, cbSize: ::std::os::raw::c_int) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTOUCHINPUT__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HTOUCHINPUT = *mut HTOUCHINPUT__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTOUCHINPUT {
    pub x: LONG,
    pub y: LONG,
    pub hSource: HANDLE,
    pub dwID: DWORD,
    pub dwFlags: DWORD,
    pub dwMask: DWORD,
    pub dwTime: DWORD,
    pub dwExtraInfo: ULONG_PTR,
    pub cxContact: DWORD,
    pub cyContact: DWORD,
}
pub type TOUCHINPUT = tagTOUCHINPUT;
pub type PTOUCHINPUT = *mut tagTOUCHINPUT;
pub type PCTOUCHINPUT = *const TOUCHINPUT;
extern "C" {
    pub fn GetTouchInputInfo(
        hTouchInput: HTOUCHINPUT,
        cInputs: UINT,
        pInputs: PTOUCHINPUT,
        cbSize: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn CloseTouchInputHandle(hTouchInput: HTOUCHINPUT) -> BOOL;
}
extern "C" {
    pub fn RegisterTouchWindow(hwnd: HWND, ulFlags: ULONG) -> BOOL;
}
extern "C" {
    pub fn UnregisterTouchWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn IsTouchWindow(hwnd: HWND, pulFlags: PULONG) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagPOINTER_INPUT_TYPE {
    PT_POINTER = 1,
    PT_TOUCH = 2,
    PT_PEN = 3,
    PT_MOUSE = 4,
    PT_TOUCHPAD = 5,
}
pub type POINTER_INPUT_TYPE = DWORD;
pub type POINTER_FLAGS = UINT32;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagPOINTER_BUTTON_CHANGE_TYPE {
    POINTER_CHANGE_NONE = 0,
    POINTER_CHANGE_FIRSTBUTTON_DOWN = 1,
    POINTER_CHANGE_FIRSTBUTTON_UP = 2,
    POINTER_CHANGE_SECONDBUTTON_DOWN = 3,
    POINTER_CHANGE_SECONDBUTTON_UP = 4,
    POINTER_CHANGE_THIRDBUTTON_DOWN = 5,
    POINTER_CHANGE_THIRDBUTTON_UP = 6,
    POINTER_CHANGE_FOURTHBUTTON_DOWN = 7,
    POINTER_CHANGE_FOURTHBUTTON_UP = 8,
    POINTER_CHANGE_FIFTHBUTTON_DOWN = 9,
    POINTER_CHANGE_FIFTHBUTTON_UP = 10,
}
pub use self::tagPOINTER_BUTTON_CHANGE_TYPE as POINTER_BUTTON_CHANGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTER_INFO {
    pub pointerType: POINTER_INPUT_TYPE,
    pub pointerId: UINT32,
    pub frameId: UINT32,
    pub pointerFlags: POINTER_FLAGS,
    pub sourceDevice: HANDLE,
    pub hwndTarget: HWND,
    pub ptPixelLocation: POINT,
    pub ptHimetricLocation: POINT,
    pub ptPixelLocationRaw: POINT,
    pub ptHimetricLocationRaw: POINT,
    pub dwTime: DWORD,
    pub historyCount: UINT32,
    pub InputData: INT32,
    pub dwKeyStates: DWORD,
    pub PerformanceCount: UINT64,
    pub ButtonChangeType: POINTER_BUTTON_CHANGE_TYPE,
}
pub type POINTER_INFO = tagPOINTER_INFO;
pub type TOUCH_FLAGS = UINT32;
pub type TOUCH_MASK = UINT32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTER_TOUCH_INFO {
    pub pointerInfo: POINTER_INFO,
    pub touchFlags: TOUCH_FLAGS,
    pub touchMask: TOUCH_MASK,
    pub rcContact: RECT,
    pub rcContactRaw: RECT,
    pub orientation: UINT32,
    pub pressure: UINT32,
}
pub type POINTER_TOUCH_INFO = tagPOINTER_TOUCH_INFO;
pub type PEN_FLAGS = UINT32;
pub type PEN_MASK = UINT32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTER_PEN_INFO {
    pub pointerInfo: POINTER_INFO,
    pub penFlags: PEN_FLAGS,
    pub penMask: PEN_MASK,
    pub pressure: UINT32,
    pub rotation: UINT32,
    pub tiltX: INT32,
    pub tiltY: INT32,
}
pub type POINTER_PEN_INFO = tagPOINTER_PEN_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum POINTER_FEEDBACK_MODE {
    POINTER_FEEDBACK_DEFAULT = 1,
    POINTER_FEEDBACK_INDIRECT = 2,
    POINTER_FEEDBACK_NONE = 3,
}
extern "C" {
    pub fn InitializeTouchInjection(maxCount: UINT32, dwMode: DWORD) -> BOOL;
}
extern "C" {
    pub fn InjectTouchInput(count: UINT32, contacts: *const POINTER_TOUCH_INFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUSAGE_PROPERTIES {
    pub level: USHORT,
    pub page: USHORT,
    pub usage: USHORT,
    pub logicalMinimum: INT32,
    pub logicalMaximum: INT32,
    pub unit: USHORT,
    pub exponent: USHORT,
    pub count: BYTE,
    pub physicalMinimum: INT32,
    pub physicalMaximum: INT32,
}
pub type USAGE_PROPERTIES = tagUSAGE_PROPERTIES;
pub type PUSAGE_PROPERTIES = *mut tagUSAGE_PROPERTIES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPOINTER_TYPE_INFO {
    pub type_: POINTER_INPUT_TYPE,
    pub __bindgen_anon_1: tagPOINTER_TYPE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPOINTER_TYPE_INFO__bindgen_ty_1 {
    pub touchInfo: POINTER_TOUCH_INFO,
    pub penInfo: POINTER_PEN_INFO,
}
pub type POINTER_TYPE_INFO = tagPOINTER_TYPE_INFO;
pub type PPOINTER_TYPE_INFO = *mut tagPOINTER_TYPE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagINPUT_INJECTION_VALUE {
    pub page: USHORT,
    pub usage: USHORT,
    pub value: INT32,
    pub index: USHORT,
}
pub type INPUT_INJECTION_VALUE = tagINPUT_INJECTION_VALUE;
pub type PINPUT_INJECTION_VALUE = *mut tagINPUT_INJECTION_VALUE;
extern "C" {
    pub fn GetPointerType(pointerId: UINT32, pointerType: *mut POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
    pub fn GetPointerCursorId(pointerId: UINT32, cursorId: *mut UINT32) -> BOOL;
}
extern "C" {
    pub fn GetPointerInfo(pointerId: UINT32, pointerInfo: *mut POINTER_INFO) -> BOOL;
}
extern "C" {
    pub fn GetPointerInfoHistory(
        pointerId: UINT32,
        entriesCount: *mut UINT32,
        pointerInfo: *mut POINTER_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerFrameInfo(
        pointerId: UINT32,
        pointerCount: *mut UINT32,
        pointerInfo: *mut POINTER_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerFrameInfoHistory(
        pointerId: UINT32,
        entriesCount: *mut UINT32,
        pointerCount: *mut UINT32,
        pointerInfo: *mut POINTER_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerTouchInfo(pointerId: UINT32, touchInfo: *mut POINTER_TOUCH_INFO) -> BOOL;
}
extern "C" {
    pub fn GetPointerTouchInfoHistory(
        pointerId: UINT32,
        entriesCount: *mut UINT32,
        touchInfo: *mut POINTER_TOUCH_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerFrameTouchInfo(
        pointerId: UINT32,
        pointerCount: *mut UINT32,
        touchInfo: *mut POINTER_TOUCH_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerFrameTouchInfoHistory(
        pointerId: UINT32,
        entriesCount: *mut UINT32,
        pointerCount: *mut UINT32,
        touchInfo: *mut POINTER_TOUCH_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerPenInfo(pointerId: UINT32, penInfo: *mut POINTER_PEN_INFO) -> BOOL;
}
extern "C" {
    pub fn GetPointerPenInfoHistory(
        pointerId: UINT32,
        entriesCount: *mut UINT32,
        penInfo: *mut POINTER_PEN_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerFramePenInfo(
        pointerId: UINT32,
        pointerCount: *mut UINT32,
        penInfo: *mut POINTER_PEN_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerFramePenInfoHistory(
        pointerId: UINT32,
        entriesCount: *mut UINT32,
        pointerCount: *mut UINT32,
        penInfo: *mut POINTER_PEN_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn SkipPointerFrameMessages(pointerId: UINT32) -> BOOL;
}
extern "C" {
    pub fn RegisterPointerInputTarget(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
    pub fn UnregisterPointerInputTarget(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) -> BOOL;
}
extern "C" {
    pub fn RegisterPointerInputTargetEx(
        hwnd: HWND,
        pointerType: POINTER_INPUT_TYPE,
        fObserve: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn UnregisterPointerInputTargetEx(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSYNTHETICPOINTERDEVICE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HSYNTHETICPOINTERDEVICE = *mut HSYNTHETICPOINTERDEVICE__;
extern "C" {
    pub fn CreateSyntheticPointerDevice(
        pointerType: POINTER_INPUT_TYPE,
        maxCount: ULONG,
        mode: POINTER_FEEDBACK_MODE,
    ) -> HSYNTHETICPOINTERDEVICE;
}
extern "C" {
    pub fn InjectSyntheticPointerInput(
        device: HSYNTHETICPOINTERDEVICE,
        pointerInfo: *const POINTER_TYPE_INFO,
        count: UINT32,
    ) -> BOOL;
}
extern "C" {
    pub fn DestroySyntheticPointerDevice(device: HSYNTHETICPOINTERDEVICE);
}
extern "C" {
    pub fn EnableMouseInPointer(fEnable: BOOL) -> BOOL;
}
extern "C" {
    pub fn IsMouseInPointerEnabled() -> BOOL;
}
extern "C" {
    pub fn EnableMouseInPointerForThread() -> BOOL;
}
extern "C" {
    pub fn RegisterTouchHitTestingWindow(hwnd: HWND, value: ULONG) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
    pub score: UINT16,
    pub adjustedPoint: POINT,
}
pub type TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
pub type PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = *mut tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTOUCH_HIT_TESTING_INPUT {
    pub pointerId: UINT32,
    pub point: POINT,
    pub boundingBox: RECT,
    pub nonOccludedBoundingBox: RECT,
    pub orientation: UINT32,
}
pub type TOUCH_HIT_TESTING_INPUT = tagTOUCH_HIT_TESTING_INPUT;
pub type PTOUCH_HIT_TESTING_INPUT = *mut tagTOUCH_HIT_TESTING_INPUT;
extern "C" {
    pub fn EvaluateProximityToRect(
        controlBoundingBox: *const RECT,
        pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
        pProximityEval: *mut TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
    ) -> BOOL;
}
extern "C" {
    pub fn EvaluateProximityToPolygon(
        numVertices: UINT32,
        controlPolygon: *const POINT,
        pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
        pProximityEval: *mut TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
    ) -> BOOL;
}
extern "C" {
    pub fn PackTouchHitTestingProximityEvaluation(
        pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
        pProximityEval: *const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
    ) -> LRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagFEEDBACK_TYPE {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION = 2,
    FEEDBACK_PEN_TAP = 3,
    FEEDBACK_PEN_DOUBLETAP = 4,
    FEEDBACK_PEN_PRESSANDHOLD = 5,
    FEEDBACK_PEN_RIGHTTAP = 6,
    FEEDBACK_TOUCH_TAP = 7,
    FEEDBACK_TOUCH_DOUBLETAP = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD = 9,
    FEEDBACK_TOUCH_RIGHTTAP = 10,
    FEEDBACK_GESTURE_PRESSANDTAP = 11,
    FEEDBACK_MAX = -1,
}
pub use self::tagFEEDBACK_TYPE as FEEDBACK_TYPE;
extern "C" {
    pub fn GetWindowFeedbackSetting(
        hwnd: HWND,
        feedback: FEEDBACK_TYPE,
        dwFlags: DWORD,
        pSize: *mut UINT32,
        config: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn SetWindowFeedbackSetting(
        hwnd: HWND,
        feedback: FEEDBACK_TYPE,
        dwFlags: DWORD,
        size: UINT32,
        configuration: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagINPUT_TRANSFORM {
    pub __bindgen_anon_1: tagINPUT_TRANSFORM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagINPUT_TRANSFORM__bindgen_ty_1 {
    pub __bindgen_anon_1: tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1,
    pub m: [[f32; 4usize]; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagINPUT_TRANSFORM__bindgen_ty_1__bindgen_ty_1 {
    pub _11: f32,
    pub _12: f32,
    pub _13: f32,
    pub _14: f32,
    pub _21: f32,
    pub _22: f32,
    pub _23: f32,
    pub _24: f32,
    pub _31: f32,
    pub _32: f32,
    pub _33: f32,
    pub _34: f32,
    pub _41: f32,
    pub _42: f32,
    pub _43: f32,
    pub _44: f32,
}
pub type INPUT_TRANSFORM = tagINPUT_TRANSFORM;
extern "C" {
    pub fn GetPointerInputTransform(
        pointerId: UINT32,
        historyCount: UINT32,
        inputTransform: *mut INPUT_TRANSFORM,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLASTINPUTINFO {
    pub cbSize: UINT,
    pub dwTime: DWORD,
}
pub type LASTINPUTINFO = tagLASTINPUTINFO;
pub type PLASTINPUTINFO = *mut tagLASTINPUTINFO;
extern "C" {
    pub fn GetLastInputInfo(plii: PLASTINPUTINFO) -> BOOL;
}
extern "C" {
    pub fn MapVirtualKeyA(uCode: UINT, uMapType: UINT) -> UINT;
}
extern "C" {
    pub fn MapVirtualKeyW(uCode: UINT, uMapType: UINT) -> UINT;
}
extern "C" {
    pub fn MapVirtualKeyExA(uCode: UINT, uMapType: UINT, dwhkl: HKL) -> UINT;
}
extern "C" {
    pub fn MapVirtualKeyExW(uCode: UINT, uMapType: UINT, dwhkl: HKL) -> UINT;
}
extern "C" {
    pub fn GetInputState() -> BOOL;
}
extern "C" {
    pub fn GetQueueStatus(flags: UINT) -> DWORD;
}
extern "C" {
    pub fn GetCapture() -> HWND;
}
extern "C" {
    pub fn SetCapture(hWnd: HWND) -> HWND;
}
extern "C" {
    pub fn ReleaseCapture() -> BOOL;
}
extern "C" {
    pub fn MsgWaitForMultipleObjects(
        nCount: DWORD,
        pHandles: *const HANDLE,
        fWaitAll: BOOL,
        dwMilliseconds: DWORD,
        dwWakeMask: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn MsgWaitForMultipleObjectsEx(
        nCount: DWORD,
        pHandles: *const HANDLE,
        dwMilliseconds: DWORD,
        dwWakeMask: DWORD,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetTimer(
        hWnd: HWND,
        nIDEvent: UINT_PTR,
        uElapse: UINT,
        lpTimerFunc: TIMERPROC,
    ) -> UINT_PTR;
}
extern "C" {
    pub fn SetCoalescableTimer(
        hWnd: HWND,
        nIDEvent: UINT_PTR,
        uElapse: UINT,
        lpTimerFunc: TIMERPROC,
        uToleranceDelay: ULONG,
    ) -> UINT_PTR;
}
extern "C" {
    pub fn KillTimer(hWnd: HWND, uIDEvent: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn IsWindowUnicode(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn EnableWindow(hWnd: HWND, bEnable: BOOL) -> BOOL;
}
extern "C" {
    pub fn IsWindowEnabled(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn LoadAcceleratorsA(hInstance: HINSTANCE, lpTableName: LPCSTR) -> HACCEL;
}
extern "C" {
    pub fn LoadAcceleratorsW(hInstance: HINSTANCE, lpTableName: LPCWSTR) -> HACCEL;
}
extern "C" {
    pub fn CreateAcceleratorTableA(paccel: LPACCEL, cAccel: ::std::os::raw::c_int) -> HACCEL;
}
extern "C" {
    pub fn CreateAcceleratorTableW(paccel: LPACCEL, cAccel: ::std::os::raw::c_int) -> HACCEL;
}
extern "C" {
    pub fn DestroyAcceleratorTable(hAccel: HACCEL) -> BOOL;
}
extern "C" {
    pub fn CopyAcceleratorTableA(
        hAccelSrc: HACCEL,
        lpAccelDst: LPACCEL,
        cAccelEntries: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CopyAcceleratorTableW(
        hAccelSrc: HACCEL,
        lpAccelDst: LPACCEL,
        cAccelEntries: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TranslateAcceleratorA(
        hWnd: HWND,
        hAccTable: HACCEL,
        lpMsg: LPMSG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TranslateAcceleratorW(
        hWnd: HWND,
        hAccTable: HACCEL,
        lpMsg: LPMSG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetSystemMetrics(nIndex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetSystemMetricsForDpi(
        nIndex: ::std::os::raw::c_int,
        dpi: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LoadMenuA(hInstance: HINSTANCE, lpMenuName: LPCSTR) -> HMENU;
}
extern "C" {
    pub fn LoadMenuW(hInstance: HINSTANCE, lpMenuName: LPCWSTR) -> HMENU;
}
extern "C" {
    pub fn LoadMenuIndirectA(lpMenuTemplate: *const MENUTEMPLATEA) -> HMENU;
}
extern "C" {
    pub fn LoadMenuIndirectW(lpMenuTemplate: *const MENUTEMPLATEW) -> HMENU;
}
extern "C" {
    pub fn GetMenu(hWnd: HWND) -> HMENU;
}
extern "C" {
    pub fn SetMenu(hWnd: HWND, hMenu: HMENU) -> BOOL;
}
extern "C" {
    pub fn ChangeMenuA(
        hMenu: HMENU,
        cmd: UINT,
        lpszNewItem: LPCSTR,
        cmdInsert: UINT,
        flags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn ChangeMenuW(
        hMenu: HMENU,
        cmd: UINT,
        lpszNewItem: LPCWSTR,
        cmdInsert: UINT,
        flags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn HiliteMenuItem(hWnd: HWND, hMenu: HMENU, uIDHiliteItem: UINT, uHilite: UINT) -> BOOL;
}
extern "C" {
    pub fn GetMenuStringA(
        hMenu: HMENU,
        uIDItem: UINT,
        lpString: LPSTR,
        cchMax: ::std::os::raw::c_int,
        flags: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMenuStringW(
        hMenu: HMENU,
        uIDItem: UINT,
        lpString: LPWSTR,
        cchMax: ::std::os::raw::c_int,
        flags: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetMenuState(hMenu: HMENU, uId: UINT, uFlags: UINT) -> UINT;
}
extern "C" {
    pub fn DrawMenuBar(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn GetSystemMenu(hWnd: HWND, bRevert: BOOL) -> HMENU;
}
extern "C" {
    pub fn CreateMenu() -> HMENU;
}
extern "C" {
    pub fn CreatePopupMenu() -> HMENU;
}
extern "C" {
    pub fn DestroyMenu(hMenu: HMENU) -> BOOL;
}
extern "C" {
    pub fn CheckMenuItem(hMenu: HMENU, uIDCheckItem: UINT, uCheck: UINT) -> DWORD;
}
extern "C" {
    pub fn EnableMenuItem(hMenu: HMENU, uIDEnableItem: UINT, uEnable: UINT) -> BOOL;
}
extern "C" {
    pub fn GetSubMenu(hMenu: HMENU, nPos: ::std::os::raw::c_int) -> HMENU;
}
extern "C" {
    pub fn GetMenuItemID(hMenu: HMENU, nPos: ::std::os::raw::c_int) -> UINT;
}
extern "C" {
    pub fn GetMenuItemCount(hMenu: HMENU) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InsertMenuA(
        hMenu: HMENU,
        uPosition: UINT,
        uFlags: UINT,
        uIDNewItem: UINT_PTR,
        lpNewItem: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn InsertMenuW(
        hMenu: HMENU,
        uPosition: UINT,
        uFlags: UINT,
        uIDNewItem: UINT_PTR,
        lpNewItem: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn AppendMenuA(hMenu: HMENU, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR)
        -> BOOL;
}
extern "C" {
    pub fn AppendMenuW(
        hMenu: HMENU,
        uFlags: UINT,
        uIDNewItem: UINT_PTR,
        lpNewItem: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ModifyMenuA(
        hMnu: HMENU,
        uPosition: UINT,
        uFlags: UINT,
        uIDNewItem: UINT_PTR,
        lpNewItem: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ModifyMenuW(
        hMnu: HMENU,
        uPosition: UINT,
        uFlags: UINT,
        uIDNewItem: UINT_PTR,
        lpNewItem: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn RemoveMenu(hMenu: HMENU, uPosition: UINT, uFlags: UINT) -> BOOL;
}
extern "C" {
    pub fn DeleteMenu(hMenu: HMENU, uPosition: UINT, uFlags: UINT) -> BOOL;
}
extern "C" {
    pub fn SetMenuItemBitmaps(
        hMenu: HMENU,
        uPosition: UINT,
        uFlags: UINT,
        hBitmapUnchecked: HBITMAP,
        hBitmapChecked: HBITMAP,
    ) -> BOOL;
}
extern "C" {
    pub fn GetMenuCheckMarkDimensions() -> LONG;
}
extern "C" {
    pub fn TrackPopupMenu(
        hMenu: HMENU,
        uFlags: UINT,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        nReserved: ::std::os::raw::c_int,
        hWnd: HWND,
        prcRect: *const RECT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTPMPARAMS {
    pub cbSize: UINT,
    pub rcExclude: RECT,
}
pub type TPMPARAMS = tagTPMPARAMS;
pub type LPTPMPARAMS = *mut TPMPARAMS;
extern "C" {
    pub fn TrackPopupMenuEx(
        hMenu: HMENU,
        uFlags: UINT,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        hwnd: HWND,
        lptpm: LPTPMPARAMS,
    ) -> BOOL;
}
extern "C" {
    pub fn CalculatePopupWindowPosition(
        anchorPoint: *const POINT,
        windowSize: *const SIZE,
        flags: UINT,
        excludeRect: *mut RECT,
        popupWindowPosition: *mut RECT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMENUINFO {
    pub cbSize: DWORD,
    pub fMask: DWORD,
    pub dwStyle: DWORD,
    pub cyMax: UINT,
    pub hbrBack: HBRUSH,
    pub dwContextHelpID: DWORD,
    pub dwMenuData: ULONG_PTR,
}
pub type MENUINFO = tagMENUINFO;
pub type LPMENUINFO = *mut tagMENUINFO;
pub type LPCMENUINFO = *const MENUINFO;
extern "C" {
    pub fn GetMenuInfo(arg1: HMENU, arg2: LPMENUINFO) -> BOOL;
}
extern "C" {
    pub fn SetMenuInfo(arg1: HMENU, arg2: LPCMENUINFO) -> BOOL;
}
extern "C" {
    pub fn EndMenu() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMENUGETOBJECTINFO {
    pub dwFlags: DWORD,
    pub uPos: UINT,
    pub hmenu: HMENU,
    pub riid: PVOID,
    pub pvObj: PVOID,
}
pub type MENUGETOBJECTINFO = tagMENUGETOBJECTINFO;
pub type PMENUGETOBJECTINFO = *mut tagMENUGETOBJECTINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMENUITEMINFOA {
    pub cbSize: UINT,
    pub fMask: UINT,
    pub fType: UINT,
    pub fState: UINT,
    pub wID: UINT,
    pub hSubMenu: HMENU,
    pub hbmpChecked: HBITMAP,
    pub hbmpUnchecked: HBITMAP,
    pub dwItemData: ULONG_PTR,
    pub dwTypeData: LPSTR,
    pub cch: UINT,
    pub hbmpItem: HBITMAP,
}
pub type MENUITEMINFOA = tagMENUITEMINFOA;
pub type LPMENUITEMINFOA = *mut tagMENUITEMINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMENUITEMINFOW {
    pub cbSize: UINT,
    pub fMask: UINT,
    pub fType: UINT,
    pub fState: UINT,
    pub wID: UINT,
    pub hSubMenu: HMENU,
    pub hbmpChecked: HBITMAP,
    pub hbmpUnchecked: HBITMAP,
    pub dwItemData: ULONG_PTR,
    pub dwTypeData: LPWSTR,
    pub cch: UINT,
    pub hbmpItem: HBITMAP,
}
pub type MENUITEMINFOW = tagMENUITEMINFOW;
pub type LPMENUITEMINFOW = *mut tagMENUITEMINFOW;
pub type MENUITEMINFO = MENUITEMINFOA;
pub type LPMENUITEMINFO = LPMENUITEMINFOA;
pub type LPCMENUITEMINFOA = *const MENUITEMINFOA;
pub type LPCMENUITEMINFOW = *const MENUITEMINFOW;
pub type LPCMENUITEMINFO = LPCMENUITEMINFOA;
extern "C" {
    pub fn InsertMenuItemA(
        hmenu: HMENU,
        item: UINT,
        fByPosition: BOOL,
        lpmi: LPCMENUITEMINFOA,
    ) -> BOOL;
}
extern "C" {
    pub fn InsertMenuItemW(
        hmenu: HMENU,
        item: UINT,
        fByPosition: BOOL,
        lpmi: LPCMENUITEMINFOW,
    ) -> BOOL;
}
extern "C" {
    pub fn GetMenuItemInfoA(
        hmenu: HMENU,
        item: UINT,
        fByPosition: BOOL,
        lpmii: LPMENUITEMINFOA,
    ) -> BOOL;
}
extern "C" {
    pub fn GetMenuItemInfoW(
        hmenu: HMENU,
        item: UINT,
        fByPosition: BOOL,
        lpmii: LPMENUITEMINFOW,
    ) -> BOOL;
}
extern "C" {
    pub fn SetMenuItemInfoA(
        hmenu: HMENU,
        item: UINT,
        fByPositon: BOOL,
        lpmii: LPCMENUITEMINFOA,
    ) -> BOOL;
}
extern "C" {
    pub fn SetMenuItemInfoW(
        hmenu: HMENU,
        item: UINT,
        fByPositon: BOOL,
        lpmii: LPCMENUITEMINFOW,
    ) -> BOOL;
}
extern "C" {
    pub fn GetMenuDefaultItem(hMenu: HMENU, fByPos: UINT, gmdiFlags: UINT) -> UINT;
}
extern "C" {
    pub fn SetMenuDefaultItem(hMenu: HMENU, uItem: UINT, fByPos: UINT) -> BOOL;
}
extern "C" {
    pub fn GetMenuItemRect(hWnd: HWND, hMenu: HMENU, uItem: UINT, lprcItem: LPRECT) -> BOOL;
}
extern "C" {
    pub fn MenuItemFromPoint(hWnd: HWND, hMenu: HMENU, ptScreen: POINT) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDROPSTRUCT {
    pub hwndSource: HWND,
    pub hwndSink: HWND,
    pub wFmt: DWORD,
    pub dwData: ULONG_PTR,
    pub ptDrop: POINT,
    pub dwControlData: DWORD,
}
pub type DROPSTRUCT = tagDROPSTRUCT;
pub type PDROPSTRUCT = *mut tagDROPSTRUCT;
pub type LPDROPSTRUCT = *mut tagDROPSTRUCT;
extern "C" {
    pub fn DragObject(
        hwndParent: HWND,
        hwndFrom: HWND,
        fmt: UINT,
        data: ULONG_PTR,
        hcur: HCURSOR,
    ) -> DWORD;
}
extern "C" {
    pub fn DragDetect(hwnd: HWND, pt: POINT) -> BOOL;
}
extern "C" {
    pub fn DrawIcon(
        hDC: HDC,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        hIcon: HICON,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDRAWTEXTPARAMS {
    pub cbSize: UINT,
    pub iTabLength: ::std::os::raw::c_int,
    pub iLeftMargin: ::std::os::raw::c_int,
    pub iRightMargin: ::std::os::raw::c_int,
    pub uiLengthDrawn: UINT,
}
pub type DRAWTEXTPARAMS = tagDRAWTEXTPARAMS;
pub type LPDRAWTEXTPARAMS = *mut tagDRAWTEXTPARAMS;
extern "C" {
    pub fn DrawTextA(
        hdc: HDC,
        lpchText: LPCSTR,
        cchText: ::std::os::raw::c_int,
        lprc: LPRECT,
        format: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DrawTextW(
        hdc: HDC,
        lpchText: LPCWSTR,
        cchText: ::std::os::raw::c_int,
        lprc: LPRECT,
        format: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DrawTextExA(
        hdc: HDC,
        lpchText: LPSTR,
        cchText: ::std::os::raw::c_int,
        lprc: LPRECT,
        format: UINT,
        lpdtp: LPDRAWTEXTPARAMS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DrawTextExW(
        hdc: HDC,
        lpchText: LPWSTR,
        cchText: ::std::os::raw::c_int,
        lprc: LPRECT,
        format: UINT,
        lpdtp: LPDRAWTEXTPARAMS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GrayStringA(
        hDC: HDC,
        hBrush: HBRUSH,
        lpOutputFunc: GRAYSTRINGPROC,
        lpData: LPARAM,
        nCount: ::std::os::raw::c_int,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn GrayStringW(
        hDC: HDC,
        hBrush: HBRUSH,
        lpOutputFunc: GRAYSTRINGPROC,
        lpData: LPARAM,
        nCount: ::std::os::raw::c_int,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn DrawStateA(
        hdc: HDC,
        hbrFore: HBRUSH,
        qfnCallBack: DRAWSTATEPROC,
        lData: LPARAM,
        wData: WPARAM,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        uFlags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn DrawStateW(
        hdc: HDC,
        hbrFore: HBRUSH,
        qfnCallBack: DRAWSTATEPROC,
        lData: LPARAM,
        wData: WPARAM,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        uFlags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn TabbedTextOutA(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lpString: LPCSTR,
        chCount: ::std::os::raw::c_int,
        nTabPositions: ::std::os::raw::c_int,
        lpnTabStopPositions: *const INT,
        nTabOrigin: ::std::os::raw::c_int,
    ) -> LONG;
}
extern "C" {
    pub fn TabbedTextOutW(
        hdc: HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        lpString: LPCWSTR,
        chCount: ::std::os::raw::c_int,
        nTabPositions: ::std::os::raw::c_int,
        lpnTabStopPositions: *const INT,
        nTabOrigin: ::std::os::raw::c_int,
    ) -> LONG;
}
extern "C" {
    pub fn GetTabbedTextExtentA(
        hdc: HDC,
        lpString: LPCSTR,
        chCount: ::std::os::raw::c_int,
        nTabPositions: ::std::os::raw::c_int,
        lpnTabStopPositions: *const INT,
    ) -> DWORD;
}
extern "C" {
    pub fn GetTabbedTextExtentW(
        hdc: HDC,
        lpString: LPCWSTR,
        chCount: ::std::os::raw::c_int,
        nTabPositions: ::std::os::raw::c_int,
        lpnTabStopPositions: *const INT,
    ) -> DWORD;
}
extern "C" {
    pub fn UpdateWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn SetActiveWindow(hWnd: HWND) -> HWND;
}
extern "C" {
    pub fn GetForegroundWindow() -> HWND;
}
extern "C" {
    pub fn PaintDesktop(hdc: HDC) -> BOOL;
}
extern "C" {
    pub fn SwitchToThisWindow(hwnd: HWND, fUnknown: BOOL);
}
extern "C" {
    pub fn SetForegroundWindow(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn AllowSetForegroundWindow(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
    pub fn LockSetForegroundWindow(uLockCode: UINT) -> BOOL;
}
extern "C" {
    pub fn WindowFromDC(hDC: HDC) -> HWND;
}
extern "C" {
    pub fn GetDC(hWnd: HWND) -> HDC;
}
extern "C" {
    pub fn GetDCEx(hWnd: HWND, hrgnClip: HRGN, flags: DWORD) -> HDC;
}
extern "C" {
    pub fn GetWindowDC(hWnd: HWND) -> HDC;
}
extern "C" {
    pub fn ReleaseDC(hWnd: HWND, hDC: HDC) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BeginPaint(hWnd: HWND, lpPaint: LPPAINTSTRUCT) -> HDC;
}
extern "C" {
    pub fn EndPaint(hWnd: HWND, lpPaint: *const PAINTSTRUCT) -> BOOL;
}
extern "C" {
    pub fn GetUpdateRect(hWnd: HWND, lpRect: LPRECT, bErase: BOOL) -> BOOL;
}
extern "C" {
    pub fn GetUpdateRgn(hWnd: HWND, hRgn: HRGN, bErase: BOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetWindowRgn(hWnd: HWND, hRgn: HRGN, bRedraw: BOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetWindowRgn(hWnd: HWND, hRgn: HRGN) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetWindowRgnBox(hWnd: HWND, lprc: LPRECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExcludeUpdateRgn(hDC: HDC, hWnd: HWND) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InvalidateRect(hWnd: HWND, lpRect: *const RECT, bErase: BOOL) -> BOOL;
}
extern "C" {
    pub fn ValidateRect(hWnd: HWND, lpRect: *const RECT) -> BOOL;
}
extern "C" {
    pub fn InvalidateRgn(hWnd: HWND, hRgn: HRGN, bErase: BOOL) -> BOOL;
}
extern "C" {
    pub fn ValidateRgn(hWnd: HWND, hRgn: HRGN) -> BOOL;
}
extern "C" {
    pub fn RedrawWindow(hWnd: HWND, lprcUpdate: *const RECT, hrgnUpdate: HRGN, flags: UINT)
        -> BOOL;
}
extern "C" {
    pub fn LockWindowUpdate(hWndLock: HWND) -> BOOL;
}
extern "C" {
    pub fn ScrollWindow(
        hWnd: HWND,
        XAmount: ::std::os::raw::c_int,
        YAmount: ::std::os::raw::c_int,
        lpRect: *const RECT,
        lpClipRect: *const RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn ScrollDC(
        hDC: HDC,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        lprcScroll: *const RECT,
        lprcClip: *const RECT,
        hrgnUpdate: HRGN,
        lprcUpdate: LPRECT,
    ) -> BOOL;
}
extern "C" {
    pub fn ScrollWindowEx(
        hWnd: HWND,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        prcScroll: *const RECT,
        prcClip: *const RECT,
        hrgnUpdate: HRGN,
        prcUpdate: LPRECT,
        flags: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetScrollPos(
        hWnd: HWND,
        nBar: ::std::os::raw::c_int,
        nPos: ::std::os::raw::c_int,
        bRedraw: BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetScrollPos(hWnd: HWND, nBar: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetScrollRange(
        hWnd: HWND,
        nBar: ::std::os::raw::c_int,
        nMinPos: ::std::os::raw::c_int,
        nMaxPos: ::std::os::raw::c_int,
        bRedraw: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetScrollRange(
        hWnd: HWND,
        nBar: ::std::os::raw::c_int,
        lpMinPos: LPINT,
        lpMaxPos: LPINT,
    ) -> BOOL;
}
extern "C" {
    pub fn ShowScrollBar(hWnd: HWND, wBar: ::std::os::raw::c_int, bShow: BOOL) -> BOOL;
}
extern "C" {
    pub fn EnableScrollBar(hWnd: HWND, wSBflags: UINT, wArrows: UINT) -> BOOL;
}
extern "C" {
    pub fn SetPropA(hWnd: HWND, lpString: LPCSTR, hData: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetPropW(hWnd: HWND, lpString: LPCWSTR, hData: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetPropA(hWnd: HWND, lpString: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn GetPropW(hWnd: HWND, lpString: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn RemovePropA(hWnd: HWND, lpString: LPCSTR) -> HANDLE;
}
extern "C" {
    pub fn RemovePropW(hWnd: HWND, lpString: LPCWSTR) -> HANDLE;
}
extern "C" {
    pub fn EnumPropsExA(
        hWnd: HWND,
        lpEnumFunc: PROPENUMPROCEXA,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumPropsExW(
        hWnd: HWND,
        lpEnumFunc: PROPENUMPROCEXW,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumPropsA(hWnd: HWND, lpEnumFunc: PROPENUMPROCA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumPropsW(hWnd: HWND, lpEnumFunc: PROPENUMPROCW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetWindowTextA(hWnd: HWND, lpString: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetWindowTextW(hWnd: HWND, lpString: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetWindowTextA(
        hWnd: HWND,
        lpString: LPSTR,
        nMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetWindowTextW(
        hWnd: HWND,
        lpString: LPWSTR,
        nMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetWindowTextLengthA(hWnd: HWND) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetWindowTextLengthW(hWnd: HWND) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetClientRect(hWnd: HWND, lpRect: LPRECT) -> BOOL;
}
extern "C" {
    pub fn GetWindowRect(hWnd: HWND, lpRect: LPRECT) -> BOOL;
}
extern "C" {
    pub fn AdjustWindowRect(lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL) -> BOOL;
}
extern "C" {
    pub fn AdjustWindowRectEx(
        lpRect: LPRECT,
        dwStyle: DWORD,
        bMenu: BOOL,
        dwExStyle: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AdjustWindowRectExForDpi(
        lpRect: LPRECT,
        dwStyle: DWORD,
        bMenu: BOOL,
        dwExStyle: DWORD,
        dpi: UINT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHELPINFO {
    pub cbSize: UINT,
    pub iContextType: ::std::os::raw::c_int,
    pub iCtrlId: ::std::os::raw::c_int,
    pub hItemHandle: HANDLE,
    pub dwContextId: DWORD_PTR,
    pub MousePos: POINT,
}
pub type HELPINFO = tagHELPINFO;
pub type LPHELPINFO = *mut tagHELPINFO;
extern "C" {
    pub fn SetWindowContextHelpId(arg1: HWND, arg2: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetWindowContextHelpId(arg1: HWND) -> DWORD;
}
extern "C" {
    pub fn SetMenuContextHelpId(arg1: HMENU, arg2: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetMenuContextHelpId(arg1: HMENU) -> DWORD;
}
extern "C" {
    pub fn MessageBoxA(
        hWnd: HWND,
        lpText: LPCSTR,
        lpCaption: LPCSTR,
        uType: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MessageBoxW(
        hWnd: HWND,
        lpText: LPCWSTR,
        lpCaption: LPCWSTR,
        uType: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MessageBoxExA(
        hWnd: HWND,
        lpText: LPCSTR,
        lpCaption: LPCSTR,
        uType: UINT,
        wLanguageId: WORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MessageBoxExW(
        hWnd: HWND,
        lpText: LPCWSTR,
        lpCaption: LPCWSTR,
        uType: UINT,
        wLanguageId: WORD,
    ) -> ::std::os::raw::c_int;
}
pub type MSGBOXCALLBACK = ::std::option::Option<unsafe extern "C" fn(lpHelpInfo: LPHELPINFO)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMSGBOXPARAMSA {
    pub cbSize: UINT,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub lpszText: LPCSTR,
    pub lpszCaption: LPCSTR,
    pub dwStyle: DWORD,
    pub lpszIcon: LPCSTR,
    pub dwContextHelpId: DWORD_PTR,
    pub lpfnMsgBoxCallback: MSGBOXCALLBACK,
    pub dwLanguageId: DWORD,
}
pub type MSGBOXPARAMSA = tagMSGBOXPARAMSA;
pub type PMSGBOXPARAMSA = *mut tagMSGBOXPARAMSA;
pub type LPMSGBOXPARAMSA = *mut tagMSGBOXPARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMSGBOXPARAMSW {
    pub cbSize: UINT,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub lpszText: LPCWSTR,
    pub lpszCaption: LPCWSTR,
    pub dwStyle: DWORD,
    pub lpszIcon: LPCWSTR,
    pub dwContextHelpId: DWORD_PTR,
    pub lpfnMsgBoxCallback: MSGBOXCALLBACK,
    pub dwLanguageId: DWORD,
}
pub type MSGBOXPARAMSW = tagMSGBOXPARAMSW;
pub type PMSGBOXPARAMSW = *mut tagMSGBOXPARAMSW;
pub type LPMSGBOXPARAMSW = *mut tagMSGBOXPARAMSW;
pub type MSGBOXPARAMS = MSGBOXPARAMSA;
pub type PMSGBOXPARAMS = PMSGBOXPARAMSA;
pub type LPMSGBOXPARAMS = LPMSGBOXPARAMSA;
extern "C" {
    pub fn MessageBoxIndirectA(lpmbp: *const MSGBOXPARAMSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MessageBoxIndirectW(lpmbp: *const MSGBOXPARAMSW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MessageBeep(uType: UINT) -> BOOL;
}
extern "C" {
    pub fn ShowCursor(bShow: BOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetCursorPos(X: ::std::os::raw::c_int, Y: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn SetPhysicalCursorPos(X: ::std::os::raw::c_int, Y: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn SetCursor(hCursor: HCURSOR) -> HCURSOR;
}
extern "C" {
    pub fn GetCursorPos(lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn GetPhysicalCursorPos(lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn GetClipCursor(lpRect: LPRECT) -> BOOL;
}
extern "C" {
    pub fn GetCursor() -> HCURSOR;
}
extern "C" {
    pub fn CreateCaret(
        hWnd: HWND,
        hBitmap: HBITMAP,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn GetCaretBlinkTime() -> UINT;
}
extern "C" {
    pub fn SetCaretBlinkTime(uMSeconds: UINT) -> BOOL;
}
extern "C" {
    pub fn DestroyCaret() -> BOOL;
}
extern "C" {
    pub fn HideCaret(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn ShowCaret(hWnd: HWND) -> BOOL;
}
extern "C" {
    pub fn SetCaretPos(X: ::std::os::raw::c_int, Y: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn GetCaretPos(lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn ClientToScreen(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn ScreenToClient(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn LogicalToPhysicalPoint(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn PhysicalToLogicalPoint(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn LogicalToPhysicalPointForPerMonitorDPI(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn PhysicalToLogicalPointForPerMonitorDPI(hWnd: HWND, lpPoint: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn MapWindowPoints(
        hWndFrom: HWND,
        hWndTo: HWND,
        lpPoints: LPPOINT,
        cPoints: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WindowFromPoint(Point: POINT) -> HWND;
}
extern "C" {
    pub fn WindowFromPhysicalPoint(Point: POINT) -> HWND;
}
extern "C" {
    pub fn ChildWindowFromPoint(hWndParent: HWND, Point: POINT) -> HWND;
}
extern "C" {
    pub fn ClipCursor(lpRect: *const RECT) -> BOOL;
}
extern "C" {
    pub fn ChildWindowFromPointEx(hwnd: HWND, pt: POINT, flags: UINT) -> HWND;
}
extern "C" {
    pub fn GetSysColor(nIndex: ::std::os::raw::c_int) -> DWORD;
}
extern "C" {
    pub fn GetSysColorBrush(nIndex: ::std::os::raw::c_int) -> HBRUSH;
}
extern "C" {
    pub fn SetSysColors(
        cElements: ::std::os::raw::c_int,
        lpaElements: *const INT,
        lpaRgbValues: *const COLORREF,
    ) -> BOOL;
}
extern "C" {
    pub fn DrawFocusRect(hDC: HDC, lprc: *const RECT) -> BOOL;
}
extern "C" {
    pub fn FillRect(hDC: HDC, lprc: *const RECT, hbr: HBRUSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FrameRect(hDC: HDC, lprc: *const RECT, hbr: HBRUSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InvertRect(hDC: HDC, lprc: *const RECT) -> BOOL;
}
extern "C" {
    pub fn SetRect(
        lprc: LPRECT,
        xLeft: ::std::os::raw::c_int,
        yTop: ::std::os::raw::c_int,
        xRight: ::std::os::raw::c_int,
        yBottom: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn SetRectEmpty(lprc: LPRECT) -> BOOL;
}
extern "C" {
    pub fn CopyRect(lprcDst: LPRECT, lprcSrc: *const RECT) -> BOOL;
}
extern "C" {
    pub fn InflateRect(lprc: LPRECT, dx: ::std::os::raw::c_int, dy: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn IntersectRect(lprcDst: LPRECT, lprcSrc1: *const RECT, lprcSrc2: *const RECT) -> BOOL;
}
extern "C" {
    pub fn UnionRect(lprcDst: LPRECT, lprcSrc1: *const RECT, lprcSrc2: *const RECT) -> BOOL;
}
extern "C" {
    pub fn SubtractRect(lprcDst: LPRECT, lprcSrc1: *const RECT, lprcSrc2: *const RECT) -> BOOL;
}
extern "C" {
    pub fn OffsetRect(lprc: LPRECT, dx: ::std::os::raw::c_int, dy: ::std::os::raw::c_int) -> BOOL;
}
extern "C" {
    pub fn IsRectEmpty(lprc: *const RECT) -> BOOL;
}
extern "C" {
    pub fn EqualRect(lprc1: *const RECT, lprc2: *const RECT) -> BOOL;
}
extern "C" {
    pub fn PtInRect(lprc: *const RECT, pt: POINT) -> BOOL;
}
extern "C" {
    pub fn GetWindowWord(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> WORD;
}
extern "C" {
    pub fn SetWindowWord(hWnd: HWND, nIndex: ::std::os::raw::c_int, wNewWord: WORD) -> WORD;
}
extern "C" {
    pub fn GetWindowLongA(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> LONG;
}
extern "C" {
    pub fn GetWindowLongW(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> LONG;
}
extern "C" {
    pub fn SetWindowLongA(hWnd: HWND, nIndex: ::std::os::raw::c_int, dwNewLong: LONG) -> LONG;
}
extern "C" {
    pub fn SetWindowLongW(hWnd: HWND, nIndex: ::std::os::raw::c_int, dwNewLong: LONG) -> LONG;
}
extern "C" {
    pub fn GetWindowLongPtrA(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> LONG_PTR;
}
extern "C" {
    pub fn GetWindowLongPtrW(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> LONG_PTR;
}
extern "C" {
    pub fn SetWindowLongPtrA(
        hWnd: HWND,
        nIndex: ::std::os::raw::c_int,
        dwNewLong: LONG_PTR,
    ) -> LONG_PTR;
}
extern "C" {
    pub fn SetWindowLongPtrW(
        hWnd: HWND,
        nIndex: ::std::os::raw::c_int,
        dwNewLong: LONG_PTR,
    ) -> LONG_PTR;
}
extern "C" {
    pub fn GetClassWord(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> WORD;
}
extern "C" {
    pub fn SetClassWord(hWnd: HWND, nIndex: ::std::os::raw::c_int, wNewWord: WORD) -> WORD;
}
extern "C" {
    pub fn GetClassLongA(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> DWORD;
}
extern "C" {
    pub fn GetClassLongW(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> DWORD;
}
extern "C" {
    pub fn SetClassLongA(hWnd: HWND, nIndex: ::std::os::raw::c_int, dwNewLong: LONG) -> DWORD;
}
extern "C" {
    pub fn SetClassLongW(hWnd: HWND, nIndex: ::std::os::raw::c_int, dwNewLong: LONG) -> DWORD;
}
extern "C" {
    pub fn GetClassLongPtrA(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> ULONG_PTR;
}
extern "C" {
    pub fn GetClassLongPtrW(hWnd: HWND, nIndex: ::std::os::raw::c_int) -> ULONG_PTR;
}
extern "C" {
    pub fn SetClassLongPtrA(
        hWnd: HWND,
        nIndex: ::std::os::raw::c_int,
        dwNewLong: LONG_PTR,
    ) -> ULONG_PTR;
}
extern "C" {
    pub fn SetClassLongPtrW(
        hWnd: HWND,
        nIndex: ::std::os::raw::c_int,
        dwNewLong: LONG_PTR,
    ) -> ULONG_PTR;
}
extern "C" {
    pub fn GetProcessDefaultLayout(pdwDefaultLayout: *mut DWORD) -> BOOL;
}
extern "C" {
    pub fn SetProcessDefaultLayout(dwDefaultLayout: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetDesktopWindow() -> HWND;
}
extern "C" {
    pub fn GetParent(hWnd: HWND) -> HWND;
}
extern "C" {
    pub fn SetParent(hWndChild: HWND, hWndNewParent: HWND) -> HWND;
}
extern "C" {
    pub fn EnumChildWindows(hWndParent: HWND, lpEnumFunc: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn FindWindowA(lpClassName: LPCSTR, lpWindowName: LPCSTR) -> HWND;
}
extern "C" {
    pub fn FindWindowW(lpClassName: LPCWSTR, lpWindowName: LPCWSTR) -> HWND;
}
extern "C" {
    pub fn FindWindowExA(
        hWndParent: HWND,
        hWndChildAfter: HWND,
        lpszClass: LPCSTR,
        lpszWindow: LPCSTR,
    ) -> HWND;
}
extern "C" {
    pub fn FindWindowExW(
        hWndParent: HWND,
        hWndChildAfter: HWND,
        lpszClass: LPCWSTR,
        lpszWindow: LPCWSTR,
    ) -> HWND;
}
extern "C" {
    pub fn GetShellWindow() -> HWND;
}
extern "C" {
    pub fn RegisterShellHookWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn DeregisterShellHookWindow(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn EnumWindows(lpEnumFunc: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn EnumThreadWindows(dwThreadId: DWORD, lpfn: WNDENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn GetClassNameA(
        hWnd: HWND,
        lpClassName: LPSTR,
        nMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetClassNameW(
        hWnd: HWND,
        lpClassName: LPWSTR,
        nMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTopWindow(hWnd: HWND) -> HWND;
}
extern "C" {
    pub fn GetWindowThreadProcessId(hWnd: HWND, lpdwProcessId: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn IsGUIThread(bConvert: BOOL) -> BOOL;
}
extern "C" {
    pub fn GetLastActivePopup(hWnd: HWND) -> HWND;
}
extern "C" {
    pub fn GetWindow(hWnd: HWND, uCmd: UINT) -> HWND;
}
extern "C" {
    pub fn SetWindowsHookA(nFilterType: ::std::os::raw::c_int, pfnFilterProc: HOOKPROC) -> HHOOK;
}
extern "C" {
    pub fn SetWindowsHookW(nFilterType: ::std::os::raw::c_int, pfnFilterProc: HOOKPROC) -> HHOOK;
}
extern "C" {
    pub fn UnhookWindowsHook(nCode: ::std::os::raw::c_int, pfnFilterProc: HOOKPROC) -> BOOL;
}
extern "C" {
    pub fn SetWindowsHookExA(
        idHook: ::std::os::raw::c_int,
        lpfn: HOOKPROC,
        hmod: HINSTANCE,
        dwThreadId: DWORD,
    ) -> HHOOK;
}
extern "C" {
    pub fn SetWindowsHookExW(
        idHook: ::std::os::raw::c_int,
        lpfn: HOOKPROC,
        hmod: HINSTANCE,
        dwThreadId: DWORD,
    ) -> HHOOK;
}
extern "C" {
    pub fn UnhookWindowsHookEx(hhk: HHOOK) -> BOOL;
}
extern "C" {
    pub fn CallNextHookEx(
        hhk: HHOOK,
        nCode: ::std::os::raw::c_int,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn CheckMenuRadioItem(
        hmenu: HMENU,
        first: UINT,
        last: UINT,
        check: UINT,
        flags: UINT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MENUITEMTEMPLATEHEADER {
    pub versionNumber: WORD,
    pub offset: WORD,
}
pub type PMENUITEMTEMPLATEHEADER = *mut MENUITEMTEMPLATEHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MENUITEMTEMPLATE {
    pub mtOption: WORD,
    pub mtID: WORD,
    pub mtString: [WCHAR; 1usize],
}
pub type PMENUITEMTEMPLATE = *mut MENUITEMTEMPLATE;
extern "C" {
    pub fn LoadBitmapA(hInstance: HINSTANCE, lpBitmapName: LPCSTR) -> HBITMAP;
}
extern "C" {
    pub fn LoadBitmapW(hInstance: HINSTANCE, lpBitmapName: LPCWSTR) -> HBITMAP;
}
extern "C" {
    pub fn LoadCursorA(hInstance: HINSTANCE, lpCursorName: LPCSTR) -> HCURSOR;
}
extern "C" {
    pub fn LoadCursorW(hInstance: HINSTANCE, lpCursorName: LPCWSTR) -> HCURSOR;
}
extern "C" {
    pub fn LoadCursorFromFileA(lpFileName: LPCSTR) -> HCURSOR;
}
extern "C" {
    pub fn LoadCursorFromFileW(lpFileName: LPCWSTR) -> HCURSOR;
}
extern "C" {
    pub fn CreateCursor(
        hInst: HINSTANCE,
        xHotSpot: ::std::os::raw::c_int,
        yHotSpot: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        pvANDPlane: *const ::std::os::raw::c_void,
        pvXORPlane: *const ::std::os::raw::c_void,
    ) -> HCURSOR;
}
extern "C" {
    pub fn DestroyCursor(hCursor: HCURSOR) -> BOOL;
}
extern "C" {
    pub fn SetSystemCursor(hcur: HCURSOR, id: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ICONINFO {
    pub fIcon: BOOL,
    pub xHotspot: DWORD,
    pub yHotspot: DWORD,
    pub hbmMask: HBITMAP,
    pub hbmColor: HBITMAP,
}
pub type ICONINFO = _ICONINFO;
pub type PICONINFO = *mut ICONINFO;
extern "C" {
    pub fn LoadIconA(hInstance: HINSTANCE, lpIconName: LPCSTR) -> HICON;
}
extern "C" {
    pub fn LoadIconW(hInstance: HINSTANCE, lpIconName: LPCWSTR) -> HICON;
}
extern "C" {
    pub fn PrivateExtractIconsA(
        szFileName: LPCSTR,
        nIconIndex: ::std::os::raw::c_int,
        cxIcon: ::std::os::raw::c_int,
        cyIcon: ::std::os::raw::c_int,
        phicon: *mut HICON,
        piconid: *mut UINT,
        nIcons: UINT,
        flags: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn PrivateExtractIconsW(
        szFileName: LPCWSTR,
        nIconIndex: ::std::os::raw::c_int,
        cxIcon: ::std::os::raw::c_int,
        cyIcon: ::std::os::raw::c_int,
        phicon: *mut HICON,
        piconid: *mut UINT,
        nIcons: UINT,
        flags: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn CreateIcon(
        hInstance: HINSTANCE,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        cPlanes: BYTE,
        cBitsPixel: BYTE,
        lpbANDbits: *const BYTE,
        lpbXORbits: *const BYTE,
    ) -> HICON;
}
extern "C" {
    pub fn DestroyIcon(hIcon: HICON) -> BOOL;
}
extern "C" {
    pub fn LookupIconIdFromDirectory(presbits: PBYTE, fIcon: BOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LookupIconIdFromDirectoryEx(
        presbits: PBYTE,
        fIcon: BOOL,
        cxDesired: ::std::os::raw::c_int,
        cyDesired: ::std::os::raw::c_int,
        Flags: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CreateIconFromResource(
        presbits: PBYTE,
        dwResSize: DWORD,
        fIcon: BOOL,
        dwVer: DWORD,
    ) -> HICON;
}
extern "C" {
    pub fn CreateIconFromResourceEx(
        presbits: PBYTE,
        dwResSize: DWORD,
        fIcon: BOOL,
        dwVer: DWORD,
        cxDesired: ::std::os::raw::c_int,
        cyDesired: ::std::os::raw::c_int,
        Flags: UINT,
    ) -> HICON;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCURSORSHAPE {
    pub xHotSpot: ::std::os::raw::c_int,
    pub yHotSpot: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
    pub cbWidth: ::std::os::raw::c_int,
    pub Planes: BYTE,
    pub BitsPixel: BYTE,
}
pub type CURSORSHAPE = tagCURSORSHAPE;
pub type LPCURSORSHAPE = *mut tagCURSORSHAPE;
extern "C" {
    pub fn SetThreadCursorCreationScaling(cursorDpi: UINT) -> UINT;
}
extern "C" {
    pub fn LoadImageA(
        hInst: HINSTANCE,
        name: LPCSTR,
        type_: UINT,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        fuLoad: UINT,
    ) -> HANDLE;
}
extern "C" {
    pub fn LoadImageW(
        hInst: HINSTANCE,
        name: LPCWSTR,
        type_: UINT,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        fuLoad: UINT,
    ) -> HANDLE;
}
extern "C" {
    pub fn CopyImage(
        h: HANDLE,
        type_: UINT,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        flags: UINT,
    ) -> HANDLE;
}
extern "C" {
    pub fn DrawIconEx(
        hdc: HDC,
        xLeft: ::std::os::raw::c_int,
        yTop: ::std::os::raw::c_int,
        hIcon: HICON,
        cxWidth: ::std::os::raw::c_int,
        cyWidth: ::std::os::raw::c_int,
        istepIfAniCur: UINT,
        hbrFlickerFreeDraw: HBRUSH,
        diFlags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateIconIndirect(piconinfo: PICONINFO) -> HICON;
}
extern "C" {
    pub fn CopyIcon(hIcon: HICON) -> HICON;
}
extern "C" {
    pub fn GetIconInfo(hIcon: HICON, piconinfo: PICONINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ICONINFOEXA {
    pub cbSize: DWORD,
    pub fIcon: BOOL,
    pub xHotspot: DWORD,
    pub yHotspot: DWORD,
    pub hbmMask: HBITMAP,
    pub hbmColor: HBITMAP,
    pub wResID: WORD,
    pub szModName: [CHAR; 260usize],
    pub szResName: [CHAR; 260usize],
}
pub type ICONINFOEXA = _ICONINFOEXA;
pub type PICONINFOEXA = *mut _ICONINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ICONINFOEXW {
    pub cbSize: DWORD,
    pub fIcon: BOOL,
    pub xHotspot: DWORD,
    pub yHotspot: DWORD,
    pub hbmMask: HBITMAP,
    pub hbmColor: HBITMAP,
    pub wResID: WORD,
    pub szModName: [WCHAR; 260usize],
    pub szResName: [WCHAR; 260usize],
}
pub type ICONINFOEXW = _ICONINFOEXW;
pub type PICONINFOEXW = *mut _ICONINFOEXW;
pub type ICONINFOEX = ICONINFOEXA;
pub type PICONINFOEX = PICONINFOEXA;
extern "C" {
    pub fn GetIconInfoExA(hicon: HICON, piconinfo: PICONINFOEXA) -> BOOL;
}
extern "C" {
    pub fn GetIconInfoExW(hicon: HICON, piconinfo: PICONINFOEXW) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDIT_CONTROL_FEATURE {
    EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0,
    EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1,
}
extern "C" {
    pub fn IsDialogMessageA(hDlg: HWND, lpMsg: LPMSG) -> BOOL;
}
extern "C" {
    pub fn IsDialogMessageW(hDlg: HWND, lpMsg: LPMSG) -> BOOL;
}
extern "C" {
    pub fn MapDialogRect(hDlg: HWND, lpRect: LPRECT) -> BOOL;
}
extern "C" {
    pub fn DlgDirListA(
        hDlg: HWND,
        lpPathSpec: LPSTR,
        nIDListBox: ::std::os::raw::c_int,
        nIDStaticPath: ::std::os::raw::c_int,
        uFileType: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DlgDirListW(
        hDlg: HWND,
        lpPathSpec: LPWSTR,
        nIDListBox: ::std::os::raw::c_int,
        nIDStaticPath: ::std::os::raw::c_int,
        uFileType: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DlgDirSelectExA(
        hwndDlg: HWND,
        lpString: LPSTR,
        chCount: ::std::os::raw::c_int,
        idListBox: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn DlgDirSelectExW(
        hwndDlg: HWND,
        lpString: LPWSTR,
        chCount: ::std::os::raw::c_int,
        idListBox: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn DlgDirListComboBoxA(
        hDlg: HWND,
        lpPathSpec: LPSTR,
        nIDComboBox: ::std::os::raw::c_int,
        nIDStaticPath: ::std::os::raw::c_int,
        uFiletype: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DlgDirListComboBoxW(
        hDlg: HWND,
        lpPathSpec: LPWSTR,
        nIDComboBox: ::std::os::raw::c_int,
        nIDStaticPath: ::std::os::raw::c_int,
        uFiletype: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DlgDirSelectComboBoxExA(
        hwndDlg: HWND,
        lpString: LPSTR,
        cchOut: ::std::os::raw::c_int,
        idComboBox: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn DlgDirSelectComboBoxExW(
        hwndDlg: HWND,
        lpString: LPWSTR,
        cchOut: ::std::os::raw::c_int,
        idComboBox: ::std::os::raw::c_int,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSCROLLINFO {
    pub cbSize: UINT,
    pub fMask: UINT,
    pub nMin: ::std::os::raw::c_int,
    pub nMax: ::std::os::raw::c_int,
    pub nPage: UINT,
    pub nPos: ::std::os::raw::c_int,
    pub nTrackPos: ::std::os::raw::c_int,
}
pub type SCROLLINFO = tagSCROLLINFO;
pub type LPSCROLLINFO = *mut tagSCROLLINFO;
pub type LPCSCROLLINFO = *const SCROLLINFO;
extern "C" {
    pub fn SetScrollInfo(
        hwnd: HWND,
        nBar: ::std::os::raw::c_int,
        lpsi: LPCSCROLLINFO,
        redraw: BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetScrollInfo(hwnd: HWND, nBar: ::std::os::raw::c_int, lpsi: LPSCROLLINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMDICREATESTRUCTA {
    pub szClass: LPCSTR,
    pub szTitle: LPCSTR,
    pub hOwner: HANDLE,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
    pub style: DWORD,
    pub lParam: LPARAM,
}
pub type MDICREATESTRUCTA = tagMDICREATESTRUCTA;
pub type LPMDICREATESTRUCTA = *mut tagMDICREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMDICREATESTRUCTW {
    pub szClass: LPCWSTR,
    pub szTitle: LPCWSTR,
    pub hOwner: HANDLE,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub cx: ::std::os::raw::c_int,
    pub cy: ::std::os::raw::c_int,
    pub style: DWORD,
    pub lParam: LPARAM,
}
pub type MDICREATESTRUCTW = tagMDICREATESTRUCTW;
pub type LPMDICREATESTRUCTW = *mut tagMDICREATESTRUCTW;
pub type MDICREATESTRUCT = MDICREATESTRUCTA;
pub type LPMDICREATESTRUCT = LPMDICREATESTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCLIENTCREATESTRUCT {
    pub hWindowMenu: HANDLE,
    pub idFirstChild: UINT,
}
pub type CLIENTCREATESTRUCT = tagCLIENTCREATESTRUCT;
pub type LPCLIENTCREATESTRUCT = *mut tagCLIENTCREATESTRUCT;
extern "C" {
    pub fn DefFrameProcA(
        hWnd: HWND,
        hWndMDIClient: HWND,
        uMsg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn DefFrameProcW(
        hWnd: HWND,
        hWndMDIClient: HWND,
        uMsg: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn DefMDIChildProcA(hWnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn DefMDIChildProcW(hWnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn TranslateMDISysAccel(hWndClient: HWND, lpMsg: LPMSG) -> BOOL;
}
extern "C" {
    pub fn ArrangeIconicWindows(hWnd: HWND) -> UINT;
}
extern "C" {
    pub fn CreateMDIWindowA(
        lpClassName: LPCSTR,
        lpWindowName: LPCSTR,
        dwStyle: DWORD,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        hWndParent: HWND,
        hInstance: HINSTANCE,
        lParam: LPARAM,
    ) -> HWND;
}
extern "C" {
    pub fn CreateMDIWindowW(
        lpClassName: LPCWSTR,
        lpWindowName: LPCWSTR,
        dwStyle: DWORD,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        hWndParent: HWND,
        hInstance: HINSTANCE,
        lParam: LPARAM,
    ) -> HWND;
}
extern "C" {
    pub fn TileWindows(
        hwndParent: HWND,
        wHow: UINT,
        lpRect: *const RECT,
        cKids: UINT,
        lpKids: *const HWND,
    ) -> WORD;
}
extern "C" {
    pub fn CascadeWindows(
        hwndParent: HWND,
        wHow: UINT,
        lpRect: *const RECT,
        cKids: UINT,
        lpKids: *const HWND,
    ) -> WORD;
}
pub type HELPPOLY = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMULTIKEYHELPA {
    pub mkSize: DWORD,
    pub mkKeylist: CHAR,
    pub szKeyphrase: [CHAR; 1usize],
}
pub type MULTIKEYHELPA = tagMULTIKEYHELPA;
pub type PMULTIKEYHELPA = *mut tagMULTIKEYHELPA;
pub type LPMULTIKEYHELPA = *mut tagMULTIKEYHELPA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMULTIKEYHELPW {
    pub mkSize: DWORD,
    pub mkKeylist: WCHAR,
    pub szKeyphrase: [WCHAR; 1usize],
}
pub type MULTIKEYHELPW = tagMULTIKEYHELPW;
pub type PMULTIKEYHELPW = *mut tagMULTIKEYHELPW;
pub type LPMULTIKEYHELPW = *mut tagMULTIKEYHELPW;
pub type MULTIKEYHELP = MULTIKEYHELPA;
pub type PMULTIKEYHELP = PMULTIKEYHELPA;
pub type LPMULTIKEYHELP = LPMULTIKEYHELPA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHELPWININFOA {
    pub wStructSize: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub dx: ::std::os::raw::c_int,
    pub dy: ::std::os::raw::c_int,
    pub wMax: ::std::os::raw::c_int,
    pub rgchMember: [CHAR; 2usize],
}
pub type HELPWININFOA = tagHELPWININFOA;
pub type PHELPWININFOA = *mut tagHELPWININFOA;
pub type LPHELPWININFOA = *mut tagHELPWININFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHELPWININFOW {
    pub wStructSize: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub dx: ::std::os::raw::c_int,
    pub dy: ::std::os::raw::c_int,
    pub wMax: ::std::os::raw::c_int,
    pub rgchMember: [WCHAR; 2usize],
}
pub type HELPWININFOW = tagHELPWININFOW;
pub type PHELPWININFOW = *mut tagHELPWININFOW;
pub type LPHELPWININFOW = *mut tagHELPWININFOW;
pub type HELPWININFO = HELPWININFOA;
pub type PHELPWININFO = PHELPWININFOA;
pub type LPHELPWININFO = LPHELPWININFOA;
extern "C" {
    pub fn WinHelpA(hWndMain: HWND, lpszHelp: LPCSTR, uCommand: UINT, dwData: ULONG_PTR) -> BOOL;
}
extern "C" {
    pub fn WinHelpW(hWndMain: HWND, lpszHelp: LPCWSTR, uCommand: UINT, dwData: ULONG_PTR) -> BOOL;
}
extern "C" {
    pub fn GetGuiResources(hProcess: HANDLE, uiFlags: DWORD) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTouchPredictionParameters {
    pub cbSize: UINT,
    pub dwLatency: UINT,
    pub dwSampleTime: UINT,
    pub bUseHWTimeStamp: UINT,
}
pub type TOUCHPREDICTIONPARAMETERS = tagTouchPredictionParameters;
pub type PTOUCHPREDICTIONPARAMETERS = *mut tagTouchPredictionParameters;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagHANDEDNESS {
    HANDEDNESS_LEFT = 0,
    HANDEDNESS_RIGHT = 1,
}
pub use self::tagHANDEDNESS as HANDEDNESS;
pub type PHANDEDNESS = *mut tagHANDEDNESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNONCLIENTMETRICSA {
    pub cbSize: UINT,
    pub iBorderWidth: ::std::os::raw::c_int,
    pub iScrollWidth: ::std::os::raw::c_int,
    pub iScrollHeight: ::std::os::raw::c_int,
    pub iCaptionWidth: ::std::os::raw::c_int,
    pub iCaptionHeight: ::std::os::raw::c_int,
    pub lfCaptionFont: LOGFONTA,
    pub iSmCaptionWidth: ::std::os::raw::c_int,
    pub iSmCaptionHeight: ::std::os::raw::c_int,
    pub lfSmCaptionFont: LOGFONTA,
    pub iMenuWidth: ::std::os::raw::c_int,
    pub iMenuHeight: ::std::os::raw::c_int,
    pub lfMenuFont: LOGFONTA,
    pub lfStatusFont: LOGFONTA,
    pub lfMessageFont: LOGFONTA,
    pub iPaddedBorderWidth: ::std::os::raw::c_int,
}
pub type NONCLIENTMETRICSA = tagNONCLIENTMETRICSA;
pub type PNONCLIENTMETRICSA = *mut tagNONCLIENTMETRICSA;
pub type LPNONCLIENTMETRICSA = *mut tagNONCLIENTMETRICSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNONCLIENTMETRICSW {
    pub cbSize: UINT,
    pub iBorderWidth: ::std::os::raw::c_int,
    pub iScrollWidth: ::std::os::raw::c_int,
    pub iScrollHeight: ::std::os::raw::c_int,
    pub iCaptionWidth: ::std::os::raw::c_int,
    pub iCaptionHeight: ::std::os::raw::c_int,
    pub lfCaptionFont: LOGFONTW,
    pub iSmCaptionWidth: ::std::os::raw::c_int,
    pub iSmCaptionHeight: ::std::os::raw::c_int,
    pub lfSmCaptionFont: LOGFONTW,
    pub iMenuWidth: ::std::os::raw::c_int,
    pub iMenuHeight: ::std::os::raw::c_int,
    pub lfMenuFont: LOGFONTW,
    pub lfStatusFont: LOGFONTW,
    pub lfMessageFont: LOGFONTW,
    pub iPaddedBorderWidth: ::std::os::raw::c_int,
}
pub type NONCLIENTMETRICSW = tagNONCLIENTMETRICSW;
pub type PNONCLIENTMETRICSW = *mut tagNONCLIENTMETRICSW;
pub type LPNONCLIENTMETRICSW = *mut tagNONCLIENTMETRICSW;
pub type NONCLIENTMETRICS = NONCLIENTMETRICSA;
pub type PNONCLIENTMETRICS = PNONCLIENTMETRICSA;
pub type LPNONCLIENTMETRICS = LPNONCLIENTMETRICSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMINIMIZEDMETRICS {
    pub cbSize: UINT,
    pub iWidth: ::std::os::raw::c_int,
    pub iHorzGap: ::std::os::raw::c_int,
    pub iVertGap: ::std::os::raw::c_int,
    pub iArrange: ::std::os::raw::c_int,
}
pub type MINIMIZEDMETRICS = tagMINIMIZEDMETRICS;
pub type PMINIMIZEDMETRICS = *mut tagMINIMIZEDMETRICS;
pub type LPMINIMIZEDMETRICS = *mut tagMINIMIZEDMETRICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagICONMETRICSA {
    pub cbSize: UINT,
    pub iHorzSpacing: ::std::os::raw::c_int,
    pub iVertSpacing: ::std::os::raw::c_int,
    pub iTitleWrap: ::std::os::raw::c_int,
    pub lfFont: LOGFONTA,
}
pub type ICONMETRICSA = tagICONMETRICSA;
pub type PICONMETRICSA = *mut tagICONMETRICSA;
pub type LPICONMETRICSA = *mut tagICONMETRICSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagICONMETRICSW {
    pub cbSize: UINT,
    pub iHorzSpacing: ::std::os::raw::c_int,
    pub iVertSpacing: ::std::os::raw::c_int,
    pub iTitleWrap: ::std::os::raw::c_int,
    pub lfFont: LOGFONTW,
}
pub type ICONMETRICSW = tagICONMETRICSW;
pub type PICONMETRICSW = *mut tagICONMETRICSW;
pub type LPICONMETRICSW = *mut tagICONMETRICSW;
pub type ICONMETRICS = ICONMETRICSA;
pub type PICONMETRICS = PICONMETRICSA;
pub type LPICONMETRICS = LPICONMETRICSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagANIMATIONINFO {
    pub cbSize: UINT,
    pub iMinAnimate: ::std::os::raw::c_int,
}
pub type ANIMATIONINFO = tagANIMATIONINFO;
pub type LPANIMATIONINFO = *mut tagANIMATIONINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALKEYSA {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub lpszActivePort: LPSTR,
    pub lpszPort: LPSTR,
    pub iBaudRate: UINT,
    pub iPortState: UINT,
    pub iActive: UINT,
}
pub type SERIALKEYSA = tagSERIALKEYSA;
pub type LPSERIALKEYSA = *mut tagSERIALKEYSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALKEYSW {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub lpszActivePort: LPWSTR,
    pub lpszPort: LPWSTR,
    pub iBaudRate: UINT,
    pub iPortState: UINT,
    pub iActive: UINT,
}
pub type SERIALKEYSW = tagSERIALKEYSW;
pub type LPSERIALKEYSW = *mut tagSERIALKEYSW;
pub type SERIALKEYS = SERIALKEYSA;
pub type LPSERIALKEYS = LPSERIALKEYSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHIGHCONTRASTA {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub lpszDefaultScheme: LPSTR,
}
pub type HIGHCONTRASTA = tagHIGHCONTRASTA;
pub type LPHIGHCONTRASTA = *mut tagHIGHCONTRASTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHIGHCONTRASTW {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub lpszDefaultScheme: LPWSTR,
}
pub type HIGHCONTRASTW = tagHIGHCONTRASTW;
pub type LPHIGHCONTRASTW = *mut tagHIGHCONTRASTW;
pub type HIGHCONTRAST = HIGHCONTRASTA;
pub type LPHIGHCONTRAST = LPHIGHCONTRASTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIDEOPARAMETERS {
    pub Guid: GUID,
    pub dwOffset: ULONG,
    pub dwCommand: ULONG,
    pub dwFlags: ULONG,
    pub dwMode: ULONG,
    pub dwTVStandard: ULONG,
    pub dwAvailableModes: ULONG,
    pub dwAvailableTVStandard: ULONG,
    pub dwFlickerFilter: ULONG,
    pub dwOverScanX: ULONG,
    pub dwOverScanY: ULONG,
    pub dwMaxUnscaledX: ULONG,
    pub dwMaxUnscaledY: ULONG,
    pub dwPositionX: ULONG,
    pub dwPositionY: ULONG,
    pub dwBrightness: ULONG,
    pub dwContrast: ULONG,
    pub dwCPType: ULONG,
    pub dwCPCommand: ULONG,
    pub dwCPStandard: ULONG,
    pub dwCPKey: ULONG,
    pub bCP_APSTriggerBits: ULONG,
    pub bOEMCopyProtection: [UCHAR; 256usize],
}
pub type VIDEOPARAMETERS = _VIDEOPARAMETERS;
pub type PVIDEOPARAMETERS = *mut _VIDEOPARAMETERS;
pub type LPVIDEOPARAMETERS = *mut _VIDEOPARAMETERS;
extern "C" {
    pub fn ChangeDisplaySettingsA(lpDevMode: *mut DEVMODEA, dwFlags: DWORD) -> LONG;
}
extern "C" {
    pub fn ChangeDisplaySettingsW(lpDevMode: *mut DEVMODEW, dwFlags: DWORD) -> LONG;
}
extern "C" {
    pub fn ChangeDisplaySettingsExA(
        lpszDeviceName: LPCSTR,
        lpDevMode: *mut DEVMODEA,
        hwnd: HWND,
        dwflags: DWORD,
        lParam: LPVOID,
    ) -> LONG;
}
extern "C" {
    pub fn ChangeDisplaySettingsExW(
        lpszDeviceName: LPCWSTR,
        lpDevMode: *mut DEVMODEW,
        hwnd: HWND,
        dwflags: DWORD,
        lParam: LPVOID,
    ) -> LONG;
}
extern "C" {
    pub fn EnumDisplaySettingsA(
        lpszDeviceName: LPCSTR,
        iModeNum: DWORD,
        lpDevMode: *mut DEVMODEA,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDisplaySettingsW(
        lpszDeviceName: LPCWSTR,
        iModeNum: DWORD,
        lpDevMode: *mut DEVMODEW,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDisplaySettingsExA(
        lpszDeviceName: LPCSTR,
        iModeNum: DWORD,
        lpDevMode: *mut DEVMODEA,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDisplaySettingsExW(
        lpszDeviceName: LPCWSTR,
        iModeNum: DWORD,
        lpDevMode: *mut DEVMODEW,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDisplayDevicesA(
        lpDevice: LPCSTR,
        iDevNum: DWORD,
        lpDisplayDevice: PDISPLAY_DEVICEA,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDisplayDevicesW(
        lpDevice: LPCWSTR,
        iDevNum: DWORD,
        lpDisplayDevice: PDISPLAY_DEVICEW,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDisplayConfigBufferSizes(
        flags: UINT32,
        numPathArrayElements: *mut UINT32,
        numModeInfoArrayElements: *mut UINT32,
    ) -> LONG;
}
extern "C" {
    pub fn SetDisplayConfig(
        numPathArrayElements: UINT32,
        pathArray: *mut DISPLAYCONFIG_PATH_INFO,
        numModeInfoArrayElements: UINT32,
        modeInfoArray: *mut DISPLAYCONFIG_MODE_INFO,
        flags: UINT32,
    ) -> LONG;
}
extern "C" {
    pub fn QueryDisplayConfig(
        flags: UINT32,
        numPathArrayElements: *mut UINT32,
        pathArray: *mut DISPLAYCONFIG_PATH_INFO,
        numModeInfoArrayElements: *mut UINT32,
        modeInfoArray: *mut DISPLAYCONFIG_MODE_INFO,
        currentTopologyId: *mut DISPLAYCONFIG_TOPOLOGY_ID,
    ) -> LONG;
}
extern "C" {
    pub fn DisplayConfigGetDeviceInfo(requestPacket: *mut DISPLAYCONFIG_DEVICE_INFO_HEADER)
        -> LONG;
}
extern "C" {
    pub fn DisplayConfigSetDeviceInfo(setPacket: *mut DISPLAYCONFIG_DEVICE_INFO_HEADER) -> LONG;
}
extern "C" {
    pub fn SystemParametersInfoA(
        uiAction: UINT,
        uiParam: UINT,
        pvParam: PVOID,
        fWinIni: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn SystemParametersInfoW(
        uiAction: UINT,
        uiParam: UINT,
        pvParam: PVOID,
        fWinIni: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn SystemParametersInfoForDpi(
        uiAction: UINT,
        uiParam: UINT,
        pvParam: PVOID,
        fWinIni: UINT,
        dpi: UINT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFILTERKEYS {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub iWaitMSec: DWORD,
    pub iDelayMSec: DWORD,
    pub iRepeatMSec: DWORD,
    pub iBounceMSec: DWORD,
}
pub type FILTERKEYS = tagFILTERKEYS;
pub type LPFILTERKEYS = *mut tagFILTERKEYS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTICKYKEYS {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
}
pub type STICKYKEYS = tagSTICKYKEYS;
pub type LPSTICKYKEYS = *mut tagSTICKYKEYS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMOUSEKEYS {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub iMaxSpeed: DWORD,
    pub iTimeToMaxSpeed: DWORD,
    pub iCtrlSpeed: DWORD,
    pub dwReserved1: DWORD,
    pub dwReserved2: DWORD,
}
pub type MOUSEKEYS = tagMOUSEKEYS;
pub type LPMOUSEKEYS = *mut tagMOUSEKEYS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagACCESSTIMEOUT {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub iTimeOutMSec: DWORD,
}
pub type ACCESSTIMEOUT = tagACCESSTIMEOUT;
pub type LPACCESSTIMEOUT = *mut tagACCESSTIMEOUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOUNDSENTRYA {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub iFSTextEffect: DWORD,
    pub iFSTextEffectMSec: DWORD,
    pub iFSTextEffectColorBits: DWORD,
    pub iFSGrafEffect: DWORD,
    pub iFSGrafEffectMSec: DWORD,
    pub iFSGrafEffectColor: DWORD,
    pub iWindowsEffect: DWORD,
    pub iWindowsEffectMSec: DWORD,
    pub lpszWindowsEffectDLL: LPSTR,
    pub iWindowsEffectOrdinal: DWORD,
}
pub type SOUNDSENTRYA = tagSOUNDSENTRYA;
pub type LPSOUNDSENTRYA = *mut tagSOUNDSENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOUNDSENTRYW {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub iFSTextEffect: DWORD,
    pub iFSTextEffectMSec: DWORD,
    pub iFSTextEffectColorBits: DWORD,
    pub iFSGrafEffect: DWORD,
    pub iFSGrafEffectMSec: DWORD,
    pub iFSGrafEffectColor: DWORD,
    pub iWindowsEffect: DWORD,
    pub iWindowsEffectMSec: DWORD,
    pub lpszWindowsEffectDLL: LPWSTR,
    pub iWindowsEffectOrdinal: DWORD,
}
pub type SOUNDSENTRYW = tagSOUNDSENTRYW;
pub type LPSOUNDSENTRYW = *mut tagSOUNDSENTRYW;
pub type SOUNDSENTRY = SOUNDSENTRYA;
pub type LPSOUNDSENTRY = LPSOUNDSENTRYA;
extern "C" {
    pub fn SoundSentry() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTOGGLEKEYS {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
}
pub type TOGGLEKEYS = tagTOGGLEKEYS;
pub type LPTOGGLEKEYS = *mut tagTOGGLEKEYS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagAUDIODESCRIPTION {
    pub cbSize: UINT,
    pub Enabled: BOOL,
    pub Locale: LCID,
}
pub type AUDIODESCRIPTION = tagAUDIODESCRIPTION;
pub type LPAUDIODESCRIPTION = *mut tagAUDIODESCRIPTION;
extern "C" {
    pub fn SetDebugErrorLevel(dwLevel: DWORD);
}
extern "C" {
    pub fn SetLastErrorEx(dwErrCode: DWORD, dwType: DWORD);
}
extern "C" {
    pub fn InternalGetWindowText(
        hWnd: HWND,
        pString: LPWSTR,
        cchMaxCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CancelShutdown() -> BOOL;
}
extern "C" {
    pub fn MonitorFromPoint(pt: POINT, dwFlags: DWORD) -> HMONITOR;
}
extern "C" {
    pub fn MonitorFromRect(lprc: LPCRECT, dwFlags: DWORD) -> HMONITOR;
}
extern "C" {
    pub fn MonitorFromWindow(hwnd: HWND, dwFlags: DWORD) -> HMONITOR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONITORINFO {
    pub cbSize: DWORD,
    pub rcMonitor: RECT,
    pub rcWork: RECT,
    pub dwFlags: DWORD,
}
pub type MONITORINFO = tagMONITORINFO;
pub type LPMONITORINFO = *mut tagMONITORINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONITORINFOEXA {
    pub _base: tagMONITORINFO,
    pub szDevice: [CHAR; 32usize],
}
pub type MONITORINFOEXA = tagMONITORINFOEXA;
pub type LPMONITORINFOEXA = *mut tagMONITORINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONITORINFOEXW {
    pub _base: tagMONITORINFO,
    pub szDevice: [WCHAR; 32usize],
}
pub type MONITORINFOEXW = tagMONITORINFOEXW;
pub type LPMONITORINFOEXW = *mut tagMONITORINFOEXW;
pub type MONITORINFOEX = MONITORINFOEXA;
pub type LPMONITORINFOEX = LPMONITORINFOEXA;
extern "C" {
    pub fn GetMonitorInfoA(hMonitor: HMONITOR, lpmi: LPMONITORINFO) -> BOOL;
}
extern "C" {
    pub fn GetMonitorInfoW(hMonitor: HMONITOR, lpmi: LPMONITORINFO) -> BOOL;
}
pub type MONITORENUMPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HMONITOR, arg2: HDC, arg3: LPRECT, arg4: LPARAM) -> BOOL,
>;
extern "C" {
    pub fn EnumDisplayMonitors(
        hdc: HDC,
        lprcClip: LPCRECT,
        lpfnEnum: MONITORENUMPROC,
        dwData: LPARAM,
    ) -> BOOL;
}
extern "C" {
    pub fn NotifyWinEvent(event: DWORD, hwnd: HWND, idObject: LONG, idChild: LONG);
}
pub type WINEVENTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        hWinEventHook: HWINEVENTHOOK,
        event: DWORD,
        hwnd: HWND,
        idObject: LONG,
        idChild: LONG,
        idEventThread: DWORD,
        dwmsEventTime: DWORD,
    ),
>;
extern "C" {
    pub fn SetWinEventHook(
        eventMin: DWORD,
        eventMax: DWORD,
        hmodWinEventProc: HMODULE,
        pfnWinEventProc: WINEVENTPROC,
        idProcess: DWORD,
        idThread: DWORD,
        dwFlags: DWORD,
    ) -> HWINEVENTHOOK;
}
extern "C" {
    pub fn IsWinEventHookInstalled(event: DWORD) -> BOOL;
}
extern "C" {
    pub fn UnhookWinEvent(hWinEventHook: HWINEVENTHOOK) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGUITHREADINFO {
    pub cbSize: DWORD,
    pub flags: DWORD,
    pub hwndActive: HWND,
    pub hwndFocus: HWND,
    pub hwndCapture: HWND,
    pub hwndMenuOwner: HWND,
    pub hwndMoveSize: HWND,
    pub hwndCaret: HWND,
    pub rcCaret: RECT,
}
pub type GUITHREADINFO = tagGUITHREADINFO;
pub type PGUITHREADINFO = *mut tagGUITHREADINFO;
pub type LPGUITHREADINFO = *mut tagGUITHREADINFO;
extern "C" {
    pub fn GetGUIThreadInfo(idThread: DWORD, pgui: PGUITHREADINFO) -> BOOL;
}
extern "C" {
    pub fn BlockInput(fBlockIt: BOOL) -> BOOL;
}
extern "C" {
    pub fn SetProcessDPIAware() -> BOOL;
}
extern "C" {
    pub fn IsProcessDPIAware() -> BOOL;
}
extern "C" {
    pub fn SetThreadDpiAwarenessContext(dpiContext: DPI_AWARENESS_CONTEXT)
        -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
    pub fn GetThreadDpiAwarenessContext() -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
    pub fn GetWindowDpiAwarenessContext(hwnd: HWND) -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
    pub fn GetAwarenessFromDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> DPI_AWARENESS;
}
extern "C" {
    pub fn GetDpiFromDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> UINT;
}
extern "C" {
    pub fn AreDpiAwarenessContextsEqual(
        dpiContextA: DPI_AWARENESS_CONTEXT,
        dpiContextB: DPI_AWARENESS_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn IsValidDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn GetDpiForWindow(hwnd: HWND) -> UINT;
}
extern "C" {
    pub fn GetDpiForSystem() -> UINT;
}
extern "C" {
    pub fn GetSystemDpiForProcess(hProcess: HANDLE) -> UINT;
}
extern "C" {
    pub fn EnableNonClientDpiScaling(hwnd: HWND) -> BOOL;
}
extern "C" {
    pub fn InheritWindowMonitor(hwnd: HWND, hwndInherit: HWND) -> BOOL;
}
extern "C" {
    pub fn SetProcessDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn GetDpiAwarenessContextForProcess(hProcess: HANDLE) -> DPI_AWARENESS_CONTEXT;
}
extern "C" {
    pub fn SetThreadDpiHostingBehavior(value: DPI_HOSTING_BEHAVIOR) -> DPI_HOSTING_BEHAVIOR;
}
extern "C" {
    pub fn GetThreadDpiHostingBehavior() -> DPI_HOSTING_BEHAVIOR;
}
extern "C" {
    pub fn GetWindowDpiHostingBehavior(hwnd: HWND) -> DPI_HOSTING_BEHAVIOR;
}
extern "C" {
    pub fn GetWindowModuleFileNameA(hwnd: HWND, pszFileName: LPSTR, cchFileNameMax: UINT) -> UINT;
}
extern "C" {
    pub fn GetWindowModuleFileNameW(hwnd: HWND, pszFileName: LPWSTR, cchFileNameMax: UINT) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCURSORINFO {
    pub cbSize: DWORD,
    pub flags: DWORD,
    pub hCursor: HCURSOR,
    pub ptScreenPos: POINT,
}
pub type CURSORINFO = tagCURSORINFO;
pub type PCURSORINFO = *mut tagCURSORINFO;
pub type LPCURSORINFO = *mut tagCURSORINFO;
extern "C" {
    pub fn GetCursorInfo(pci: PCURSORINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagWINDOWINFO {
    pub cbSize: DWORD,
    pub rcWindow: RECT,
    pub rcClient: RECT,
    pub dwStyle: DWORD,
    pub dwExStyle: DWORD,
    pub dwWindowStatus: DWORD,
    pub cxWindowBorders: UINT,
    pub cyWindowBorders: UINT,
    pub atomWindowType: ATOM,
    pub wCreatorVersion: WORD,
}
pub type WINDOWINFO = tagWINDOWINFO;
pub type PWINDOWINFO = *mut tagWINDOWINFO;
pub type LPWINDOWINFO = *mut tagWINDOWINFO;
extern "C" {
    pub fn GetWindowInfo(hwnd: HWND, pwi: PWINDOWINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTITLEBARINFO {
    pub cbSize: DWORD,
    pub rcTitleBar: RECT,
    pub rgstate: [DWORD; 6usize],
}
pub type TITLEBARINFO = tagTITLEBARINFO;
pub type PTITLEBARINFO = *mut tagTITLEBARINFO;
pub type LPTITLEBARINFO = *mut tagTITLEBARINFO;
extern "C" {
    pub fn GetTitleBarInfo(hwnd: HWND, pti: PTITLEBARINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTITLEBARINFOEX {
    pub cbSize: DWORD,
    pub rcTitleBar: RECT,
    pub rgstate: [DWORD; 6usize],
    pub rgrect: [RECT; 6usize],
}
pub type TITLEBARINFOEX = tagTITLEBARINFOEX;
pub type PTITLEBARINFOEX = *mut tagTITLEBARINFOEX;
pub type LPTITLEBARINFOEX = *mut tagTITLEBARINFOEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMENUBARINFO {
    pub cbSize: DWORD,
    pub rcBar: RECT,
    pub hMenu: HMENU,
    pub hwndMenu: HWND,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl tagMENUBARINFO {
    #[inline]
    pub fn fBarFocused(&self) -> BOOL {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fBarFocused(&mut self, val: BOOL) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fFocused(&self) -> BOOL {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fFocused(&mut self, val: BOOL) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUnused(&self) -> BOOL {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_fUnused(&mut self, val: BOOL) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fBarFocused: BOOL,
        fFocused: BOOL,
        fUnused: BOOL,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fBarFocused: u32 = unsafe { ::std::mem::transmute(fBarFocused) };
            fBarFocused as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fFocused: u32 = unsafe { ::std::mem::transmute(fFocused) };
            fFocused as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let fUnused: u32 = unsafe { ::std::mem::transmute(fUnused) };
            fUnused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MENUBARINFO = tagMENUBARINFO;
pub type PMENUBARINFO = *mut tagMENUBARINFO;
pub type LPMENUBARINFO = *mut tagMENUBARINFO;
extern "C" {
    pub fn GetMenuBarInfo(hwnd: HWND, idObject: LONG, idItem: LONG, pmbi: PMENUBARINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSCROLLBARINFO {
    pub cbSize: DWORD,
    pub rcScrollBar: RECT,
    pub dxyLineButton: ::std::os::raw::c_int,
    pub xyThumbTop: ::std::os::raw::c_int,
    pub xyThumbBottom: ::std::os::raw::c_int,
    pub reserved: ::std::os::raw::c_int,
    pub rgstate: [DWORD; 6usize],
}
pub type SCROLLBARINFO = tagSCROLLBARINFO;
pub type PSCROLLBARINFO = *mut tagSCROLLBARINFO;
pub type LPSCROLLBARINFO = *mut tagSCROLLBARINFO;
extern "C" {
    pub fn GetScrollBarInfo(hwnd: HWND, idObject: LONG, psbi: PSCROLLBARINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOMBOBOXINFO {
    pub cbSize: DWORD,
    pub rcItem: RECT,
    pub rcButton: RECT,
    pub stateButton: DWORD,
    pub hwndCombo: HWND,
    pub hwndItem: HWND,
    pub hwndList: HWND,
}
pub type COMBOBOXINFO = tagCOMBOBOXINFO;
pub type PCOMBOBOXINFO = *mut tagCOMBOBOXINFO;
pub type LPCOMBOBOXINFO = *mut tagCOMBOBOXINFO;
extern "C" {
    pub fn GetComboBoxInfo(hwndCombo: HWND, pcbi: PCOMBOBOXINFO) -> BOOL;
}
extern "C" {
    pub fn GetAncestor(hwnd: HWND, gaFlags: UINT) -> HWND;
}
extern "C" {
    pub fn RealChildWindowFromPoint(hwndParent: HWND, ptParentClientCoords: POINT) -> HWND;
}
extern "C" {
    pub fn RealGetWindowClassA(hwnd: HWND, ptszClassName: LPSTR, cchClassNameMax: UINT) -> UINT;
}
extern "C" {
    pub fn RealGetWindowClassW(hwnd: HWND, ptszClassName: LPWSTR, cchClassNameMax: UINT) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagALTTABINFO {
    pub cbSize: DWORD,
    pub cItems: ::std::os::raw::c_int,
    pub cColumns: ::std::os::raw::c_int,
    pub cRows: ::std::os::raw::c_int,
    pub iColFocus: ::std::os::raw::c_int,
    pub iRowFocus: ::std::os::raw::c_int,
    pub cxItem: ::std::os::raw::c_int,
    pub cyItem: ::std::os::raw::c_int,
    pub ptStart: POINT,
}
pub type ALTTABINFO = tagALTTABINFO;
pub type PALTTABINFO = *mut tagALTTABINFO;
pub type LPALTTABINFO = *mut tagALTTABINFO;
extern "C" {
    pub fn GetAltTabInfoA(
        hwnd: HWND,
        iItem: ::std::os::raw::c_int,
        pati: PALTTABINFO,
        pszItemText: LPSTR,
        cchItemText: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetAltTabInfoW(
        hwnd: HWND,
        iItem: ::std::os::raw::c_int,
        pati: PALTTABINFO,
        pszItemText: LPWSTR,
        cchItemText: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetListBoxInfo(hwnd: HWND) -> DWORD;
}
extern "C" {
    pub fn LockWorkStation() -> BOOL;
}
extern "C" {
    pub fn UserHandleGrantAccess(hUserHandle: HANDLE, hJob: HANDLE, bGrant: BOOL) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRAWINPUT__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HRAWINPUT = *mut HRAWINPUT__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWINPUTHEADER {
    pub dwType: DWORD,
    pub dwSize: DWORD,
    pub hDevice: HANDLE,
    pub wParam: WPARAM,
}
pub type RAWINPUTHEADER = tagRAWINPUTHEADER;
pub type PRAWINPUTHEADER = *mut tagRAWINPUTHEADER;
pub type LPRAWINPUTHEADER = *mut tagRAWINPUTHEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRAWMOUSE {
    pub usFlags: USHORT,
    pub __bindgen_anon_1: tagRAWMOUSE__bindgen_ty_1,
    pub ulRawButtons: ULONG,
    pub lLastX: LONG,
    pub lLastY: LONG,
    pub ulExtraInformation: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRAWMOUSE__bindgen_ty_1 {
    pub ulButtons: ULONG,
    pub __bindgen_anon_1: tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWMOUSE__bindgen_ty_1__bindgen_ty_1 {
    pub usButtonFlags: USHORT,
    pub usButtonData: USHORT,
}
pub type RAWMOUSE = tagRAWMOUSE;
pub type PRAWMOUSE = *mut tagRAWMOUSE;
pub type LPRAWMOUSE = *mut tagRAWMOUSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWKEYBOARD {
    pub MakeCode: USHORT,
    pub Flags: USHORT,
    pub Reserved: USHORT,
    pub VKey: USHORT,
    pub Message: UINT,
    pub ExtraInformation: ULONG,
}
pub type RAWKEYBOARD = tagRAWKEYBOARD;
pub type PRAWKEYBOARD = *mut tagRAWKEYBOARD;
pub type LPRAWKEYBOARD = *mut tagRAWKEYBOARD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWHID {
    pub dwSizeHid: DWORD,
    pub dwCount: DWORD,
    pub bRawData: [BYTE; 1usize],
}
pub type RAWHID = tagRAWHID;
pub type PRAWHID = *mut tagRAWHID;
pub type LPRAWHID = *mut tagRAWHID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRAWINPUT {
    pub header: RAWINPUTHEADER,
    pub data: tagRAWINPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRAWINPUT__bindgen_ty_1 {
    pub mouse: RAWMOUSE,
    pub keyboard: RAWKEYBOARD,
    pub hid: RAWHID,
}
pub type RAWINPUT = tagRAWINPUT;
pub type PRAWINPUT = *mut tagRAWINPUT;
pub type LPRAWINPUT = *mut tagRAWINPUT;
extern "C" {
    pub fn GetRawInputData(
        hRawInput: HRAWINPUT,
        uiCommand: UINT,
        pData: LPVOID,
        pcbSize: PUINT,
        cbSizeHeader: UINT,
    ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRID_DEVICE_INFO_MOUSE {
    pub dwId: DWORD,
    pub dwNumberOfButtons: DWORD,
    pub dwSampleRate: DWORD,
    pub fHasHorizontalWheel: BOOL,
}
pub type RID_DEVICE_INFO_MOUSE = tagRID_DEVICE_INFO_MOUSE;
pub type PRID_DEVICE_INFO_MOUSE = *mut tagRID_DEVICE_INFO_MOUSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRID_DEVICE_INFO_KEYBOARD {
    pub dwType: DWORD,
    pub dwSubType: DWORD,
    pub dwKeyboardMode: DWORD,
    pub dwNumberOfFunctionKeys: DWORD,
    pub dwNumberOfIndicators: DWORD,
    pub dwNumberOfKeysTotal: DWORD,
}
pub type RID_DEVICE_INFO_KEYBOARD = tagRID_DEVICE_INFO_KEYBOARD;
pub type PRID_DEVICE_INFO_KEYBOARD = *mut tagRID_DEVICE_INFO_KEYBOARD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRID_DEVICE_INFO_HID {
    pub dwVendorId: DWORD,
    pub dwProductId: DWORD,
    pub dwVersionNumber: DWORD,
    pub usUsagePage: USHORT,
    pub usUsage: USHORT,
}
pub type RID_DEVICE_INFO_HID = tagRID_DEVICE_INFO_HID;
pub type PRID_DEVICE_INFO_HID = *mut tagRID_DEVICE_INFO_HID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRID_DEVICE_INFO {
    pub cbSize: DWORD,
    pub dwType: DWORD,
    pub __bindgen_anon_1: tagRID_DEVICE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRID_DEVICE_INFO__bindgen_ty_1 {
    pub mouse: RID_DEVICE_INFO_MOUSE,
    pub keyboard: RID_DEVICE_INFO_KEYBOARD,
    pub hid: RID_DEVICE_INFO_HID,
}
pub type RID_DEVICE_INFO = tagRID_DEVICE_INFO;
pub type PRID_DEVICE_INFO = *mut tagRID_DEVICE_INFO;
pub type LPRID_DEVICE_INFO = *mut tagRID_DEVICE_INFO;
extern "C" {
    pub fn GetRawInputDeviceInfoA(
        hDevice: HANDLE,
        uiCommand: UINT,
        pData: LPVOID,
        pcbSize: PUINT,
    ) -> UINT;
}
extern "C" {
    pub fn GetRawInputDeviceInfoW(
        hDevice: HANDLE,
        uiCommand: UINT,
        pData: LPVOID,
        pcbSize: PUINT,
    ) -> UINT;
}
extern "C" {
    pub fn GetRawInputBuffer(pData: PRAWINPUT, pcbSize: PUINT, cbSizeHeader: UINT) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWINPUTDEVICE {
    pub usUsagePage: USHORT,
    pub usUsage: USHORT,
    pub dwFlags: DWORD,
    pub hwndTarget: HWND,
}
pub type RAWINPUTDEVICE = tagRAWINPUTDEVICE;
pub type PRAWINPUTDEVICE = *mut tagRAWINPUTDEVICE;
pub type LPRAWINPUTDEVICE = *mut tagRAWINPUTDEVICE;
pub type PCRAWINPUTDEVICE = *const RAWINPUTDEVICE;
extern "C" {
    pub fn RegisterRawInputDevices(
        pRawInputDevices: PCRAWINPUTDEVICE,
        uiNumDevices: UINT,
        cbSize: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetRegisteredRawInputDevices(
        pRawInputDevices: PRAWINPUTDEVICE,
        puiNumDevices: PUINT,
        cbSize: UINT,
    ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRAWINPUTDEVICELIST {
    pub hDevice: HANDLE,
    pub dwType: DWORD,
}
pub type RAWINPUTDEVICELIST = tagRAWINPUTDEVICELIST;
pub type PRAWINPUTDEVICELIST = *mut tagRAWINPUTDEVICELIST;
extern "C" {
    pub fn GetRawInputDeviceList(
        pRawInputDeviceList: PRAWINPUTDEVICELIST,
        puiNumDevices: PUINT,
        cbSize: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn DefRawInputProc(paRawInput: *mut PRAWINPUT, nInput: INT, cbSizeHeader: UINT) -> LRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagPOINTER_DEVICE_TYPE {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 1,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN = 2,
    POINTER_DEVICE_TYPE_TOUCH = 3,
    POINTER_DEVICE_TYPE_TOUCH_PAD = 4,
    POINTER_DEVICE_TYPE_MAX = -1,
}
pub use self::tagPOINTER_DEVICE_TYPE as POINTER_DEVICE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTER_DEVICE_INFO {
    pub displayOrientation: DWORD,
    pub device: HANDLE,
    pub pointerDeviceType: POINTER_DEVICE_TYPE,
    pub monitor: HMONITOR,
    pub startingCursorId: ULONG,
    pub maxActiveContacts: USHORT,
    pub productString: [WCHAR; 520usize],
}
pub type POINTER_DEVICE_INFO = tagPOINTER_DEVICE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTER_DEVICE_PROPERTY {
    pub logicalMin: INT32,
    pub logicalMax: INT32,
    pub physicalMin: INT32,
    pub physicalMax: INT32,
    pub unit: UINT32,
    pub unitExponent: UINT32,
    pub usagePageId: USHORT,
    pub usageId: USHORT,
}
pub type POINTER_DEVICE_PROPERTY = tagPOINTER_DEVICE_PROPERTY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagPOINTER_DEVICE_CURSOR_TYPE {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0,
    POINTER_DEVICE_CURSOR_TYPE_TIP = 1,
    POINTER_DEVICE_CURSOR_TYPE_ERASER = 2,
    POINTER_DEVICE_CURSOR_TYPE_MAX = -1,
}
pub use self::tagPOINTER_DEVICE_CURSOR_TYPE as POINTER_DEVICE_CURSOR_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTER_DEVICE_CURSOR_INFO {
    pub cursorId: UINT32,
    pub cursor: POINTER_DEVICE_CURSOR_TYPE,
}
pub type POINTER_DEVICE_CURSOR_INFO = tagPOINTER_DEVICE_CURSOR_INFO;
extern "C" {
    pub fn GetPointerDevices(
        deviceCount: *mut UINT32,
        pointerDevices: *mut POINTER_DEVICE_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerDevice(device: HANDLE, pointerDevice: *mut POINTER_DEVICE_INFO) -> BOOL;
}
extern "C" {
    pub fn GetPointerDeviceProperties(
        device: HANDLE,
        propertyCount: *mut UINT32,
        pointerProperties: *mut POINTER_DEVICE_PROPERTY,
    ) -> BOOL;
}
extern "C" {
    pub fn RegisterPointerDeviceNotifications(window: HWND, notifyRange: BOOL) -> BOOL;
}
extern "C" {
    pub fn GetPointerDeviceRects(
        device: HANDLE,
        pointerDeviceRect: *mut RECT,
        displayRect: *mut RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPointerDeviceCursors(
        device: HANDLE,
        cursorCount: *mut UINT32,
        deviceCursors: *mut POINTER_DEVICE_CURSOR_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn GetRawPointerDeviceData(
        pointerId: UINT32,
        historyCount: UINT32,
        propertiesCount: UINT32,
        pProperties: *mut POINTER_DEVICE_PROPERTY,
        pValues: *mut LONG,
    ) -> BOOL;
}
extern "C" {
    pub fn ChangeWindowMessageFilter(message: UINT, dwFlag: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCHANGEFILTERSTRUCT {
    pub cbSize: DWORD,
    pub ExtStatus: DWORD,
}
pub type CHANGEFILTERSTRUCT = tagCHANGEFILTERSTRUCT;
pub type PCHANGEFILTERSTRUCT = *mut tagCHANGEFILTERSTRUCT;
extern "C" {
    pub fn ChangeWindowMessageFilterEx(
        hwnd: HWND,
        message: UINT,
        action: DWORD,
        pChangeFilterStruct: PCHANGEFILTERSTRUCT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HGESTUREINFO__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HGESTUREINFO = *mut HGESTUREINFO__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGESTUREINFO {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub dwID: DWORD,
    pub hwndTarget: HWND,
    pub ptsLocation: POINTS,
    pub dwInstanceID: DWORD,
    pub dwSequenceID: DWORD,
    pub ullArguments: ULONGLONG,
    pub cbExtraArgs: UINT,
}
pub type GESTUREINFO = tagGESTUREINFO;
pub type PGESTUREINFO = *mut tagGESTUREINFO;
pub type PCGESTUREINFO = *const GESTUREINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGESTURENOTIFYSTRUCT {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
    pub hwndTarget: HWND,
    pub ptsLocation: POINTS,
    pub dwInstanceID: DWORD,
}
pub type GESTURENOTIFYSTRUCT = tagGESTURENOTIFYSTRUCT;
pub type PGESTURENOTIFYSTRUCT = *mut tagGESTURENOTIFYSTRUCT;
extern "C" {
    pub fn GetGestureInfo(hGestureInfo: HGESTUREINFO, pGestureInfo: PGESTUREINFO) -> BOOL;
}
extern "C" {
    pub fn GetGestureExtraArgs(
        hGestureInfo: HGESTUREINFO,
        cbExtraArgs: UINT,
        pExtraArgs: PBYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn CloseGestureInfoHandle(hGestureInfo: HGESTUREINFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagGESTURECONFIG {
    pub dwID: DWORD,
    pub dwWant: DWORD,
    pub dwBlock: DWORD,
}
pub type GESTURECONFIG = tagGESTURECONFIG;
pub type PGESTURECONFIG = *mut tagGESTURECONFIG;
extern "C" {
    pub fn SetGestureConfig(
        hwnd: HWND,
        dwReserved: DWORD,
        cIDs: UINT,
        pGestureConfig: PGESTURECONFIG,
        cbSize: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetGestureConfig(
        hwnd: HWND,
        dwReserved: DWORD,
        dwFlags: DWORD,
        pcIDs: PUINT,
        pGestureConfig: PGESTURECONFIG,
        cbSize: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn ShutdownBlockReasonCreate(hWnd: HWND, pwszReason: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn ShutdownBlockReasonQuery(hWnd: HWND, pwszBuff: LPWSTR, pcchBuff: *mut DWORD) -> BOOL;
}
extern "C" {
    pub fn ShutdownBlockReasonDestroy(hWnd: HWND) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagINPUT_MESSAGE_DEVICE_TYPE {
    IMDT_UNAVAILABLE = 0,
    IMDT_KEYBOARD = 1,
    IMDT_MOUSE = 2,
    IMDT_TOUCH = 4,
    IMDT_PEN = 8,
    IMDT_TOUCHPAD = 16,
}
pub use self::tagINPUT_MESSAGE_DEVICE_TYPE as INPUT_MESSAGE_DEVICE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagINPUT_MESSAGE_ORIGIN_ID {
    IMO_UNAVAILABLE = 0,
    IMO_HARDWARE = 1,
    IMO_INJECTED = 2,
    IMO_SYSTEM = 4,
}
pub use self::tagINPUT_MESSAGE_ORIGIN_ID as INPUT_MESSAGE_ORIGIN_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagINPUT_MESSAGE_SOURCE {
    pub deviceType: INPUT_MESSAGE_DEVICE_TYPE,
    pub originId: INPUT_MESSAGE_ORIGIN_ID,
}
pub type INPUT_MESSAGE_SOURCE = tagINPUT_MESSAGE_SOURCE;
extern "C" {
    pub fn GetCurrentInputMessageSource(inputMessageSource: *mut INPUT_MESSAGE_SOURCE) -> BOOL;
}
extern "C" {
    pub fn GetCIMSSM(inputMessageSource: *mut INPUT_MESSAGE_SOURCE) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagAR_STATE {
    AR_ENABLED = 0,
    AR_DISABLED = 1,
    AR_SUPPRESSED = 2,
    AR_REMOTESESSION = 4,
    AR_MULTIMON = 8,
    AR_NOSENSOR = 16,
    AR_NOT_SUPPORTED = 32,
    AR_DOCKED = 64,
    AR_LAPTOP = 128,
}
pub use self::tagAR_STATE as AR_STATE;
pub type PAR_STATE = *mut tagAR_STATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE = 0,
    ORIENTATION_PREFERENCE_LANDSCAPE = 1,
    ORIENTATION_PREFERENCE_PORTRAIT = 2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 8,
}
extern "C" {
    pub fn GetAutoRotationState(pState: PAR_STATE) -> BOOL;
}
extern "C" {
    pub fn GetDisplayAutoRotationPreferences(pOrientation: *mut ORIENTATION_PREFERENCE) -> BOOL;
}
extern "C" {
    pub fn GetDisplayAutoRotationPreferencesByProcessId(
        dwProcessId: DWORD,
        pOrientation: *mut ORIENTATION_PREFERENCE,
        fRotateScreen: *mut BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SetDisplayAutoRotationPreferences(orientation: ORIENTATION_PREFERENCE) -> BOOL;
}
extern "C" {
    pub fn IsImmersiveProcess(hProcess: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetProcessRestrictionExemption(fEnableExemption: BOOL) -> BOOL;
}
extern "C" {
    pub fn SetAdditionalForegroundBoostProcesses(
        topLevelWindow: HWND,
        processHandleCount: DWORD,
        processHandleArray: *mut HANDLE,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TOOLTIP_DISMISS_FLAGS {
    TDF_REGISTER = 1,
    TDF_UNREGISTER = 2,
}
extern "C" {
    pub fn RegisterForTooltipDismissNotification(
        hWnd: HWND,
        tdFlags: TOOLTIP_DISMISS_FLAGS,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDateFormatA(
        Locale: LCID,
        dwFlags: DWORD,
        lpDate: *const SYSTEMTIME,
        lpFormat: LPCSTR,
        lpDateStr: LPSTR,
        cchDate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDateFormatW(
        Locale: LCID,
        dwFlags: DWORD,
        lpDate: *const SYSTEMTIME,
        lpFormat: LPCWSTR,
        lpDateStr: LPWSTR,
        cchDate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTimeFormatA(
        Locale: LCID,
        dwFlags: DWORD,
        lpTime: *const SYSTEMTIME,
        lpFormat: LPCSTR,
        lpTimeStr: LPSTR,
        cchTime: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTimeFormatW(
        Locale: LCID,
        dwFlags: DWORD,
        lpTime: *const SYSTEMTIME,
        lpFormat: LPCWSTR,
        lpTimeStr: LPWSTR,
        cchTime: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetTimeFormatEx(
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lpTime: *const SYSTEMTIME,
        lpFormat: LPCWSTR,
        lpTimeStr: LPWSTR,
        cchTime: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDateFormatEx(
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lpDate: *const SYSTEMTIME,
        lpFormat: LPCWSTR,
        lpDateStr: LPWSTR,
        cchDate: ::std::os::raw::c_int,
        lpCalendar: LPCWSTR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDurationFormatEx(
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lpDuration: *const SYSTEMTIME,
        ullDuration: ULONGLONG,
        lpFormat: LPCWSTR,
        lpDurationStr: LPWSTR,
        cchDuration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LGRPID = DWORD;
pub type LCTYPE = DWORD;
pub type CALTYPE = DWORD;
pub type CALID = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpinfo {
    pub MaxCharSize: UINT,
    pub DefaultChar: [BYTE; 2usize],
    pub LeadByte: [BYTE; 12usize],
}
pub type CPINFO = _cpinfo;
pub type LPCPINFO = *mut _cpinfo;
pub type GEOTYPE = DWORD;
pub type GEOCLASS = DWORD;
pub type GEOID = LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpinfoexA {
    pub MaxCharSize: UINT,
    pub DefaultChar: [BYTE; 2usize],
    pub LeadByte: [BYTE; 12usize],
    pub UnicodeDefaultChar: WCHAR,
    pub CodePage: UINT,
    pub CodePageName: [CHAR; 260usize],
}
pub type CPINFOEXA = _cpinfoexA;
pub type LPCPINFOEXA = *mut _cpinfoexA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpinfoexW {
    pub MaxCharSize: UINT,
    pub DefaultChar: [BYTE; 2usize],
    pub LeadByte: [BYTE; 12usize],
    pub UnicodeDefaultChar: WCHAR,
    pub CodePage: UINT,
    pub CodePageName: [WCHAR; 260usize],
}
pub type CPINFOEXW = _cpinfoexW;
pub type LPCPINFOEXW = *mut _cpinfoexW;
pub type CPINFOEX = CPINFOEXA;
pub type LPCPINFOEX = LPCPINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _numberfmtA {
    pub NumDigits: UINT,
    pub LeadingZero: UINT,
    pub Grouping: UINT,
    pub lpDecimalSep: LPSTR,
    pub lpThousandSep: LPSTR,
    pub NegativeOrder: UINT,
}
pub type NUMBERFMTA = _numberfmtA;
pub type LPNUMBERFMTA = *mut _numberfmtA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _numberfmtW {
    pub NumDigits: UINT,
    pub LeadingZero: UINT,
    pub Grouping: UINT,
    pub lpDecimalSep: LPWSTR,
    pub lpThousandSep: LPWSTR,
    pub NegativeOrder: UINT,
}
pub type NUMBERFMTW = _numberfmtW;
pub type LPNUMBERFMTW = *mut _numberfmtW;
pub type NUMBERFMT = NUMBERFMTA;
pub type LPNUMBERFMT = LPNUMBERFMTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _currencyfmtA {
    pub NumDigits: UINT,
    pub LeadingZero: UINT,
    pub Grouping: UINT,
    pub lpDecimalSep: LPSTR,
    pub lpThousandSep: LPSTR,
    pub NegativeOrder: UINT,
    pub PositiveOrder: UINT,
    pub lpCurrencySymbol: LPSTR,
}
pub type CURRENCYFMTA = _currencyfmtA;
pub type LPCURRENCYFMTA = *mut _currencyfmtA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _currencyfmtW {
    pub NumDigits: UINT,
    pub LeadingZero: UINT,
    pub Grouping: UINT,
    pub lpDecimalSep: LPWSTR,
    pub lpThousandSep: LPWSTR,
    pub NegativeOrder: UINT,
    pub PositiveOrder: UINT,
    pub lpCurrencySymbol: LPWSTR,
}
pub type CURRENCYFMTW = _currencyfmtW;
pub type LPCURRENCYFMTW = *mut _currencyfmtW;
pub type CURRENCYFMT = CURRENCYFMTA;
pub type LPCURRENCYFMT = LPCURRENCYFMTA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSNLS_FUNCTION {
    COMPARE_STRING = 1,
}
pub type NLS_FUNCTION = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _nlsversioninfo {
    pub dwNLSVersionInfoSize: DWORD,
    pub dwNLSVersion: DWORD,
    pub dwDefinedVersion: DWORD,
    pub dwEffectiveId: DWORD,
    pub guidCustomVersion: GUID,
}
pub type NLSVERSIONINFO = _nlsversioninfo;
pub type LPNLSVERSIONINFO = *mut _nlsversioninfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _nlsversioninfoex {
    pub dwNLSVersionInfoSize: DWORD,
    pub dwNLSVersion: DWORD,
    pub dwDefinedVersion: DWORD,
    pub dwEffectiveId: DWORD,
    pub guidCustomVersion: GUID,
}
pub type NLSVERSIONINFOEX = _nlsversioninfoex;
pub type LPNLSVERSIONINFOEX = *mut _nlsversioninfoex;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSGEOTYPE {
    GEO_NATION = 1,
    GEO_LATITUDE = 2,
    GEO_LONGITUDE = 3,
    GEO_ISO2 = 4,
    GEO_ISO3 = 5,
    GEO_RFC1766 = 6,
    GEO_LCID = 7,
    GEO_FRIENDLYNAME = 8,
    GEO_OFFICIALNAME = 9,
    GEO_TIMEZONES = 10,
    GEO_OFFICIALLANGUAGES = 11,
    GEO_ISO_UN_NUMBER = 12,
    GEO_PARENT = 13,
    GEO_DIALINGCODE = 14,
    GEO_CURRENCYCODE = 15,
    GEO_CURRENCYSYMBOL = 16,
    GEO_NAME = 17,
    GEO_ID = 18,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSGEOCLASS {
    GEOCLASS_NATION = 16,
    GEOCLASS_REGION = 14,
    GEOCLASS_ALL = 0,
}
pub type LOCALE_ENUMPROCA = ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type LOCALE_ENUMPROCW = ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _NORM_FORM {
    NormalizationOther = 0,
    NormalizationC = 1,
    NormalizationD = 2,
    NormalizationKC = 5,
    NormalizationKD = 6,
}
pub use self::_NORM_FORM as NORM_FORM;
pub type LANGUAGEGROUP_ENUMPROCA = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: LGRPID,
        arg2: LPSTR,
        arg3: LPSTR,
        arg4: DWORD,
        arg5: LONG_PTR,
    ) -> BOOL,
>;
pub type LANGGROUPLOCALE_ENUMPROCA = ::std::option::Option<
    unsafe extern "C" fn(arg1: LGRPID, arg2: LCID, arg3: LPSTR, arg4: LONG_PTR) -> BOOL,
>;
pub type UILANGUAGE_ENUMPROCA =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: LONG_PTR) -> BOOL>;
pub type CODEPAGE_ENUMPROCA = ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCA = ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCEXA =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: CALID) -> BOOL>;
pub type TIMEFMT_ENUMPROCA = ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type CALINFO_ENUMPROCA = ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR) -> BOOL>;
pub type CALINFO_ENUMPROCEXA =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPSTR, arg2: CALID) -> BOOL>;
pub type LANGUAGEGROUP_ENUMPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: LGRPID,
        arg2: LPWSTR,
        arg3: LPWSTR,
        arg4: DWORD,
        arg5: LONG_PTR,
    ) -> BOOL,
>;
pub type LANGGROUPLOCALE_ENUMPROCW = ::std::option::Option<
    unsafe extern "C" fn(arg1: LGRPID, arg2: LCID, arg3: LPWSTR, arg4: LONG_PTR) -> BOOL,
>;
pub type UILANGUAGE_ENUMPROCW =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LONG_PTR) -> BOOL>;
pub type CODEPAGE_ENUMPROCW = ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCW = ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type DATEFMT_ENUMPROCEXW =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID) -> BOOL>;
pub type TIMEFMT_ENUMPROCW = ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type CALINFO_ENUMPROCW = ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR) -> BOOL>;
pub type CALINFO_ENUMPROCEXW =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID) -> BOOL>;
pub type GEO_ENUMPROC = ::std::option::Option<unsafe extern "C" fn(arg1: GEOID) -> BOOL>;
pub type GEO_ENUMNAMEPROC =
    ::std::option::Option<unsafe extern "C" fn(arg1: PWSTR, arg2: LPARAM) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILEMUIINFO {
    pub dwSize: DWORD,
    pub dwVersion: DWORD,
    pub dwFileType: DWORD,
    pub pChecksum: [BYTE; 16usize],
    pub pServiceChecksum: [BYTE; 16usize],
    pub dwLanguageNameOffset: DWORD,
    pub dwTypeIDMainSize: DWORD,
    pub dwTypeIDMainOffset: DWORD,
    pub dwTypeNameMainOffset: DWORD,
    pub dwTypeIDMUISize: DWORD,
    pub dwTypeIDMUIOffset: DWORD,
    pub dwTypeNameMUIOffset: DWORD,
    pub abBuffer: [BYTE; 8usize],
}
pub type FILEMUIINFO = _FILEMUIINFO;
pub type PFILEMUIINFO = *mut _FILEMUIINFO;
extern "C" {
    pub fn CompareStringEx(
        lpLocaleName: LPCWSTR,
        dwCmpFlags: DWORD,
        lpString1: LPCWCH,
        cchCount1: ::std::os::raw::c_int,
        lpString2: LPCWCH,
        cchCount2: ::std::os::raw::c_int,
        lpVersionInformation: LPNLSVERSIONINFO,
        lpReserved: LPVOID,
        lParam: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CompareStringOrdinal(
        lpString1: LPCWCH,
        cchCount1: ::std::os::raw::c_int,
        lpString2: LPCWCH,
        cchCount2: ::std::os::raw::c_int,
        bIgnoreCase: BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CompareStringW(
        Locale: LCID,
        dwCmpFlags: DWORD,
        lpString1: PCNZWCH,
        cchCount1: ::std::os::raw::c_int,
        lpString2: PCNZWCH,
        cchCount2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FoldStringW(
        dwMapFlags: DWORD,
        lpSrcStr: LPCWCH,
        cchSrc: ::std::os::raw::c_int,
        lpDestStr: LPWSTR,
        cchDest: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetStringTypeExW(
        Locale: LCID,
        dwInfoType: DWORD,
        lpSrcStr: LPCWCH,
        cchSrc: ::std::os::raw::c_int,
        lpCharType: LPWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetStringTypeW(
        dwInfoType: DWORD,
        lpSrcStr: LPCWCH,
        cchSrc: ::std::os::raw::c_int,
        lpCharType: LPWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn MultiByteToWideChar(
        CodePage: UINT,
        dwFlags: DWORD,
        lpMultiByteStr: LPCCH,
        cbMultiByte: ::std::os::raw::c_int,
        lpWideCharStr: LPWSTR,
        cchWideChar: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WideCharToMultiByte(
        CodePage: UINT,
        dwFlags: DWORD,
        lpWideCharStr: LPCWCH,
        cchWideChar: ::std::os::raw::c_int,
        lpMultiByteStr: LPSTR,
        cbMultiByte: ::std::os::raw::c_int,
        lpDefaultChar: LPCCH,
        lpUsedDefaultChar: LPBOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsValidCodePage(CodePage: UINT) -> BOOL;
}
extern "C" {
    pub fn GetACP() -> UINT;
}
extern "C" {
    pub fn GetOEMCP() -> UINT;
}
extern "C" {
    pub fn GetCPInfo(CodePage: UINT, lpCPInfo: LPCPINFO) -> BOOL;
}
extern "C" {
    pub fn GetCPInfoExA(CodePage: UINT, dwFlags: DWORD, lpCPInfoEx: LPCPINFOEXA) -> BOOL;
}
extern "C" {
    pub fn GetCPInfoExW(CodePage: UINT, dwFlags: DWORD, lpCPInfoEx: LPCPINFOEXW) -> BOOL;
}
extern "C" {
    pub fn CompareStringA(
        Locale: LCID,
        dwCmpFlags: DWORD,
        lpString1: PCNZCH,
        cchCount1: ::std::os::raw::c_int,
        lpString2: PCNZCH,
        cchCount2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FindNLSString(
        Locale: LCID,
        dwFindNLSStringFlags: DWORD,
        lpStringSource: LPCWSTR,
        cchSource: ::std::os::raw::c_int,
        lpStringValue: LPCWSTR,
        cchValue: ::std::os::raw::c_int,
        pcchFound: LPINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCMapStringW(
        Locale: LCID,
        dwMapFlags: DWORD,
        lpSrcStr: LPCWSTR,
        cchSrc: ::std::os::raw::c_int,
        lpDestStr: LPWSTR,
        cchDest: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCMapStringA(
        Locale: LCID,
        dwMapFlags: DWORD,
        lpSrcStr: LPCSTR,
        cchSrc: ::std::os::raw::c_int,
        lpDestStr: LPSTR,
        cchDest: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetLocaleInfoW(
        Locale: LCID,
        LCType: LCTYPE,
        lpLCData: LPWSTR,
        cchData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetLocaleInfoA(
        Locale: LCID,
        LCType: LCTYPE,
        lpLCData: LPSTR,
        cchData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetLocaleInfoA(Locale: LCID, LCType: LCTYPE, lpLCData: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetLocaleInfoW(Locale: LCID, LCType: LCTYPE, lpLCData: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetCalendarInfoA(
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
        lpCalData: LPSTR,
        cchData: ::std::os::raw::c_int,
        lpValue: LPDWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetCalendarInfoW(
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
        lpCalData: LPWSTR,
        cchData: ::std::os::raw::c_int,
        lpValue: LPDWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetCalendarInfoA(
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
        lpCalData: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetCalendarInfoW(
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
        lpCalData: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn LoadStringByReference(
        Flags: DWORD,
        Language: PCWSTR,
        SourceString: PCWSTR,
        Buffer: PWSTR,
        cchBuffer: ULONG,
        Directory: PCWSTR,
        pcchBufferOut: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn IsDBCSLeadByte(TestChar: BYTE) -> BOOL;
}
extern "C" {
    pub fn IsDBCSLeadByteEx(CodePage: UINT, TestChar: BYTE) -> BOOL;
}
extern "C" {
    pub fn LocaleNameToLCID(lpName: LPCWSTR, dwFlags: DWORD) -> LCID;
}
extern "C" {
    pub fn LCIDToLocaleName(
        Locale: LCID,
        lpName: LPWSTR,
        cchName: ::std::os::raw::c_int,
        dwFlags: DWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDurationFormat(
        Locale: LCID,
        dwFlags: DWORD,
        lpDuration: *const SYSTEMTIME,
        ullDuration: ULONGLONG,
        lpFormat: LPCWSTR,
        lpDurationStr: LPWSTR,
        cchDuration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetNumberFormatA(
        Locale: LCID,
        dwFlags: DWORD,
        lpValue: LPCSTR,
        lpFormat: *const NUMBERFMTA,
        lpNumberStr: LPSTR,
        cchNumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetNumberFormatW(
        Locale: LCID,
        dwFlags: DWORD,
        lpValue: LPCWSTR,
        lpFormat: *const NUMBERFMTW,
        lpNumberStr: LPWSTR,
        cchNumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetCurrencyFormatA(
        Locale: LCID,
        dwFlags: DWORD,
        lpValue: LPCSTR,
        lpFormat: *const CURRENCYFMTA,
        lpCurrencyStr: LPSTR,
        cchCurrency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetCurrencyFormatW(
        Locale: LCID,
        dwFlags: DWORD,
        lpValue: LPCWSTR,
        lpFormat: *const CURRENCYFMTW,
        lpCurrencyStr: LPWSTR,
        cchCurrency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumCalendarInfoA(
        lpCalInfoEnumProc: CALINFO_ENUMPROCA,
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumCalendarInfoW(
        lpCalInfoEnumProc: CALINFO_ENUMPROCW,
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumCalendarInfoExA(
        lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXA,
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumCalendarInfoExW(
        lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXW,
        Locale: LCID,
        Calendar: CALID,
        CalType: CALTYPE,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumTimeFormatsA(
        lpTimeFmtEnumProc: TIMEFMT_ENUMPROCA,
        Locale: LCID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumTimeFormatsW(
        lpTimeFmtEnumProc: TIMEFMT_ENUMPROCW,
        Locale: LCID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDateFormatsA(
        lpDateFmtEnumProc: DATEFMT_ENUMPROCA,
        Locale: LCID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDateFormatsW(
        lpDateFmtEnumProc: DATEFMT_ENUMPROCW,
        Locale: LCID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDateFormatsExA(
        lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXA,
        Locale: LCID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDateFormatsExW(
        lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXW,
        Locale: LCID,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn IsValidLanguageGroup(LanguageGroup: LGRPID, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetNLSVersion(
        Function: NLS_FUNCTION,
        Locale: LCID,
        lpVersionInformation: LPNLSVERSIONINFO,
    ) -> BOOL;
}
extern "C" {
    pub fn IsValidLocale(Locale: LCID, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetGeoInfoA(
        Location: GEOID,
        GeoType: GEOTYPE,
        lpGeoData: LPSTR,
        cchData: ::std::os::raw::c_int,
        LangId: LANGID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetGeoInfoW(
        Location: GEOID,
        GeoType: GEOTYPE,
        lpGeoData: LPWSTR,
        cchData: ::std::os::raw::c_int,
        LangId: LANGID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetGeoInfoEx(
        location: PWSTR,
        geoType: GEOTYPE,
        geoData: PWSTR,
        geoDataCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumSystemGeoID(
        GeoClass: GEOCLASS,
        ParentGeoId: GEOID,
        lpGeoEnumProc: GEO_ENUMPROC,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumSystemGeoNames(
        geoClass: GEOCLASS,
        geoEnumProc: GEO_ENUMNAMEPROC,
        data: LPARAM,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUserGeoID(GeoClass: GEOCLASS) -> GEOID;
}
extern "C" {
    pub fn GetUserDefaultGeoName(
        geoName: LPWSTR,
        geoNameCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SetUserGeoID(GeoId: GEOID) -> BOOL;
}
extern "C" {
    pub fn SetUserGeoName(geoName: PWSTR) -> BOOL;
}
extern "C" {
    pub fn ConvertDefaultLocale(Locale: LCID) -> LCID;
}
extern "C" {
    pub fn GetSystemDefaultUILanguage() -> LANGID;
}
extern "C" {
    pub fn GetThreadLocale() -> LCID;
}
extern "C" {
    pub fn SetThreadLocale(Locale: LCID) -> BOOL;
}
extern "C" {
    pub fn GetUserDefaultUILanguage() -> LANGID;
}
extern "C" {
    pub fn GetUserDefaultLangID() -> LANGID;
}
extern "C" {
    pub fn GetSystemDefaultLangID() -> LANGID;
}
extern "C" {
    pub fn GetSystemDefaultLCID() -> LCID;
}
extern "C" {
    pub fn GetUserDefaultLCID() -> LCID;
}
extern "C" {
    pub fn SetThreadUILanguage(LangId: LANGID) -> LANGID;
}
extern "C" {
    pub fn GetThreadUILanguage() -> LANGID;
}
extern "C" {
    pub fn GetProcessPreferredUILanguages(
        dwFlags: DWORD,
        pulNumLanguages: PULONG,
        pwszLanguagesBuffer: PZZWSTR,
        pcchLanguagesBuffer: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetProcessPreferredUILanguages(
        dwFlags: DWORD,
        pwszLanguagesBuffer: PCZZWSTR,
        pulNumLanguages: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUserPreferredUILanguages(
        dwFlags: DWORD,
        pulNumLanguages: PULONG,
        pwszLanguagesBuffer: PZZWSTR,
        pcchLanguagesBuffer: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSystemPreferredUILanguages(
        dwFlags: DWORD,
        pulNumLanguages: PULONG,
        pwszLanguagesBuffer: PZZWSTR,
        pcchLanguagesBuffer: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetThreadPreferredUILanguages(
        dwFlags: DWORD,
        pulNumLanguages: PULONG,
        pwszLanguagesBuffer: PZZWSTR,
        pcchLanguagesBuffer: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn SetThreadPreferredUILanguages(
        dwFlags: DWORD,
        pwszLanguagesBuffer: PCZZWSTR,
        pulNumLanguages: PULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileMUIInfo(
        dwFlags: DWORD,
        pcwszFilePath: PCWSTR,
        pFileMUIInfo: PFILEMUIINFO,
        pcbFileMUIInfo: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileMUIPath(
        dwFlags: DWORD,
        pcwszFilePath: PCWSTR,
        pwszLanguage: PWSTR,
        pcchLanguage: PULONG,
        pwszFileMUIPath: PWSTR,
        pcchFileMUIPath: PULONG,
        pululEnumerator: PULONGLONG,
    ) -> BOOL;
}
extern "C" {
    pub fn GetUILanguageInfo(
        dwFlags: DWORD,
        pwmszLanguage: PCZZWSTR,
        pwszFallbackLanguages: PZZWSTR,
        pcchFallbackLanguages: PDWORD,
        pAttributes: PDWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSAVEDUILANGUAGES__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HSAVEDUILANGUAGES = *mut HSAVEDUILANGUAGES__;
extern "C" {
    pub fn SetThreadPreferredUILanguages2(
        flags: ULONG,
        languages: PCZZWSTR,
        numLanguagesSet: PULONG,
        snapshot: *mut HSAVEDUILANGUAGES,
    ) -> BOOL;
}
extern "C" {
    pub fn RestoreThreadPreferredUILanguages(snapshot: HSAVEDUILANGUAGES);
}
extern "C" {
    pub fn NotifyUILanguageChange(
        dwFlags: DWORD,
        pcwstrNewLanguage: PCWSTR,
        pcwstrPreviousLanguage: PCWSTR,
        dwReserved: DWORD,
        pdwStatusRtrn: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetStringTypeExA(
        Locale: LCID,
        dwInfoType: DWORD,
        lpSrcStr: LPCSTR,
        cchSrc: ::std::os::raw::c_int,
        lpCharType: LPWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetStringTypeA(
        Locale: LCID,
        dwInfoType: DWORD,
        lpSrcStr: LPCSTR,
        cchSrc: ::std::os::raw::c_int,
        lpCharType: LPWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FoldStringA(
        dwMapFlags: DWORD,
        lpSrcStr: LPCSTR,
        cchSrc: ::std::os::raw::c_int,
        lpDestStr: LPSTR,
        cchDest: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EnumSystemLocalesA(lpLocaleEnumProc: LOCALE_ENUMPROCA, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn EnumSystemLocalesW(lpLocaleEnumProc: LOCALE_ENUMPROCW, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn EnumSystemLanguageGroupsA(
        lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCA,
        dwFlags: DWORD,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumSystemLanguageGroupsW(
        lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCW,
        dwFlags: DWORD,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumLanguageGroupLocalesA(
        lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCA,
        LanguageGroup: LGRPID,
        dwFlags: DWORD,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumLanguageGroupLocalesW(
        lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCW,
        LanguageGroup: LGRPID,
        dwFlags: DWORD,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumUILanguagesA(
        lpUILanguageEnumProc: UILANGUAGE_ENUMPROCA,
        dwFlags: DWORD,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumUILanguagesW(
        lpUILanguageEnumProc: UILANGUAGE_ENUMPROCW,
        dwFlags: DWORD,
        lParam: LONG_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumSystemCodePagesA(lpCodePageEnumProc: CODEPAGE_ENUMPROCA, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn EnumSystemCodePagesW(lpCodePageEnumProc: CODEPAGE_ENUMPROCW, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn IdnToAscii(
        dwFlags: DWORD,
        lpUnicodeCharStr: LPCWSTR,
        cchUnicodeChar: ::std::os::raw::c_int,
        lpASCIICharStr: LPWSTR,
        cchASCIIChar: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IdnToUnicode(
        dwFlags: DWORD,
        lpASCIICharStr: LPCWSTR,
        cchASCIIChar: ::std::os::raw::c_int,
        lpUnicodeCharStr: LPWSTR,
        cchUnicodeChar: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IdnToNameprepUnicode(
        dwFlags: DWORD,
        lpUnicodeCharStr: LPCWSTR,
        cchUnicodeChar: ::std::os::raw::c_int,
        lpNameprepCharStr: LPWSTR,
        cchNameprepChar: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NormalizeString(
        NormForm: NORM_FORM,
        lpSrcString: LPCWSTR,
        cwSrcLength: ::std::os::raw::c_int,
        lpDstString: LPWSTR,
        cwDstLength: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsNormalizedString(
        NormForm: NORM_FORM,
        lpString: LPCWSTR,
        cwLength: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn VerifyScripts(
        dwFlags: DWORD,
        lpLocaleScripts: LPCWSTR,
        cchLocaleScripts: ::std::os::raw::c_int,
        lpTestScripts: LPCWSTR,
        cchTestScripts: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn GetStringScripts(
        dwFlags: DWORD,
        lpString: LPCWSTR,
        cchString: ::std::os::raw::c_int,
        lpScripts: LPWSTR,
        cchScripts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetLocaleInfoEx(
        lpLocaleName: LPCWSTR,
        LCType: LCTYPE,
        lpLCData: LPWSTR,
        cchData: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetCalendarInfoEx(
        lpLocaleName: LPCWSTR,
        Calendar: CALID,
        lpReserved: LPCWSTR,
        CalType: CALTYPE,
        lpCalData: LPWSTR,
        cchData: ::std::os::raw::c_int,
        lpValue: LPDWORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetNumberFormatEx(
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lpValue: LPCWSTR,
        lpFormat: *const NUMBERFMTW,
        lpNumberStr: LPWSTR,
        cchNumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetCurrencyFormatEx(
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lpValue: LPCWSTR,
        lpFormat: *const CURRENCYFMTW,
        lpCurrencyStr: LPWSTR,
        cchCurrency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetUserDefaultLocaleName(
        lpLocaleName: LPWSTR,
        cchLocaleName: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetSystemDefaultLocaleName(
        lpLocaleName: LPWSTR,
        cchLocaleName: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsNLSDefinedString(
        Function: NLS_FUNCTION,
        dwFlags: DWORD,
        lpVersionInformation: LPNLSVERSIONINFO,
        lpString: LPCWSTR,
        cchStr: INT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetNLSVersionEx(
        function: NLS_FUNCTION,
        lpLocaleName: LPCWSTR,
        lpVersionInformation: LPNLSVERSIONINFOEX,
    ) -> BOOL;
}
extern "C" {
    pub fn IsValidNLSVersion(
        function: NLS_FUNCTION,
        lpLocaleName: LPCWSTR,
        lpVersionInformation: LPNLSVERSIONINFOEX,
    ) -> DWORD;
}
extern "C" {
    pub fn FindNLSStringEx(
        lpLocaleName: LPCWSTR,
        dwFindNLSStringFlags: DWORD,
        lpStringSource: LPCWSTR,
        cchSource: ::std::os::raw::c_int,
        lpStringValue: LPCWSTR,
        cchValue: ::std::os::raw::c_int,
        pcchFound: LPINT,
        lpVersionInformation: LPNLSVERSIONINFO,
        lpReserved: LPVOID,
        sortHandle: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LCMapStringEx(
        lpLocaleName: LPCWSTR,
        dwMapFlags: DWORD,
        lpSrcStr: LPCWSTR,
        cchSrc: ::std::os::raw::c_int,
        lpDestStr: LPWSTR,
        cchDest: ::std::os::raw::c_int,
        lpVersionInformation: LPNLSVERSIONINFO,
        lpReserved: LPVOID,
        sortHandle: LPARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsValidLocaleName(lpLocaleName: LPCWSTR) -> BOOL;
}
pub type CALINFO_ENUMPROCEXEX = ::std::option::Option<
    unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID, arg3: LPWSTR, arg4: LPARAM) -> BOOL,
>;
extern "C" {
    pub fn EnumCalendarInfoExEx(
        pCalInfoEnumProcExEx: CALINFO_ENUMPROCEXEX,
        lpLocaleName: LPCWSTR,
        Calendar: CALID,
        lpReserved: LPCWSTR,
        CalType: CALTYPE,
        lParam: LPARAM,
    ) -> BOOL;
}
pub type DATEFMT_ENUMPROCEXEX =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: CALID, arg3: LPARAM) -> BOOL>;
extern "C" {
    pub fn EnumDateFormatsExEx(
        lpDateFmtEnumProcExEx: DATEFMT_ENUMPROCEXEX,
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lParam: LPARAM,
    ) -> BOOL;
}
pub type TIMEFMT_ENUMPROCEX =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: LPARAM) -> BOOL>;
extern "C" {
    pub fn EnumTimeFormatsEx(
        lpTimeFmtEnumProcEx: TIMEFMT_ENUMPROCEX,
        lpLocaleName: LPCWSTR,
        dwFlags: DWORD,
        lParam: LPARAM,
    ) -> BOOL;
}
pub type LOCALE_ENUMPROCEX =
    ::std::option::Option<unsafe extern "C" fn(arg1: LPWSTR, arg2: DWORD, arg3: LPARAM) -> BOOL>;
extern "C" {
    pub fn EnumSystemLocalesEx(
        lpLocaleEnumProcEx: LOCALE_ENUMPROCEX,
        dwFlags: DWORD,
        lParam: LPARAM,
        lpReserved: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn ResolveLocaleName(
        lpNameToResolve: LPCWSTR,
        lpLocaleName: LPWSTR,
        cchLocaleName: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COORD {
    pub X: SHORT,
    pub Y: SHORT,
}
pub type COORD = _COORD;
pub type PCOORD = *mut _COORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMALL_RECT {
    pub Left: SHORT,
    pub Top: SHORT,
    pub Right: SHORT,
    pub Bottom: SHORT,
}
pub type SMALL_RECT = _SMALL_RECT;
pub type PSMALL_RECT = *mut _SMALL_RECT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEY_EVENT_RECORD {
    pub bKeyDown: BOOL,
    pub wRepeatCount: WORD,
    pub wVirtualKeyCode: WORD,
    pub wVirtualScanCode: WORD,
    pub uChar: _KEY_EVENT_RECORD__bindgen_ty_1,
    pub dwControlKeyState: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KEY_EVENT_RECORD__bindgen_ty_1 {
    pub UnicodeChar: WCHAR,
    pub AsciiChar: CHAR,
}
pub type KEY_EVENT_RECORD = _KEY_EVENT_RECORD;
pub type PKEY_EVENT_RECORD = *mut _KEY_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOUSE_EVENT_RECORD {
    pub dwMousePosition: COORD,
    pub dwButtonState: DWORD,
    pub dwControlKeyState: DWORD,
    pub dwEventFlags: DWORD,
}
pub type MOUSE_EVENT_RECORD = _MOUSE_EVENT_RECORD;
pub type PMOUSE_EVENT_RECORD = *mut _MOUSE_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WINDOW_BUFFER_SIZE_RECORD {
    pub dwSize: COORD,
}
pub type WINDOW_BUFFER_SIZE_RECORD = _WINDOW_BUFFER_SIZE_RECORD;
pub type PWINDOW_BUFFER_SIZE_RECORD = *mut _WINDOW_BUFFER_SIZE_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MENU_EVENT_RECORD {
    pub dwCommandId: UINT,
}
pub type MENU_EVENT_RECORD = _MENU_EVENT_RECORD;
pub type PMENU_EVENT_RECORD = *mut _MENU_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FOCUS_EVENT_RECORD {
    pub bSetFocus: BOOL,
}
pub type FOCUS_EVENT_RECORD = _FOCUS_EVENT_RECORD;
pub type PFOCUS_EVENT_RECORD = *mut _FOCUS_EVENT_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _INPUT_RECORD {
    pub EventType: WORD,
    pub Event: _INPUT_RECORD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _INPUT_RECORD__bindgen_ty_1 {
    pub KeyEvent: KEY_EVENT_RECORD,
    pub MouseEvent: MOUSE_EVENT_RECORD,
    pub WindowBufferSizeEvent: WINDOW_BUFFER_SIZE_RECORD,
    pub MenuEvent: MENU_EVENT_RECORD,
    pub FocusEvent: FOCUS_EVENT_RECORD,
}
pub type INPUT_RECORD = _INPUT_RECORD;
pub type PINPUT_RECORD = *mut _INPUT_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CHAR_INFO {
    pub Char: _CHAR_INFO__bindgen_ty_1,
    pub Attributes: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CHAR_INFO__bindgen_ty_1 {
    pub UnicodeChar: WCHAR,
    pub AsciiChar: CHAR,
}
pub type CHAR_INFO = _CHAR_INFO;
pub type PCHAR_INFO = *mut _CHAR_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_FONT_INFO {
    pub nFont: DWORD,
    pub dwFontSize: COORD,
}
pub type CONSOLE_FONT_INFO = _CONSOLE_FONT_INFO;
pub type PCONSOLE_FONT_INFO = *mut _CONSOLE_FONT_INFO;
pub type HPCON = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn AllocConsole() -> BOOL;
}
extern "C" {
    pub fn FreeConsole() -> BOOL;
}
extern "C" {
    pub fn AttachConsole(dwProcessId: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetConsoleCP() -> UINT;
}
extern "C" {
    pub fn GetConsoleOutputCP() -> UINT;
}
extern "C" {
    pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SetConsoleMode(hConsoleHandle: HANDLE, dwMode: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetNumberOfConsoleInputEvents(hConsoleInput: HANDLE, lpNumberOfEvents: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleInputA(
        hConsoleInput: HANDLE,
        lpBuffer: PINPUT_RECORD,
        nLength: DWORD,
        lpNumberOfEventsRead: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleInputW(
        hConsoleInput: HANDLE,
        lpBuffer: PINPUT_RECORD,
        nLength: DWORD,
        lpNumberOfEventsRead: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PeekConsoleInputA(
        hConsoleInput: HANDLE,
        lpBuffer: PINPUT_RECORD,
        nLength: DWORD,
        lpNumberOfEventsRead: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PeekConsoleInputW(
        hConsoleInput: HANDLE,
        lpBuffer: PINPUT_RECORD,
        nLength: DWORD,
        lpNumberOfEventsRead: LPDWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_READCONSOLE_CONTROL {
    pub nLength: ULONG,
    pub nInitialChars: ULONG,
    pub dwCtrlWakeupMask: ULONG,
    pub dwControlKeyState: ULONG,
}
pub type CONSOLE_READCONSOLE_CONTROL = _CONSOLE_READCONSOLE_CONTROL;
pub type PCONSOLE_READCONSOLE_CONTROL = *mut _CONSOLE_READCONSOLE_CONTROL;
extern "C" {
    pub fn ReadConsoleA(
        hConsoleInput: HANDLE,
        lpBuffer: LPVOID,
        nNumberOfCharsToRead: DWORD,
        lpNumberOfCharsRead: LPDWORD,
        pInputControl: PCONSOLE_READCONSOLE_CONTROL,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleW(
        hConsoleInput: HANDLE,
        lpBuffer: LPVOID,
        nNumberOfCharsToRead: DWORD,
        lpNumberOfCharsRead: LPDWORD,
        pInputControl: PCONSOLE_READCONSOLE_CONTROL,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleA(
        hConsoleOutput: HANDLE,
        lpBuffer: *const ::std::os::raw::c_void,
        nNumberOfCharsToWrite: DWORD,
        lpNumberOfCharsWritten: LPDWORD,
        lpReserved: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleW(
        hConsoleOutput: HANDLE,
        lpBuffer: *const ::std::os::raw::c_void,
        nNumberOfCharsToWrite: DWORD,
        lpNumberOfCharsWritten: LPDWORD,
        lpReserved: LPVOID,
    ) -> BOOL;
}
pub type PHANDLER_ROUTINE = ::std::option::Option<unsafe extern "C" fn(CtrlType: DWORD) -> BOOL>;
extern "C" {
    pub fn SetConsoleCtrlHandler(HandlerRoutine: PHANDLER_ROUTINE, Add: BOOL) -> BOOL;
}
extern "C" {
    pub fn CreatePseudoConsole(
        size: COORD,
        hInput: HANDLE,
        hOutput: HANDLE,
        dwFlags: DWORD,
        phPC: *mut HPCON,
    ) -> HRESULT;
}
extern "C" {
    pub fn ResizePseudoConsole(hPC: HPCON, size: COORD) -> HRESULT;
}
extern "C" {
    pub fn ClosePseudoConsole(hPC: HPCON);
}
extern "C" {
    pub fn FillConsoleOutputCharacterA(
        hConsoleOutput: HANDLE,
        cCharacter: CHAR,
        nLength: DWORD,
        dwWriteCoord: COORD,
        lpNumberOfCharsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FillConsoleOutputCharacterW(
        hConsoleOutput: HANDLE,
        cCharacter: WCHAR,
        nLength: DWORD,
        dwWriteCoord: COORD,
        lpNumberOfCharsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FillConsoleOutputAttribute(
        hConsoleOutput: HANDLE,
        wAttribute: WORD,
        nLength: DWORD,
        dwWriteCoord: COORD,
        lpNumberOfAttrsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GenerateConsoleCtrlEvent(dwCtrlEvent: DWORD, dwProcessGroupId: DWORD) -> BOOL;
}
extern "C" {
    pub fn CreateConsoleScreenBuffer(
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: *const SECURITY_ATTRIBUTES,
        dwFlags: DWORD,
        lpScreenBufferData: LPVOID,
    ) -> HANDLE;
}
extern "C" {
    pub fn SetConsoleActiveScreenBuffer(hConsoleOutput: HANDLE) -> BOOL;
}
extern "C" {
    pub fn FlushConsoleInputBuffer(hConsoleInput: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetConsoleCP(wCodePageID: UINT) -> BOOL;
}
extern "C" {
    pub fn SetConsoleOutputCP(wCodePageID: UINT) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_CURSOR_INFO {
    pub dwSize: DWORD,
    pub bVisible: BOOL,
}
pub type CONSOLE_CURSOR_INFO = _CONSOLE_CURSOR_INFO;
pub type PCONSOLE_CURSOR_INFO = *mut _CONSOLE_CURSOR_INFO;
extern "C" {
    pub fn GetConsoleCursorInfo(
        hConsoleOutput: HANDLE,
        lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn SetConsoleCursorInfo(
        hConsoleOutput: HANDLE,
        lpConsoleCursorInfo: *const CONSOLE_CURSOR_INFO,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_SCREEN_BUFFER_INFO {
    pub dwSize: COORD,
    pub dwCursorPosition: COORD,
    pub wAttributes: WORD,
    pub srWindow: SMALL_RECT,
    pub dwMaximumWindowSize: COORD,
}
pub type CONSOLE_SCREEN_BUFFER_INFO = _CONSOLE_SCREEN_BUFFER_INFO;
pub type PCONSOLE_SCREEN_BUFFER_INFO = *mut _CONSOLE_SCREEN_BUFFER_INFO;
extern "C" {
    pub fn GetConsoleScreenBufferInfo(
        hConsoleOutput: HANDLE,
        lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    pub cbSize: ULONG,
    pub dwSize: COORD,
    pub dwCursorPosition: COORD,
    pub wAttributes: WORD,
    pub srWindow: SMALL_RECT,
    pub dwMaximumWindowSize: COORD,
    pub wPopupAttributes: WORD,
    pub bFullscreenSupported: BOOL,
    pub ColorTable: [COLORREF; 16usize],
}
pub type CONSOLE_SCREEN_BUFFER_INFOEX = _CONSOLE_SCREEN_BUFFER_INFOEX;
pub type PCONSOLE_SCREEN_BUFFER_INFOEX = *mut _CONSOLE_SCREEN_BUFFER_INFOEX;
extern "C" {
    pub fn GetConsoleScreenBufferInfoEx(
        hConsoleOutput: HANDLE,
        lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
    ) -> BOOL;
}
extern "C" {
    pub fn SetConsoleScreenBufferInfoEx(
        hConsoleOutput: HANDLE,
        lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX,
    ) -> BOOL;
}
extern "C" {
    pub fn SetConsoleScreenBufferSize(hConsoleOutput: HANDLE, dwSize: COORD) -> BOOL;
}
extern "C" {
    pub fn SetConsoleCursorPosition(hConsoleOutput: HANDLE, dwCursorPosition: COORD) -> BOOL;
}
extern "C" {
    pub fn GetLargestConsoleWindowSize(hConsoleOutput: HANDLE) -> COORD;
}
extern "C" {
    pub fn SetConsoleTextAttribute(hConsoleOutput: HANDLE, wAttributes: WORD) -> BOOL;
}
extern "C" {
    pub fn SetConsoleWindowInfo(
        hConsoleOutput: HANDLE,
        bAbsolute: BOOL,
        lpConsoleWindow: *const SMALL_RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleOutputCharacterA(
        hConsoleOutput: HANDLE,
        lpCharacter: LPCSTR,
        nLength: DWORD,
        dwWriteCoord: COORD,
        lpNumberOfCharsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleOutputCharacterW(
        hConsoleOutput: HANDLE,
        lpCharacter: LPCWSTR,
        nLength: DWORD,
        dwWriteCoord: COORD,
        lpNumberOfCharsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleOutputAttribute(
        hConsoleOutput: HANDLE,
        lpAttribute: *const WORD,
        nLength: DWORD,
        dwWriteCoord: COORD,
        lpNumberOfAttrsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleOutputCharacterA(
        hConsoleOutput: HANDLE,
        lpCharacter: LPSTR,
        nLength: DWORD,
        dwReadCoord: COORD,
        lpNumberOfCharsRead: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleOutputCharacterW(
        hConsoleOutput: HANDLE,
        lpCharacter: LPWSTR,
        nLength: DWORD,
        dwReadCoord: COORD,
        lpNumberOfCharsRead: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleOutputAttribute(
        hConsoleOutput: HANDLE,
        lpAttribute: LPWORD,
        nLength: DWORD,
        dwReadCoord: COORD,
        lpNumberOfAttrsRead: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleInputA(
        hConsoleInput: HANDLE,
        lpBuffer: *const INPUT_RECORD,
        nLength: DWORD,
        lpNumberOfEventsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleInputW(
        hConsoleInput: HANDLE,
        lpBuffer: *const INPUT_RECORD,
        nLength: DWORD,
        lpNumberOfEventsWritten: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ScrollConsoleScreenBufferA(
        hConsoleOutput: HANDLE,
        lpScrollRectangle: *const SMALL_RECT,
        lpClipRectangle: *const SMALL_RECT,
        dwDestinationOrigin: COORD,
        lpFill: *const CHAR_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn ScrollConsoleScreenBufferW(
        hConsoleOutput: HANDLE,
        lpScrollRectangle: *const SMALL_RECT,
        lpClipRectangle: *const SMALL_RECT,
        dwDestinationOrigin: COORD,
        lpFill: *const CHAR_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleOutputA(
        hConsoleOutput: HANDLE,
        lpBuffer: *const CHAR_INFO,
        dwBufferSize: COORD,
        dwBufferCoord: COORD,
        lpWriteRegion: PSMALL_RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteConsoleOutputW(
        hConsoleOutput: HANDLE,
        lpBuffer: *const CHAR_INFO,
        dwBufferSize: COORD,
        dwBufferCoord: COORD,
        lpWriteRegion: PSMALL_RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleOutputA(
        hConsoleOutput: HANDLE,
        lpBuffer: PCHAR_INFO,
        dwBufferSize: COORD,
        dwBufferCoord: COORD,
        lpReadRegion: PSMALL_RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn ReadConsoleOutputW(
        hConsoleOutput: HANDLE,
        lpBuffer: PCHAR_INFO,
        dwBufferSize: COORD,
        dwBufferCoord: COORD,
        lpReadRegion: PSMALL_RECT,
    ) -> BOOL;
}
extern "C" {
    pub fn GetConsoleTitleA(lpConsoleTitle: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetConsoleTitleW(lpConsoleTitle: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetConsoleOriginalTitleA(lpConsoleTitle: LPSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetConsoleOriginalTitleW(lpConsoleTitle: LPWSTR, nSize: DWORD) -> DWORD;
}
extern "C" {
    pub fn SetConsoleTitleA(lpConsoleTitle: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetConsoleTitleW(lpConsoleTitle: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn GetNumberOfConsoleMouseButtons(lpNumberOfMouseButtons: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetConsoleFontSize(hConsoleOutput: HANDLE, nFont: DWORD) -> COORD;
}
extern "C" {
    pub fn GetCurrentConsoleFont(
        hConsoleOutput: HANDLE,
        bMaximumWindow: BOOL,
        lpConsoleCurrentFont: PCONSOLE_FONT_INFO,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_FONT_INFOEX {
    pub cbSize: ULONG,
    pub nFont: DWORD,
    pub dwFontSize: COORD,
    pub FontFamily: UINT,
    pub FontWeight: UINT,
    pub FaceName: [WCHAR; 32usize],
}
pub type CONSOLE_FONT_INFOEX = _CONSOLE_FONT_INFOEX;
pub type PCONSOLE_FONT_INFOEX = *mut _CONSOLE_FONT_INFOEX;
extern "C" {
    pub fn GetCurrentConsoleFontEx(
        hConsoleOutput: HANDLE,
        bMaximumWindow: BOOL,
        lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
    ) -> BOOL;
}
extern "C" {
    pub fn SetCurrentConsoleFontEx(
        hConsoleOutput: HANDLE,
        bMaximumWindow: BOOL,
        lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_SELECTION_INFO {
    pub dwFlags: DWORD,
    pub dwSelectionAnchor: COORD,
    pub srSelection: SMALL_RECT,
}
pub type CONSOLE_SELECTION_INFO = _CONSOLE_SELECTION_INFO;
pub type PCONSOLE_SELECTION_INFO = *mut _CONSOLE_SELECTION_INFO;
extern "C" {
    pub fn GetConsoleSelectionInfo(lpConsoleSelectionInfo: PCONSOLE_SELECTION_INFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONSOLE_HISTORY_INFO {
    pub cbSize: UINT,
    pub HistoryBufferSize: UINT,
    pub NumberOfHistoryBuffers: UINT,
    pub dwFlags: DWORD,
}
pub type CONSOLE_HISTORY_INFO = _CONSOLE_HISTORY_INFO;
pub type PCONSOLE_HISTORY_INFO = *mut _CONSOLE_HISTORY_INFO;
extern "C" {
    pub fn GetConsoleHistoryInfo(lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO) -> BOOL;
}
extern "C" {
    pub fn SetConsoleHistoryInfo(lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO) -> BOOL;
}
extern "C" {
    pub fn GetConsoleDisplayMode(lpModeFlags: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SetConsoleDisplayMode(
        hConsoleOutput: HANDLE,
        dwFlags: DWORD,
        lpNewScreenBufferDimensions: PCOORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetConsoleWindow() -> HWND;
}
extern "C" {
    pub fn AddConsoleAliasA(Source: LPSTR, Target: LPSTR, ExeName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn AddConsoleAliasW(Source: LPWSTR, Target: LPWSTR, ExeName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn GetConsoleAliasA(
        Source: LPSTR,
        TargetBuffer: LPSTR,
        TargetBufferLength: DWORD,
        ExeName: LPSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasW(
        Source: LPWSTR,
        TargetBuffer: LPWSTR,
        TargetBufferLength: DWORD,
        ExeName: LPWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasesLengthA(ExeName: LPSTR) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasesLengthW(ExeName: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasExesLengthA() -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasExesLengthW() -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasesA(
        AliasBuffer: LPSTR,
        AliasBufferLength: DWORD,
        ExeName: LPSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasesW(
        AliasBuffer: LPWSTR,
        AliasBufferLength: DWORD,
        ExeName: LPWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasExesA(ExeNameBuffer: LPSTR, ExeNameBufferLength: DWORD) -> DWORD;
}
extern "C" {
    pub fn GetConsoleAliasExesW(ExeNameBuffer: LPWSTR, ExeNameBufferLength: DWORD) -> DWORD;
}
extern "C" {
    pub fn ExpungeConsoleCommandHistoryA(ExeName: LPSTR);
}
extern "C" {
    pub fn ExpungeConsoleCommandHistoryW(ExeName: LPWSTR);
}
extern "C" {
    pub fn SetConsoleNumberOfCommandsA(Number: DWORD, ExeName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn SetConsoleNumberOfCommandsW(Number: DWORD, ExeName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn GetConsoleCommandHistoryLengthA(ExeName: LPSTR) -> DWORD;
}
extern "C" {
    pub fn GetConsoleCommandHistoryLengthW(ExeName: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn GetConsoleCommandHistoryA(
        Commands: LPSTR,
        CommandBufferLength: DWORD,
        ExeName: LPSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetConsoleCommandHistoryW(
        Commands: LPWSTR,
        CommandBufferLength: DWORD,
        ExeName: LPWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn GetConsoleProcessList(lpdwProcessList: LPDWORD, dwProcessCount: DWORD) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVS_FIXEDFILEINFO {
    pub dwSignature: DWORD,
    pub dwStrucVersion: DWORD,
    pub dwFileVersionMS: DWORD,
    pub dwFileVersionLS: DWORD,
    pub dwProductVersionMS: DWORD,
    pub dwProductVersionLS: DWORD,
    pub dwFileFlagsMask: DWORD,
    pub dwFileFlags: DWORD,
    pub dwFileOS: DWORD,
    pub dwFileType: DWORD,
    pub dwFileSubtype: DWORD,
    pub dwFileDateMS: DWORD,
    pub dwFileDateLS: DWORD,
}
pub type VS_FIXEDFILEINFO = tagVS_FIXEDFILEINFO;
extern "C" {
    pub fn VerFindFileA(
        uFlags: DWORD,
        szFileName: LPCSTR,
        szWinDir: LPCSTR,
        szAppDir: LPCSTR,
        szCurDir: LPSTR,
        puCurDirLen: PUINT,
        szDestDir: LPSTR,
        puDestDirLen: PUINT,
    ) -> DWORD;
}
extern "C" {
    pub fn VerFindFileW(
        uFlags: DWORD,
        szFileName: LPCWSTR,
        szWinDir: LPCWSTR,
        szAppDir: LPCWSTR,
        szCurDir: LPWSTR,
        puCurDirLen: PUINT,
        szDestDir: LPWSTR,
        puDestDirLen: PUINT,
    ) -> DWORD;
}
extern "C" {
    pub fn VerInstallFileA(
        uFlags: DWORD,
        szSrcFileName: LPCSTR,
        szDestFileName: LPCSTR,
        szSrcDir: LPCSTR,
        szDestDir: LPCSTR,
        szCurDir: LPCSTR,
        szTmpFile: LPSTR,
        puTmpFileLen: PUINT,
    ) -> DWORD;
}
extern "C" {
    pub fn VerInstallFileW(
        uFlags: DWORD,
        szSrcFileName: LPCWSTR,
        szDestFileName: LPCWSTR,
        szSrcDir: LPCWSTR,
        szDestDir: LPCWSTR,
        szCurDir: LPCWSTR,
        szTmpFile: LPWSTR,
        puTmpFileLen: PUINT,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFileVersionInfoSizeA(lptstrFilename: LPCSTR, lpdwHandle: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn GetFileVersionInfoSizeW(lptstrFilename: LPCWSTR, lpdwHandle: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn GetFileVersionInfoA(
        lptstrFilename: LPCSTR,
        dwHandle: DWORD,
        dwLen: DWORD,
        lpData: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileVersionInfoW(
        lptstrFilename: LPCWSTR,
        dwHandle: DWORD,
        dwLen: DWORD,
        lpData: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileVersionInfoSizeExA(
        dwFlags: DWORD,
        lpwstrFilename: LPCSTR,
        lpdwHandle: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFileVersionInfoSizeExW(
        dwFlags: DWORD,
        lpwstrFilename: LPCWSTR,
        lpdwHandle: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetFileVersionInfoExA(
        dwFlags: DWORD,
        lpwstrFilename: LPCSTR,
        dwHandle: DWORD,
        dwLen: DWORD,
        lpData: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileVersionInfoExW(
        dwFlags: DWORD,
        lpwstrFilename: LPCWSTR,
        dwHandle: DWORD,
        dwLen: DWORD,
        lpData: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn VerLanguageNameA(wLang: DWORD, szLang: LPSTR, cchLang: DWORD) -> DWORD;
}
extern "C" {
    pub fn VerLanguageNameW(wLang: DWORD, szLang: LPWSTR, cchLang: DWORD) -> DWORD;
}
extern "C" {
    pub fn VerQueryValueA(
        pBlock: LPCVOID,
        lpSubBlock: LPCSTR,
        lplpBuffer: *mut LPVOID,
        puLen: PUINT,
    ) -> BOOL;
}
extern "C" {
    pub fn VerQueryValueW(
        pBlock: LPCVOID,
        lpSubBlock: LPCWSTR,
        lplpBuffer: *mut LPVOID,
        puLen: PUINT,
    ) -> BOOL;
}
pub type LSTATUS = LONG;
pub type REGSAM = ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct val_context {
    pub valuelen: ::std::os::raw::c_int,
    pub value_context: LPVOID,
    pub val_buff_ptr: LPVOID,
}
pub type PVALCONTEXT = *mut val_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvalueA {
    pub pv_valuename: LPSTR,
    pub pv_valuelen: ::std::os::raw::c_int,
    pub pv_value_context: LPVOID,
    pub pv_type: DWORD,
}
pub type PVALUEA = pvalueA;
pub type PPVALUEA = *mut pvalueA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvalueW {
    pub pv_valuename: LPWSTR,
    pub pv_valuelen: ::std::os::raw::c_int,
    pub pv_value_context: LPVOID,
    pub pv_type: DWORD,
}
pub type PVALUEW = pvalueW;
pub type PPVALUEW = *mut pvalueW;
pub type PVALUE = PVALUEA;
pub type PPVALUE = PPVALUEA;
pub type PQUERYHANDLER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: LPVOID,
        arg2: PVALCONTEXT,
        arg3: DWORD,
        arg4: LPVOID,
        arg5: *mut DWORD,
        arg6: DWORD,
    ) -> DWORD,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct provider_info {
    pub pi_R0_1val: PQUERYHANDLER,
    pub pi_R0_allvals: PQUERYHANDLER,
    pub pi_R3_1val: PQUERYHANDLER,
    pub pi_R3_allvals: PQUERYHANDLER,
    pub pi_flags: DWORD,
    pub pi_key_context: LPVOID,
}
pub type REG_PROVIDER = provider_info;
pub type PPROVIDER = *mut provider_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct value_entA {
    pub ve_valuename: LPSTR,
    pub ve_valuelen: DWORD,
    pub ve_valueptr: DWORD_PTR,
    pub ve_type: DWORD,
}
pub type VALENTA = value_entA;
pub type PVALENTA = *mut value_entA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct value_entW {
    pub ve_valuename: LPWSTR,
    pub ve_valuelen: DWORD,
    pub ve_valueptr: DWORD_PTR,
    pub ve_type: DWORD,
}
pub type VALENTW = value_entW;
pub type PVALENTW = *mut value_entW;
pub type VALENT = VALENTA;
pub type PVALENT = PVALENTA;
extern "C" {
    pub fn RegCloseKey(hKey: HKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegOverridePredefKey(hKey: HKEY, hNewHKey: HKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenUserClassesRoot(
        hToken: HANDLE,
        dwOptions: DWORD,
        samDesired: REGSAM,
        phkResult: PHKEY,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenCurrentUser(samDesired: REGSAM, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegDisablePredefinedCache() -> LSTATUS;
}
extern "C" {
    pub fn RegDisablePredefinedCacheEx() -> LSTATUS;
}
extern "C" {
    pub fn RegConnectRegistryA(lpMachineName: LPCSTR, hKey: HKEY, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegConnectRegistryW(lpMachineName: LPCWSTR, hKey: HKEY, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegConnectRegistryExA(
        lpMachineName: LPCSTR,
        hKey: HKEY,
        Flags: ULONG,
        phkResult: PHKEY,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegConnectRegistryExW(
        lpMachineName: LPCWSTR,
        hKey: HKEY,
        Flags: ULONG,
        phkResult: PHKEY,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegCreateKeyA(hKey: HKEY, lpSubKey: LPCSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegCreateKeyW(hKey: HKEY, lpSubKey: LPCWSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegCreateKeyExA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        Reserved: DWORD,
        lpClass: LPSTR,
        dwOptions: DWORD,
        samDesired: REGSAM,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        phkResult: PHKEY,
        lpdwDisposition: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegCreateKeyExW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        Reserved: DWORD,
        lpClass: LPWSTR,
        dwOptions: DWORD,
        samDesired: REGSAM,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        phkResult: PHKEY,
        lpdwDisposition: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegCreateKeyTransactedA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        Reserved: DWORD,
        lpClass: LPSTR,
        dwOptions: DWORD,
        samDesired: REGSAM,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        phkResult: PHKEY,
        lpdwDisposition: LPDWORD,
        hTransaction: HANDLE,
        pExtendedParemeter: PVOID,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegCreateKeyTransactedW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        Reserved: DWORD,
        lpClass: LPWSTR,
        dwOptions: DWORD,
        samDesired: REGSAM,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        phkResult: PHKEY,
        lpdwDisposition: LPDWORD,
        hTransaction: HANDLE,
        pExtendedParemeter: PVOID,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyA(hKey: HKEY, lpSubKey: LPCSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyW(hKey: HKEY, lpSubKey: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyExA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        samDesired: REGSAM,
        Reserved: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyExW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        samDesired: REGSAM,
        Reserved: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyTransactedA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        samDesired: REGSAM,
        Reserved: DWORD,
        hTransaction: HANDLE,
        pExtendedParameter: PVOID,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyTransactedW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        samDesired: REGSAM,
        Reserved: DWORD,
        hTransaction: HANDLE,
        pExtendedParameter: PVOID,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegDisableReflectionKey(hBase: HKEY) -> LONG;
}
extern "C" {
    pub fn RegEnableReflectionKey(hBase: HKEY) -> LONG;
}
extern "C" {
    pub fn RegQueryReflectionKey(hBase: HKEY, bIsReflectionDisabled: *mut BOOL) -> LONG;
}
extern "C" {
    pub fn RegDeleteValueA(hKey: HKEY, lpValueName: LPCSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteValueW(hKey: HKEY, lpValueName: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegEnumKeyA(hKey: HKEY, dwIndex: DWORD, lpName: LPSTR, cchName: DWORD) -> LSTATUS;
}
extern "C" {
    pub fn RegEnumKeyW(hKey: HKEY, dwIndex: DWORD, lpName: LPWSTR, cchName: DWORD) -> LSTATUS;
}
extern "C" {
    pub fn RegEnumKeyExA(
        hKey: HKEY,
        dwIndex: DWORD,
        lpName: LPSTR,
        lpcchName: LPDWORD,
        lpReserved: LPDWORD,
        lpClass: LPSTR,
        lpcchClass: LPDWORD,
        lpftLastWriteTime: PFILETIME,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegEnumKeyExW(
        hKey: HKEY,
        dwIndex: DWORD,
        lpName: LPWSTR,
        lpcchName: LPDWORD,
        lpReserved: LPDWORD,
        lpClass: LPWSTR,
        lpcchClass: LPDWORD,
        lpftLastWriteTime: PFILETIME,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegEnumValueA(
        hKey: HKEY,
        dwIndex: DWORD,
        lpValueName: LPSTR,
        lpcchValueName: LPDWORD,
        lpReserved: LPDWORD,
        lpType: LPDWORD,
        lpData: LPBYTE,
        lpcbData: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegEnumValueW(
        hKey: HKEY,
        dwIndex: DWORD,
        lpValueName: LPWSTR,
        lpcchValueName: LPDWORD,
        lpReserved: LPDWORD,
        lpType: LPDWORD,
        lpData: LPBYTE,
        lpcbData: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegFlushKey(hKey: HKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegGetKeySecurity(
        hKey: HKEY,
        SecurityInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        lpcbSecurityDescriptor: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegLoadKeyA(hKey: HKEY, lpSubKey: LPCSTR, lpFile: LPCSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegLoadKeyW(hKey: HKEY, lpSubKey: LPCWSTR, lpFile: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegNotifyChangeKeyValue(
        hKey: HKEY,
        bWatchSubtree: BOOL,
        dwNotifyFilter: DWORD,
        hEvent: HANDLE,
        fAsynchronous: BOOL,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenKeyA(hKey: HKEY, lpSubKey: LPCSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenKeyW(hKey: HKEY, lpSubKey: LPCWSTR, phkResult: PHKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenKeyExA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        ulOptions: DWORD,
        samDesired: REGSAM,
        phkResult: PHKEY,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenKeyExW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        ulOptions: DWORD,
        samDesired: REGSAM,
        phkResult: PHKEY,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenKeyTransactedA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        ulOptions: DWORD,
        samDesired: REGSAM,
        phkResult: PHKEY,
        hTransaction: HANDLE,
        pExtendedParemeter: PVOID,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegOpenKeyTransactedW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        ulOptions: DWORD,
        samDesired: REGSAM,
        phkResult: PHKEY,
        hTransaction: HANDLE,
        pExtendedParemeter: PVOID,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryInfoKeyA(
        hKey: HKEY,
        lpClass: LPSTR,
        lpcchClass: LPDWORD,
        lpReserved: LPDWORD,
        lpcSubKeys: LPDWORD,
        lpcbMaxSubKeyLen: LPDWORD,
        lpcbMaxClassLen: LPDWORD,
        lpcValues: LPDWORD,
        lpcbMaxValueNameLen: LPDWORD,
        lpcbMaxValueLen: LPDWORD,
        lpcbSecurityDescriptor: LPDWORD,
        lpftLastWriteTime: PFILETIME,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryInfoKeyW(
        hKey: HKEY,
        lpClass: LPWSTR,
        lpcchClass: LPDWORD,
        lpReserved: LPDWORD,
        lpcSubKeys: LPDWORD,
        lpcbMaxSubKeyLen: LPDWORD,
        lpcbMaxClassLen: LPDWORD,
        lpcValues: LPDWORD,
        lpcbMaxValueNameLen: LPDWORD,
        lpcbMaxValueLen: LPDWORD,
        lpcbSecurityDescriptor: LPDWORD,
        lpftLastWriteTime: PFILETIME,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryValueA(hKey: HKEY, lpSubKey: LPCSTR, lpData: LPSTR, lpcbData: PLONG) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryValueW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        lpData: LPWSTR,
        lpcbData: PLONG,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryMultipleValuesA(
        hKey: HKEY,
        val_list: PVALENTA,
        num_vals: DWORD,
        lpValueBuf: LPSTR,
        ldwTotsize: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryMultipleValuesW(
        hKey: HKEY,
        val_list: PVALENTW,
        num_vals: DWORD,
        lpValueBuf: LPWSTR,
        ldwTotsize: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryValueExA(
        hKey: HKEY,
        lpValueName: LPCSTR,
        lpReserved: LPDWORD,
        lpType: LPDWORD,
        lpData: LPBYTE,
        lpcbData: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegQueryValueExW(
        hKey: HKEY,
        lpValueName: LPCWSTR,
        lpReserved: LPDWORD,
        lpType: LPDWORD,
        lpData: LPBYTE,
        lpcbData: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegReplaceKeyA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        lpNewFile: LPCSTR,
        lpOldFile: LPCSTR,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegReplaceKeyW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        lpNewFile: LPCWSTR,
        lpOldFile: LPCWSTR,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegRestoreKeyA(hKey: HKEY, lpFile: LPCSTR, dwFlags: DWORD) -> LSTATUS;
}
extern "C" {
    pub fn RegRestoreKeyW(hKey: HKEY, lpFile: LPCWSTR, dwFlags: DWORD) -> LSTATUS;
}
extern "C" {
    pub fn RegRenameKey(hKey: HKEY, lpSubKeyName: LPCWSTR, lpNewKeyName: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegSaveKeyA(
        hKey: HKEY,
        lpFile: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSaveKeyW(
        hKey: HKEY,
        lpFile: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSetKeySecurity(
        hKey: HKEY,
        SecurityInformation: SECURITY_INFORMATION,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSetValueA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        dwType: DWORD,
        lpData: LPCSTR,
        cbData: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSetValueW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        dwType: DWORD,
        lpData: LPCWSTR,
        cbData: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSetValueExA(
        hKey: HKEY,
        lpValueName: LPCSTR,
        Reserved: DWORD,
        dwType: DWORD,
        lpData: *const BYTE,
        cbData: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSetValueExW(
        hKey: HKEY,
        lpValueName: LPCWSTR,
        Reserved: DWORD,
        dwType: DWORD,
        lpData: *const BYTE,
        cbData: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegUnLoadKeyA(hKey: HKEY, lpSubKey: LPCSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegUnLoadKeyW(hKey: HKEY, lpSubKey: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyValueA(hKey: HKEY, lpSubKey: LPCSTR, lpValueName: LPCSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteKeyValueW(hKey: HKEY, lpSubKey: LPCWSTR, lpValueName: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegSetKeyValueA(
        hKey: HKEY,
        lpSubKey: LPCSTR,
        lpValueName: LPCSTR,
        dwType: DWORD,
        lpData: LPCVOID,
        cbData: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSetKeyValueW(
        hKey: HKEY,
        lpSubKey: LPCWSTR,
        lpValueName: LPCWSTR,
        dwType: DWORD,
        lpData: LPCVOID,
        cbData: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteTreeA(hKey: HKEY, lpSubKey: LPCSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegDeleteTreeW(hKey: HKEY, lpSubKey: LPCWSTR) -> LSTATUS;
}
extern "C" {
    pub fn RegCopyTreeA(hKeySrc: HKEY, lpSubKey: LPCSTR, hKeyDest: HKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegGetValueA(
        hkey: HKEY,
        lpSubKey: LPCSTR,
        lpValue: LPCSTR,
        dwFlags: DWORD,
        pdwType: LPDWORD,
        pvData: PVOID,
        pcbData: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegGetValueW(
        hkey: HKEY,
        lpSubKey: LPCWSTR,
        lpValue: LPCWSTR,
        dwFlags: DWORD,
        pdwType: LPDWORD,
        pvData: PVOID,
        pcbData: LPDWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegCopyTreeW(hKeySrc: HKEY, lpSubKey: LPCWSTR, hKeyDest: HKEY) -> LSTATUS;
}
extern "C" {
    pub fn RegLoadMUIStringA(
        hKey: HKEY,
        pszValue: LPCSTR,
        pszOutBuf: LPSTR,
        cbOutBuf: DWORD,
        pcbData: LPDWORD,
        Flags: DWORD,
        pszDirectory: LPCSTR,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegLoadMUIStringW(
        hKey: HKEY,
        pszValue: LPCWSTR,
        pszOutBuf: LPWSTR,
        cbOutBuf: DWORD,
        pcbData: LPDWORD,
        Flags: DWORD,
        pszDirectory: LPCWSTR,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegLoadAppKeyA(
        lpFile: LPCSTR,
        phkResult: PHKEY,
        samDesired: REGSAM,
        dwOptions: DWORD,
        Reserved: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegLoadAppKeyW(
        lpFile: LPCWSTR,
        phkResult: PHKEY,
        samDesired: REGSAM,
        dwOptions: DWORD,
        Reserved: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn InitiateSystemShutdownA(
        lpMachineName: LPSTR,
        lpMessage: LPSTR,
        dwTimeout: DWORD,
        bForceAppsClosed: BOOL,
        bRebootAfterShutdown: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn InitiateSystemShutdownW(
        lpMachineName: LPWSTR,
        lpMessage: LPWSTR,
        dwTimeout: DWORD,
        bForceAppsClosed: BOOL,
        bRebootAfterShutdown: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn AbortSystemShutdownA(lpMachineName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn AbortSystemShutdownW(lpMachineName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn InitiateSystemShutdownExA(
        lpMachineName: LPSTR,
        lpMessage: LPSTR,
        dwTimeout: DWORD,
        bForceAppsClosed: BOOL,
        bRebootAfterShutdown: BOOL,
        dwReason: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitiateSystemShutdownExW(
        lpMachineName: LPWSTR,
        lpMessage: LPWSTR,
        dwTimeout: DWORD,
        bForceAppsClosed: BOOL,
        bRebootAfterShutdown: BOOL,
        dwReason: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn InitiateShutdownA(
        lpMachineName: LPSTR,
        lpMessage: LPSTR,
        dwGracePeriod: DWORD,
        dwShutdownFlags: DWORD,
        dwReason: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn InitiateShutdownW(
        lpMachineName: LPWSTR,
        lpMessage: LPWSTR,
        dwGracePeriod: DWORD,
        dwShutdownFlags: DWORD,
        dwReason: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CheckForHiberboot(pHiberboot: PBOOLEAN, bClearFlag: BOOLEAN) -> DWORD;
}
extern "C" {
    pub fn RegSaveKeyExA(
        hKey: HKEY,
        lpFile: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        Flags: DWORD,
    ) -> LSTATUS;
}
extern "C" {
    pub fn RegSaveKeyExW(
        hKey: HKEY,
        lpFile: LPCWSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        Flags: DWORD,
    ) -> LSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETRESOURCEA {
    pub dwScope: DWORD,
    pub dwType: DWORD,
    pub dwDisplayType: DWORD,
    pub dwUsage: DWORD,
    pub lpLocalName: LPSTR,
    pub lpRemoteName: LPSTR,
    pub lpComment: LPSTR,
    pub lpProvider: LPSTR,
}
pub type NETRESOURCEA = _NETRESOURCEA;
pub type LPNETRESOURCEA = *mut _NETRESOURCEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETRESOURCEW {
    pub dwScope: DWORD,
    pub dwType: DWORD,
    pub dwDisplayType: DWORD,
    pub dwUsage: DWORD,
    pub lpLocalName: LPWSTR,
    pub lpRemoteName: LPWSTR,
    pub lpComment: LPWSTR,
    pub lpProvider: LPWSTR,
}
pub type NETRESOURCEW = _NETRESOURCEW;
pub type LPNETRESOURCEW = *mut _NETRESOURCEW;
pub type NETRESOURCE = NETRESOURCEA;
pub type LPNETRESOURCE = LPNETRESOURCEA;
extern "C" {
    pub fn WNetAddConnectionA(
        lpRemoteName: LPCSTR,
        lpPassword: LPCSTR,
        lpLocalName: LPCSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnectionW(
        lpRemoteName: LPCWSTR,
        lpPassword: LPCWSTR,
        lpLocalName: LPCWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnection2A(
        lpNetResource: LPNETRESOURCEA,
        lpPassword: LPCSTR,
        lpUserName: LPCSTR,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnection2W(
        lpNetResource: LPNETRESOURCEW,
        lpPassword: LPCWSTR,
        lpUserName: LPCWSTR,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnection3A(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEA,
        lpPassword: LPCSTR,
        lpUserName: LPCSTR,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnection3W(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEW,
        lpPassword: LPCWSTR,
        lpUserName: LPCWSTR,
        dwFlags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnection4A(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEA,
        pAuthBuffer: PVOID,
        cbAuthBuffer: DWORD,
        dwFlags: DWORD,
        lpUseOptions: PBYTE,
        cbUseOptions: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetAddConnection4W(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEW,
        pAuthBuffer: PVOID,
        cbAuthBuffer: DWORD,
        dwFlags: DWORD,
        lpUseOptions: PBYTE,
        cbUseOptions: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetCancelConnectionA(lpName: LPCSTR, fForce: BOOL) -> DWORD;
}
extern "C" {
    pub fn WNetCancelConnectionW(lpName: LPCWSTR, fForce: BOOL) -> DWORD;
}
extern "C" {
    pub fn WNetCancelConnection2A(lpName: LPCSTR, dwFlags: DWORD, fForce: BOOL) -> DWORD;
}
extern "C" {
    pub fn WNetCancelConnection2W(lpName: LPCWSTR, dwFlags: DWORD, fForce: BOOL) -> DWORD;
}
extern "C" {
    pub fn WNetGetConnectionA(
        lpLocalName: LPCSTR,
        lpRemoteName: LPSTR,
        lpnLength: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetConnectionW(
        lpLocalName: LPCWSTR,
        lpRemoteName: LPWSTR,
        lpnLength: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetRestoreSingleConnectionW(hwndParent: HWND, lpDevice: LPCWSTR, fUseUI: BOOL)
        -> DWORD;
}
extern "C" {
    pub fn WNetUseConnectionA(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEA,
        lpPassword: LPCSTR,
        lpUserId: LPCSTR,
        dwFlags: DWORD,
        lpAccessName: LPSTR,
        lpBufferSize: LPDWORD,
        lpResult: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetUseConnectionW(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEW,
        lpPassword: LPCWSTR,
        lpUserId: LPCWSTR,
        dwFlags: DWORD,
        lpAccessName: LPWSTR,
        lpBufferSize: LPDWORD,
        lpResult: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetUseConnection4A(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEA,
        pAuthBuffer: PVOID,
        cbAuthBuffer: DWORD,
        dwFlags: DWORD,
        lpUseOptions: PBYTE,
        cbUseOptions: DWORD,
        lpAccessName: LPSTR,
        lpBufferSize: LPDWORD,
        lpResult: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetUseConnection4W(
        hwndOwner: HWND,
        lpNetResource: LPNETRESOURCEW,
        pAuthBuffer: PVOID,
        cbAuthBuffer: DWORD,
        dwFlags: DWORD,
        lpUseOptions: PBYTE,
        cbUseOptions: DWORD,
        lpAccessName: LPWSTR,
        lpBufferSize: LPDWORD,
        lpResult: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetConnectionDialog(hwnd: HWND, dwType: DWORD) -> DWORD;
}
extern "C" {
    pub fn WNetDisconnectDialog(hwnd: HWND, dwType: DWORD) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONNECTDLGSTRUCTA {
    pub cbStructure: DWORD,
    pub hwndOwner: HWND,
    pub lpConnRes: LPNETRESOURCEA,
    pub dwFlags: DWORD,
    pub dwDevNum: DWORD,
}
pub type CONNECTDLGSTRUCTA = _CONNECTDLGSTRUCTA;
pub type LPCONNECTDLGSTRUCTA = *mut _CONNECTDLGSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONNECTDLGSTRUCTW {
    pub cbStructure: DWORD,
    pub hwndOwner: HWND,
    pub lpConnRes: LPNETRESOURCEW,
    pub dwFlags: DWORD,
    pub dwDevNum: DWORD,
}
pub type CONNECTDLGSTRUCTW = _CONNECTDLGSTRUCTW;
pub type LPCONNECTDLGSTRUCTW = *mut _CONNECTDLGSTRUCTW;
pub type CONNECTDLGSTRUCT = CONNECTDLGSTRUCTA;
pub type LPCONNECTDLGSTRUCT = LPCONNECTDLGSTRUCTA;
extern "C" {
    pub fn WNetConnectionDialog1A(lpConnDlgStruct: LPCONNECTDLGSTRUCTA) -> DWORD;
}
extern "C" {
    pub fn WNetConnectionDialog1W(lpConnDlgStruct: LPCONNECTDLGSTRUCTW) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISCDLGSTRUCTA {
    pub cbStructure: DWORD,
    pub hwndOwner: HWND,
    pub lpLocalName: LPSTR,
    pub lpRemoteName: LPSTR,
    pub dwFlags: DWORD,
}
pub type DISCDLGSTRUCTA = _DISCDLGSTRUCTA;
pub type LPDISCDLGSTRUCTA = *mut _DISCDLGSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISCDLGSTRUCTW {
    pub cbStructure: DWORD,
    pub hwndOwner: HWND,
    pub lpLocalName: LPWSTR,
    pub lpRemoteName: LPWSTR,
    pub dwFlags: DWORD,
}
pub type DISCDLGSTRUCTW = _DISCDLGSTRUCTW;
pub type LPDISCDLGSTRUCTW = *mut _DISCDLGSTRUCTW;
pub type DISCDLGSTRUCT = DISCDLGSTRUCTA;
pub type LPDISCDLGSTRUCT = LPDISCDLGSTRUCTA;
extern "C" {
    pub fn WNetDisconnectDialog1A(lpConnDlgStruct: LPDISCDLGSTRUCTA) -> DWORD;
}
extern "C" {
    pub fn WNetDisconnectDialog1W(lpConnDlgStruct: LPDISCDLGSTRUCTW) -> DWORD;
}
extern "C" {
    pub fn WNetOpenEnumA(
        dwScope: DWORD,
        dwType: DWORD,
        dwUsage: DWORD,
        lpNetResource: LPNETRESOURCEA,
        lphEnum: LPHANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetOpenEnumW(
        dwScope: DWORD,
        dwType: DWORD,
        dwUsage: DWORD,
        lpNetResource: LPNETRESOURCEW,
        lphEnum: LPHANDLE,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetEnumResourceA(
        hEnum: HANDLE,
        lpcCount: LPDWORD,
        lpBuffer: LPVOID,
        lpBufferSize: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetEnumResourceW(
        hEnum: HANDLE,
        lpcCount: LPDWORD,
        lpBuffer: LPVOID,
        lpBufferSize: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetCloseEnum(hEnum: HANDLE) -> DWORD;
}
extern "C" {
    pub fn WNetGetResourceParentA(
        lpNetResource: LPNETRESOURCEA,
        lpBuffer: LPVOID,
        lpcbBuffer: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetResourceParentW(
        lpNetResource: LPNETRESOURCEW,
        lpBuffer: LPVOID,
        lpcbBuffer: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetResourceInformationA(
        lpNetResource: LPNETRESOURCEA,
        lpBuffer: LPVOID,
        lpcbBuffer: LPDWORD,
        lplpSystem: *mut LPSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetResourceInformationW(
        lpNetResource: LPNETRESOURCEW,
        lpBuffer: LPVOID,
        lpcbBuffer: LPDWORD,
        lplpSystem: *mut LPWSTR,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNIVERSAL_NAME_INFOA {
    pub lpUniversalName: LPSTR,
}
pub type UNIVERSAL_NAME_INFOA = _UNIVERSAL_NAME_INFOA;
pub type LPUNIVERSAL_NAME_INFOA = *mut _UNIVERSAL_NAME_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNIVERSAL_NAME_INFOW {
    pub lpUniversalName: LPWSTR,
}
pub type UNIVERSAL_NAME_INFOW = _UNIVERSAL_NAME_INFOW;
pub type LPUNIVERSAL_NAME_INFOW = *mut _UNIVERSAL_NAME_INFOW;
pub type UNIVERSAL_NAME_INFO = UNIVERSAL_NAME_INFOA;
pub type LPUNIVERSAL_NAME_INFO = LPUNIVERSAL_NAME_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOTE_NAME_INFOA {
    pub lpUniversalName: LPSTR,
    pub lpConnectionName: LPSTR,
    pub lpRemainingPath: LPSTR,
}
pub type REMOTE_NAME_INFOA = _REMOTE_NAME_INFOA;
pub type LPREMOTE_NAME_INFOA = *mut _REMOTE_NAME_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOTE_NAME_INFOW {
    pub lpUniversalName: LPWSTR,
    pub lpConnectionName: LPWSTR,
    pub lpRemainingPath: LPWSTR,
}
pub type REMOTE_NAME_INFOW = _REMOTE_NAME_INFOW;
pub type LPREMOTE_NAME_INFOW = *mut _REMOTE_NAME_INFOW;
pub type REMOTE_NAME_INFO = REMOTE_NAME_INFOA;
pub type LPREMOTE_NAME_INFO = LPREMOTE_NAME_INFOA;
extern "C" {
    pub fn WNetGetUniversalNameA(
        lpLocalPath: LPCSTR,
        dwInfoLevel: DWORD,
        lpBuffer: LPVOID,
        lpBufferSize: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetUniversalNameW(
        lpLocalPath: LPCWSTR,
        dwInfoLevel: DWORD,
        lpBuffer: LPVOID,
        lpBufferSize: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetUserA(lpName: LPCSTR, lpUserName: LPSTR, lpnLength: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn WNetGetUserW(lpName: LPCWSTR, lpUserName: LPWSTR, lpnLength: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn WNetGetProviderNameA(
        dwNetType: DWORD,
        lpProviderName: LPSTR,
        lpBufferSize: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetProviderNameW(
        dwNetType: DWORD,
        lpProviderName: LPWSTR,
        lpBufferSize: LPDWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETINFOSTRUCT {
    pub cbStructure: DWORD,
    pub dwProviderVersion: DWORD,
    pub dwStatus: DWORD,
    pub dwCharacteristics: DWORD,
    pub dwHandle: ULONG_PTR,
    pub wNetType: WORD,
    pub dwPrinters: DWORD,
    pub dwDrives: DWORD,
}
pub type NETINFOSTRUCT = _NETINFOSTRUCT;
pub type LPNETINFOSTRUCT = *mut _NETINFOSTRUCT;
extern "C" {
    pub fn WNetGetNetworkInformationA(
        lpProvider: LPCSTR,
        lpNetInfoStruct: LPNETINFOSTRUCT,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetNetworkInformationW(
        lpProvider: LPCWSTR,
        lpNetInfoStruct: LPNETINFOSTRUCT,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetLastErrorA(
        lpError: LPDWORD,
        lpErrorBuf: LPSTR,
        nErrorBufSize: DWORD,
        lpNameBuf: LPSTR,
        nNameBufSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn WNetGetLastErrorW(
        lpError: LPDWORD,
        lpErrorBuf: LPWSTR,
        nErrorBufSize: DWORD,
        lpNameBuf: LPWSTR,
        nNameBufSize: DWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETCONNECTINFOSTRUCT {
    pub cbStructure: DWORD,
    pub dwFlags: DWORD,
    pub dwSpeed: DWORD,
    pub dwDelay: DWORD,
    pub dwOptDataSize: DWORD,
}
pub type NETCONNECTINFOSTRUCT = _NETCONNECTINFOSTRUCT;
pub type LPNETCONNECTINFOSTRUCT = *mut _NETCONNECTINFOSTRUCT;
extern "C" {
    pub fn MultinetGetConnectionPerformanceA(
        lpNetResource: LPNETRESOURCEA,
        lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT,
    ) -> DWORD;
}
extern "C" {
    pub fn MultinetGetConnectionPerformanceW(
        lpNetResource: LPNETRESOURCEW,
        lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT,
    ) -> DWORD;
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DDEACK {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl DDEACK {
    #[inline]
    pub fn bAppReturnCode(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_bAppReturnCode(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn fBusy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fBusy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fAck(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fAck(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAppReturnCode: ::std::os::raw::c_ushort,
        reserved: ::std::os::raw::c_ushort,
        fBusy: ::std::os::raw::c_ushort,
        fAck: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let bAppReturnCode: u16 = unsafe { ::std::mem::transmute(bAppReturnCode) };
            bAppReturnCode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fBusy: u16 = unsafe { ::std::mem::transmute(fBusy) };
            fBusy as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fAck: u16 = unsafe { ::std::mem::transmute(fAck) };
            fAck as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDEADVISE {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cfFormat: ::std::os::raw::c_short,
}
impl DDEADVISE {
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn fDeferUpd(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fDeferUpd(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fAckReq(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fAckReq(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: ::std::os::raw::c_ushort,
        fDeferUpd: ::std::os::raw::c_ushort,
        fAckReq: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fDeferUpd: u16 = unsafe { ::std::mem::transmute(fDeferUpd) };
            fDeferUpd as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fAckReq: u16 = unsafe { ::std::mem::transmute(fAckReq) };
            fAckReq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDEDATA {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cfFormat: ::std::os::raw::c_short,
    pub Value: [BYTE; 1usize],
}
impl DDEDATA {
    #[inline]
    pub fn unused(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn fResponse(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fResponse(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fRelease(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fRelease(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fAckReq(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fAckReq(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unused: ::std::os::raw::c_ushort,
        fResponse: ::std::os::raw::c_ushort,
        fRelease: ::std::os::raw::c_ushort,
        reserved: ::std::os::raw::c_ushort,
        fAckReq: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let unused: u16 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fResponse: u16 = unsafe { ::std::mem::transmute(fResponse) };
            fResponse as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fRelease: u16 = unsafe { ::std::mem::transmute(fRelease) };
            fRelease as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fAckReq: u16 = unsafe { ::std::mem::transmute(fAckReq) };
            fAckReq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDEPOKE {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cfFormat: ::std::os::raw::c_short,
    pub Value: [BYTE; 1usize],
}
impl DDEPOKE {
    #[inline]
    pub fn unused(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn fRelease(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fRelease(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fReserved(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_fReserved(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unused: ::std::os::raw::c_ushort,
        fRelease: ::std::os::raw::c_ushort,
        fReserved: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let unused: u16 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fRelease: u16 = unsafe { ::std::mem::transmute(fRelease) };
            fRelease as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let fReserved: u16 = unsafe { ::std::mem::transmute(fReserved) };
            fReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDELN {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cfFormat: ::std::os::raw::c_short,
}
impl DDELN {
    #[inline]
    pub fn unused(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn fRelease(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fRelease(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDeferUpd(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fDeferUpd(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fAckReq(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fAckReq(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unused: ::std::os::raw::c_ushort,
        fRelease: ::std::os::raw::c_ushort,
        fDeferUpd: ::std::os::raw::c_ushort,
        fAckReq: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let unused: u16 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fRelease: u16 = unsafe { ::std::mem::transmute(fRelease) };
            fRelease as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fDeferUpd: u16 = unsafe { ::std::mem::transmute(fDeferUpd) };
            fDeferUpd as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fAckReq: u16 = unsafe { ::std::mem::transmute(fAckReq) };
            fAckReq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDEUP {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub cfFormat: ::std::os::raw::c_short,
    pub rgb: [BYTE; 1usize],
}
impl DDEUP {
    #[inline]
    pub fn unused(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn fAck(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fAck(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fRelease(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fRelease(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fReserved(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fReserved(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fAckReq(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fAckReq(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unused: ::std::os::raw::c_ushort,
        fAck: ::std::os::raw::c_ushort,
        fRelease: ::std::os::raw::c_ushort,
        fReserved: ::std::os::raw::c_ushort,
        fAckReq: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let unused: u16 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fAck: u16 = unsafe { ::std::mem::transmute(fAck) };
            fAck as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fRelease: u16 = unsafe { ::std::mem::transmute(fRelease) };
            fRelease as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fReserved: u16 = unsafe { ::std::mem::transmute(fReserved) };
            fReserved as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let fAckReq: u16 = unsafe { ::std::mem::transmute(fAckReq) };
            fAckReq as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn DdeSetQualityOfService(
        hwndClient: HWND,
        pqosNew: *const SECURITY_QUALITY_OF_SERVICE,
        pqosPrev: PSECURITY_QUALITY_OF_SERVICE,
    ) -> BOOL;
}
extern "C" {
    pub fn ImpersonateDdeClientWindow(hWndClient: HWND, hWndServer: HWND) -> BOOL;
}
extern "C" {
    pub fn PackDDElParam(msg: UINT, uiLo: UINT_PTR, uiHi: UINT_PTR) -> LPARAM;
}
extern "C" {
    pub fn UnpackDDElParam(msg: UINT, lParam: LPARAM, puiLo: PUINT_PTR, puiHi: PUINT_PTR) -> BOOL;
}
extern "C" {
    pub fn FreeDDElParam(msg: UINT, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn ReuseDDElParam(
        lParam: LPARAM,
        msgIn: UINT,
        msgOut: UINT,
        uiLo: UINT_PTR,
        uiHi: UINT_PTR,
    ) -> LPARAM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HCONVLIST__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HCONVLIST = *mut HCONVLIST__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HCONV__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HCONV = *mut HCONV__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSZ__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HSZ = *mut HSZ__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDDEDATA__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDDEDATA = *mut HDDEDATA__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagHSZPAIR {
    pub hszSvc: HSZ,
    pub hszTopic: HSZ,
}
pub type HSZPAIR = tagHSZPAIR;
pub type PHSZPAIR = *mut tagHSZPAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCONVCONTEXT {
    pub cb: UINT,
    pub wFlags: UINT,
    pub wCountryID: UINT,
    pub iCodePage: ::std::os::raw::c_int,
    pub dwLangID: DWORD,
    pub dwSecurity: DWORD,
    pub qos: SECURITY_QUALITY_OF_SERVICE,
}
pub type CONVCONTEXT = tagCONVCONTEXT;
pub type PCONVCONTEXT = *mut tagCONVCONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCONVINFO {
    pub cb: DWORD,
    pub hUser: DWORD_PTR,
    pub hConvPartner: HCONV,
    pub hszSvcPartner: HSZ,
    pub hszServiceReq: HSZ,
    pub hszTopic: HSZ,
    pub hszItem: HSZ,
    pub wFmt: UINT,
    pub wType: UINT,
    pub wStatus: UINT,
    pub wConvst: UINT,
    pub wLastError: UINT,
    pub hConvList: HCONVLIST,
    pub ConvCtxt: CONVCONTEXT,
    pub hwnd: HWND,
    pub hwndPartner: HWND,
}
pub type CONVINFO = tagCONVINFO;
pub type PCONVINFO = *mut tagCONVINFO;
pub type PFNCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        wType: UINT,
        wFmt: UINT,
        hConv: HCONV,
        hsz1: HSZ,
        hsz2: HSZ,
        hData: HDDEDATA,
        dwData1: ULONG_PTR,
        dwData2: ULONG_PTR,
    ) -> HDDEDATA,
>;
extern "C" {
    pub fn DdeInitializeA(
        pidInst: LPDWORD,
        pfnCallback: PFNCALLBACK,
        afCmd: DWORD,
        ulRes: DWORD,
    ) -> UINT;
}
extern "C" {
    pub fn DdeInitializeW(
        pidInst: LPDWORD,
        pfnCallback: PFNCALLBACK,
        afCmd: DWORD,
        ulRes: DWORD,
    ) -> UINT;
}
extern "C" {
    pub fn DdeUninitialize(idInst: DWORD) -> BOOL;
}
extern "C" {
    pub fn DdeConnectList(
        idInst: DWORD,
        hszService: HSZ,
        hszTopic: HSZ,
        hConvList: HCONVLIST,
        pCC: PCONVCONTEXT,
    ) -> HCONVLIST;
}
extern "C" {
    pub fn DdeQueryNextServer(hConvList: HCONVLIST, hConvPrev: HCONV) -> HCONV;
}
extern "C" {
    pub fn DdeDisconnectList(hConvList: HCONVLIST) -> BOOL;
}
extern "C" {
    pub fn DdeConnect(idInst: DWORD, hszService: HSZ, hszTopic: HSZ, pCC: PCONVCONTEXT) -> HCONV;
}
extern "C" {
    pub fn DdeDisconnect(hConv: HCONV) -> BOOL;
}
extern "C" {
    pub fn DdeReconnect(hConv: HCONV) -> HCONV;
}
extern "C" {
    pub fn DdeQueryConvInfo(hConv: HCONV, idTransaction: DWORD, pConvInfo: PCONVINFO) -> UINT;
}
extern "C" {
    pub fn DdeSetUserHandle(hConv: HCONV, id: DWORD, hUser: DWORD_PTR) -> BOOL;
}
extern "C" {
    pub fn DdeAbandonTransaction(idInst: DWORD, hConv: HCONV, idTransaction: DWORD) -> BOOL;
}
extern "C" {
    pub fn DdePostAdvise(idInst: DWORD, hszTopic: HSZ, hszItem: HSZ) -> BOOL;
}
extern "C" {
    pub fn DdeEnableCallback(idInst: DWORD, hConv: HCONV, wCmd: UINT) -> BOOL;
}
extern "C" {
    pub fn DdeImpersonateClient(hConv: HCONV) -> BOOL;
}
extern "C" {
    pub fn DdeNameService(idInst: DWORD, hsz1: HSZ, hsz2: HSZ, afCmd: UINT) -> HDDEDATA;
}
extern "C" {
    pub fn DdeClientTransaction(
        pData: LPBYTE,
        cbData: DWORD,
        hConv: HCONV,
        hszItem: HSZ,
        wFmt: UINT,
        wType: UINT,
        dwTimeout: DWORD,
        pdwResult: LPDWORD,
    ) -> HDDEDATA;
}
extern "C" {
    pub fn DdeCreateDataHandle(
        idInst: DWORD,
        pSrc: LPBYTE,
        cb: DWORD,
        cbOff: DWORD,
        hszItem: HSZ,
        wFmt: UINT,
        afCmd: UINT,
    ) -> HDDEDATA;
}
extern "C" {
    pub fn DdeAddData(hData: HDDEDATA, pSrc: LPBYTE, cb: DWORD, cbOff: DWORD) -> HDDEDATA;
}
extern "C" {
    pub fn DdeGetData(hData: HDDEDATA, pDst: LPBYTE, cbMax: DWORD, cbOff: DWORD) -> DWORD;
}
extern "C" {
    pub fn DdeAccessData(hData: HDDEDATA, pcbDataSize: LPDWORD) -> LPBYTE;
}
extern "C" {
    pub fn DdeUnaccessData(hData: HDDEDATA) -> BOOL;
}
extern "C" {
    pub fn DdeFreeDataHandle(hData: HDDEDATA) -> BOOL;
}
extern "C" {
    pub fn DdeGetLastError(idInst: DWORD) -> UINT;
}
extern "C" {
    pub fn DdeCreateStringHandleA(
        idInst: DWORD,
        psz: LPCSTR,
        iCodePage: ::std::os::raw::c_int,
    ) -> HSZ;
}
extern "C" {
    pub fn DdeCreateStringHandleW(
        idInst: DWORD,
        psz: LPCWSTR,
        iCodePage: ::std::os::raw::c_int,
    ) -> HSZ;
}
extern "C" {
    pub fn DdeQueryStringA(
        idInst: DWORD,
        hsz: HSZ,
        psz: LPSTR,
        cchMax: DWORD,
        iCodePage: ::std::os::raw::c_int,
    ) -> DWORD;
}
extern "C" {
    pub fn DdeQueryStringW(
        idInst: DWORD,
        hsz: HSZ,
        psz: LPWSTR,
        cchMax: DWORD,
        iCodePage: ::std::os::raw::c_int,
    ) -> DWORD;
}
extern "C" {
    pub fn DdeFreeStringHandle(idInst: DWORD, hsz: HSZ) -> BOOL;
}
extern "C" {
    pub fn DdeKeepStringHandle(idInst: DWORD, hsz: HSZ) -> BOOL;
}
extern "C" {
    pub fn DdeCmpStringHandles(hsz1: HSZ, hsz2: HSZ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDDEML_MSG_HOOK_DATA {
    pub uiLo: UINT_PTR,
    pub uiHi: UINT_PTR,
    pub cbData: DWORD,
    pub Data: [DWORD; 8usize],
}
pub type DDEML_MSG_HOOK_DATA = tagDDEML_MSG_HOOK_DATA;
pub type PDDEML_MSG_HOOK_DATA = *mut tagDDEML_MSG_HOOK_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONMSGSTRUCT {
    pub cb: UINT,
    pub hwndTo: HWND,
    pub dwTime: DWORD,
    pub hTask: HANDLE,
    pub wMsg: UINT,
    pub wParam: WPARAM,
    pub lParam: LPARAM,
    pub dmhd: DDEML_MSG_HOOK_DATA,
}
pub type MONMSGSTRUCT = tagMONMSGSTRUCT;
pub type PMONMSGSTRUCT = *mut tagMONMSGSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONCBSTRUCT {
    pub cb: UINT,
    pub dwTime: DWORD,
    pub hTask: HANDLE,
    pub dwRet: DWORD,
    pub wType: UINT,
    pub wFmt: UINT,
    pub hConv: HCONV,
    pub hsz1: HSZ,
    pub hsz2: HSZ,
    pub hData: HDDEDATA,
    pub dwData1: ULONG_PTR,
    pub dwData2: ULONG_PTR,
    pub cc: CONVCONTEXT,
    pub cbData: DWORD,
    pub Data: [DWORD; 8usize],
}
pub type MONCBSTRUCT = tagMONCBSTRUCT;
pub type PMONCBSTRUCT = *mut tagMONCBSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONHSZSTRUCTA {
    pub cb: UINT,
    pub fsAction: BOOL,
    pub dwTime: DWORD,
    pub hsz: HSZ,
    pub hTask: HANDLE,
    pub str_: [CHAR; 1usize],
}
pub type MONHSZSTRUCTA = tagMONHSZSTRUCTA;
pub type PMONHSZSTRUCTA = *mut tagMONHSZSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONHSZSTRUCTW {
    pub cb: UINT,
    pub fsAction: BOOL,
    pub dwTime: DWORD,
    pub hsz: HSZ,
    pub hTask: HANDLE,
    pub str_: [WCHAR; 1usize],
}
pub type MONHSZSTRUCTW = tagMONHSZSTRUCTW;
pub type PMONHSZSTRUCTW = *mut tagMONHSZSTRUCTW;
pub type MONHSZSTRUCT = MONHSZSTRUCTA;
pub type PMONHSZSTRUCT = PMONHSZSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONERRSTRUCT {
    pub cb: UINT,
    pub wLastError: UINT,
    pub dwTime: DWORD,
    pub hTask: HANDLE,
}
pub type MONERRSTRUCT = tagMONERRSTRUCT;
pub type PMONERRSTRUCT = *mut tagMONERRSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONLINKSTRUCT {
    pub cb: UINT,
    pub dwTime: DWORD,
    pub hTask: HANDLE,
    pub fEstablished: BOOL,
    pub fNoData: BOOL,
    pub hszSvc: HSZ,
    pub hszTopic: HSZ,
    pub hszItem: HSZ,
    pub wFmt: UINT,
    pub fServer: BOOL,
    pub hConvServer: HCONV,
    pub hConvClient: HCONV,
}
pub type MONLINKSTRUCT = tagMONLINKSTRUCT;
pub type PMONLINKSTRUCT = *mut tagMONLINKSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMONCONVSTRUCT {
    pub cb: UINT,
    pub fConnect: BOOL,
    pub dwTime: DWORD,
    pub hTask: HANDLE,
    pub hszSvc: HSZ,
    pub hszTopic: HSZ,
    pub hConvClient: HCONV,
    pub hConvServer: HCONV,
}
pub type MONCONVSTRUCT = tagMONCONVSTRUCT;
pub type PMONCONVSTRUCT = *mut tagMONCONVSTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCRGB {
    pub bRed: BYTE,
    pub bGreen: BYTE,
    pub bBlue: BYTE,
    pub bExtra: BYTE,
}
pub type CRGB = tagCRGB;
extern "C" {
    pub fn LZStart() -> INT;
}
extern "C" {
    pub fn LZDone();
}
extern "C" {
    pub fn CopyLZFile(hfSource: INT, hfDest: INT) -> LONG;
}
extern "C" {
    pub fn LZCopy(hfSource: INT, hfDest: INT) -> LONG;
}
extern "C" {
    pub fn LZInit(hfSource: INT) -> INT;
}
extern "C" {
    pub fn GetExpandedNameA(lpszSource: LPSTR, lpszBuffer: LPSTR) -> INT;
}
extern "C" {
    pub fn GetExpandedNameW(lpszSource: LPWSTR, lpszBuffer: LPWSTR) -> INT;
}
extern "C" {
    pub fn LZOpenFileA(lpFileName: LPSTR, lpReOpenBuf: LPOFSTRUCT, wStyle: WORD) -> INT;
}
extern "C" {
    pub fn LZOpenFileW(lpFileName: LPWSTR, lpReOpenBuf: LPOFSTRUCT, wStyle: WORD) -> INT;
}
extern "C" {
    pub fn LZSeek(hFile: INT, lOffset: LONG, iOrigin: INT) -> LONG;
}
extern "C" {
    pub fn LZRead(hFile: INT, lpBuffer: *mut CHAR, cbRead: INT) -> INT;
}
extern "C" {
    pub fn LZClose(hFile: INT);
}
pub type MMVERSION = UINT;
pub type MMRESULT = UINT;
pub type LPUINT = *mut UINT;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mmtime_tag {
    pub wType: UINT,
    pub u: mmtime_tag__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union mmtime_tag__bindgen_ty_1 {
    pub ms: DWORD,
    pub sample: DWORD,
    pub cb: DWORD,
    pub ticks: DWORD,
    pub smpte: mmtime_tag__bindgen_ty_1__bindgen_ty_1,
    pub midi: mmtime_tag__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmtime_tag__bindgen_ty_1__bindgen_ty_1 {
    pub hour: BYTE,
    pub min: BYTE,
    pub sec: BYTE,
    pub frame: BYTE,
    pub fps: BYTE,
    pub dummy: BYTE,
    pub pad: [BYTE; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mmtime_tag__bindgen_ty_1__bindgen_ty_2 {
    pub songptrpos: DWORD,
}
pub type MMTIME = mmtime_tag;
pub type PMMTIME = *mut mmtime_tag;
pub type NPMMTIME = *mut mmtime_tag;
pub type LPMMTIME = *mut mmtime_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HDRVR__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDRVR = *mut HDRVR__;
pub type LPDRVCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: HDRVR,
        arg2: UINT,
        arg3: DWORD_PTR,
        arg4: DWORD_PTR,
        arg5: DWORD_PTR,
    ),
>;
pub type PDRVCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: HDRVR,
        arg2: UINT,
        arg3: DWORD_PTR,
        arg4: DWORD_PTR,
        arg5: DWORD_PTR,
    ),
>;
pub type MCIERROR = DWORD;
pub type MCIDEVICEID = UINT;
pub type YIELDPROC =
    ::std::option::Option<unsafe extern "C" fn(mciId: MCIDEVICEID, dwYieldData: DWORD) -> UINT>;
extern "C" {
    pub fn mciSendCommandA(
        mciId: MCIDEVICEID,
        uMsg: UINT,
        dwParam1: DWORD_PTR,
        dwParam2: DWORD_PTR,
    ) -> MCIERROR;
}
extern "C" {
    pub fn mciSendCommandW(
        mciId: MCIDEVICEID,
        uMsg: UINT,
        dwParam1: DWORD_PTR,
        dwParam2: DWORD_PTR,
    ) -> MCIERROR;
}
extern "C" {
    pub fn mciSendStringA(
        lpstrCommand: LPCSTR,
        lpstrReturnString: LPSTR,
        uReturnLength: UINT,
        hwndCallback: HWND,
    ) -> MCIERROR;
}
extern "C" {
    pub fn mciSendStringW(
        lpstrCommand: LPCWSTR,
        lpstrReturnString: LPWSTR,
        uReturnLength: UINT,
        hwndCallback: HWND,
    ) -> MCIERROR;
}
extern "C" {
    pub fn mciGetDeviceIDA(pszDevice: LPCSTR) -> MCIDEVICEID;
}
extern "C" {
    pub fn mciGetDeviceIDW(pszDevice: LPCWSTR) -> MCIDEVICEID;
}
extern "C" {
    pub fn mciGetDeviceIDFromElementIDA(dwElementID: DWORD, lpstrType: LPCSTR) -> MCIDEVICEID;
}
extern "C" {
    pub fn mciGetDeviceIDFromElementIDW(dwElementID: DWORD, lpstrType: LPCWSTR) -> MCIDEVICEID;
}
extern "C" {
    pub fn mciGetErrorStringA(mcierr: MCIERROR, pszText: LPSTR, cchText: UINT) -> BOOL;
}
extern "C" {
    pub fn mciGetErrorStringW(mcierr: MCIERROR, pszText: LPWSTR, cchText: UINT) -> BOOL;
}
extern "C" {
    pub fn mciSetYieldProc(mciId: MCIDEVICEID, fpYieldProc: YIELDPROC, dwYieldData: DWORD) -> BOOL;
}
extern "C" {
    pub fn mciGetCreatorTask(mciId: MCIDEVICEID) -> HTASK;
}
extern "C" {
    pub fn mciGetYieldProc(mciId: MCIDEVICEID, pdwYieldData: LPDWORD) -> YIELDPROC;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_GENERIC_PARMS {
    pub dwCallback: DWORD_PTR,
}
pub type MCI_GENERIC_PARMS = tagMCI_GENERIC_PARMS;
pub type PMCI_GENERIC_PARMS = *mut tagMCI_GENERIC_PARMS;
pub type LPMCI_GENERIC_PARMS = *mut tagMCI_GENERIC_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OPEN_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCSTR,
    pub lpstrElementName: LPCSTR,
    pub lpstrAlias: LPCSTR,
}
pub type MCI_OPEN_PARMSA = tagMCI_OPEN_PARMSA;
pub type PMCI_OPEN_PARMSA = *mut tagMCI_OPEN_PARMSA;
pub type LPMCI_OPEN_PARMSA = *mut tagMCI_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OPEN_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCWSTR,
    pub lpstrElementName: LPCWSTR,
    pub lpstrAlias: LPCWSTR,
}
pub type MCI_OPEN_PARMSW = tagMCI_OPEN_PARMSW;
pub type PMCI_OPEN_PARMSW = *mut tagMCI_OPEN_PARMSW;
pub type LPMCI_OPEN_PARMSW = *mut tagMCI_OPEN_PARMSW;
pub type MCI_OPEN_PARMS = MCI_OPEN_PARMSA;
pub type PMCI_OPEN_PARMS = PMCI_OPEN_PARMSA;
pub type LPMCI_OPEN_PARMS = LPMCI_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_PLAY_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrom: DWORD,
    pub dwTo: DWORD,
}
pub type MCI_PLAY_PARMS = tagMCI_PLAY_PARMS;
pub type PMCI_PLAY_PARMS = *mut tagMCI_PLAY_PARMS;
pub type LPMCI_PLAY_PARMS = *mut tagMCI_PLAY_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SEEK_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwTo: DWORD,
}
pub type MCI_SEEK_PARMS = tagMCI_SEEK_PARMS;
pub type PMCI_SEEK_PARMS = *mut tagMCI_SEEK_PARMS;
pub type LPMCI_SEEK_PARMS = *mut tagMCI_SEEK_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_STATUS_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwReturn: DWORD_PTR,
    pub dwItem: DWORD,
    pub dwTrack: DWORD,
}
pub type MCI_STATUS_PARMS = tagMCI_STATUS_PARMS;
pub type PMCI_STATUS_PARMS = *mut tagMCI_STATUS_PARMS;
pub type LPMCI_STATUS_PARMS = *mut tagMCI_STATUS_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_INFO_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpstrReturn: LPSTR,
    pub dwRetSize: DWORD,
}
pub type MCI_INFO_PARMSA = tagMCI_INFO_PARMSA;
pub type LPMCI_INFO_PARMSA = *mut tagMCI_INFO_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_INFO_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpstrReturn: LPWSTR,
    pub dwRetSize: DWORD,
}
pub type MCI_INFO_PARMSW = tagMCI_INFO_PARMSW;
pub type LPMCI_INFO_PARMSW = *mut tagMCI_INFO_PARMSW;
pub type MCI_INFO_PARMS = MCI_INFO_PARMSA;
pub type LPMCI_INFO_PARMS = LPMCI_INFO_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_GETDEVCAPS_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwReturn: DWORD,
    pub dwItem: DWORD,
}
pub type MCI_GETDEVCAPS_PARMS = tagMCI_GETDEVCAPS_PARMS;
pub type PMCI_GETDEVCAPS_PARMS = *mut tagMCI_GETDEVCAPS_PARMS;
pub type LPMCI_GETDEVCAPS_PARMS = *mut tagMCI_GETDEVCAPS_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SYSINFO_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpstrReturn: LPSTR,
    pub dwRetSize: DWORD,
    pub dwNumber: DWORD,
    pub wDeviceType: UINT,
}
pub type MCI_SYSINFO_PARMSA = tagMCI_SYSINFO_PARMSA;
pub type PMCI_SYSINFO_PARMSA = *mut tagMCI_SYSINFO_PARMSA;
pub type LPMCI_SYSINFO_PARMSA = *mut tagMCI_SYSINFO_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SYSINFO_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpstrReturn: LPWSTR,
    pub dwRetSize: DWORD,
    pub dwNumber: DWORD,
    pub wDeviceType: UINT,
}
pub type MCI_SYSINFO_PARMSW = tagMCI_SYSINFO_PARMSW;
pub type PMCI_SYSINFO_PARMSW = *mut tagMCI_SYSINFO_PARMSW;
pub type LPMCI_SYSINFO_PARMSW = *mut tagMCI_SYSINFO_PARMSW;
pub type MCI_SYSINFO_PARMS = MCI_SYSINFO_PARMSA;
pub type PMCI_SYSINFO_PARMS = PMCI_SYSINFO_PARMSA;
pub type LPMCI_SYSINFO_PARMS = LPMCI_SYSINFO_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SET_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwTimeFormat: DWORD,
    pub dwAudio: DWORD,
}
pub type MCI_SET_PARMS = tagMCI_SET_PARMS;
pub type PMCI_SET_PARMS = *mut tagMCI_SET_PARMS;
pub type LPMCI_SET_PARMS = *mut tagMCI_SET_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_BREAK_PARMS {
    pub dwCallback: DWORD_PTR,
    pub nVirtKey: ::std::os::raw::c_int,
    pub hwndBreak: HWND,
}
pub type MCI_BREAK_PARMS = tagMCI_BREAK_PARMS;
pub type PMCI_BREAK_PARMS = *mut tagMCI_BREAK_PARMS;
pub type LPMCI_BREAK_PARMS = *mut tagMCI_BREAK_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SAVE_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCSTR,
}
pub type MCI_SAVE_PARMSA = tagMCI_SAVE_PARMSA;
pub type PMCI_SAVE_PARMSA = *mut tagMCI_SAVE_PARMSA;
pub type LPMCI_SAVE_PARMSA = *mut tagMCI_SAVE_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SAVE_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCWSTR,
}
pub type MCI_SAVE_PARMSW = tagMCI_SAVE_PARMSW;
pub type PMCI_SAVE_PARMSW = *mut tagMCI_SAVE_PARMSW;
pub type LPMCI_SAVE_PARMSW = *mut tagMCI_SAVE_PARMSW;
pub type MCI_SAVE_PARMS = MCI_SAVE_PARMSA;
pub type PMCI_SAVE_PARMS = PMCI_SAVE_PARMSA;
pub type LPMCI_SAVE_PARMS = LPMCI_SAVE_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_LOAD_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCSTR,
}
pub type MCI_LOAD_PARMSA = tagMCI_LOAD_PARMSA;
pub type PMCI_LOAD_PARMSA = *mut tagMCI_LOAD_PARMSA;
pub type LPMCI_LOAD_PARMSA = *mut tagMCI_LOAD_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_LOAD_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCWSTR,
}
pub type MCI_LOAD_PARMSW = tagMCI_LOAD_PARMSW;
pub type PMCI_LOAD_PARMSW = *mut tagMCI_LOAD_PARMSW;
pub type LPMCI_LOAD_PARMSW = *mut tagMCI_LOAD_PARMSW;
pub type MCI_LOAD_PARMS = MCI_LOAD_PARMSA;
pub type PMCI_LOAD_PARMS = PMCI_LOAD_PARMSA;
pub type LPMCI_LOAD_PARMS = LPMCI_LOAD_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_RECORD_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrom: DWORD,
    pub dwTo: DWORD,
}
pub type MCI_RECORD_PARMS = tagMCI_RECORD_PARMS;
pub type LPMCI_RECORD_PARMS = *mut tagMCI_RECORD_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_VD_PLAY_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrom: DWORD,
    pub dwTo: DWORD,
    pub dwSpeed: DWORD,
}
pub type MCI_VD_PLAY_PARMS = tagMCI_VD_PLAY_PARMS;
pub type PMCI_VD_PLAY_PARMS = *mut tagMCI_VD_PLAY_PARMS;
pub type LPMCI_VD_PLAY_PARMS = *mut tagMCI_VD_PLAY_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_VD_STEP_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrames: DWORD,
}
pub type MCI_VD_STEP_PARMS = tagMCI_VD_STEP_PARMS;
pub type PMCI_VD_STEP_PARMS = *mut tagMCI_VD_STEP_PARMS;
pub type LPMCI_VD_STEP_PARMS = *mut tagMCI_VD_STEP_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_VD_ESCAPE_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpstrCommand: LPCSTR,
}
pub type MCI_VD_ESCAPE_PARMSA = tagMCI_VD_ESCAPE_PARMSA;
pub type PMCI_VD_ESCAPE_PARMSA = *mut tagMCI_VD_ESCAPE_PARMSA;
pub type LPMCI_VD_ESCAPE_PARMSA = *mut tagMCI_VD_ESCAPE_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_VD_ESCAPE_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpstrCommand: LPCWSTR,
}
pub type MCI_VD_ESCAPE_PARMSW = tagMCI_VD_ESCAPE_PARMSW;
pub type PMCI_VD_ESCAPE_PARMSW = *mut tagMCI_VD_ESCAPE_PARMSW;
pub type LPMCI_VD_ESCAPE_PARMSW = *mut tagMCI_VD_ESCAPE_PARMSW;
pub type MCI_VD_ESCAPE_PARMS = MCI_VD_ESCAPE_PARMSA;
pub type PMCI_VD_ESCAPE_PARMS = PMCI_VD_ESCAPE_PARMSA;
pub type LPMCI_VD_ESCAPE_PARMS = LPMCI_VD_ESCAPE_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_WAVE_OPEN_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCSTR,
    pub lpstrElementName: LPCSTR,
    pub lpstrAlias: LPCSTR,
    pub dwBufferSeconds: DWORD,
}
pub type MCI_WAVE_OPEN_PARMSA = tagMCI_WAVE_OPEN_PARMSA;
pub type PMCI_WAVE_OPEN_PARMSA = *mut tagMCI_WAVE_OPEN_PARMSA;
pub type LPMCI_WAVE_OPEN_PARMSA = *mut tagMCI_WAVE_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_WAVE_OPEN_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCWSTR,
    pub lpstrElementName: LPCWSTR,
    pub lpstrAlias: LPCWSTR,
    pub dwBufferSeconds: DWORD,
}
pub type MCI_WAVE_OPEN_PARMSW = tagMCI_WAVE_OPEN_PARMSW;
pub type PMCI_WAVE_OPEN_PARMSW = *mut tagMCI_WAVE_OPEN_PARMSW;
pub type LPMCI_WAVE_OPEN_PARMSW = *mut tagMCI_WAVE_OPEN_PARMSW;
pub type MCI_WAVE_OPEN_PARMS = MCI_WAVE_OPEN_PARMSA;
pub type PMCI_WAVE_OPEN_PARMS = PMCI_WAVE_OPEN_PARMSA;
pub type LPMCI_WAVE_OPEN_PARMS = LPMCI_WAVE_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_WAVE_DELETE_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrom: DWORD,
    pub dwTo: DWORD,
}
pub type MCI_WAVE_DELETE_PARMS = tagMCI_WAVE_DELETE_PARMS;
pub type PMCI_WAVE_DELETE_PARMS = *mut tagMCI_WAVE_DELETE_PARMS;
pub type LPMCI_WAVE_DELETE_PARMS = *mut tagMCI_WAVE_DELETE_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_WAVE_SET_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwTimeFormat: DWORD,
    pub dwAudio: DWORD,
    pub wInput: UINT,
    pub wOutput: UINT,
    pub wFormatTag: WORD,
    pub wReserved2: WORD,
    pub nChannels: WORD,
    pub wReserved3: WORD,
    pub nSamplesPerSec: DWORD,
    pub nAvgBytesPerSec: DWORD,
    pub nBlockAlign: WORD,
    pub wReserved4: WORD,
    pub wBitsPerSample: WORD,
    pub wReserved5: WORD,
}
pub type MCI_WAVE_SET_PARMS = tagMCI_WAVE_SET_PARMS;
pub type PMCI_WAVE_SET_PARMS = *mut tagMCI_WAVE_SET_PARMS;
pub type LPMCI_WAVE_SET_PARMS = *mut tagMCI_WAVE_SET_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_SEQ_SET_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwTimeFormat: DWORD,
    pub dwAudio: DWORD,
    pub dwTempo: DWORD,
    pub dwPort: DWORD,
    pub dwSlave: DWORD,
    pub dwMaster: DWORD,
    pub dwOffset: DWORD,
}
pub type MCI_SEQ_SET_PARMS = tagMCI_SEQ_SET_PARMS;
pub type PMCI_SEQ_SET_PARMS = *mut tagMCI_SEQ_SET_PARMS;
pub type LPMCI_SEQ_SET_PARMS = *mut tagMCI_SEQ_SET_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_OPEN_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCSTR,
    pub lpstrElementName: LPCSTR,
    pub lpstrAlias: LPCSTR,
    pub dwStyle: DWORD,
    pub hWndParent: HWND,
}
pub type MCI_ANIM_OPEN_PARMSA = tagMCI_ANIM_OPEN_PARMSA;
pub type PMCI_ANIM_OPEN_PARMSA = *mut tagMCI_ANIM_OPEN_PARMSA;
pub type LPMCI_ANIM_OPEN_PARMSA = *mut tagMCI_ANIM_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_OPEN_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCWSTR,
    pub lpstrElementName: LPCWSTR,
    pub lpstrAlias: LPCWSTR,
    pub dwStyle: DWORD,
    pub hWndParent: HWND,
}
pub type MCI_ANIM_OPEN_PARMSW = tagMCI_ANIM_OPEN_PARMSW;
pub type PMCI_ANIM_OPEN_PARMSW = *mut tagMCI_ANIM_OPEN_PARMSW;
pub type LPMCI_ANIM_OPEN_PARMSW = *mut tagMCI_ANIM_OPEN_PARMSW;
pub type MCI_ANIM_OPEN_PARMS = MCI_ANIM_OPEN_PARMSA;
pub type PMCI_ANIM_OPEN_PARMS = PMCI_ANIM_OPEN_PARMSA;
pub type LPMCI_ANIM_OPEN_PARMS = LPMCI_ANIM_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_PLAY_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrom: DWORD,
    pub dwTo: DWORD,
    pub dwSpeed: DWORD,
}
pub type MCI_ANIM_PLAY_PARMS = tagMCI_ANIM_PLAY_PARMS;
pub type PMCI_ANIM_PLAY_PARMS = *mut tagMCI_ANIM_PLAY_PARMS;
pub type LPMCI_ANIM_PLAY_PARMS = *mut tagMCI_ANIM_PLAY_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_STEP_PARMS {
    pub dwCallback: DWORD_PTR,
    pub dwFrames: DWORD,
}
pub type MCI_ANIM_STEP_PARMS = tagMCI_ANIM_STEP_PARMS;
pub type PMCI_ANIM_STEP_PARMS = *mut tagMCI_ANIM_STEP_PARMS;
pub type LPMCI_ANIM_STEP_PARMS = *mut tagMCI_ANIM_STEP_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_WINDOW_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub hWnd: HWND,
    pub nCmdShow: UINT,
    pub lpstrText: LPCSTR,
}
pub type MCI_ANIM_WINDOW_PARMSA = tagMCI_ANIM_WINDOW_PARMSA;
pub type PMCI_ANIM_WINDOW_PARMSA = *mut tagMCI_ANIM_WINDOW_PARMSA;
pub type LPMCI_ANIM_WINDOW_PARMSA = *mut tagMCI_ANIM_WINDOW_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_WINDOW_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub hWnd: HWND,
    pub nCmdShow: UINT,
    pub lpstrText: LPCWSTR,
}
pub type MCI_ANIM_WINDOW_PARMSW = tagMCI_ANIM_WINDOW_PARMSW;
pub type PMCI_ANIM_WINDOW_PARMSW = *mut tagMCI_ANIM_WINDOW_PARMSW;
pub type LPMCI_ANIM_WINDOW_PARMSW = *mut tagMCI_ANIM_WINDOW_PARMSW;
pub type MCI_ANIM_WINDOW_PARMS = MCI_ANIM_WINDOW_PARMSA;
pub type PMCI_ANIM_WINDOW_PARMS = PMCI_ANIM_WINDOW_PARMSA;
pub type LPMCI_ANIM_WINDOW_PARMS = LPMCI_ANIM_WINDOW_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_RECT_PARMS {
    pub dwCallback: DWORD_PTR,
    pub rc: RECT,
}
pub type MCI_ANIM_RECT_PARMS = tagMCI_ANIM_RECT_PARMS;
pub type PMCI_ANIM_RECT_PARMS = *mut MCI_ANIM_RECT_PARMS;
pub type LPMCI_ANIM_RECT_PARMS = *mut MCI_ANIM_RECT_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_ANIM_UPDATE_PARMS {
    pub dwCallback: DWORD_PTR,
    pub rc: RECT,
    pub hDC: HDC,
}
pub type MCI_ANIM_UPDATE_PARMS = tagMCI_ANIM_UPDATE_PARMS;
pub type PMCI_ANIM_UPDATE_PARMS = *mut tagMCI_ANIM_UPDATE_PARMS;
pub type LPMCI_ANIM_UPDATE_PARMS = *mut tagMCI_ANIM_UPDATE_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_OPEN_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCSTR,
    pub lpstrElementName: LPCSTR,
    pub lpstrAlias: LPCSTR,
    pub dwStyle: DWORD,
    pub hWndParent: HWND,
}
pub type MCI_OVLY_OPEN_PARMSA = tagMCI_OVLY_OPEN_PARMSA;
pub type PMCI_OVLY_OPEN_PARMSA = *mut tagMCI_OVLY_OPEN_PARMSA;
pub type LPMCI_OVLY_OPEN_PARMSA = *mut tagMCI_OVLY_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_OPEN_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub wDeviceID: MCIDEVICEID,
    pub lpstrDeviceType: LPCWSTR,
    pub lpstrElementName: LPCWSTR,
    pub lpstrAlias: LPCWSTR,
    pub dwStyle: DWORD,
    pub hWndParent: HWND,
}
pub type MCI_OVLY_OPEN_PARMSW = tagMCI_OVLY_OPEN_PARMSW;
pub type PMCI_OVLY_OPEN_PARMSW = *mut tagMCI_OVLY_OPEN_PARMSW;
pub type LPMCI_OVLY_OPEN_PARMSW = *mut tagMCI_OVLY_OPEN_PARMSW;
pub type MCI_OVLY_OPEN_PARMS = MCI_OVLY_OPEN_PARMSA;
pub type PMCI_OVLY_OPEN_PARMS = PMCI_OVLY_OPEN_PARMSA;
pub type LPMCI_OVLY_OPEN_PARMS = LPMCI_OVLY_OPEN_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_WINDOW_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub hWnd: HWND,
    pub nCmdShow: UINT,
    pub lpstrText: LPCSTR,
}
pub type MCI_OVLY_WINDOW_PARMSA = tagMCI_OVLY_WINDOW_PARMSA;
pub type PMCI_OVLY_WINDOW_PARMSA = *mut tagMCI_OVLY_WINDOW_PARMSA;
pub type LPMCI_OVLY_WINDOW_PARMSA = *mut tagMCI_OVLY_WINDOW_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_WINDOW_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub hWnd: HWND,
    pub nCmdShow: UINT,
    pub lpstrText: LPCWSTR,
}
pub type MCI_OVLY_WINDOW_PARMSW = tagMCI_OVLY_WINDOW_PARMSW;
pub type PMCI_OVLY_WINDOW_PARMSW = *mut tagMCI_OVLY_WINDOW_PARMSW;
pub type LPMCI_OVLY_WINDOW_PARMSW = *mut tagMCI_OVLY_WINDOW_PARMSW;
pub type MCI_OVLY_WINDOW_PARMS = MCI_OVLY_WINDOW_PARMSA;
pub type PMCI_OVLY_WINDOW_PARMS = PMCI_OVLY_WINDOW_PARMSA;
pub type LPMCI_OVLY_WINDOW_PARMS = LPMCI_OVLY_WINDOW_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_RECT_PARMS {
    pub dwCallback: DWORD_PTR,
    pub rc: RECT,
}
pub type MCI_OVLY_RECT_PARMS = tagMCI_OVLY_RECT_PARMS;
pub type PMCI_OVLY_RECT_PARMS = *mut tagMCI_OVLY_RECT_PARMS;
pub type LPMCI_OVLY_RECT_PARMS = *mut tagMCI_OVLY_RECT_PARMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_SAVE_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCSTR,
    pub rc: RECT,
}
pub type MCI_OVLY_SAVE_PARMSA = tagMCI_OVLY_SAVE_PARMSA;
pub type PMCI_OVLY_SAVE_PARMSA = *mut tagMCI_OVLY_SAVE_PARMSA;
pub type LPMCI_OVLY_SAVE_PARMSA = *mut tagMCI_OVLY_SAVE_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_SAVE_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCWSTR,
    pub rc: RECT,
}
pub type MCI_OVLY_SAVE_PARMSW = tagMCI_OVLY_SAVE_PARMSW;
pub type PMCI_OVLY_SAVE_PARMSW = *mut tagMCI_OVLY_SAVE_PARMSW;
pub type LPMCI_OVLY_SAVE_PARMSW = *mut tagMCI_OVLY_SAVE_PARMSW;
pub type MCI_OVLY_SAVE_PARMS = MCI_OVLY_SAVE_PARMSA;
pub type PMCI_OVLY_SAVE_PARMS = PMCI_OVLY_SAVE_PARMSA;
pub type LPMCI_OVLY_SAVE_PARMS = LPMCI_OVLY_SAVE_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_LOAD_PARMSA {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCSTR,
    pub rc: RECT,
}
pub type MCI_OVLY_LOAD_PARMSA = tagMCI_OVLY_LOAD_PARMSA;
pub type PMCI_OVLY_LOAD_PARMSA = *mut tagMCI_OVLY_LOAD_PARMSA;
pub type LPMCI_OVLY_LOAD_PARMSA = *mut tagMCI_OVLY_LOAD_PARMSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMCI_OVLY_LOAD_PARMSW {
    pub dwCallback: DWORD_PTR,
    pub lpfilename: LPCWSTR,
    pub rc: RECT,
}
pub type MCI_OVLY_LOAD_PARMSW = tagMCI_OVLY_LOAD_PARMSW;
pub type PMCI_OVLY_LOAD_PARMSW = *mut tagMCI_OVLY_LOAD_PARMSW;
pub type LPMCI_OVLY_LOAD_PARMSW = *mut tagMCI_OVLY_LOAD_PARMSW;
pub type MCI_OVLY_LOAD_PARMS = MCI_OVLY_LOAD_PARMSA;
pub type PMCI_OVLY_LOAD_PARMS = PMCI_OVLY_LOAD_PARMSA;
pub type LPMCI_OVLY_LOAD_PARMS = LPMCI_OVLY_LOAD_PARMSA;
extern "C" {
    pub fn mciGetDriverData(wDeviceID: MCIDEVICEID) -> DWORD_PTR;
}
extern "C" {
    pub fn mciLoadCommandResource(hInstance: HANDLE, lpResName: LPCWSTR, wType: UINT) -> UINT;
}
extern "C" {
    pub fn mciSetDriverData(wDeviceID: MCIDEVICEID, dwData: DWORD_PTR) -> BOOL;
}
extern "C" {
    pub fn mciDriverYield(wDeviceID: MCIDEVICEID) -> UINT;
}
extern "C" {
    pub fn mciDriverNotify(hwndCallback: HANDLE, wDeviceID: MCIDEVICEID, uStatus: UINT) -> BOOL;
}
extern "C" {
    pub fn mciFreeCommandResource(wTable: UINT) -> BOOL;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DRVCONFIGINFOEX {
    pub dwDCISize: DWORD,
    pub lpszDCISectionName: LPCWSTR,
    pub lpszDCIAliasName: LPCWSTR,
    pub dnDevNode: DWORD,
}
pub type PDRVCONFIGINFOEX = *mut DRVCONFIGINFOEX;
pub type NPDRVCONFIGINFOEX = *mut DRVCONFIGINFOEX;
pub type LPDRVCONFIGINFOEX = *mut DRVCONFIGINFOEX;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagDRVCONFIGINFO {
    pub dwDCISize: DWORD,
    pub lpszDCISectionName: LPCWSTR,
    pub lpszDCIAliasName: LPCWSTR,
}
pub type DRVCONFIGINFO = tagDRVCONFIGINFO;
pub type PDRVCONFIGINFO = *mut tagDRVCONFIGINFO;
pub type NPDRVCONFIGINFO = *mut tagDRVCONFIGINFO;
pub type LPDRVCONFIGINFO = *mut tagDRVCONFIGINFO;
pub type DRIVERPROC = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: DWORD_PTR,
        arg2: HDRVR,
        arg3: UINT,
        arg4: LPARAM,
        arg5: LPARAM,
    ) -> LRESULT,
>;
extern "C" {
    pub fn CloseDriver(hDriver: HDRVR, lParam1: LPARAM, lParam2: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn OpenDriver(szDriverName: LPCWSTR, szSectionName: LPCWSTR, lParam2: LPARAM) -> HDRVR;
}
extern "C" {
    pub fn SendDriverMessage(
        hDriver: HDRVR,
        message: UINT,
        lParam1: LPARAM,
        lParam2: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn DrvGetModuleHandle(hDriver: HDRVR) -> HMODULE;
}
extern "C" {
    pub fn GetDriverModuleHandle(hDriver: HDRVR) -> HMODULE;
}
extern "C" {
    pub fn DefDriverProc(
        dwDriverIdentifier: DWORD_PTR,
        hdrvr: HDRVR,
        uMsg: UINT,
        lParam1: LPARAM,
        lParam2: LPARAM,
    ) -> LRESULT;
}
extern "C" {
    pub fn DriverCallback(
        dwCallback: DWORD_PTR,
        dwFlags: DWORD,
        hDevice: HDRVR,
        dwMsg: DWORD,
        dwUser: DWORD_PTR,
        dwParam1: DWORD_PTR,
        dwParam2: DWORD_PTR,
    ) -> BOOL;
}
extern "C" {
    pub fn sndOpenSound(
        EventName: LPCWSTR,
        AppName: LPCWSTR,
        Flags: INT32,
        FileHandle: PHANDLE,
    ) -> LONG;
}
pub type DRIVERMSGPROC = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: DWORD,
        arg2: DWORD,
        arg3: DWORD_PTR,
        arg4: DWORD_PTR,
        arg5: DWORD_PTR,
    ) -> DWORD,
>;
extern "C" {
    pub fn mmDrvInstall(
        hDriver: HDRVR,
        wszDrvEntry: LPCWSTR,
        drvMessage: DRIVERMSGPROC,
        wFlags: UINT,
    ) -> UINT;
}
pub type FOURCC = DWORD;
pub type HPSTR = *mut ::std::os::raw::c_char;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMMIO__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMMIO = *mut HMMIO__;
pub type LPMMIOPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: LPSTR, arg2: UINT, arg3: LPARAM, arg4: LPARAM) -> LRESULT,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MMIOINFO {
    pub dwFlags: DWORD,
    pub fccIOProc: FOURCC,
    pub pIOProc: LPMMIOPROC,
    pub wErrorRet: UINT,
    pub htask: HTASK,
    pub cchBuffer: LONG,
    pub pchBuffer: HPSTR,
    pub pchNext: HPSTR,
    pub pchEndRead: HPSTR,
    pub pchEndWrite: HPSTR,
    pub lBufOffset: LONG,
    pub lDiskOffset: LONG,
    pub adwInfo: [DWORD; 3usize],
    pub dwReserved1: DWORD,
    pub dwReserved2: DWORD,
    pub hmmio: HMMIO,
}
pub type MMIOINFO = _MMIOINFO;
pub type PMMIOINFO = *mut _MMIOINFO;
pub type NPMMIOINFO = *mut _MMIOINFO;
pub type LPMMIOINFO = *mut _MMIOINFO;
pub type LPCMMIOINFO = *const MMIOINFO;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _MMCKINFO {
    pub ckid: FOURCC,
    pub cksize: DWORD,
    pub fccType: FOURCC,
    pub dwDataOffset: DWORD,
    pub dwFlags: DWORD,
}
pub type MMCKINFO = _MMCKINFO;
pub type PMMCKINFO = *mut _MMCKINFO;
pub type NPMMCKINFO = *mut _MMCKINFO;
pub type LPMMCKINFO = *mut _MMCKINFO;
pub type LPCMMCKINFO = *const MMCKINFO;
extern "C" {
    pub fn mmioStringToFOURCCA(sz: LPCSTR, uFlags: UINT) -> FOURCC;
}
extern "C" {
    pub fn mmioStringToFOURCCW(sz: LPCWSTR, uFlags: UINT) -> FOURCC;
}
extern "C" {
    pub fn mmioInstallIOProcA(fccIOProc: FOURCC, pIOProc: LPMMIOPROC, dwFlags: DWORD)
        -> LPMMIOPROC;
}
extern "C" {
    pub fn mmioInstallIOProcW(fccIOProc: FOURCC, pIOProc: LPMMIOPROC, dwFlags: DWORD)
        -> LPMMIOPROC;
}
extern "C" {
    pub fn mmioOpenA(pszFileName: LPSTR, pmmioinfo: LPMMIOINFO, fdwOpen: DWORD) -> HMMIO;
}
extern "C" {
    pub fn mmioOpenW(pszFileName: LPWSTR, pmmioinfo: LPMMIOINFO, fdwOpen: DWORD) -> HMMIO;
}
extern "C" {
    pub fn mmioRenameA(
        pszFileName: LPCSTR,
        pszNewFileName: LPCSTR,
        pmmioinfo: LPCMMIOINFO,
        fdwRename: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mmioRenameW(
        pszFileName: LPCWSTR,
        pszNewFileName: LPCWSTR,
        pmmioinfo: LPCMMIOINFO,
        fdwRename: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mmioClose(hmmio: HMMIO, fuClose: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mmioRead(hmmio: HMMIO, pch: HPSTR, cch: LONG) -> LONG;
}
extern "C" {
    pub fn mmioWrite(hmmio: HMMIO, pch: *const ::std::os::raw::c_char, cch: LONG) -> LONG;
}
extern "C" {
    pub fn mmioSeek(hmmio: HMMIO, lOffset: LONG, iOrigin: ::std::os::raw::c_int) -> LONG;
}
extern "C" {
    pub fn mmioGetInfo(hmmio: HMMIO, pmmioinfo: LPMMIOINFO, fuInfo: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mmioSetInfo(hmmio: HMMIO, pmmioinfo: LPCMMIOINFO, fuInfo: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mmioSetBuffer(
        hmmio: HMMIO,
        pchBuffer: LPSTR,
        cchBuffer: LONG,
        fuBuffer: UINT,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mmioFlush(hmmio: HMMIO, fuFlush: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mmioAdvance(hmmio: HMMIO, pmmioinfo: LPMMIOINFO, fuAdvance: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mmioSendMessage(hmmio: HMMIO, uMsg: UINT, lParam1: LPARAM, lParam2: LPARAM) -> LRESULT;
}
extern "C" {
    pub fn mmioDescend(
        hmmio: HMMIO,
        pmmcki: LPMMCKINFO,
        pmmckiParent: *const MMCKINFO,
        fuDescend: UINT,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mmioAscend(hmmio: HMMIO, pmmcki: LPMMCKINFO, fuAscend: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mmioCreateChunk(hmmio: HMMIO, pmmcki: LPMMCKINFO, fuCreate: UINT) -> MMRESULT;
}
pub type LPTIMECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(arg1: UINT, arg2: UINT, arg3: DWORD_PTR, arg4: DWORD_PTR, arg5: DWORD_PTR),
>;
extern "C" {
    pub fn timeSetEvent(
        uDelay: UINT,
        uResolution: UINT,
        fptc: LPTIMECALLBACK,
        dwUser: DWORD_PTR,
        fuEvent: UINT,
    ) -> MMRESULT;
}
extern "C" {
    pub fn timeKillEvent(uTimerID: UINT) -> MMRESULT;
}
extern "C" {
    pub fn sndPlaySoundA(pszSound: LPCSTR, fuSound: UINT) -> BOOL;
}
extern "C" {
    pub fn sndPlaySoundW(pszSound: LPCWSTR, fuSound: UINT) -> BOOL;
}
extern "C" {
    pub fn PlaySoundA(pszSound: LPCSTR, hmod: HMODULE, fdwSound: DWORD) -> BOOL;
}
extern "C" {
    pub fn PlaySoundW(pszSound: LPCWSTR, hmod: HMODULE, fdwSound: DWORD) -> BOOL;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HWAVE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWAVE = *mut HWAVE__;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HWAVEIN__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWAVEIN = *mut HWAVEIN__;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HWAVEOUT__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWAVEOUT = *mut HWAVEOUT__;
pub type LPHWAVEIN = *mut HWAVEIN;
pub type LPHWAVEOUT = *mut HWAVEOUT;
pub type LPWAVECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: HDRVR,
        arg2: UINT,
        arg3: DWORD_PTR,
        arg4: DWORD_PTR,
        arg5: DWORD_PTR,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct wavehdr_tag {
    pub lpData: LPSTR,
    pub dwBufferLength: DWORD,
    pub dwBytesRecorded: DWORD,
    pub dwUser: DWORD_PTR,
    pub dwFlags: DWORD,
    pub dwLoops: DWORD,
    pub lpNext: *mut wavehdr_tag,
    pub reserved: DWORD_PTR,
}
pub type WAVEHDR = wavehdr_tag;
pub type PWAVEHDR = *mut wavehdr_tag;
pub type NPWAVEHDR = *mut wavehdr_tag;
pub type LPWAVEHDR = *mut wavehdr_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEOUTCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
}
pub type WAVEOUTCAPSA = tagWAVEOUTCAPSA;
pub type PWAVEOUTCAPSA = *mut tagWAVEOUTCAPSA;
pub type NPWAVEOUTCAPSA = *mut tagWAVEOUTCAPSA;
pub type LPWAVEOUTCAPSA = *mut tagWAVEOUTCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEOUTCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
}
pub type WAVEOUTCAPSW = tagWAVEOUTCAPSW;
pub type PWAVEOUTCAPSW = *mut tagWAVEOUTCAPSW;
pub type NPWAVEOUTCAPSW = *mut tagWAVEOUTCAPSW;
pub type LPWAVEOUTCAPSW = *mut tagWAVEOUTCAPSW;
pub type WAVEOUTCAPS = WAVEOUTCAPSA;
pub type PWAVEOUTCAPS = PWAVEOUTCAPSA;
pub type NPWAVEOUTCAPS = NPWAVEOUTCAPSA;
pub type LPWAVEOUTCAPS = LPWAVEOUTCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEOUTCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type WAVEOUTCAPS2A = tagWAVEOUTCAPS2A;
pub type PWAVEOUTCAPS2A = *mut tagWAVEOUTCAPS2A;
pub type NPWAVEOUTCAPS2A = *mut tagWAVEOUTCAPS2A;
pub type LPWAVEOUTCAPS2A = *mut tagWAVEOUTCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEOUTCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type WAVEOUTCAPS2W = tagWAVEOUTCAPS2W;
pub type PWAVEOUTCAPS2W = *mut tagWAVEOUTCAPS2W;
pub type NPWAVEOUTCAPS2W = *mut tagWAVEOUTCAPS2W;
pub type LPWAVEOUTCAPS2W = *mut tagWAVEOUTCAPS2W;
pub type WAVEOUTCAPS2 = WAVEOUTCAPS2A;
pub type PWAVEOUTCAPS2 = PWAVEOUTCAPS2A;
pub type NPWAVEOUTCAPS2 = NPWAVEOUTCAPS2A;
pub type LPWAVEOUTCAPS2 = LPWAVEOUTCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEINCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
}
pub type WAVEINCAPSA = tagWAVEINCAPSA;
pub type PWAVEINCAPSA = *mut tagWAVEINCAPSA;
pub type NPWAVEINCAPSA = *mut tagWAVEINCAPSA;
pub type LPWAVEINCAPSA = *mut tagWAVEINCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEINCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
}
pub type WAVEINCAPSW = tagWAVEINCAPSW;
pub type PWAVEINCAPSW = *mut tagWAVEINCAPSW;
pub type NPWAVEINCAPSW = *mut tagWAVEINCAPSW;
pub type LPWAVEINCAPSW = *mut tagWAVEINCAPSW;
pub type WAVEINCAPS = WAVEINCAPSA;
pub type PWAVEINCAPS = PWAVEINCAPSA;
pub type NPWAVEINCAPS = NPWAVEINCAPSA;
pub type LPWAVEINCAPS = LPWAVEINCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEINCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type WAVEINCAPS2A = tagWAVEINCAPS2A;
pub type PWAVEINCAPS2A = *mut tagWAVEINCAPS2A;
pub type NPWAVEINCAPS2A = *mut tagWAVEINCAPS2A;
pub type LPWAVEINCAPS2A = *mut tagWAVEINCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagWAVEINCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub dwFormats: DWORD,
    pub wChannels: WORD,
    pub wReserved1: WORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type WAVEINCAPS2W = tagWAVEINCAPS2W;
pub type PWAVEINCAPS2W = *mut tagWAVEINCAPS2W;
pub type NPWAVEINCAPS2W = *mut tagWAVEINCAPS2W;
pub type LPWAVEINCAPS2W = *mut tagWAVEINCAPS2W;
pub type WAVEINCAPS2 = WAVEINCAPS2A;
pub type PWAVEINCAPS2 = PWAVEINCAPS2A;
pub type NPWAVEINCAPS2 = NPWAVEINCAPS2A;
pub type LPWAVEINCAPS2 = LPWAVEINCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct waveformat_tag {
    pub wFormatTag: WORD,
    pub nChannels: WORD,
    pub nSamplesPerSec: DWORD,
    pub nAvgBytesPerSec: DWORD,
    pub nBlockAlign: WORD,
}
pub type WAVEFORMAT = waveformat_tag;
pub type PWAVEFORMAT = *mut waveformat_tag;
pub type NPWAVEFORMAT = *mut waveformat_tag;
pub type LPWAVEFORMAT = *mut waveformat_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pcmwaveformat_tag {
    pub wf: WAVEFORMAT,
    pub wBitsPerSample: WORD,
}
pub type PCMWAVEFORMAT = pcmwaveformat_tag;
pub type PPCMWAVEFORMAT = *mut pcmwaveformat_tag;
pub type NPPCMWAVEFORMAT = *mut pcmwaveformat_tag;
pub type LPPCMWAVEFORMAT = *mut pcmwaveformat_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tWAVEFORMATEX {
    pub wFormatTag: WORD,
    pub nChannels: WORD,
    pub nSamplesPerSec: DWORD,
    pub nAvgBytesPerSec: DWORD,
    pub nBlockAlign: WORD,
    pub wBitsPerSample: WORD,
    pub cbSize: WORD,
}
pub type WAVEFORMATEX = tWAVEFORMATEX;
pub type PWAVEFORMATEX = *mut tWAVEFORMATEX;
pub type NPWAVEFORMATEX = *mut tWAVEFORMATEX;
pub type LPWAVEFORMATEX = *mut tWAVEFORMATEX;
pub type LPCWAVEFORMATEX = *const WAVEFORMATEX;
extern "C" {
    pub fn waveOutGetNumDevs() -> UINT;
}
extern "C" {
    pub fn waveOutGetDevCapsA(uDeviceID: UINT_PTR, pwoc: LPWAVEOUTCAPSA, cbwoc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetDevCapsW(uDeviceID: UINT_PTR, pwoc: LPWAVEOUTCAPSW, cbwoc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetVolume(hwo: HWAVEOUT, pdwVolume: LPDWORD) -> MMRESULT;
}
extern "C" {
    pub fn waveOutSetVolume(hwo: HWAVEOUT, dwVolume: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutOpen(
        phwo: LPHWAVEOUT,
        uDeviceID: UINT,
        pwfx: LPCWAVEFORMATEX,
        dwCallback: DWORD_PTR,
        dwInstance: DWORD_PTR,
        fdwOpen: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn waveOutClose(hwo: HWAVEOUT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutPrepareHeader(hwo: HWAVEOUT, pwh: LPWAVEHDR, cbwh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutUnprepareHeader(hwo: HWAVEOUT, pwh: LPWAVEHDR, cbwh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutWrite(hwo: HWAVEOUT, pwh: LPWAVEHDR, cbwh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutPause(hwo: HWAVEOUT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutRestart(hwo: HWAVEOUT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutReset(hwo: HWAVEOUT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutBreakLoop(hwo: HWAVEOUT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetPosition(hwo: HWAVEOUT, pmmt: LPMMTIME, cbmmt: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetPitch(hwo: HWAVEOUT, pdwPitch: LPDWORD) -> MMRESULT;
}
extern "C" {
    pub fn waveOutSetPitch(hwo: HWAVEOUT, dwPitch: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetPlaybackRate(hwo: HWAVEOUT, pdwRate: LPDWORD) -> MMRESULT;
}
extern "C" {
    pub fn waveOutSetPlaybackRate(hwo: HWAVEOUT, dwRate: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn waveOutGetID(hwo: HWAVEOUT, puDeviceID: LPUINT) -> MMRESULT;
}
extern "C" {
    pub fn waveOutMessage(hwo: HWAVEOUT, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) -> MMRESULT;
}
extern "C" {
    pub fn waveInGetNumDevs() -> UINT;
}
extern "C" {
    pub fn waveInGetDevCapsA(uDeviceID: UINT_PTR, pwic: LPWAVEINCAPSA, cbwic: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInGetDevCapsW(uDeviceID: UINT_PTR, pwic: LPWAVEINCAPSW, cbwic: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInOpen(
        phwi: LPHWAVEIN,
        uDeviceID: UINT,
        pwfx: LPCWAVEFORMATEX,
        dwCallback: DWORD_PTR,
        dwInstance: DWORD_PTR,
        fdwOpen: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn waveInClose(hwi: HWAVEIN) -> MMRESULT;
}
extern "C" {
    pub fn waveInPrepareHeader(hwi: HWAVEIN, pwh: LPWAVEHDR, cbwh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInUnprepareHeader(hwi: HWAVEIN, pwh: LPWAVEHDR, cbwh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInAddBuffer(hwi: HWAVEIN, pwh: LPWAVEHDR, cbwh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInStart(hwi: HWAVEIN) -> MMRESULT;
}
extern "C" {
    pub fn waveInStop(hwi: HWAVEIN) -> MMRESULT;
}
extern "C" {
    pub fn waveInReset(hwi: HWAVEIN) -> MMRESULT;
}
extern "C" {
    pub fn waveInGetPosition(hwi: HWAVEIN, pmmt: LPMMTIME, cbmmt: UINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInGetID(hwi: HWAVEIN, puDeviceID: LPUINT) -> MMRESULT;
}
extern "C" {
    pub fn waveInMessage(hwi: HWAVEIN, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMIDI__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMIDI = *mut HMIDI__;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMIDIIN__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMIDIIN = *mut HMIDIIN__;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMIDIOUT__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMIDIOUT = *mut HMIDIOUT__;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMIDISTRM__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMIDISTRM = *mut HMIDISTRM__;
pub type LPHMIDI = *mut HMIDI;
pub type LPHMIDIIN = *mut HMIDIIN;
pub type LPHMIDIOUT = *mut HMIDIOUT;
pub type LPHMIDISTRM = *mut HMIDISTRM;
pub type LPMIDICALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: HDRVR,
        arg2: UINT,
        arg3: DWORD_PTR,
        arg4: DWORD_PTR,
        arg5: DWORD_PTR,
    ),
>;
pub type PATCHARRAY = [WORD; 128usize];
pub type LPPATCHARRAY = *mut WORD;
pub type KEYARRAY = [WORD; 128usize];
pub type LPKEYARRAY = *mut WORD;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIOUTCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub wTechnology: WORD,
    pub wVoices: WORD,
    pub wNotes: WORD,
    pub wChannelMask: WORD,
    pub dwSupport: DWORD,
}
pub type MIDIOUTCAPSA = tagMIDIOUTCAPSA;
pub type PMIDIOUTCAPSA = *mut tagMIDIOUTCAPSA;
pub type NPMIDIOUTCAPSA = *mut tagMIDIOUTCAPSA;
pub type LPMIDIOUTCAPSA = *mut tagMIDIOUTCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIOUTCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub wTechnology: WORD,
    pub wVoices: WORD,
    pub wNotes: WORD,
    pub wChannelMask: WORD,
    pub dwSupport: DWORD,
}
pub type MIDIOUTCAPSW = tagMIDIOUTCAPSW;
pub type PMIDIOUTCAPSW = *mut tagMIDIOUTCAPSW;
pub type NPMIDIOUTCAPSW = *mut tagMIDIOUTCAPSW;
pub type LPMIDIOUTCAPSW = *mut tagMIDIOUTCAPSW;
pub type MIDIOUTCAPS = MIDIOUTCAPSA;
pub type PMIDIOUTCAPS = PMIDIOUTCAPSA;
pub type NPMIDIOUTCAPS = NPMIDIOUTCAPSA;
pub type LPMIDIOUTCAPS = LPMIDIOUTCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIOUTCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub wTechnology: WORD,
    pub wVoices: WORD,
    pub wNotes: WORD,
    pub wChannelMask: WORD,
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type MIDIOUTCAPS2A = tagMIDIOUTCAPS2A;
pub type PMIDIOUTCAPS2A = *mut tagMIDIOUTCAPS2A;
pub type NPMIDIOUTCAPS2A = *mut tagMIDIOUTCAPS2A;
pub type LPMIDIOUTCAPS2A = *mut tagMIDIOUTCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIOUTCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub wTechnology: WORD,
    pub wVoices: WORD,
    pub wNotes: WORD,
    pub wChannelMask: WORD,
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type MIDIOUTCAPS2W = tagMIDIOUTCAPS2W;
pub type PMIDIOUTCAPS2W = *mut tagMIDIOUTCAPS2W;
pub type NPMIDIOUTCAPS2W = *mut tagMIDIOUTCAPS2W;
pub type LPMIDIOUTCAPS2W = *mut tagMIDIOUTCAPS2W;
pub type MIDIOUTCAPS2 = MIDIOUTCAPS2A;
pub type PMIDIOUTCAPS2 = PMIDIOUTCAPS2A;
pub type NPMIDIOUTCAPS2 = NPMIDIOUTCAPS2A;
pub type LPMIDIOUTCAPS2 = LPMIDIOUTCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIINCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub dwSupport: DWORD,
}
pub type MIDIINCAPSA = tagMIDIINCAPSA;
pub type PMIDIINCAPSA = *mut tagMIDIINCAPSA;
pub type NPMIDIINCAPSA = *mut tagMIDIINCAPSA;
pub type LPMIDIINCAPSA = *mut tagMIDIINCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIINCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub dwSupport: DWORD,
}
pub type MIDIINCAPSW = tagMIDIINCAPSW;
pub type PMIDIINCAPSW = *mut tagMIDIINCAPSW;
pub type NPMIDIINCAPSW = *mut tagMIDIINCAPSW;
pub type LPMIDIINCAPSW = *mut tagMIDIINCAPSW;
pub type MIDIINCAPS = MIDIINCAPSA;
pub type PMIDIINCAPS = PMIDIINCAPSA;
pub type NPMIDIINCAPS = NPMIDIINCAPSA;
pub type LPMIDIINCAPS = LPMIDIINCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIINCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type MIDIINCAPS2A = tagMIDIINCAPS2A;
pub type PMIDIINCAPS2A = *mut tagMIDIINCAPS2A;
pub type NPMIDIINCAPS2A = *mut tagMIDIINCAPS2A;
pub type LPMIDIINCAPS2A = *mut tagMIDIINCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIDIINCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type MIDIINCAPS2W = tagMIDIINCAPS2W;
pub type PMIDIINCAPS2W = *mut tagMIDIINCAPS2W;
pub type NPMIDIINCAPS2W = *mut tagMIDIINCAPS2W;
pub type LPMIDIINCAPS2W = *mut tagMIDIINCAPS2W;
pub type MIDIINCAPS2 = MIDIINCAPS2A;
pub type PMIDIINCAPS2 = PMIDIINCAPS2A;
pub type NPMIDIINCAPS2 = NPMIDIINCAPS2A;
pub type LPMIDIINCAPS2 = LPMIDIINCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct midihdr_tag {
    pub lpData: LPSTR,
    pub dwBufferLength: DWORD,
    pub dwBytesRecorded: DWORD,
    pub dwUser: DWORD_PTR,
    pub dwFlags: DWORD,
    pub lpNext: *mut midihdr_tag,
    pub reserved: DWORD_PTR,
    pub dwOffset: DWORD,
    pub dwReserved: [DWORD_PTR; 8usize],
}
pub type MIDIHDR = midihdr_tag;
pub type PMIDIHDR = *mut midihdr_tag;
pub type NPMIDIHDR = *mut midihdr_tag;
pub type LPMIDIHDR = *mut midihdr_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct midievent_tag {
    pub dwDeltaTime: DWORD,
    pub dwStreamID: DWORD,
    pub dwEvent: DWORD,
    pub dwParms: [DWORD; 1usize],
}
pub type MIDIEVENT = midievent_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct midistrmbuffver_tag {
    pub dwVersion: DWORD,
    pub dwMid: DWORD,
    pub dwOEMVersion: DWORD,
}
pub type MIDISTRMBUFFVER = midistrmbuffver_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct midiproptimediv_tag {
    pub cbStruct: DWORD,
    pub dwTimeDiv: DWORD,
}
pub type MIDIPROPTIMEDIV = midiproptimediv_tag;
pub type LPMIDIPROPTIMEDIV = *mut midiproptimediv_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct midiproptempo_tag {
    pub cbStruct: DWORD,
    pub dwTempo: DWORD,
}
pub type MIDIPROPTEMPO = midiproptempo_tag;
pub type LPMIDIPROPTEMPO = *mut midiproptempo_tag;
extern "C" {
    pub fn midiOutGetNumDevs() -> UINT;
}
extern "C" {
    pub fn midiStreamOpen(
        phms: LPHMIDISTRM,
        puDeviceID: LPUINT,
        cMidi: DWORD,
        dwCallback: DWORD_PTR,
        dwInstance: DWORD_PTR,
        fdwOpen: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamClose(hms: HMIDISTRM) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamProperty(hms: HMIDISTRM, lppropdata: LPBYTE, dwProperty: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamPosition(hms: HMIDISTRM, lpmmt: LPMMTIME, cbmmt: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamOut(hms: HMIDISTRM, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamPause(hms: HMIDISTRM) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamRestart(hms: HMIDISTRM) -> MMRESULT;
}
extern "C" {
    pub fn midiStreamStop(hms: HMIDISTRM) -> MMRESULT;
}
extern "C" {
    pub fn midiConnect(hmi: HMIDI, hmo: HMIDIOUT, pReserved: LPVOID) -> MMRESULT;
}
extern "C" {
    pub fn midiDisconnect(hmi: HMIDI, hmo: HMIDIOUT, pReserved: LPVOID) -> MMRESULT;
}
extern "C" {
    pub fn midiOutGetDevCapsA(uDeviceID: UINT_PTR, pmoc: LPMIDIOUTCAPSA, cbmoc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutGetDevCapsW(uDeviceID: UINT_PTR, pmoc: LPMIDIOUTCAPSW, cbmoc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutGetVolume(hmo: HMIDIOUT, pdwVolume: LPDWORD) -> MMRESULT;
}
extern "C" {
    pub fn midiOutSetVolume(hmo: HMIDIOUT, dwVolume: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn midiOutGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutOpen(
        phmo: LPHMIDIOUT,
        uDeviceID: UINT,
        dwCallback: DWORD_PTR,
        dwInstance: DWORD_PTR,
        fdwOpen: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn midiOutClose(hmo: HMIDIOUT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutPrepareHeader(hmo: HMIDIOUT, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutUnprepareHeader(hmo: HMIDIOUT, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutShortMsg(hmo: HMIDIOUT, dwMsg: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn midiOutLongMsg(hmo: HMIDIOUT, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutReset(hmo: HMIDIOUT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutCachePatches(hmo: HMIDIOUT, uBank: UINT, pwpa: LPWORD, fuCache: UINT)
        -> MMRESULT;
}
extern "C" {
    pub fn midiOutCacheDrumPatches(
        hmo: HMIDIOUT,
        uPatch: UINT,
        pwkya: LPWORD,
        fuCache: UINT,
    ) -> MMRESULT;
}
extern "C" {
    pub fn midiOutGetID(hmo: HMIDIOUT, puDeviceID: LPUINT) -> MMRESULT;
}
extern "C" {
    pub fn midiOutMessage(hmo: HMIDIOUT, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) -> MMRESULT;
}
extern "C" {
    pub fn midiInGetNumDevs() -> UINT;
}
extern "C" {
    pub fn midiInGetDevCapsA(uDeviceID: UINT_PTR, pmic: LPMIDIINCAPSA, cbmic: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInGetDevCapsW(uDeviceID: UINT_PTR, pmic: LPMIDIINCAPSW, cbmic: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInOpen(
        phmi: LPHMIDIIN,
        uDeviceID: UINT,
        dwCallback: DWORD_PTR,
        dwInstance: DWORD_PTR,
        fdwOpen: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn midiInClose(hmi: HMIDIIN) -> MMRESULT;
}
extern "C" {
    pub fn midiInPrepareHeader(hmi: HMIDIIN, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInUnprepareHeader(hmi: HMIDIIN, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInAddBuffer(hmi: HMIDIIN, pmh: LPMIDIHDR, cbmh: UINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInStart(hmi: HMIDIIN) -> MMRESULT;
}
extern "C" {
    pub fn midiInStop(hmi: HMIDIIN) -> MMRESULT;
}
extern "C" {
    pub fn midiInReset(hmi: HMIDIIN) -> MMRESULT;
}
extern "C" {
    pub fn midiInGetID(hmi: HMIDIIN, puDeviceID: LPUINT) -> MMRESULT;
}
extern "C" {
    pub fn midiInMessage(hmi: HMIDIIN, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagAUXCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub wTechnology: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
}
pub type AUXCAPSA = tagAUXCAPSA;
pub type PAUXCAPSA = *mut tagAUXCAPSA;
pub type NPAUXCAPSA = *mut tagAUXCAPSA;
pub type LPAUXCAPSA = *mut tagAUXCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagAUXCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub wTechnology: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
}
pub type AUXCAPSW = tagAUXCAPSW;
pub type PAUXCAPSW = *mut tagAUXCAPSW;
pub type NPAUXCAPSW = *mut tagAUXCAPSW;
pub type LPAUXCAPSW = *mut tagAUXCAPSW;
pub type AUXCAPS = AUXCAPSA;
pub type PAUXCAPS = PAUXCAPSA;
pub type NPAUXCAPS = NPAUXCAPSA;
pub type LPAUXCAPS = LPAUXCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagAUXCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub wTechnology: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type AUXCAPS2A = tagAUXCAPS2A;
pub type PAUXCAPS2A = *mut tagAUXCAPS2A;
pub type NPAUXCAPS2A = *mut tagAUXCAPS2A;
pub type LPAUXCAPS2A = *mut tagAUXCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagAUXCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub wTechnology: WORD,
    pub wReserved1: WORD,
    pub dwSupport: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type AUXCAPS2W = tagAUXCAPS2W;
pub type PAUXCAPS2W = *mut tagAUXCAPS2W;
pub type NPAUXCAPS2W = *mut tagAUXCAPS2W;
pub type LPAUXCAPS2W = *mut tagAUXCAPS2W;
pub type AUXCAPS2 = AUXCAPS2A;
pub type PAUXCAPS2 = PAUXCAPS2A;
pub type NPAUXCAPS2 = NPAUXCAPS2A;
pub type LPAUXCAPS2 = LPAUXCAPS2A;
extern "C" {
    pub fn auxGetNumDevs() -> UINT;
}
extern "C" {
    pub fn auxGetDevCapsA(uDeviceID: UINT_PTR, pac: LPAUXCAPSA, cbac: UINT) -> MMRESULT;
}
extern "C" {
    pub fn auxGetDevCapsW(uDeviceID: UINT_PTR, pac: LPAUXCAPSW, cbac: UINT) -> MMRESULT;
}
extern "C" {
    pub fn auxSetVolume(uDeviceID: UINT, dwVolume: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn auxGetVolume(uDeviceID: UINT, pdwVolume: LPDWORD) -> MMRESULT;
}
extern "C" {
    pub fn auxOutMessage(uDeviceID: UINT, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMIXEROBJ__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMIXEROBJ = *mut HMIXEROBJ__;
pub type LPHMIXEROBJ = *mut HMIXEROBJ;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct HMIXER__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HMIXER = *mut HMIXER__;
pub type LPHMIXER = *mut HMIXER;
extern "C" {
    pub fn mixerGetNumDevs() -> UINT;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub fdwSupport: DWORD,
    pub cDestinations: DWORD,
}
pub type MIXERCAPSA = tagMIXERCAPSA;
pub type PMIXERCAPSA = *mut tagMIXERCAPSA;
pub type LPMIXERCAPSA = *mut tagMIXERCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub fdwSupport: DWORD,
    pub cDestinations: DWORD,
}
pub type MIXERCAPSW = tagMIXERCAPSW;
pub type PMIXERCAPSW = *mut tagMIXERCAPSW;
pub type LPMIXERCAPSW = *mut tagMIXERCAPSW;
pub type MIXERCAPS = MIXERCAPSA;
pub type PMIXERCAPS = PMIXERCAPSA;
pub type LPMIXERCAPS = LPMIXERCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
    pub fdwSupport: DWORD,
    pub cDestinations: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type MIXERCAPS2A = tagMIXERCAPS2A;
pub type PMIXERCAPS2A = *mut tagMIXERCAPS2A;
pub type LPMIXERCAPS2A = *mut tagMIXERCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
    pub fdwSupport: DWORD,
    pub cDestinations: DWORD,
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type MIXERCAPS2W = tagMIXERCAPS2W;
pub type PMIXERCAPS2W = *mut tagMIXERCAPS2W;
pub type LPMIXERCAPS2W = *mut tagMIXERCAPS2W;
pub type MIXERCAPS2 = MIXERCAPS2A;
pub type PMIXERCAPS2 = PMIXERCAPS2A;
pub type LPMIXERCAPS2 = LPMIXERCAPS2A;
extern "C" {
    pub fn mixerGetDevCapsA(uMxId: UINT_PTR, pmxcaps: LPMIXERCAPSA, cbmxcaps: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mixerGetDevCapsW(uMxId: UINT_PTR, pmxcaps: LPMIXERCAPSW, cbmxcaps: UINT) -> MMRESULT;
}
extern "C" {
    pub fn mixerOpen(
        phmx: LPHMIXER,
        uMxId: UINT,
        dwCallback: DWORD_PTR,
        dwInstance: DWORD_PTR,
        fdwOpen: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mixerClose(hmx: HMIXER) -> MMRESULT;
}
extern "C" {
    pub fn mixerMessage(hmx: HMIXER, uMsg: UINT, dwParam1: DWORD_PTR, dwParam2: DWORD_PTR)
        -> DWORD;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERLINEA {
    pub cbStruct: DWORD,
    pub dwDestination: DWORD,
    pub dwSource: DWORD,
    pub dwLineID: DWORD,
    pub fdwLine: DWORD,
    pub dwUser: DWORD_PTR,
    pub dwComponentType: DWORD,
    pub cChannels: DWORD,
    pub cConnections: DWORD,
    pub cControls: DWORD,
    pub szShortName: [CHAR; 16usize],
    pub szName: [CHAR; 64usize],
    pub Target: tagMIXERLINEA__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERLINEA__bindgen_ty_1 {
    pub dwType: DWORD,
    pub dwDeviceID: DWORD,
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [CHAR; 32usize],
}
pub type MIXERLINEA = tagMIXERLINEA;
pub type PMIXERLINEA = *mut tagMIXERLINEA;
pub type LPMIXERLINEA = *mut tagMIXERLINEA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERLINEW {
    pub cbStruct: DWORD,
    pub dwDestination: DWORD,
    pub dwSource: DWORD,
    pub dwLineID: DWORD,
    pub fdwLine: DWORD,
    pub dwUser: DWORD_PTR,
    pub dwComponentType: DWORD,
    pub cChannels: DWORD,
    pub cConnections: DWORD,
    pub cControls: DWORD,
    pub szShortName: [WCHAR; 16usize],
    pub szName: [WCHAR; 64usize],
    pub Target: tagMIXERLINEW__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERLINEW__bindgen_ty_1 {
    pub dwType: DWORD,
    pub dwDeviceID: DWORD,
    pub wMid: WORD,
    pub wPid: WORD,
    pub vDriverVersion: MMVERSION,
    pub szPname: [WCHAR; 32usize],
}
pub type MIXERLINEW = tagMIXERLINEW;
pub type PMIXERLINEW = *mut tagMIXERLINEW;
pub type LPMIXERLINEW = *mut tagMIXERLINEW;
pub type MIXERLINE = MIXERLINEA;
pub type PMIXERLINE = PMIXERLINEA;
pub type LPMIXERLINE = LPMIXERLINEA;
extern "C" {
    pub fn mixerGetLineInfoA(hmxobj: HMIXEROBJ, pmxl: LPMIXERLINEA, fdwInfo: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn mixerGetLineInfoW(hmxobj: HMIXEROBJ, pmxl: LPMIXERLINEW, fdwInfo: DWORD) -> MMRESULT;
}
extern "C" {
    pub fn mixerGetID(hmxobj: HMIXEROBJ, puMxId: *mut UINT, fdwId: DWORD) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagMIXERCONTROLA {
    pub cbStruct: DWORD,
    pub dwControlID: DWORD,
    pub dwControlType: DWORD,
    pub fdwControl: DWORD,
    pub cMultipleItems: DWORD,
    pub szShortName: [CHAR; 16usize],
    pub szName: [CHAR; 64usize],
    pub Bounds: tagMIXERCONTROLA__bindgen_ty_1,
    pub Metrics: tagMIXERCONTROLA__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagMIXERCONTROLA__bindgen_ty_1 {
    pub __bindgen_anon_1: tagMIXERCONTROLA__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tagMIXERCONTROLA__bindgen_ty_1__bindgen_ty_2,
    pub dwReserved: [DWORD; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCONTROLA__bindgen_ty_1__bindgen_ty_1 {
    pub lMinimum: LONG,
    pub lMaximum: LONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCONTROLA__bindgen_ty_1__bindgen_ty_2 {
    pub dwMinimum: DWORD,
    pub dwMaximum: DWORD,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagMIXERCONTROLA__bindgen_ty_2 {
    pub cSteps: DWORD,
    pub cbCustomData: DWORD,
    pub dwReserved: [DWORD; 6usize],
}
pub type MIXERCONTROLA = tagMIXERCONTROLA;
pub type PMIXERCONTROLA = *mut tagMIXERCONTROLA;
pub type LPMIXERCONTROLA = *mut tagMIXERCONTROLA;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagMIXERCONTROLW {
    pub cbStruct: DWORD,
    pub dwControlID: DWORD,
    pub dwControlType: DWORD,
    pub fdwControl: DWORD,
    pub cMultipleItems: DWORD,
    pub szShortName: [WCHAR; 16usize],
    pub szName: [WCHAR; 64usize],
    pub Bounds: tagMIXERCONTROLW__bindgen_ty_1,
    pub Metrics: tagMIXERCONTROLW__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagMIXERCONTROLW__bindgen_ty_1 {
    pub __bindgen_anon_1: tagMIXERCONTROLW__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tagMIXERCONTROLW__bindgen_ty_1__bindgen_ty_2,
    pub dwReserved: [DWORD; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCONTROLW__bindgen_ty_1__bindgen_ty_1 {
    pub lMinimum: LONG,
    pub lMaximum: LONG,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCONTROLW__bindgen_ty_1__bindgen_ty_2 {
    pub dwMinimum: DWORD,
    pub dwMaximum: DWORD,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagMIXERCONTROLW__bindgen_ty_2 {
    pub cSteps: DWORD,
    pub cbCustomData: DWORD,
    pub dwReserved: [DWORD; 6usize],
}
pub type MIXERCONTROLW = tagMIXERCONTROLW;
pub type PMIXERCONTROLW = *mut tagMIXERCONTROLW;
pub type LPMIXERCONTROLW = *mut tagMIXERCONTROLW;
pub type MIXERCONTROL = MIXERCONTROLA;
pub type PMIXERCONTROL = PMIXERCONTROLA;
pub type LPMIXERCONTROL = LPMIXERCONTROLA;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagMIXERLINECONTROLSA {
    pub cbStruct: DWORD,
    pub dwLineID: DWORD,
    pub __bindgen_anon_1: tagMIXERLINECONTROLSA__bindgen_ty_1,
    pub cControls: DWORD,
    pub cbmxctrl: DWORD,
    pub pamxctrl: LPMIXERCONTROLA,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagMIXERLINECONTROLSA__bindgen_ty_1 {
    pub dwControlID: DWORD,
    pub dwControlType: DWORD,
}
pub type MIXERLINECONTROLSA = tagMIXERLINECONTROLSA;
pub type PMIXERLINECONTROLSA = *mut tagMIXERLINECONTROLSA;
pub type LPMIXERLINECONTROLSA = *mut tagMIXERLINECONTROLSA;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagMIXERLINECONTROLSW {
    pub cbStruct: DWORD,
    pub dwLineID: DWORD,
    pub __bindgen_anon_1: tagMIXERLINECONTROLSW__bindgen_ty_1,
    pub cControls: DWORD,
    pub cbmxctrl: DWORD,
    pub pamxctrl: LPMIXERCONTROLW,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagMIXERLINECONTROLSW__bindgen_ty_1 {
    pub dwControlID: DWORD,
    pub dwControlType: DWORD,
}
pub type MIXERLINECONTROLSW = tagMIXERLINECONTROLSW;
pub type PMIXERLINECONTROLSW = *mut tagMIXERLINECONTROLSW;
pub type LPMIXERLINECONTROLSW = *mut tagMIXERLINECONTROLSW;
pub type MIXERLINECONTROLS = MIXERLINECONTROLSA;
pub type PMIXERLINECONTROLS = PMIXERLINECONTROLSA;
pub type LPMIXERLINECONTROLS = LPMIXERLINECONTROLSA;
extern "C" {
    pub fn mixerGetLineControlsA(
        hmxobj: HMIXEROBJ,
        pmxlc: LPMIXERLINECONTROLSA,
        fdwControls: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mixerGetLineControlsW(
        hmxobj: HMIXEROBJ,
        pmxlc: LPMIXERLINECONTROLSW,
        fdwControls: DWORD,
    ) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tMIXERCONTROLDETAILS {
    pub cbStruct: DWORD,
    pub dwControlID: DWORD,
    pub cChannels: DWORD,
    pub __bindgen_anon_1: tMIXERCONTROLDETAILS__bindgen_ty_1,
    pub cbDetails: DWORD,
    pub paDetails: LPVOID,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tMIXERCONTROLDETAILS__bindgen_ty_1 {
    pub hwndOwner: HWND,
    pub cMultipleItems: DWORD,
}
pub type MIXERCONTROLDETAILS = tMIXERCONTROLDETAILS;
pub type PMIXERCONTROLDETAILS = *mut tMIXERCONTROLDETAILS;
pub type LPMIXERCONTROLDETAILS = *mut tMIXERCONTROLDETAILS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCONTROLDETAILS_LISTTEXTA {
    pub dwParam1: DWORD,
    pub dwParam2: DWORD,
    pub szName: [CHAR; 64usize],
}
pub type MIXERCONTROLDETAILS_LISTTEXTA = tagMIXERCONTROLDETAILS_LISTTEXTA;
pub type PMIXERCONTROLDETAILS_LISTTEXTA = *mut tagMIXERCONTROLDETAILS_LISTTEXTA;
pub type LPMIXERCONTROLDETAILS_LISTTEXTA = *mut tagMIXERCONTROLDETAILS_LISTTEXTA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagMIXERCONTROLDETAILS_LISTTEXTW {
    pub dwParam1: DWORD,
    pub dwParam2: DWORD,
    pub szName: [WCHAR; 64usize],
}
pub type MIXERCONTROLDETAILS_LISTTEXTW = tagMIXERCONTROLDETAILS_LISTTEXTW;
pub type PMIXERCONTROLDETAILS_LISTTEXTW = *mut tagMIXERCONTROLDETAILS_LISTTEXTW;
pub type LPMIXERCONTROLDETAILS_LISTTEXTW = *mut tagMIXERCONTROLDETAILS_LISTTEXTW;
pub type MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTA;
pub type PMIXERCONTROLDETAILS_LISTTEXT = PMIXERCONTROLDETAILS_LISTTEXTA;
pub type LPMIXERCONTROLDETAILS_LISTTEXT = LPMIXERCONTROLDETAILS_LISTTEXTA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tMIXERCONTROLDETAILS_BOOLEAN {
    pub fValue: LONG,
}
pub type MIXERCONTROLDETAILS_BOOLEAN = tMIXERCONTROLDETAILS_BOOLEAN;
pub type PMIXERCONTROLDETAILS_BOOLEAN = *mut tMIXERCONTROLDETAILS_BOOLEAN;
pub type LPMIXERCONTROLDETAILS_BOOLEAN = *mut tMIXERCONTROLDETAILS_BOOLEAN;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tMIXERCONTROLDETAILS_SIGNED {
    pub lValue: LONG,
}
pub type MIXERCONTROLDETAILS_SIGNED = tMIXERCONTROLDETAILS_SIGNED;
pub type PMIXERCONTROLDETAILS_SIGNED = *mut tMIXERCONTROLDETAILS_SIGNED;
pub type LPMIXERCONTROLDETAILS_SIGNED = *mut tMIXERCONTROLDETAILS_SIGNED;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tMIXERCONTROLDETAILS_UNSIGNED {
    pub dwValue: DWORD,
}
pub type MIXERCONTROLDETAILS_UNSIGNED = tMIXERCONTROLDETAILS_UNSIGNED;
pub type PMIXERCONTROLDETAILS_UNSIGNED = *mut tMIXERCONTROLDETAILS_UNSIGNED;
pub type LPMIXERCONTROLDETAILS_UNSIGNED = *mut tMIXERCONTROLDETAILS_UNSIGNED;
extern "C" {
    pub fn mixerGetControlDetailsA(
        hmxobj: HMIXEROBJ,
        pmxcd: LPMIXERCONTROLDETAILS,
        fdwDetails: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mixerGetControlDetailsW(
        hmxobj: HMIXEROBJ,
        pmxcd: LPMIXERCONTROLDETAILS,
        fdwDetails: DWORD,
    ) -> MMRESULT;
}
extern "C" {
    pub fn mixerSetControlDetails(
        hmxobj: HMIXEROBJ,
        pmxcd: LPMIXERCONTROLDETAILS,
        fdwDetails: DWORD,
    ) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct timecaps_tag {
    pub wPeriodMin: UINT,
    pub wPeriodMax: UINT,
}
pub type TIMECAPS = timecaps_tag;
pub type PTIMECAPS = *mut timecaps_tag;
pub type NPTIMECAPS = *mut timecaps_tag;
pub type LPTIMECAPS = *mut timecaps_tag;
extern "C" {
    pub fn timeGetSystemTime(pmmt: LPMMTIME, cbmmt: UINT) -> MMRESULT;
}
extern "C" {
    pub fn timeGetTime() -> DWORD;
}
extern "C" {
    pub fn timeGetDevCaps(ptc: LPTIMECAPS, cbtc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn timeBeginPeriod(uPeriod: UINT) -> MMRESULT;
}
extern "C" {
    pub fn timeEndPeriod(uPeriod: UINT) -> MMRESULT;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagJOYCAPSA {
    pub wMid: WORD,
    pub wPid: WORD,
    pub szPname: [CHAR; 32usize],
    pub wXmin: UINT,
    pub wXmax: UINT,
    pub wYmin: UINT,
    pub wYmax: UINT,
    pub wZmin: UINT,
    pub wZmax: UINT,
    pub wNumButtons: UINT,
    pub wPeriodMin: UINT,
    pub wPeriodMax: UINT,
    pub wRmin: UINT,
    pub wRmax: UINT,
    pub wUmin: UINT,
    pub wUmax: UINT,
    pub wVmin: UINT,
    pub wVmax: UINT,
    pub wCaps: UINT,
    pub wMaxAxes: UINT,
    pub wNumAxes: UINT,
    pub wMaxButtons: UINT,
    pub szRegKey: [CHAR; 32usize],
    pub szOEMVxD: [CHAR; 260usize],
}
pub type JOYCAPSA = tagJOYCAPSA;
pub type PJOYCAPSA = *mut tagJOYCAPSA;
pub type NPJOYCAPSA = *mut tagJOYCAPSA;
pub type LPJOYCAPSA = *mut tagJOYCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagJOYCAPSW {
    pub wMid: WORD,
    pub wPid: WORD,
    pub szPname: [WCHAR; 32usize],
    pub wXmin: UINT,
    pub wXmax: UINT,
    pub wYmin: UINT,
    pub wYmax: UINT,
    pub wZmin: UINT,
    pub wZmax: UINT,
    pub wNumButtons: UINT,
    pub wPeriodMin: UINT,
    pub wPeriodMax: UINT,
    pub wRmin: UINT,
    pub wRmax: UINT,
    pub wUmin: UINT,
    pub wUmax: UINT,
    pub wVmin: UINT,
    pub wVmax: UINT,
    pub wCaps: UINT,
    pub wMaxAxes: UINT,
    pub wNumAxes: UINT,
    pub wMaxButtons: UINT,
    pub szRegKey: [WCHAR; 32usize],
    pub szOEMVxD: [WCHAR; 260usize],
}
pub type JOYCAPSW = tagJOYCAPSW;
pub type PJOYCAPSW = *mut tagJOYCAPSW;
pub type NPJOYCAPSW = *mut tagJOYCAPSW;
pub type LPJOYCAPSW = *mut tagJOYCAPSW;
pub type JOYCAPS = JOYCAPSA;
pub type PJOYCAPS = PJOYCAPSA;
pub type NPJOYCAPS = NPJOYCAPSA;
pub type LPJOYCAPS = LPJOYCAPSA;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagJOYCAPS2A {
    pub wMid: WORD,
    pub wPid: WORD,
    pub szPname: [CHAR; 32usize],
    pub wXmin: UINT,
    pub wXmax: UINT,
    pub wYmin: UINT,
    pub wYmax: UINT,
    pub wZmin: UINT,
    pub wZmax: UINT,
    pub wNumButtons: UINT,
    pub wPeriodMin: UINT,
    pub wPeriodMax: UINT,
    pub wRmin: UINT,
    pub wRmax: UINT,
    pub wUmin: UINT,
    pub wUmax: UINT,
    pub wVmin: UINT,
    pub wVmax: UINT,
    pub wCaps: UINT,
    pub wMaxAxes: UINT,
    pub wNumAxes: UINT,
    pub wMaxButtons: UINT,
    pub szRegKey: [CHAR; 32usize],
    pub szOEMVxD: [CHAR; 260usize],
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type JOYCAPS2A = tagJOYCAPS2A;
pub type PJOYCAPS2A = *mut tagJOYCAPS2A;
pub type NPJOYCAPS2A = *mut tagJOYCAPS2A;
pub type LPJOYCAPS2A = *mut tagJOYCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagJOYCAPS2W {
    pub wMid: WORD,
    pub wPid: WORD,
    pub szPname: [WCHAR; 32usize],
    pub wXmin: UINT,
    pub wXmax: UINT,
    pub wYmin: UINT,
    pub wYmax: UINT,
    pub wZmin: UINT,
    pub wZmax: UINT,
    pub wNumButtons: UINT,
    pub wPeriodMin: UINT,
    pub wPeriodMax: UINT,
    pub wRmin: UINT,
    pub wRmax: UINT,
    pub wUmin: UINT,
    pub wUmax: UINT,
    pub wVmin: UINT,
    pub wVmax: UINT,
    pub wCaps: UINT,
    pub wMaxAxes: UINT,
    pub wNumAxes: UINT,
    pub wMaxButtons: UINT,
    pub szRegKey: [WCHAR; 32usize],
    pub szOEMVxD: [WCHAR; 260usize],
    pub ManufacturerGuid: GUID,
    pub ProductGuid: GUID,
    pub NameGuid: GUID,
}
pub type JOYCAPS2W = tagJOYCAPS2W;
pub type PJOYCAPS2W = *mut tagJOYCAPS2W;
pub type NPJOYCAPS2W = *mut tagJOYCAPS2W;
pub type LPJOYCAPS2W = *mut tagJOYCAPS2W;
pub type JOYCAPS2 = JOYCAPS2A;
pub type PJOYCAPS2 = PJOYCAPS2A;
pub type NPJOYCAPS2 = NPJOYCAPS2A;
pub type LPJOYCAPS2 = LPJOYCAPS2A;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct joyinfo_tag {
    pub wXpos: UINT,
    pub wYpos: UINT,
    pub wZpos: UINT,
    pub wButtons: UINT,
}
pub type JOYINFO = joyinfo_tag;
pub type PJOYINFO = *mut joyinfo_tag;
pub type NPJOYINFO = *mut joyinfo_tag;
pub type LPJOYINFO = *mut joyinfo_tag;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct joyinfoex_tag {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub dwXpos: DWORD,
    pub dwYpos: DWORD,
    pub dwZpos: DWORD,
    pub dwRpos: DWORD,
    pub dwUpos: DWORD,
    pub dwVpos: DWORD,
    pub dwButtons: DWORD,
    pub dwButtonNumber: DWORD,
    pub dwPOV: DWORD,
    pub dwReserved1: DWORD,
    pub dwReserved2: DWORD,
}
pub type JOYINFOEX = joyinfoex_tag;
pub type PJOYINFOEX = *mut joyinfoex_tag;
pub type NPJOYINFOEX = *mut joyinfoex_tag;
pub type LPJOYINFOEX = *mut joyinfoex_tag;
extern "C" {
    pub fn joyGetPosEx(uJoyID: UINT, pji: LPJOYINFOEX) -> MMRESULT;
}
extern "C" {
    pub fn joyGetNumDevs() -> UINT;
}
extern "C" {
    pub fn joyGetDevCapsA(uJoyID: UINT_PTR, pjc: LPJOYCAPSA, cbjc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn joyGetDevCapsW(uJoyID: UINT_PTR, pjc: LPJOYCAPSW, cbjc: UINT) -> MMRESULT;
}
extern "C" {
    pub fn joyGetPos(uJoyID: UINT, pji: LPJOYINFO) -> MMRESULT;
}
extern "C" {
    pub fn joyGetThreshold(uJoyID: UINT, puThreshold: LPUINT) -> MMRESULT;
}
extern "C" {
    pub fn joyReleaseCapture(uJoyID: UINT) -> MMRESULT;
}
extern "C" {
    pub fn joySetCapture(hwnd: HWND, uJoyID: UINT, uPeriod: UINT, fChanged: BOOL) -> MMRESULT;
}
extern "C" {
    pub fn joySetThreshold(uJoyID: UINT, uThreshold: UINT) -> MMRESULT;
}
extern "C" {
    pub fn joyConfigChanged(dwFlags: DWORD) -> MMRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCB {
    pub ncb_command: UCHAR,
    pub ncb_retcode: UCHAR,
    pub ncb_lsn: UCHAR,
    pub ncb_num: UCHAR,
    pub ncb_buffer: PUCHAR,
    pub ncb_length: WORD,
    pub ncb_callname: [UCHAR; 16usize],
    pub ncb_name: [UCHAR; 16usize],
    pub ncb_rto: UCHAR,
    pub ncb_sto: UCHAR,
    pub ncb_post: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _NCB)>,
    pub ncb_lana_num: UCHAR,
    pub ncb_cmd_cplt: UCHAR,
    pub ncb_reserve: [UCHAR; 18usize],
    pub ncb_event: HANDLE,
}
pub type NCB = _NCB;
pub type PNCB = *mut _NCB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADAPTER_STATUS {
    pub adapter_address: [UCHAR; 6usize],
    pub rev_major: UCHAR,
    pub reserved0: UCHAR,
    pub adapter_type: UCHAR,
    pub rev_minor: UCHAR,
    pub duration: WORD,
    pub frmr_recv: WORD,
    pub frmr_xmit: WORD,
    pub iframe_recv_err: WORD,
    pub xmit_aborts: WORD,
    pub xmit_success: DWORD,
    pub recv_success: DWORD,
    pub iframe_xmit_err: WORD,
    pub recv_buff_unavail: WORD,
    pub t1_timeouts: WORD,
    pub ti_timeouts: WORD,
    pub reserved1: DWORD,
    pub free_ncbs: WORD,
    pub max_cfg_ncbs: WORD,
    pub max_ncbs: WORD,
    pub xmit_buf_unavail: WORD,
    pub max_dgram_size: WORD,
    pub pending_sess: WORD,
    pub max_cfg_sess: WORD,
    pub max_sess: WORD,
    pub max_sess_pkt_size: WORD,
    pub name_count: WORD,
}
pub type ADAPTER_STATUS = _ADAPTER_STATUS;
pub type PADAPTER_STATUS = *mut _ADAPTER_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NAME_BUFFER {
    pub name: [UCHAR; 16usize],
    pub name_num: UCHAR,
    pub name_flags: UCHAR,
}
pub type NAME_BUFFER = _NAME_BUFFER;
pub type PNAME_BUFFER = *mut _NAME_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SESSION_HEADER {
    pub sess_name: UCHAR,
    pub num_sess: UCHAR,
    pub rcv_dg_outstanding: UCHAR,
    pub rcv_any_outstanding: UCHAR,
}
pub type SESSION_HEADER = _SESSION_HEADER;
pub type PSESSION_HEADER = *mut _SESSION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SESSION_BUFFER {
    pub lsn: UCHAR,
    pub state: UCHAR,
    pub local_name: [UCHAR; 16usize],
    pub remote_name: [UCHAR; 16usize],
    pub rcvs_outstanding: UCHAR,
    pub sends_outstanding: UCHAR,
}
pub type SESSION_BUFFER = _SESSION_BUFFER;
pub type PSESSION_BUFFER = *mut _SESSION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LANA_ENUM {
    pub length: UCHAR,
    pub lana: [UCHAR; 255usize],
}
pub type LANA_ENUM = _LANA_ENUM;
pub type PLANA_ENUM = *mut _LANA_ENUM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FIND_NAME_HEADER {
    pub node_count: WORD,
    pub reserved: UCHAR,
    pub unique_group: UCHAR,
}
pub type FIND_NAME_HEADER = _FIND_NAME_HEADER;
pub type PFIND_NAME_HEADER = *mut _FIND_NAME_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FIND_NAME_BUFFER {
    pub length: UCHAR,
    pub access_control: UCHAR,
    pub frame_control: UCHAR,
    pub destination_addr: [UCHAR; 6usize],
    pub source_addr: [UCHAR; 6usize],
    pub routing_info: [UCHAR; 18usize],
}
pub type FIND_NAME_BUFFER = _FIND_NAME_BUFFER;
pub type PFIND_NAME_BUFFER = *mut _FIND_NAME_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTION_HEADER {
    pub transport_id: ULONG,
    pub action_code: USHORT,
    pub reserved: USHORT,
}
pub type ACTION_HEADER = _ACTION_HEADER;
pub type PACTION_HEADER = *mut _ACTION_HEADER;
extern "C" {
    pub fn Netbios(pncb: PNCB) -> UCHAR;
}
pub type I_RPC_HANDLE = *mut ::std::os::raw::c_void;
pub type RPC_STATUS = ::std::os::raw::c_long;
pub type RPC_CSTR = *mut ::std::os::raw::c_uchar;
pub type RPC_WSTR = *mut ::std::os::raw::c_ushort;
pub type RPC_CWSTR = *const ::std::os::raw::c_ushort;
pub type RPC_BINDING_HANDLE = I_RPC_HANDLE;
pub type handle_t = RPC_BINDING_HANDLE;
pub type UUID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_BINDING_VECTOR {
    pub Count: ::std::os::raw::c_ulong,
    pub BindingH: [RPC_BINDING_HANDLE; 1usize],
}
pub type RPC_BINDING_VECTOR = _RPC_BINDING_VECTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UUID_VECTOR {
    pub Count: ::std::os::raw::c_ulong,
    pub Uuid: [*mut UUID; 1usize],
}
pub type UUID_VECTOR = _UUID_VECTOR;
pub type RPC_IF_HANDLE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_IF_ID {
    pub Uuid: UUID,
    pub VersMajor: ::std::os::raw::c_ushort,
    pub VersMinor: ::std::os::raw::c_ushort,
}
pub type RPC_IF_ID = _RPC_IF_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_PROTSEQ_VECTORA {
    pub Count: ::std::os::raw::c_uint,
    pub Protseq: [*mut ::std::os::raw::c_uchar; 1usize],
}
pub type RPC_PROTSEQ_VECTORA = _RPC_PROTSEQ_VECTORA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_PROTSEQ_VECTORW {
    pub Count: ::std::os::raw::c_uint,
    pub Protseq: [*mut ::std::os::raw::c_ushort; 1usize],
}
pub type RPC_PROTSEQ_VECTORW = _RPC_PROTSEQ_VECTORW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_POLICY {
    pub Length: ::std::os::raw::c_uint,
    pub EndpointFlags: ::std::os::raw::c_ulong,
    pub NICFlags: ::std::os::raw::c_ulong,
}
pub type RPC_POLICY = _RPC_POLICY;
pub type PRPC_POLICY = *mut _RPC_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_STATS_VECTOR {
    pub Count: ::std::os::raw::c_uint,
    pub Stats: [::std::os::raw::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_IF_ID_VECTOR {
    pub Count: ::std::os::raw::c_ulong,
    pub IfId: [*mut RPC_IF_ID; 1usize],
}
extern "C" {
    pub fn RpcBindingCopy(
        SourceBinding: RPC_BINDING_HANDLE,
        DestinationBinding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingFree(Binding: *mut RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingSetOption(
        hBinding: RPC_BINDING_HANDLE,
        option: ::std::os::raw::c_ulong,
        optionValue: ULONG_PTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqOption(
        hBinding: RPC_BINDING_HANDLE,
        option: ::std::os::raw::c_ulong,
        pOptionValue: *mut ULONG_PTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingFromStringBindingA(
        StringBinding: RPC_CSTR,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingFromStringBindingW(
        StringBinding: RPC_WSTR,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSsGetContextBinding(
        ContextHandle: *mut ::std::os::raw::c_void,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqMaxCalls(
        Binding: RPC_BINDING_HANDLE,
        MaxCalls: *mut ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqObject(Binding: RPC_BINDING_HANDLE, ObjectUuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingReset(Binding: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingSetObject(Binding: RPC_BINDING_HANDLE, ObjectUuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtInqDefaultProtectLevel(
        AuthnSvc: ::std::os::raw::c_ulong,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingToStringBindingA(
        Binding: RPC_BINDING_HANDLE,
        StringBinding: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingToStringBindingW(
        Binding: RPC_BINDING_HANDLE,
        StringBinding: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingVectorFree(BindingVector: *mut *mut RPC_BINDING_VECTOR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcStringBindingComposeA(
        ObjUuid: RPC_CSTR,
        ProtSeq: RPC_CSTR,
        NetworkAddr: RPC_CSTR,
        Endpoint: RPC_CSTR,
        Options: RPC_CSTR,
        StringBinding: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcStringBindingComposeW(
        ObjUuid: RPC_WSTR,
        ProtSeq: RPC_WSTR,
        NetworkAddr: RPC_WSTR,
        Endpoint: RPC_WSTR,
        Options: RPC_WSTR,
        StringBinding: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcStringBindingParseA(
        StringBinding: RPC_CSTR,
        ObjUuid: *mut RPC_CSTR,
        Protseq: *mut RPC_CSTR,
        NetworkAddr: *mut RPC_CSTR,
        Endpoint: *mut RPC_CSTR,
        NetworkOptions: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcStringBindingParseW(
        StringBinding: RPC_WSTR,
        ObjUuid: *mut RPC_WSTR,
        Protseq: *mut RPC_WSTR,
        NetworkAddr: *mut RPC_WSTR,
        Endpoint: *mut RPC_WSTR,
        NetworkOptions: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcStringFreeA(String: *mut RPC_CSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcStringFreeW(String: *mut RPC_WSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcIfInqId(RpcIfHandle: RPC_IF_HANDLE, RpcIfId: *mut RPC_IF_ID) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNetworkIsProtseqValidA(Protseq: RPC_CSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNetworkIsProtseqValidW(Protseq: RPC_WSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtInqComTimeout(
        Binding: RPC_BINDING_HANDLE,
        Timeout: *mut ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtSetComTimeout(
        Binding: RPC_BINDING_HANDLE,
        Timeout: ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtSetCancelTimeout(Timeout: ::std::os::raw::c_long) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNetworkInqProtseqsA(ProtseqVector: *mut *mut RPC_PROTSEQ_VECTORA) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNetworkInqProtseqsW(ProtseqVector: *mut *mut RPC_PROTSEQ_VECTORW) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcObjectInqType(ObjUuid: *mut UUID, TypeUuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcObjectSetInqFn(
        InquiryFn: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut UUID, arg2: *mut UUID, arg3: *mut RPC_STATUS),
        >,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcObjectSetType(ObjUuid: *mut UUID, TypeUuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcProtseqVectorFreeA(ProtseqVector: *mut *mut RPC_PROTSEQ_VECTORA) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcProtseqVectorFreeW(ProtseqVector: *mut *mut RPC_PROTSEQ_VECTORW) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqBindings(BindingVector: *mut *mut RPC_BINDING_VECTOR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqBindingsEx(
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        BindingVector: *mut *mut RPC_BINDING_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqIf(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        MgrEpv: *mut *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerListen(
        MinimumCallThreads: ::std::os::raw::c_uint,
        MaxCalls: ::std::os::raw::c_uint,
        DontWait: ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerRegisterIf(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        MgrEpv: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerRegisterIfEx(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        MgrEpv: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
        MaxCalls: ::std::os::raw::c_uint,
        IfCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: RPC_IF_HANDLE,
                arg2: *mut ::std::os::raw::c_void,
            ) -> RPC_STATUS,
        >,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerRegisterIf2(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        MgrEpv: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
        MaxCalls: ::std::os::raw::c_uint,
        MaxRpcSize: ::std::os::raw::c_uint,
        IfCallbackFn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: RPC_IF_HANDLE,
                arg2: *mut ::std::os::raw::c_void,
            ) -> RPC_STATUS,
        >,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerRegisterIf3(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        MgrEpv: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
        MaxCalls: ::std::os::raw::c_uint,
        MaxRpcSize: ::std::os::raw::c_uint,
        IfCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: RPC_IF_HANDLE,
                arg2: *mut ::std::os::raw::c_void,
            ) -> RPC_STATUS,
        >,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUnregisterIf(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        WaitForCallsToComplete: ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUnregisterIfEx(
        IfSpec: RPC_IF_HANDLE,
        MgrTypeUuid: *mut UUID,
        RundownContextHandles: ::std::os::raw::c_int,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseAllProtseqs(
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseAllProtseqsEx(
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseAllProtseqsIf(
        MaxCalls: ::std::os::raw::c_uint,
        IfSpec: RPC_IF_HANDLE,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseAllProtseqsIfEx(
        MaxCalls: ::std::os::raw::c_uint,
        IfSpec: RPC_IF_HANDLE,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqA(
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqExA(
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqW(
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqExW(
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqEpA(
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        Endpoint: RPC_CSTR,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqEpExA(
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        Endpoint: RPC_CSTR,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqEpW(
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        Endpoint: RPC_WSTR,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqEpExW(
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        Endpoint: RPC_WSTR,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqIfA(
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        IfSpec: RPC_IF_HANDLE,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqIfExA(
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        IfSpec: RPC_IF_HANDLE,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqIfW(
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        IfSpec: RPC_IF_HANDLE,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUseProtseqIfExW(
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        IfSpec: RPC_IF_HANDLE,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: PRPC_POLICY,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerYield();
}
extern "C" {
    pub fn RpcMgmtStatsVectorFree(StatsVector: *mut *mut RPC_STATS_VECTOR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtInqStats(
        Binding: RPC_BINDING_HANDLE,
        Statistics: *mut *mut RPC_STATS_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtIsServerListening(Binding: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtStopServerListening(Binding: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtWaitServerListen() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtSetServerStackSize(ThreadStackSize: ::std::os::raw::c_ulong) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSsDontSerializeContext();
}
extern "C" {
    pub fn RpcMgmtEnableIdleCleanup() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtInqIfIds(
        Binding: RPC_BINDING_HANDLE,
        IfIdVector: *mut *mut RPC_IF_ID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcIfIdVectorFree(IfIdVector: *mut *mut RPC_IF_ID_VECTOR) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtInqServerPrincNameA(
        Binding: RPC_BINDING_HANDLE,
        AuthnSvc: ::std::os::raw::c_ulong,
        ServerPrincName: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtInqServerPrincNameW(
        Binding: RPC_BINDING_HANDLE,
        AuthnSvc: ::std::os::raw::c_ulong,
        ServerPrincName: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqDefaultPrincNameA(
        AuthnSvc: ::std::os::raw::c_ulong,
        PrincName: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqDefaultPrincNameW(
        AuthnSvc: ::std::os::raw::c_ulong,
        PrincName: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcEpResolveBinding(Binding: RPC_BINDING_HANDLE, IfSpec: RPC_IF_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingInqEntryNameA(
        Binding: RPC_BINDING_HANDLE,
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingInqEntryNameW(
        Binding: RPC_BINDING_HANDLE,
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
pub type RPC_AUTH_IDENTITY_HANDLE = *mut ::std::os::raw::c_void;
pub type RPC_AUTHZ_HANDLE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_SECURITY_QOS {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
}
pub type RPC_SECURITY_QOS = _RPC_SECURITY_QOS;
pub type PRPC_SECURITY_QOS = *mut _RPC_SECURITY_QOS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_W {
    pub User: *mut ::std::os::raw::c_ushort,
    pub UserLength: ::std::os::raw::c_ulong,
    pub Domain: *mut ::std::os::raw::c_ushort,
    pub DomainLength: ::std::os::raw::c_ulong,
    pub Password: *mut ::std::os::raw::c_ushort,
    pub PasswordLength: ::std::os::raw::c_ulong,
    pub Flags: ::std::os::raw::c_ulong,
}
pub type SEC_WINNT_AUTH_IDENTITY_W = _SEC_WINNT_AUTH_IDENTITY_W;
pub type PSEC_WINNT_AUTH_IDENTITY_W = *mut _SEC_WINNT_AUTH_IDENTITY_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_A {
    pub User: *mut ::std::os::raw::c_uchar,
    pub UserLength: ::std::os::raw::c_ulong,
    pub Domain: *mut ::std::os::raw::c_uchar,
    pub DomainLength: ::std::os::raw::c_ulong,
    pub Password: *mut ::std::os::raw::c_uchar,
    pub PasswordLength: ::std::os::raw::c_ulong,
    pub Flags: ::std::os::raw::c_ulong,
}
pub type SEC_WINNT_AUTH_IDENTITY_A = _SEC_WINNT_AUTH_IDENTITY_A;
pub type PSEC_WINNT_AUTH_IDENTITY_A = *mut _SEC_WINNT_AUTH_IDENTITY_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W {
    pub TransportCredentials: *mut SEC_WINNT_AUTH_IDENTITY_W,
    pub Flags: ::std::os::raw::c_ulong,
    pub AuthenticationTarget: ::std::os::raw::c_ulong,
    pub NumberOfAuthnSchemes: ::std::os::raw::c_ulong,
    pub AuthnSchemes: *mut ::std::os::raw::c_ulong,
    pub ServerCertificateSubject: *mut ::std::os::raw::c_ushort,
}
pub type RPC_HTTP_TRANSPORT_CREDENTIALS_W = _RPC_HTTP_TRANSPORT_CREDENTIALS_W;
pub type PRPC_HTTP_TRANSPORT_CREDENTIALS_W = *mut _RPC_HTTP_TRANSPORT_CREDENTIALS_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A {
    pub TransportCredentials: *mut SEC_WINNT_AUTH_IDENTITY_A,
    pub Flags: ::std::os::raw::c_ulong,
    pub AuthenticationTarget: ::std::os::raw::c_ulong,
    pub NumberOfAuthnSchemes: ::std::os::raw::c_ulong,
    pub AuthnSchemes: *mut ::std::os::raw::c_ulong,
    pub ServerCertificateSubject: *mut ::std::os::raw::c_uchar,
}
pub type RPC_HTTP_TRANSPORT_CREDENTIALS_A = _RPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub type PRPC_HTTP_TRANSPORT_CREDENTIALS_A = *mut _RPC_HTTP_TRANSPORT_CREDENTIALS_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W {
    pub TransportCredentials: *mut SEC_WINNT_AUTH_IDENTITY_W,
    pub Flags: ::std::os::raw::c_ulong,
    pub AuthenticationTarget: ::std::os::raw::c_ulong,
    pub NumberOfAuthnSchemes: ::std::os::raw::c_ulong,
    pub AuthnSchemes: *mut ::std::os::raw::c_ulong,
    pub ServerCertificateSubject: *mut ::std::os::raw::c_ushort,
    pub ProxyCredentials: *mut SEC_WINNT_AUTH_IDENTITY_W,
    pub NumberOfProxyAuthnSchemes: ::std::os::raw::c_ulong,
    pub ProxyAuthnSchemes: *mut ::std::os::raw::c_ulong,
}
pub type RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W = _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
pub type PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W = *mut _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A {
    pub TransportCredentials: *mut SEC_WINNT_AUTH_IDENTITY_A,
    pub Flags: ::std::os::raw::c_ulong,
    pub AuthenticationTarget: ::std::os::raw::c_ulong,
    pub NumberOfAuthnSchemes: ::std::os::raw::c_ulong,
    pub AuthnSchemes: *mut ::std::os::raw::c_ulong,
    pub ServerCertificateSubject: *mut ::std::os::raw::c_uchar,
    pub ProxyCredentials: *mut SEC_WINNT_AUTH_IDENTITY_A,
    pub NumberOfProxyAuthnSchemes: ::std::os::raw::c_ulong,
    pub ProxyAuthnSchemes: *mut ::std::os::raw::c_ulong,
}
pub type RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A = _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub type PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A = *mut _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W {
    pub TransportCredentials: RPC_AUTH_IDENTITY_HANDLE,
    pub Flags: ::std::os::raw::c_ulong,
    pub AuthenticationTarget: ::std::os::raw::c_ulong,
    pub NumberOfAuthnSchemes: ::std::os::raw::c_ulong,
    pub AuthnSchemes: *mut ::std::os::raw::c_ulong,
    pub ServerCertificateSubject: *mut ::std::os::raw::c_ushort,
    pub ProxyCredentials: RPC_AUTH_IDENTITY_HANDLE,
    pub NumberOfProxyAuthnSchemes: ::std::os::raw::c_ulong,
    pub ProxyAuthnSchemes: *mut ::std::os::raw::c_ulong,
}
pub type RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W = _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
pub type PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W = *mut _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A {
    pub TransportCredentials: RPC_AUTH_IDENTITY_HANDLE,
    pub Flags: ::std::os::raw::c_ulong,
    pub AuthenticationTarget: ::std::os::raw::c_ulong,
    pub NumberOfAuthnSchemes: ::std::os::raw::c_ulong,
    pub AuthnSchemes: *mut ::std::os::raw::c_ulong,
    pub ServerCertificateSubject: *mut ::std::os::raw::c_uchar,
    pub ProxyCredentials: RPC_AUTH_IDENTITY_HANDLE,
    pub NumberOfProxyAuthnSchemes: ::std::os::raw::c_ulong,
    pub ProxyAuthnSchemes: *mut ::std::os::raw::c_ulong,
}
pub type RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A = _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub type PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A = *mut _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V2_W {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V2_W__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V2_W__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_W,
}
pub type RPC_SECURITY_QOS_V2_W = _RPC_SECURITY_QOS_V2_W;
pub type PRPC_SECURITY_QOS_V2_W = *mut _RPC_SECURITY_QOS_V2_W;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V2_A {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V2_A__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V2_A__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_A,
}
pub type RPC_SECURITY_QOS_V2_A = _RPC_SECURITY_QOS_V2_A;
pub type PRPC_SECURITY_QOS_V2_A = *mut _RPC_SECURITY_QOS_V2_A;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V3_W {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V3_W__bindgen_ty_1,
    pub Sid: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V3_W__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_W,
}
pub type RPC_SECURITY_QOS_V3_W = _RPC_SECURITY_QOS_V3_W;
pub type PRPC_SECURITY_QOS_V3_W = *mut _RPC_SECURITY_QOS_V3_W;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V3_A {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V3_A__bindgen_ty_1,
    pub Sid: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V3_A__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_A,
}
pub type RPC_SECURITY_QOS_V3_A = _RPC_SECURITY_QOS_V3_A;
pub type PRPC_SECURITY_QOS_V3_A = *mut _RPC_SECURITY_QOS_V3_A;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V4_W {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V4_W__bindgen_ty_1,
    pub Sid: *mut ::std::os::raw::c_void,
    pub EffectiveOnly: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V4_W__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_W,
}
pub type RPC_SECURITY_QOS_V4_W = _RPC_SECURITY_QOS_V4_W;
pub type PRPC_SECURITY_QOS_V4_W = *mut _RPC_SECURITY_QOS_V4_W;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V4_A {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V4_A__bindgen_ty_1,
    pub Sid: *mut ::std::os::raw::c_void,
    pub EffectiveOnly: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V4_A__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_A,
}
pub type RPC_SECURITY_QOS_V4_A = _RPC_SECURITY_QOS_V4_A;
pub type PRPC_SECURITY_QOS_V4_A = *mut _RPC_SECURITY_QOS_V4_A;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V5_W {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V5_W__bindgen_ty_1,
    pub Sid: *mut ::std::os::raw::c_void,
    pub EffectiveOnly: ::std::os::raw::c_uint,
    pub ServerSecurityDescriptor: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V5_W__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_W,
}
pub type RPC_SECURITY_QOS_V5_W = _RPC_SECURITY_QOS_V5_W;
pub type PRPC_SECURITY_QOS_V5_W = *mut _RPC_SECURITY_QOS_V5_W;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_SECURITY_QOS_V5_A {
    pub Version: ::std::os::raw::c_ulong,
    pub Capabilities: ::std::os::raw::c_ulong,
    pub IdentityTracking: ::std::os::raw::c_ulong,
    pub ImpersonationType: ::std::os::raw::c_ulong,
    pub AdditionalSecurityInfoType: ::std::os::raw::c_ulong,
    pub u: _RPC_SECURITY_QOS_V5_A__bindgen_ty_1,
    pub Sid: *mut ::std::os::raw::c_void,
    pub EffectiveOnly: ::std::os::raw::c_uint,
    pub ServerSecurityDescriptor: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_SECURITY_QOS_V5_A__bindgen_ty_1 {
    pub HttpCredentials: *mut RPC_HTTP_TRANSPORT_CREDENTIALS_A,
}
pub type RPC_SECURITY_QOS_V5_A = _RPC_SECURITY_QOS_V5_A;
pub type PRPC_SECURITY_QOS_V5_A = *mut _RPC_SECURITY_QOS_V5_A;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_BINDING_HANDLE_TEMPLATE_V1_W {
    pub Version: ::std::os::raw::c_ulong,
    pub Flags: ::std::os::raw::c_ulong,
    pub ProtocolSequence: ::std::os::raw::c_ulong,
    pub NetworkAddress: *mut ::std::os::raw::c_ushort,
    pub StringEndpoint: *mut ::std::os::raw::c_ushort,
    pub u1: _RPC_BINDING_HANDLE_TEMPLATE_V1_W__bindgen_ty_1,
    pub ObjectUuid: UUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_BINDING_HANDLE_TEMPLATE_V1_W__bindgen_ty_1 {
    pub Reserved: *mut ::std::os::raw::c_ushort,
}
pub type RPC_BINDING_HANDLE_TEMPLATE_V1_W = _RPC_BINDING_HANDLE_TEMPLATE_V1_W;
pub type PRPC_BINDING_HANDLE_TEMPLATE_V1_W = *mut _RPC_BINDING_HANDLE_TEMPLATE_V1_W;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_BINDING_HANDLE_TEMPLATE_V1_A {
    pub Version: ::std::os::raw::c_ulong,
    pub Flags: ::std::os::raw::c_ulong,
    pub ProtocolSequence: ::std::os::raw::c_ulong,
    pub NetworkAddress: *mut ::std::os::raw::c_uchar,
    pub StringEndpoint: *mut ::std::os::raw::c_uchar,
    pub u1: _RPC_BINDING_HANDLE_TEMPLATE_V1_A__bindgen_ty_1,
    pub ObjectUuid: UUID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_BINDING_HANDLE_TEMPLATE_V1_A__bindgen_ty_1 {
    pub Reserved: *mut ::std::os::raw::c_uchar,
}
pub type RPC_BINDING_HANDLE_TEMPLATE_V1_A = _RPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub type PRPC_BINDING_HANDLE_TEMPLATE_V1_A = *mut _RPC_BINDING_HANDLE_TEMPLATE_V1_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_BINDING_HANDLE_SECURITY_V1_W {
    pub Version: ::std::os::raw::c_ulong,
    pub ServerPrincName: *mut ::std::os::raw::c_ushort,
    pub AuthnLevel: ::std::os::raw::c_ulong,
    pub AuthnSvc: ::std::os::raw::c_ulong,
    pub AuthIdentity: *mut SEC_WINNT_AUTH_IDENTITY_W,
    pub SecurityQos: *mut RPC_SECURITY_QOS,
}
pub type RPC_BINDING_HANDLE_SECURITY_V1_W = _RPC_BINDING_HANDLE_SECURITY_V1_W;
pub type PRPC_BINDING_HANDLE_SECURITY_V1_W = *mut _RPC_BINDING_HANDLE_SECURITY_V1_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_BINDING_HANDLE_SECURITY_V1_A {
    pub Version: ::std::os::raw::c_ulong,
    pub ServerPrincName: *mut ::std::os::raw::c_uchar,
    pub AuthnLevel: ::std::os::raw::c_ulong,
    pub AuthnSvc: ::std::os::raw::c_ulong,
    pub AuthIdentity: *mut SEC_WINNT_AUTH_IDENTITY_A,
    pub SecurityQos: *mut RPC_SECURITY_QOS,
}
pub type RPC_BINDING_HANDLE_SECURITY_V1_A = _RPC_BINDING_HANDLE_SECURITY_V1_A;
pub type PRPC_BINDING_HANDLE_SECURITY_V1_A = *mut _RPC_BINDING_HANDLE_SECURITY_V1_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_BINDING_HANDLE_OPTIONS_V1 {
    pub Version: ::std::os::raw::c_ulong,
    pub Flags: ::std::os::raw::c_ulong,
    pub ComTimeout: ::std::os::raw::c_ulong,
    pub CallTimeout: ::std::os::raw::c_ulong,
}
pub type RPC_BINDING_HANDLE_OPTIONS_V1 = _RPC_BINDING_HANDLE_OPTIONS_V1;
pub type PRPC_BINDING_HANDLE_OPTIONS_V1 = *mut _RPC_BINDING_HANDLE_OPTIONS_V1;
extern "C" {
    pub fn RpcBindingCreateA(
        Template: *mut RPC_BINDING_HANDLE_TEMPLATE_V1_A,
        Security: *mut RPC_BINDING_HANDLE_SECURITY_V1_A,
        Options: *mut RPC_BINDING_HANDLE_OPTIONS_V1,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingCreateW(
        Template: *mut RPC_BINDING_HANDLE_TEMPLATE_V1_W,
        Security: *mut RPC_BINDING_HANDLE_SECURITY_V1_W,
        Options: *mut RPC_BINDING_HANDLE_OPTIONS_V1,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingGetTrainingContextHandle(
        Binding: RPC_BINDING_HANDLE,
        ContextHandle: *mut *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqBindingHandle(Binding: *mut RPC_BINDING_HANDLE) -> RPC_STATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RPC_HTTP_REDIRECTOR_STAGE {
    RPCHTTP_RS_REDIRECT = 1,
    RPCHTTP_RS_ACCESS_1 = 2,
    RPCHTTP_RS_SESSION = 3,
    RPCHTTP_RS_ACCESS_2 = 4,
    RPCHTTP_RS_INTERFACE = 5,
}
pub use self::_RPC_HTTP_REDIRECTOR_STAGE as RPC_HTTP_REDIRECTOR_STAGE;
pub type RPC_NEW_HTTP_PROXY_CHANNEL = ::std::option::Option<
    unsafe extern "C" fn(
        RedirectorStage: RPC_HTTP_REDIRECTOR_STAGE,
        ServerName: RPC_WSTR,
        ServerPort: RPC_WSTR,
        RemoteUser: RPC_WSTR,
        AuthType: RPC_WSTR,
        ResourceUuid: *mut ::std::os::raw::c_void,
        SessionId: *mut ::std::os::raw::c_void,
        Interface: *mut ::std::os::raw::c_void,
        Reserved: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_ulong,
        NewServerName: *mut RPC_WSTR,
        NewServerPort: *mut RPC_WSTR,
    ) -> RPC_STATUS,
>;
pub type RPC_HTTP_PROXY_FREE_STRING = ::std::option::Option<unsafe extern "C" fn(String: RPC_WSTR)>;
extern "C" {
    pub fn RpcImpersonateClient(BindingHandle: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcImpersonateClient2(BindingHandle: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcRevertToSelfEx(BindingHandle: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcRevertToSelf() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcImpersonateClientContainer(BindingHandle: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcRevertContainerImpersonation() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthClientA(
        ClientBinding: RPC_BINDING_HANDLE,
        Privs: *mut RPC_AUTHZ_HANDLE,
        ServerPrincName: *mut RPC_CSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthClientW(
        ClientBinding: RPC_BINDING_HANDLE,
        Privs: *mut RPC_AUTHZ_HANDLE,
        ServerPrincName: *mut RPC_WSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthClientExA(
        ClientBinding: RPC_BINDING_HANDLE,
        Privs: *mut RPC_AUTHZ_HANDLE,
        ServerPrincName: *mut RPC_CSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
        Flags: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthClientExW(
        ClientBinding: RPC_BINDING_HANDLE,
        Privs: *mut RPC_AUTHZ_HANDLE,
        ServerPrincName: *mut RPC_WSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
        Flags: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthInfoA(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: *mut RPC_CSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthIdentity: *mut RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthInfoW(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: *mut RPC_WSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthIdentity: *mut RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingSetAuthInfoA(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: RPC_CSTR,
        AuthnLevel: ::std::os::raw::c_ulong,
        AuthnSvc: ::std::os::raw::c_ulong,
        AuthIdentity: RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingSetAuthInfoExA(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: RPC_CSTR,
        AuthnLevel: ::std::os::raw::c_ulong,
        AuthnSvc: ::std::os::raw::c_ulong,
        AuthIdentity: RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: ::std::os::raw::c_ulong,
        SecurityQos: *mut RPC_SECURITY_QOS,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingSetAuthInfoW(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: RPC_WSTR,
        AuthnLevel: ::std::os::raw::c_ulong,
        AuthnSvc: ::std::os::raw::c_ulong,
        AuthIdentity: RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingSetAuthInfoExW(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: RPC_WSTR,
        AuthnLevel: ::std::os::raw::c_ulong,
        AuthnSvc: ::std::os::raw::c_ulong,
        AuthIdentity: RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: ::std::os::raw::c_ulong,
        SecurityQOS: *mut RPC_SECURITY_QOS,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthInfoExA(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: *mut RPC_CSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthIdentity: *mut RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
        RpcQosVersion: ::std::os::raw::c_ulong,
        SecurityQOS: *mut RPC_SECURITY_QOS,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingInqAuthInfoExW(
        Binding: RPC_BINDING_HANDLE,
        ServerPrincName: *mut RPC_WSTR,
        AuthnLevel: *mut ::std::os::raw::c_ulong,
        AuthnSvc: *mut ::std::os::raw::c_ulong,
        AuthIdentity: *mut RPC_AUTH_IDENTITY_HANDLE,
        AuthzSvc: *mut ::std::os::raw::c_ulong,
        RpcQosVersion: ::std::os::raw::c_ulong,
        SecurityQOS: *mut RPC_SECURITY_QOS,
    ) -> RPC_STATUS;
}
pub type RPC_AUTH_KEY_RETRIEVAL_FN = ::std::option::Option<
    unsafe extern "C" fn(
        Arg: *mut ::std::os::raw::c_void,
        ServerPrincName: RPC_WSTR,
        KeyVer: ::std::os::raw::c_ulong,
        Key: *mut *mut ::std::os::raw::c_void,
        Status: *mut RPC_STATUS,
    ),
>;
extern "C" {
    pub fn RpcServerCompleteSecurityCallback(
        BindingHandle: RPC_BINDING_HANDLE,
        Status: RPC_STATUS,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerRegisterAuthInfoA(
        ServerPrincName: RPC_CSTR,
        AuthnSvc: ::std::os::raw::c_ulong,
        GetKeyFn: RPC_AUTH_KEY_RETRIEVAL_FN,
        Arg: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerRegisterAuthInfoW(
        ServerPrincName: RPC_WSTR,
        AuthnSvc: ::std::os::raw::c_ulong,
        GetKeyFn: RPC_AUTH_KEY_RETRIEVAL_FN,
        Arg: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_CLIENT_INFORMATION1 {
    pub UserName: *mut ::std::os::raw::c_uchar,
    pub ComputerName: *mut ::std::os::raw::c_uchar,
    pub Privilege: ::std::os::raw::c_ushort,
    pub AuthFlags: ::std::os::raw::c_ulong,
}
pub type PRPC_CLIENT_INFORMATION1 = *mut RPC_CLIENT_INFORMATION1;
extern "C" {
    pub fn RpcBindingServerFromClient(
        ClientBinding: RPC_BINDING_HANDLE,
        ServerBinding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcRaiseException(exception: RPC_STATUS) -> !;
}
extern "C" {
    pub fn RpcTestCancel() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerTestCancel(BindingHandle: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcCancelThread(Thread: *mut ::std::os::raw::c_void) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcCancelThreadEx(
        Thread: *mut ::std::os::raw::c_void,
        Timeout: ::std::os::raw::c_long,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidCreate(Uuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidCreateSequential(Uuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidToStringA(Uuid: *const UUID, StringUuid: *mut RPC_CSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidFromStringA(StringUuid: RPC_CSTR, Uuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidToStringW(Uuid: *const UUID, StringUuid: *mut RPC_WSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidFromStringW(StringUuid: RPC_WSTR, Uuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidCompare(
        Uuid1: *mut UUID,
        Uuid2: *mut UUID,
        Status: *mut RPC_STATUS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UuidCreateNil(NilUuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn UuidEqual(
        Uuid1: *mut UUID,
        Uuid2: *mut UUID,
        Status: *mut RPC_STATUS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UuidHash(Uuid: *mut UUID, Status: *mut RPC_STATUS) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn UuidIsNil(Uuid: *mut UUID, Status: *mut RPC_STATUS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RpcEpRegisterNoReplaceA(
        IfSpec: RPC_IF_HANDLE,
        BindingVector: *mut RPC_BINDING_VECTOR,
        UuidVector: *mut UUID_VECTOR,
        Annotation: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcEpRegisterNoReplaceW(
        IfSpec: RPC_IF_HANDLE,
        BindingVector: *mut RPC_BINDING_VECTOR,
        UuidVector: *mut UUID_VECTOR,
        Annotation: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcEpRegisterA(
        IfSpec: RPC_IF_HANDLE,
        BindingVector: *mut RPC_BINDING_VECTOR,
        UuidVector: *mut UUID_VECTOR,
        Annotation: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcEpRegisterW(
        IfSpec: RPC_IF_HANDLE,
        BindingVector: *mut RPC_BINDING_VECTOR,
        UuidVector: *mut UUID_VECTOR,
        Annotation: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcEpUnregister(
        IfSpec: RPC_IF_HANDLE,
        BindingVector: *mut RPC_BINDING_VECTOR,
        UuidVector: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn DceErrorInqTextA(RpcStatus: RPC_STATUS, ErrorText: RPC_CSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn DceErrorInqTextW(RpcStatus: RPC_STATUS, ErrorText: RPC_WSTR) -> RPC_STATUS;
}
pub type RPC_EP_INQ_HANDLE = *mut I_RPC_HANDLE;
extern "C" {
    pub fn RpcMgmtEpEltInqBegin(
        EpBinding: RPC_BINDING_HANDLE,
        InquiryType: ::std::os::raw::c_ulong,
        IfId: *mut RPC_IF_ID,
        VersOption: ::std::os::raw::c_ulong,
        ObjectUuid: *mut UUID,
        InquiryContext: *mut RPC_EP_INQ_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtEpEltInqDone(InquiryContext: *mut RPC_EP_INQ_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtEpEltInqNextA(
        InquiryContext: RPC_EP_INQ_HANDLE,
        IfId: *mut RPC_IF_ID,
        Binding: *mut RPC_BINDING_HANDLE,
        ObjectUuid: *mut UUID,
        Annotation: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtEpEltInqNextW(
        InquiryContext: RPC_EP_INQ_HANDLE,
        IfId: *mut RPC_IF_ID,
        Binding: *mut RPC_BINDING_HANDLE,
        ObjectUuid: *mut UUID,
        Annotation: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcMgmtEpUnregister(
        EpBinding: RPC_BINDING_HANDLE,
        IfId: *mut RPC_IF_ID,
        Binding: RPC_BINDING_HANDLE,
        ObjectUuid: *mut UUID,
    ) -> RPC_STATUS;
}
pub type RPC_MGMT_AUTHORIZATION_FN = ::std::option::Option<
    unsafe extern "C" fn(
        ClientBinding: RPC_BINDING_HANDLE,
        RequestedMgmtOperation: ::std::os::raw::c_ulong,
        Status: *mut RPC_STATUS,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn RpcMgmtSetAuthorizationFn(AuthorizationFn: RPC_MGMT_AUTHORIZATION_FN) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcExceptionFilter(ExceptionCode: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
pub type RPC_INTERFACE_GROUP = *mut ::std::os::raw::c_void;
pub type PRPC_INTERFACE_GROUP = *mut *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_ENDPOINT_TEMPLATEW {
    pub Version: ::std::os::raw::c_ulong,
    pub ProtSeq: RPC_WSTR,
    pub Endpoint: RPC_WSTR,
    pub SecurityDescriptor: *mut ::std::os::raw::c_void,
    pub Backlog: ::std::os::raw::c_ulong,
}
pub type PRPC_ENDPOINT_TEMPLATEW = *mut RPC_ENDPOINT_TEMPLATEW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_ENDPOINT_TEMPLATEA {
    pub Version: ::std::os::raw::c_ulong,
    pub ProtSeq: RPC_CSTR,
    pub Endpoint: RPC_CSTR,
    pub SecurityDescriptor: *mut ::std::os::raw::c_void,
    pub Backlog: ::std::os::raw::c_ulong,
}
pub type PRPC_ENDPOINT_TEMPLATEA = *mut RPC_ENDPOINT_TEMPLATEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_INTERFACE_TEMPLATEA {
    pub Version: ::std::os::raw::c_ulong,
    pub IfSpec: RPC_IF_HANDLE,
    pub MgrTypeUuid: *mut UUID,
    pub MgrEpv: *mut ::std::os::raw::c_void,
    pub Flags: ::std::os::raw::c_uint,
    pub MaxCalls: ::std::os::raw::c_uint,
    pub MaxRpcSize: ::std::os::raw::c_uint,
    pub IfCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: RPC_IF_HANDLE, arg2: *mut ::std::os::raw::c_void) -> RPC_STATUS,
    >,
    pub UuidVector: *mut UUID_VECTOR,
    pub Annotation: RPC_CSTR,
    pub SecurityDescriptor: *mut ::std::os::raw::c_void,
}
pub type PRPC_INTERFACE_TEMPLATEA = *mut RPC_INTERFACE_TEMPLATEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_INTERFACE_TEMPLATEW {
    pub Version: ::std::os::raw::c_ulong,
    pub IfSpec: RPC_IF_HANDLE,
    pub MgrTypeUuid: *mut UUID,
    pub MgrEpv: *mut ::std::os::raw::c_void,
    pub Flags: ::std::os::raw::c_uint,
    pub MaxCalls: ::std::os::raw::c_uint,
    pub MaxRpcSize: ::std::os::raw::c_uint,
    pub IfCallback: ::std::option::Option<
        unsafe extern "C" fn(arg1: RPC_IF_HANDLE, arg2: *mut ::std::os::raw::c_void) -> RPC_STATUS,
    >,
    pub UuidVector: *mut UUID_VECTOR,
    pub Annotation: RPC_WSTR,
    pub SecurityDescriptor: *mut ::std::os::raw::c_void,
}
pub type PRPC_INTERFACE_TEMPLATEW = *mut RPC_INTERFACE_TEMPLATEW;
extern "C" {
    pub fn RpcServerInterfaceGroupCreateW(
        Interfaces: *mut RPC_INTERFACE_TEMPLATEW,
        NumIfs: ::std::os::raw::c_ulong,
        Endpoints: *mut RPC_ENDPOINT_TEMPLATEW,
        NumEndpoints: ::std::os::raw::c_ulong,
        IdlePeriod: ::std::os::raw::c_ulong,
        IdleCallbackFn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: RPC_INTERFACE_GROUP,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_ulong,
            ),
        >,
        IdleCallbackContext: *mut ::std::os::raw::c_void,
        IfGroup: PRPC_INTERFACE_GROUP,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInterfaceGroupCreateA(
        Interfaces: *mut RPC_INTERFACE_TEMPLATEA,
        NumIfs: ::std::os::raw::c_ulong,
        Endpoints: *mut RPC_ENDPOINT_TEMPLATEA,
        NumEndpoints: ::std::os::raw::c_ulong,
        IdlePeriod: ::std::os::raw::c_ulong,
        IdleCallbackFn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: RPC_INTERFACE_GROUP,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_ulong,
            ),
        >,
        IdleCallbackContext: *mut ::std::os::raw::c_void,
        IfGroup: PRPC_INTERFACE_GROUP,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInterfaceGroupClose(IfGroup: RPC_INTERFACE_GROUP) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInterfaceGroupActivate(IfGroup: RPC_INTERFACE_GROUP) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInterfaceGroupDeactivate(
        IfGroup: RPC_INTERFACE_GROUP,
        ForceDeactivation: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInterfaceGroupInqBindings(
        IfGroup: RPC_INTERFACE_GROUP,
        BindingVector: *mut *mut RPC_BINDING_VECTOR,
    ) -> RPC_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_VERSION {
    pub MajorVersion: ::std::os::raw::c_ushort,
    pub MinorVersion: ::std::os::raw::c_ushort,
}
pub type RPC_VERSION = _RPC_VERSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_SYNTAX_IDENTIFIER {
    pub SyntaxGUID: GUID,
    pub SyntaxVersion: RPC_VERSION,
}
pub type RPC_SYNTAX_IDENTIFIER = _RPC_SYNTAX_IDENTIFIER;
pub type PRPC_SYNTAX_IDENTIFIER = *mut _RPC_SYNTAX_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_MESSAGE {
    pub Handle: RPC_BINDING_HANDLE,
    pub DataRepresentation: ::std::os::raw::c_ulong,
    pub Buffer: *mut ::std::os::raw::c_void,
    pub BufferLength: ::std::os::raw::c_uint,
    pub ProcNum: ::std::os::raw::c_uint,
    pub TransferSyntax: PRPC_SYNTAX_IDENTIFIER,
    pub RpcInterfaceInformation: *mut ::std::os::raw::c_void,
    pub ReservedForRuntime: *mut ::std::os::raw::c_void,
    pub ManagerEpv: *mut ::std::os::raw::c_void,
    pub ImportContext: *mut ::std::os::raw::c_void,
    pub RpcFlags: ::std::os::raw::c_ulong,
}
pub type RPC_MESSAGE = _RPC_MESSAGE;
pub type PRPC_MESSAGE = *mut _RPC_MESSAGE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RPC_ADDRESS_CHANGE_TYPE {
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED = 2,
    PROTOCOL_ADDRESS_CHANGE = 3,
}
pub type RPC_DISPATCH_FUNCTION = ::std::option::Option<unsafe extern "C" fn(Message: PRPC_MESSAGE)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_DISPATCH_TABLE {
    pub DispatchTableCount: ::std::os::raw::c_uint,
    pub DispatchTable: *mut RPC_DISPATCH_FUNCTION,
    pub Reserved: LONG_PTR,
}
pub type PRPC_DISPATCH_TABLE = *mut RPC_DISPATCH_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_PROTSEQ_ENDPOINT {
    pub RpcProtocolSequence: *mut ::std::os::raw::c_uchar,
    pub Endpoint: *mut ::std::os::raw::c_uchar,
}
pub type RPC_PROTSEQ_ENDPOINT = _RPC_PROTSEQ_ENDPOINT;
pub type PRPC_PROTSEQ_ENDPOINT = *mut _RPC_PROTSEQ_ENDPOINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_SERVER_INTERFACE {
    pub Length: ::std::os::raw::c_uint,
    pub InterfaceId: RPC_SYNTAX_IDENTIFIER,
    pub TransferSyntax: RPC_SYNTAX_IDENTIFIER,
    pub DispatchTable: PRPC_DISPATCH_TABLE,
    pub RpcProtseqEndpointCount: ::std::os::raw::c_uint,
    pub RpcProtseqEndpoint: PRPC_PROTSEQ_ENDPOINT,
    pub DefaultManagerEpv: *mut ::std::os::raw::c_void,
    pub InterpreterInfo: *const ::std::os::raw::c_void,
    pub Flags: ::std::os::raw::c_uint,
}
pub type RPC_SERVER_INTERFACE = _RPC_SERVER_INTERFACE;
pub type PRPC_SERVER_INTERFACE = *mut _RPC_SERVER_INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_CLIENT_INTERFACE {
    pub Length: ::std::os::raw::c_uint,
    pub InterfaceId: RPC_SYNTAX_IDENTIFIER,
    pub TransferSyntax: RPC_SYNTAX_IDENTIFIER,
    pub DispatchTable: PRPC_DISPATCH_TABLE,
    pub RpcProtseqEndpointCount: ::std::os::raw::c_uint,
    pub RpcProtseqEndpoint: PRPC_PROTSEQ_ENDPOINT,
    pub Reserved: ULONG_PTR,
    pub InterpreterInfo: *const ::std::os::raw::c_void,
    pub Flags: ::std::os::raw::c_uint,
}
pub type RPC_CLIENT_INTERFACE = _RPC_CLIENT_INTERFACE;
pub type PRPC_CLIENT_INTERFACE = *mut _RPC_CLIENT_INTERFACE;
extern "C" {
    pub fn I_RpcNegotiateTransferSyntax(Message: *mut RPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcGetBuffer(Message: *mut RPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcGetBufferWithObject(Message: *mut RPC_MESSAGE, ObjectUuid: *mut UUID)
        -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcSendReceive(Message: *mut RPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcFreeBuffer(Message: *mut RPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcSend(Message: PRPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcReceive(Message: PRPC_MESSAGE, Size: ::std::os::raw::c_uint) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcFreePipeBuffer(Message: *mut RPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcReallocPipeBuffer(
        Message: PRPC_MESSAGE,
        NewSize: ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
pub type I_RPC_MUTEX = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn I_RpcRequestMutex(Mutex: *mut I_RPC_MUTEX);
}
extern "C" {
    pub fn I_RpcClearMutex(Mutex: I_RPC_MUTEX);
}
extern "C" {
    pub fn I_RpcDeleteMutex(Mutex: I_RPC_MUTEX);
}
extern "C" {
    pub fn I_RpcAllocate(Size: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn I_RpcFree(Object: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn I_RpcFreeSystemHandleCollection(
        CallObj: *mut ::std::os::raw::c_void,
        FreeFlags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn I_RpcSetSystemHandle(
        Handle: *mut ::std::os::raw::c_void,
        Type: ::std::os::raw::c_uchar,
        AccessMask: ::std::os::raw::c_ulong,
        CallObj: *mut ::std::os::raw::c_void,
        HandleIndex: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcGetSystemHandle(
        pMemory: *mut ::std::os::raw::c_uchar,
        Type: ::std::os::raw::c_uchar,
        AccessMask: ::std::os::raw::c_ulong,
        HandleIndex: ::std::os::raw::c_ulong,
        CallObj: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcFreeSystemHandle(
        Type: ::std::os::raw::c_uchar,
        Handle: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn I_RpcPauseExecution(Milliseconds: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn I_RpcGetExtendedError() -> RPC_STATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION {
    MarshalDirectionMarshal = 0,
    MarshalDirectionUnmarshal = 1,
}
pub use self::_LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION as LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION;
extern "C" {
    pub fn I_RpcSystemHandleTypeSpecificWork(
        Handle: *mut ::std::os::raw::c_void,
        ActualType: ::std::os::raw::c_uchar,
        IdlType: ::std::os::raw::c_uchar,
        MarshalDirection: LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION,
    ) -> RPC_STATUS;
}
pub type PRPC_RUNDOWN =
    ::std::option::Option<unsafe extern "C" fn(AssociationContext: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn I_RpcMonitorAssociation(
        Handle: RPC_BINDING_HANDLE,
        RundownRoutine: PRPC_RUNDOWN,
        Context: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcStopMonitorAssociation(Handle: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcGetCurrentCallHandle() -> RPC_BINDING_HANDLE;
}
extern "C" {
    pub fn I_RpcGetAssociationContext(
        BindingHandle: RPC_BINDING_HANDLE,
        AssociationContext: *mut *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcGetServerContextList(
        BindingHandle: RPC_BINDING_HANDLE,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn I_RpcSetServerContextList(
        BindingHandle: RPC_BINDING_HANDLE,
        ServerContextList: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn I_RpcNsInterfaceExported(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: *mut ::std::os::raw::c_ushort,
        RpcInterfaceInformation: *mut RPC_SERVER_INTERFACE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcNsInterfaceUnexported(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: *mut ::std::os::raw::c_ushort,
        RpcInterfaceInformation: *mut RPC_SERVER_INTERFACE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingToStaticStringBindingW(
        Binding: RPC_BINDING_HANDLE,
        StringBinding: *mut *mut ::std::os::raw::c_ushort,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqSecurityContext(
        Binding: RPC_BINDING_HANDLE,
        SecurityContextHandle: *mut *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_SEC_CONTEXT_KEY_INFO {
    pub EncryptAlgorithm: ::std::os::raw::c_ulong,
    pub KeySize: ::std::os::raw::c_ulong,
    pub SignatureAlgorithm: ::std::os::raw::c_ulong,
}
pub type RPC_SEC_CONTEXT_KEY_INFO = _RPC_SEC_CONTEXT_KEY_INFO;
pub type PRPC_SEC_CONTEXT_KEY_INFO = *mut _RPC_SEC_CONTEXT_KEY_INFO;
extern "C" {
    pub fn I_RpcBindingInqSecurityContextKeyInfo(
        Binding: RPC_BINDING_HANDLE,
        KeyInfo: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqWireIdForSnego(
        Binding: RPC_BINDING_HANDLE,
        WireId: *mut ::std::os::raw::c_uchar,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqMarshalledTargetInfo(
        Binding: RPC_BINDING_HANDLE,
        MarshalledTargetInfoSize: *mut ::std::os::raw::c_ulong,
        MarshalledTargetInfo: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqLocalClientPID(
        Binding: RPC_BINDING_HANDLE,
        Pid: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingHandleToAsyncHandle(
        Binding: RPC_BINDING_HANDLE,
        AsyncHandle: *mut *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcNsBindingSetEntryNameW(
        Binding: RPC_BINDING_HANDLE,
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcNsBindingSetEntryNameA(
        Binding: RPC_BINDING_HANDLE,
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerUseProtseqEp2A(
        NetworkAddress: RPC_CSTR,
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        Endpoint: RPC_CSTR,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerUseProtseqEp2W(
        NetworkAddress: RPC_WSTR,
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        Endpoint: RPC_WSTR,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerUseProtseq2W(
        NetworkAddress: RPC_WSTR,
        Protseq: RPC_WSTR,
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerUseProtseq2A(
        NetworkAddress: RPC_CSTR,
        Protseq: RPC_CSTR,
        MaxCalls: ::std::os::raw::c_uint,
        SecurityDescriptor: *mut ::std::os::raw::c_void,
        Policy: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerStartService(
        Protseq: RPC_WSTR,
        Endpoint: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqDynamicEndpointW(
        Binding: RPC_BINDING_HANDLE,
        DynamicEndpoint: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqDynamicEndpointA(
        Binding: RPC_BINDING_HANDLE,
        DynamicEndpoint: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerCheckClientRestriction(Context: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqTransportType(
        Binding: RPC_BINDING_HANDLE,
        Type: *mut ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_TRANSFER_SYNTAX {
    pub Uuid: UUID,
    pub VersMajor: ::std::os::raw::c_ushort,
    pub VersMinor: ::std::os::raw::c_ushort,
}
pub type RPC_TRANSFER_SYNTAX = _RPC_TRANSFER_SYNTAX;
extern "C" {
    pub fn I_RpcIfInqTransferSyntaxes(
        RpcIfHandle: RPC_IF_HANDLE,
        TransferSyntaxes: *mut RPC_TRANSFER_SYNTAX,
        TransferSyntaxSize: ::std::os::raw::c_uint,
        TransferSyntaxCount: *mut ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_UuidCreate(Uuid: *mut UUID) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcUninitializeNdrOle();
}
extern "C" {
    pub fn I_RpcBindingCopy(
        SourceBinding: RPC_BINDING_HANDLE,
        DestinationBinding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingIsClientLocal(
        BindingHandle: RPC_BINDING_HANDLE,
        ClientLocalFlag: *mut ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingInqConnId(
        Binding: RPC_BINDING_HANDLE,
        ConnId: *mut *mut ::std::os::raw::c_void,
        pfFirstCall: *mut ::std::os::raw::c_int,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingCreateNP(
        ServerName: RPC_WSTR,
        ServiceName: RPC_WSTR,
        NetworkOptions: RPC_WSTR,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcSsDontSerializeContext();
}
extern "C" {
    pub fn I_RpcLaunchDatagramReceiveThread(pAddress: *mut ::std::os::raw::c_void) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerRegisterForwardFunction(
        pForwardFunction: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut UUID,
                arg2: *mut RPC_VERSION,
                arg3: *mut UUID,
                arg4: *mut ::std::os::raw::c_uchar,
                arg5: *mut *mut ::std::os::raw::c_void,
            ) -> RPC_STATUS,
        >,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerInqAddressChangeFn(
    ) -> ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub fn I_RpcServerSetAddressChangeFn(
        pAddressChangeFn: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerInqLocalConnAddress(
        Binding: RPC_BINDING_HANDLE,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSize: *mut ::std::os::raw::c_ulong,
        AddressFormat: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerInqRemoteConnAddress(
        Binding: RPC_BINDING_HANDLE,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSize: *mut ::std::os::raw::c_ulong,
        AddressFormat: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcSessionStrictContextHandle();
}
extern "C" {
    pub fn I_RpcTurnOnEEInfoPropagation() -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcConnectionInqSockBuffSize(
        RecvBuffSize: *mut ::std::os::raw::c_ulong,
        SendBuffSize: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcConnectionSetSockBuffSize(
        RecvBuffSize: ::std::os::raw::c_ulong,
        SendBuffSize: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
pub type RPCLT_PDU_FILTER_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        Buffer: *mut ::std::os::raw::c_void,
        BufferLength: ::std::os::raw::c_uint,
        fDatagram: ::std::os::raw::c_int,
    ),
>;
pub type RPC_SETFILTER_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pfnFilter: RPCLT_PDU_FILTER_FUNC)>;
extern "C" {
    pub fn I_RpcServerStartListening(hWnd: *mut ::std::os::raw::c_void) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerStopListening() -> RPC_STATUS;
}
pub type RPC_BLOCKING_FN = ::std::option::Option<
    unsafe extern "C" fn(
        hWnd: *mut ::std::os::raw::c_void,
        Context: *mut ::std::os::raw::c_void,
        hSyncEvent: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS,
>;
extern "C" {
    pub fn I_RpcBindingSetAsync(
        Binding: RPC_BINDING_HANDLE,
        BlockingFn: RPC_BLOCKING_FN,
        ServerTid: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcSetThreadParams(
        fClientFree: ::std::os::raw::c_int,
        Context: *mut ::std::os::raw::c_void,
        hWndClient: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcWindowProc(
        hWnd: *mut ::std::os::raw::c_void,
        Message: ::std::os::raw::c_uint,
        wParam: ::std::os::raw::c_uint,
        lParam: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn I_RpcServerUnregisterEndpointA(Protseq: RPC_CSTR, Endpoint: RPC_CSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerUnregisterEndpointW(Protseq: RPC_WSTR, Endpoint: RPC_WSTR) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerInqTransportType(Type: *mut ::std::os::raw::c_uint) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcMapWin32Status(Status: RPC_STATUS) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR {
    pub BufferSize: ::std::os::raw::c_ulong,
    pub Buffer: *mut ::std::os::raw::c_char,
}
pub type RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR = _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RDR_CALLOUT_STATE {
    pub LastError: RPC_STATUS,
    pub LastEEInfo: *mut ::std::os::raw::c_void,
    pub LastCalledStage: RPC_HTTP_REDIRECTOR_STAGE,
    pub ServerName: *mut ::std::os::raw::c_ushort,
    pub ServerPort: *mut ::std::os::raw::c_ushort,
    pub RemoteUser: *mut ::std::os::raw::c_ushort,
    pub AuthType: *mut ::std::os::raw::c_ushort,
    pub ResourceTypePresent: ::std::os::raw::c_uchar,
    pub SessionIdPresent: ::std::os::raw::c_uchar,
    pub InterfacePresent: ::std::os::raw::c_uchar,
    pub ResourceType: UUID,
    pub SessionId: UUID,
    pub Interface: RPC_SYNTAX_IDENTIFIER,
    pub CertContext: *mut ::std::os::raw::c_void,
}
pub type RDR_CALLOUT_STATE = _RDR_CALLOUT_STATE;
pub type I_RpcProxyIsValidMachineFn = ::std::option::Option<
    unsafe extern "C" fn(
        Machine: RPC_WSTR,
        DotMachine: RPC_WSTR,
        PortNumber: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS,
>;
pub type I_RpcProxyGetClientAddressFn = ::std::option::Option<
    unsafe extern "C" fn(
        Context: *mut ::std::os::raw::c_void,
        Buffer: *mut ::std::os::raw::c_char,
        BufferLength: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS,
>;
pub type I_RpcProxyGetConnectionTimeoutFn = ::std::option::Option<
    unsafe extern "C" fn(ConnectionTimeout: *mut ::std::os::raw::c_ulong) -> RPC_STATUS,
>;
pub type I_RpcPerformCalloutFn = ::std::option::Option<
    unsafe extern "C" fn(
        Context: *mut ::std::os::raw::c_void,
        CallOutState: *mut RDR_CALLOUT_STATE,
        Stage: RPC_HTTP_REDIRECTOR_STAGE,
    ) -> RPC_STATUS,
>;
pub type I_RpcFreeCalloutStateFn =
    ::std::option::Option<unsafe extern "C" fn(CallOutState: *mut RDR_CALLOUT_STATE)>;
pub type I_RpcProxyGetClientSessionAndResourceUUID = ::std::option::Option<
    unsafe extern "C" fn(
        Context: *mut ::std::os::raw::c_void,
        SessionIdPresent: *mut ::std::os::raw::c_int,
        SessionId: *mut UUID,
        ResourceIdPresent: *mut ::std::os::raw::c_int,
        ResourceId: *mut UUID,
    ) -> RPC_STATUS,
>;
pub type I_RpcProxyFilterIfFn = ::std::option::Option<
    unsafe extern "C" fn(
        Context: *mut ::std::os::raw::c_void,
        IfUuid: *mut UUID,
        IfMajorVersion: ::std::os::raw::c_ushort,
        fAllow: *mut ::std::os::raw::c_int,
    ) -> RPC_STATUS,
>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RpcProxyPerfCounters {
    RpcCurrentUniqueUser = 1,
    RpcBackEndConnectionAttempts = 2,
    RpcBackEndConnectionFailed = 3,
    RpcRequestsPerSecond = 4,
    RpcIncomingConnections = 5,
    RpcIncomingBandwidth = 6,
    RpcOutgoingBandwidth = 7,
    RpcAttemptedLbsDecisions = 8,
    RpcFailedLbsDecisions = 9,
    RpcAttemptedLbsMessages = 10,
    RpcFailedLbsMessages = 11,
    RpcLastCounter = 12,
}
pub use self::RpcProxyPerfCounters as RpcPerfCounters;
pub type I_RpcProxyUpdatePerfCounterFn = ::std::option::Option<
    unsafe extern "C" fn(
        Counter: RpcPerfCounters,
        ModifyTrend: ::std::os::raw::c_int,
        Size: ::std::os::raw::c_ulong,
    ),
>;
pub type I_RpcProxyUpdatePerfCounterBackendServerFn = ::std::option::Option<
    unsafe extern "C" fn(
        MachineName: *mut ::std::os::raw::c_ushort,
        IsConnectEvent: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagI_RpcProxyCallbackInterface {
    pub IsValidMachineFn: I_RpcProxyIsValidMachineFn,
    pub GetClientAddressFn: I_RpcProxyGetClientAddressFn,
    pub GetConnectionTimeoutFn: I_RpcProxyGetConnectionTimeoutFn,
    pub PerformCalloutFn: I_RpcPerformCalloutFn,
    pub FreeCalloutStateFn: I_RpcFreeCalloutStateFn,
    pub GetClientSessionAndResourceUUIDFn: I_RpcProxyGetClientSessionAndResourceUUID,
    pub ProxyFilterIfFn: I_RpcProxyFilterIfFn,
    pub RpcProxyUpdatePerfCounterFn: I_RpcProxyUpdatePerfCounterFn,
    pub RpcProxyUpdatePerfCounterBackendServerFn: I_RpcProxyUpdatePerfCounterBackendServerFn,
}
pub type I_RpcProxyCallbackInterface = tagI_RpcProxyCallbackInterface;
extern "C" {
    pub fn I_RpcProxyNewConnection(
        ConnectionType: ::std::os::raw::c_ulong,
        ServerAddress: *mut ::std::os::raw::c_ushort,
        ServerPort: *mut ::std::os::raw::c_ushort,
        MinConnTimeout: *mut ::std::os::raw::c_ushort,
        ConnectionParameter: *mut ::std::os::raw::c_void,
        CallOutState: *mut RDR_CALLOUT_STATE,
        ProxyCallbackInterface: *mut I_RpcProxyCallbackInterface,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcReplyToClientWithStatus(
        ConnectionParameter: *mut ::std::os::raw::c_void,
        RpcStatus: RPC_STATUS,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcRecordCalloutFailure(
        RpcStatus: RPC_STATUS,
        CallOutState: *mut RDR_CALLOUT_STATE,
        DllName: *mut ::std::os::raw::c_ushort,
    );
}
extern "C" {
    pub fn I_RpcMgmtEnableDedicatedThreadPool() -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcGetDefaultSD(ppSecurityDescriptor: *mut *mut ::std::os::raw::c_void) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcOpenClientProcess(
        Binding: RPC_BINDING_HANDLE,
        DesiredAccess: ::std::os::raw::c_ulong,
        ClientProcess: *mut *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingIsServerLocal(
        Binding: RPC_BINDING_HANDLE,
        ServerLocalFlag: *mut ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcBindingSetPrivateOption(
        hBinding: RPC_BINDING_HANDLE,
        option: ::std::os::raw::c_ulong,
        optionValue: ULONG_PTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerSubscribeForDisconnectNotification(
        Binding: RPC_BINDING_HANDLE,
        hEvent: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerGetAssociationID(
        Binding: RPC_BINDING_HANDLE,
        AssociationID: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerDisableExceptionFilter() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn I_RpcServerSubscribeForDisconnectNotification2(
        Binding: RPC_BINDING_HANDLE,
        hEvent: *mut ::std::os::raw::c_void,
        SubscriptionId: *mut UUID,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcServerUnsubscribeForDisconnectNotification(
        Binding: RPC_BINDING_HANDLE,
        SubscriptionId: UUID,
    ) -> RPC_STATUS;
}
pub type RPC_NS_HANDLE = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn RpcNsBindingExportA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfSpec: RPC_IF_HANDLE,
        BindingVec: *mut RPC_BINDING_VECTOR,
        ObjectUuidVec: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingUnexportA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjectUuidVec: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingExportW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
        BindingVec: *mut RPC_BINDING_VECTOR,
        ObjectUuidVec: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingUnexportW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjectUuidVec: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingExportPnPA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjectVector: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingUnexportPnPA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjectVector: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingExportPnPW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjectVector: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingUnexportPnPW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjectVector: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingLookupBeginA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjUuid: *mut UUID,
        BindingMaxCount: ::std::os::raw::c_ulong,
        LookupContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingLookupBeginW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjUuid: *mut UUID,
        BindingMaxCount: ::std::os::raw::c_ulong,
        LookupContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingLookupNext(
        LookupContext: RPC_NS_HANDLE,
        BindingVec: *mut *mut RPC_BINDING_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingLookupDone(LookupContext: *mut RPC_NS_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupDeleteA(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrAddA(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_CSTR,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrRemoveA(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_CSTR,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrInqBeginA(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_CSTR,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        InquiryContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrInqNextA(
        InquiryContext: RPC_NS_HANDLE,
        MemberName: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupDeleteW(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrAddW(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_WSTR,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrRemoveW(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_WSTR,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrInqBeginW(
        GroupNameSyntax: ::std::os::raw::c_ulong,
        GroupName: RPC_WSTR,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        InquiryContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrInqNextW(
        InquiryContext: RPC_NS_HANDLE,
        MemberName: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsGroupMbrInqDone(InquiryContext: *mut RPC_NS_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileDeleteA(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltAddA(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_CSTR,
        IfId: *mut RPC_IF_ID,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_CSTR,
        Priority: ::std::os::raw::c_ulong,
        Annotation: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltRemoveA(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_CSTR,
        IfId: *mut RPC_IF_ID,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltInqBeginA(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_CSTR,
        InquiryType: ::std::os::raw::c_ulong,
        IfId: *mut RPC_IF_ID,
        VersOption: ::std::os::raw::c_ulong,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_CSTR,
        InquiryContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltInqNextA(
        InquiryContext: RPC_NS_HANDLE,
        IfId: *mut RPC_IF_ID,
        MemberName: *mut RPC_CSTR,
        Priority: *mut ::std::os::raw::c_ulong,
        Annotation: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileDeleteW(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltAddW(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_WSTR,
        IfId: *mut RPC_IF_ID,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_WSTR,
        Priority: ::std::os::raw::c_ulong,
        Annotation: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltRemoveW(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_WSTR,
        IfId: *mut RPC_IF_ID,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltInqBeginW(
        ProfileNameSyntax: ::std::os::raw::c_ulong,
        ProfileName: RPC_WSTR,
        InquiryType: ::std::os::raw::c_ulong,
        IfId: *mut RPC_IF_ID,
        VersOption: ::std::os::raw::c_ulong,
        MemberNameSyntax: ::std::os::raw::c_ulong,
        MemberName: RPC_WSTR,
        InquiryContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltInqNextW(
        InquiryContext: RPC_NS_HANDLE,
        IfId: *mut RPC_IF_ID,
        MemberName: *mut RPC_WSTR,
        Priority: *mut ::std::os::raw::c_ulong,
        Annotation: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsProfileEltInqDone(InquiryContext: *mut RPC_NS_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsEntryObjectInqBeginA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        InquiryContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsEntryObjectInqBeginW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        InquiryContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsEntryObjectInqNext(InquiryContext: RPC_NS_HANDLE, ObjUuid: *mut UUID)
        -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsEntryObjectInqDone(InquiryContext: *mut RPC_NS_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsEntryExpandNameA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        ExpandedName: *mut RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtBindingUnexportA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfId: *mut RPC_IF_ID,
        VersOption: ::std::os::raw::c_ulong,
        ObjectUuidVec: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtEntryCreateA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtEntryDeleteA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtEntryInqIfIdsA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfIdVec: *mut *mut RPC_IF_ID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtHandleSetExpAge(
        NsHandle: RPC_NS_HANDLE,
        ExpirationAge: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtInqExpAge(ExpirationAge: *mut ::std::os::raw::c_ulong) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtSetExpAge(ExpirationAge: ::std::os::raw::c_ulong) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsEntryExpandNameW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        ExpandedName: *mut RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtBindingUnexportW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfId: *mut RPC_IF_ID,
        VersOption: ::std::os::raw::c_ulong,
        ObjectUuidVec: *mut UUID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtEntryCreateW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtEntryDeleteW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsMgmtEntryInqIfIdsW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfIdVec: *mut *mut RPC_IF_ID_VECTOR,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingImportBeginA(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_CSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjUuid: *mut UUID,
        ImportContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingImportBeginW(
        EntryNameSyntax: ::std::os::raw::c_ulong,
        EntryName: RPC_WSTR,
        IfSpec: RPC_IF_HANDLE,
        ObjUuid: *mut UUID,
        ImportContext: *mut RPC_NS_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingImportNext(
        ImportContext: RPC_NS_HANDLE,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingImportDone(ImportContext: *mut RPC_NS_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcNsBindingSelect(
        BindingVec: *mut RPC_BINDING_VECTOR,
        Binding: *mut RPC_BINDING_HANDLE,
    ) -> RPC_STATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RPC_NOTIFICATION_TYPES {
    RpcNotificationTypeNone = 0,
    RpcNotificationTypeEvent = 1,
    RpcNotificationTypeApc = 2,
    RpcNotificationTypeIoc = 3,
    RpcNotificationTypeHwnd = 4,
    RpcNotificationTypeCallback = 5,
}
pub use self::_RPC_NOTIFICATION_TYPES as RPC_NOTIFICATION_TYPES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RPC_ASYNC_EVENT {
    RpcCallComplete = 0,
    RpcSendComplete = 1,
    RpcReceiveComplete = 2,
    RpcClientDisconnect = 3,
    RpcClientCancel = 4,
}
pub use self::_RPC_ASYNC_EVENT as RPC_ASYNC_EVENT;
pub type PFN_RPCNOTIFICATION_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _RPC_ASYNC_STATE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: RPC_ASYNC_EVENT,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_ASYNC_NOTIFICATION_INFO {
    pub APC: _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_1,
    pub IOC: _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_2,
    pub HWND: _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_3,
    pub hEvent: HANDLE,
    pub NotificationRoutine: PFN_RPCNOTIFICATION_ROUTINE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_1 {
    pub NotificationRoutine: PFN_RPCNOTIFICATION_ROUTINE,
    pub hThread: HANDLE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_2 {
    pub hIOPort: HANDLE,
    pub dwNumberOfBytesTransferred: DWORD,
    pub dwCompletionKey: DWORD_PTR,
    pub lpOverlapped: LPOVERLAPPED,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_3 {
    pub hWnd: HWND,
    pub Msg: UINT,
}
pub type RPC_ASYNC_NOTIFICATION_INFO = _RPC_ASYNC_NOTIFICATION_INFO;
pub type PRPC_ASYNC_NOTIFICATION_INFO = *mut _RPC_ASYNC_NOTIFICATION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_ASYNC_STATE {
    pub Size: ::std::os::raw::c_uint,
    pub Signature: ::std::os::raw::c_ulong,
    pub Lock: ::std::os::raw::c_long,
    pub Flags: ::std::os::raw::c_ulong,
    pub StubInfo: *mut ::std::os::raw::c_void,
    pub UserInfo: *mut ::std::os::raw::c_void,
    pub RuntimeInfo: *mut ::std::os::raw::c_void,
    pub Event: RPC_ASYNC_EVENT,
    pub NotificationType: RPC_NOTIFICATION_TYPES,
    pub u: RPC_ASYNC_NOTIFICATION_INFO,
    pub Reserved: [LONG_PTR; 4usize],
}
pub type RPC_ASYNC_STATE = _RPC_ASYNC_STATE;
pub type PRPC_ASYNC_STATE = *mut _RPC_ASYNC_STATE;
extern "C" {
    pub fn RpcAsyncRegisterInfo(pAsync: PRPC_ASYNC_STATE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcAsyncInitializeHandle(
        pAsync: PRPC_ASYNC_STATE,
        Size: ::std::os::raw::c_uint,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcAsyncGetCallStatus(pAsync: PRPC_ASYNC_STATE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcAsyncCompleteCall(
        pAsync: PRPC_ASYNC_STATE,
        Reply: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcAsyncAbortCall(
        pAsync: PRPC_ASYNC_STATE,
        ExceptionCode: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcAsyncCancelCall(pAsync: PRPC_ASYNC_STATE, fAbort: BOOL) -> RPC_STATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagExtendedErrorParamTypes {
    eeptAnsiString = 1,
    eeptUnicodeString = 2,
    eeptLongVal = 3,
    eeptShortVal = 4,
    eeptPointerVal = 5,
    eeptNone = 6,
    eeptBinary = 7,
}
pub use self::tagExtendedErrorParamTypes as ExtendedErrorParamTypes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBinaryParam {
    pub Buffer: *mut ::std::os::raw::c_void,
    pub Size: ::std::os::raw::c_short,
}
pub type BinaryParam = tagBinaryParam;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRPC_EE_INFO_PARAM {
    pub ParameterType: ExtendedErrorParamTypes,
    pub u: tagRPC_EE_INFO_PARAM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRPC_EE_INFO_PARAM__bindgen_ty_1 {
    pub AnsiString: LPSTR,
    pub UnicodeString: LPWSTR,
    pub LVal: ::std::os::raw::c_long,
    pub SVal: ::std::os::raw::c_short,
    pub PVal: ULONGLONG,
    pub BVal: BinaryParam,
}
pub type RPC_EE_INFO_PARAM = tagRPC_EE_INFO_PARAM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagRPC_EXTENDED_ERROR_INFO {
    pub Version: ULONG,
    pub ComputerName: LPWSTR,
    pub ProcessID: ULONG,
    pub u: tagRPC_EXTENDED_ERROR_INFO__bindgen_ty_1,
    pub GeneratingComponent: ULONG,
    pub Status: ULONG,
    pub DetectionLocation: USHORT,
    pub Flags: USHORT,
    pub NumberOfParameters: ::std::os::raw::c_int,
    pub Parameters: [RPC_EE_INFO_PARAM; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagRPC_EXTENDED_ERROR_INFO__bindgen_ty_1 {
    pub SystemTime: SYSTEMTIME,
    pub FileTime: FILETIME,
}
pub type RPC_EXTENDED_ERROR_INFO = tagRPC_EXTENDED_ERROR_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_ERROR_ENUM_HANDLE {
    pub Signature: ULONG,
    pub CurrentPos: *mut ::std::os::raw::c_void,
    pub Head: *mut ::std::os::raw::c_void,
}
pub type RPC_ERROR_ENUM_HANDLE = tagRPC_ERROR_ENUM_HANDLE;
extern "C" {
    pub fn RpcErrorStartEnumeration(EnumHandle: *mut RPC_ERROR_ENUM_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorGetNextRecord(
        EnumHandle: *mut RPC_ERROR_ENUM_HANDLE,
        CopyStrings: BOOL,
        ErrorInfo: *mut RPC_EXTENDED_ERROR_INFO,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorEndEnumeration(EnumHandle: *mut RPC_ERROR_ENUM_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorResetEnumeration(EnumHandle: *mut RPC_ERROR_ENUM_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorGetNumberOfRecords(
        EnumHandle: *mut RPC_ERROR_ENUM_HANDLE,
        Records: *mut ::std::os::raw::c_int,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorSaveErrorInfo(
        EnumHandle: *mut RPC_ERROR_ENUM_HANDLE,
        ErrorBlob: *mut PVOID,
        BlobSize: *mut usize,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorLoadErrorInfo(
        ErrorBlob: PVOID,
        BlobSize: usize,
        EnumHandle: *mut RPC_ERROR_ENUM_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorAddRecord(ErrorInfo: *mut RPC_EXTENDED_ERROR_INFO) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcErrorClearInformation();
}
extern "C" {
    pub fn RpcAsyncCleanupThread(dwTimeout: DWORD) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcGetAuthorizationContextForClient(
        ClientBinding: RPC_BINDING_HANDLE,
        ImpersonateOnReturn: BOOL,
        Reserved1: PVOID,
        pExpirationTime: PLARGE_INTEGER,
        Reserved2: LUID,
        Reserved3: DWORD,
        Reserved4: PVOID,
        pAuthzClientContext: *mut PVOID,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcFreeAuthorizationContext(pAuthzClientContext: *mut PVOID) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSsContextLockExclusive(
        ServerBindingHandle: RPC_BINDING_HANDLE,
        UserContext: PVOID,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSsContextLockShared(
        ServerBindingHandle: RPC_BINDING_HANDLE,
        UserContext: PVOID,
    ) -> RPC_STATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagRpcLocalAddressFormat {
    rlafInvalid = 0,
    rlafIPv4 = 1,
    rlafIPv6 = 2,
}
pub use self::tagRpcLocalAddressFormat as RpcLocalAddressFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_CALL_LOCAL_ADDRESS_V1 {
    pub Version: ::std::os::raw::c_uint,
    pub Buffer: *mut ::std::os::raw::c_void,
    pub BufferSize: ::std::os::raw::c_ulong,
    pub AddressFormat: RpcLocalAddressFormat,
}
pub type RPC_CALL_LOCAL_ADDRESS_V1 = _RPC_CALL_LOCAL_ADDRESS_V1;
pub type PRPC_CALL_LOCAL_ADDRESS_V1 = *mut _RPC_CALL_LOCAL_ADDRESS_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_CALL_ATTRIBUTES_V1_W {
    pub Version: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_ulong,
    pub ServerPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ServerPrincipalName: *mut ::std::os::raw::c_ushort,
    pub ClientPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ClientPrincipalName: *mut ::std::os::raw::c_ushort,
    pub AuthenticationLevel: ::std::os::raw::c_ulong,
    pub AuthenticationService: ::std::os::raw::c_ulong,
    pub NullSession: BOOL,
}
pub type RPC_CALL_ATTRIBUTES_V1_W = tagRPC_CALL_ATTRIBUTES_V1_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_CALL_ATTRIBUTES_V1_A {
    pub Version: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_ulong,
    pub ServerPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ServerPrincipalName: *mut ::std::os::raw::c_uchar,
    pub ClientPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ClientPrincipalName: *mut ::std::os::raw::c_uchar,
    pub AuthenticationLevel: ::std::os::raw::c_ulong,
    pub AuthenticationService: ::std::os::raw::c_ulong,
    pub NullSession: BOOL,
}
pub type RPC_CALL_ATTRIBUTES_V1_A = tagRPC_CALL_ATTRIBUTES_V1_A;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagRpcCallType {
    rctInvalid = 0,
    rctNormal = 1,
    rctTraining = 2,
    rctGuaranteed = 3,
}
pub use self::tagRpcCallType as RpcCallType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagRpcCallClientLocality {
    rcclInvalid = 0,
    rcclLocal = 1,
    rcclRemote = 2,
    rcclClientUnknownLocality = 3,
}
pub use self::tagRpcCallClientLocality as RpcCallClientLocality;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_CALL_ATTRIBUTES_V2_W {
    pub Version: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_ulong,
    pub ServerPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ServerPrincipalName: *mut ::std::os::raw::c_ushort,
    pub ClientPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ClientPrincipalName: *mut ::std::os::raw::c_ushort,
    pub AuthenticationLevel: ::std::os::raw::c_ulong,
    pub AuthenticationService: ::std::os::raw::c_ulong,
    pub NullSession: BOOL,
    pub KernelModeCaller: BOOL,
    pub ProtocolSequence: ::std::os::raw::c_ulong,
    pub IsClientLocal: RpcCallClientLocality,
    pub ClientPID: HANDLE,
    pub CallStatus: ::std::os::raw::c_ulong,
    pub CallType: RpcCallType,
    pub CallLocalAddress: *mut RPC_CALL_LOCAL_ADDRESS_V1,
    pub OpNum: ::std::os::raw::c_ushort,
    pub InterfaceUuid: UUID,
}
pub type RPC_CALL_ATTRIBUTES_V2_W = tagRPC_CALL_ATTRIBUTES_V2_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_CALL_ATTRIBUTES_V2_A {
    pub Version: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_ulong,
    pub ServerPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ServerPrincipalName: *mut ::std::os::raw::c_uchar,
    pub ClientPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ClientPrincipalName: *mut ::std::os::raw::c_uchar,
    pub AuthenticationLevel: ::std::os::raw::c_ulong,
    pub AuthenticationService: ::std::os::raw::c_ulong,
    pub NullSession: BOOL,
    pub KernelModeCaller: BOOL,
    pub ProtocolSequence: ::std::os::raw::c_ulong,
    pub IsClientLocal: ::std::os::raw::c_ulong,
    pub ClientPID: HANDLE,
    pub CallStatus: ::std::os::raw::c_ulong,
    pub CallType: RpcCallType,
    pub CallLocalAddress: *mut RPC_CALL_LOCAL_ADDRESS_V1,
    pub OpNum: ::std::os::raw::c_ushort,
    pub InterfaceUuid: UUID,
}
pub type RPC_CALL_ATTRIBUTES_V2_A = tagRPC_CALL_ATTRIBUTES_V2_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_CALL_ATTRIBUTES_V3_W {
    pub Version: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_ulong,
    pub ServerPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ServerPrincipalName: *mut ::std::os::raw::c_ushort,
    pub ClientPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ClientPrincipalName: *mut ::std::os::raw::c_ushort,
    pub AuthenticationLevel: ::std::os::raw::c_ulong,
    pub AuthenticationService: ::std::os::raw::c_ulong,
    pub NullSession: BOOL,
    pub KernelModeCaller: BOOL,
    pub ProtocolSequence: ::std::os::raw::c_ulong,
    pub IsClientLocal: RpcCallClientLocality,
    pub ClientPID: HANDLE,
    pub CallStatus: ::std::os::raw::c_ulong,
    pub CallType: RpcCallType,
    pub CallLocalAddress: *mut RPC_CALL_LOCAL_ADDRESS_V1,
    pub OpNum: ::std::os::raw::c_ushort,
    pub InterfaceUuid: UUID,
    pub ClientIdentifierBufferLength: ::std::os::raw::c_ulong,
    pub ClientIdentifier: *mut ::std::os::raw::c_uchar,
}
pub type RPC_CALL_ATTRIBUTES_V3_W = tagRPC_CALL_ATTRIBUTES_V3_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPC_CALL_ATTRIBUTES_V3_A {
    pub Version: ::std::os::raw::c_uint,
    pub Flags: ::std::os::raw::c_ulong,
    pub ServerPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ServerPrincipalName: *mut ::std::os::raw::c_uchar,
    pub ClientPrincipalNameBufferLength: ::std::os::raw::c_ulong,
    pub ClientPrincipalName: *mut ::std::os::raw::c_uchar,
    pub AuthenticationLevel: ::std::os::raw::c_ulong,
    pub AuthenticationService: ::std::os::raw::c_ulong,
    pub NullSession: BOOL,
    pub KernelModeCaller: BOOL,
    pub ProtocolSequence: ::std::os::raw::c_ulong,
    pub IsClientLocal: ::std::os::raw::c_ulong,
    pub ClientPID: HANDLE,
    pub CallStatus: ::std::os::raw::c_ulong,
    pub CallType: RpcCallType,
    pub CallLocalAddress: *mut RPC_CALL_LOCAL_ADDRESS_V1,
    pub OpNum: ::std::os::raw::c_ushort,
    pub InterfaceUuid: UUID,
    pub ClientIdentifierBufferLength: ::std::os::raw::c_ulong,
    pub ClientIdentifier: *mut ::std::os::raw::c_uchar,
}
pub type RPC_CALL_ATTRIBUTES_V3_A = tagRPC_CALL_ATTRIBUTES_V3_A;
extern "C" {
    pub fn RpcServerInqCallAttributesW(
        ClientBinding: RPC_BINDING_HANDLE,
        RpcCallAttributes: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerInqCallAttributesA(
        ClientBinding: RPC_BINDING_HANDLE,
        RpcCallAttributes: *mut ::std::os::raw::c_void,
    ) -> RPC_STATUS;
}
pub type RPC_CALL_ATTRIBUTES = RPC_CALL_ATTRIBUTES_V3_A;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _RPC_NOTIFICATIONS {
    RpcNotificationCallNone = 0,
    RpcNotificationClientDisconnect = 1,
    RpcNotificationCallCancel = 2,
}
pub use self::_RPC_NOTIFICATIONS as RPC_NOTIFICATIONS;
extern "C" {
    pub fn RpcServerSubscribeForNotification(
        Binding: RPC_BINDING_HANDLE,
        Notification: RPC_NOTIFICATIONS,
        NotificationType: RPC_NOTIFICATION_TYPES,
        NotificationInfo: *mut RPC_ASYNC_NOTIFICATION_INFO,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcServerUnsubscribeForNotification(
        Binding: RPC_BINDING_HANDLE,
        Notification: RPC_NOTIFICATIONS,
        NotificationsQueued: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingBind(
        pAsync: PRPC_ASYNC_STATE,
        Binding: RPC_BINDING_HANDLE,
        IfSpec: RPC_IF_HANDLE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcBindingUnbind(Binding: RPC_BINDING_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcAsyncSetHandle(Message: PRPC_MESSAGE, pAsync: PRPC_ASYNC_STATE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcAsyncAbortCall(
        pAsync: PRPC_ASYNC_STATE,
        ExceptionCode: ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcExceptionFilter(ExceptionCode: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn I_RpcBindingInqClientTokenAttributes(
        Binding: RPC_BINDING_HANDLE,
        TokenId: *mut LUID,
        AuthenticationId: *mut LUID,
        ModifiedId: *mut LUID,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn CommandLineToArgvW(
        lpCmdLine: LPCWSTR,
        pNumArgs: *mut ::std::os::raw::c_int,
    ) -> *mut LPWSTR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDROP__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDROP = *mut HDROP__;
extern "C" {
    pub fn DragQueryFileA(hDrop: HDROP, iFile: UINT, lpszFile: LPSTR, cch: UINT) -> UINT;
}
extern "C" {
    pub fn DragQueryFileW(hDrop: HDROP, iFile: UINT, lpszFile: LPWSTR, cch: UINT) -> UINT;
}
extern "C" {
    pub fn DragQueryPoint(hDrop: HDROP, ppt: *mut POINT) -> BOOL;
}
extern "C" {
    pub fn DragFinish(hDrop: HDROP);
}
extern "C" {
    pub fn DragAcceptFiles(hWnd: HWND, fAccept: BOOL);
}
extern "C" {
    pub fn ShellExecuteA(
        hwnd: HWND,
        lpOperation: LPCSTR,
        lpFile: LPCSTR,
        lpParameters: LPCSTR,
        lpDirectory: LPCSTR,
        nShowCmd: INT,
    ) -> HINSTANCE;
}
extern "C" {
    pub fn ShellExecuteW(
        hwnd: HWND,
        lpOperation: LPCWSTR,
        lpFile: LPCWSTR,
        lpParameters: LPCWSTR,
        lpDirectory: LPCWSTR,
        nShowCmd: INT,
    ) -> HINSTANCE;
}
extern "C" {
    pub fn FindExecutableA(lpFile: LPCSTR, lpDirectory: LPCSTR, lpResult: LPSTR) -> HINSTANCE;
}
extern "C" {
    pub fn FindExecutableW(lpFile: LPCWSTR, lpDirectory: LPCWSTR, lpResult: LPWSTR) -> HINSTANCE;
}
extern "C" {
    pub fn ShellAboutA(hWnd: HWND, szApp: LPCSTR, szOtherStuff: LPCSTR, hIcon: HICON) -> INT;
}
extern "C" {
    pub fn ShellAboutW(hWnd: HWND, szApp: LPCWSTR, szOtherStuff: LPCWSTR, hIcon: HICON) -> INT;
}
extern "C" {
    pub fn DuplicateIcon(hInst: HINSTANCE, hIcon: HICON) -> HICON;
}
extern "C" {
    pub fn ExtractAssociatedIconA(hInst: HINSTANCE, pszIconPath: LPSTR, piIcon: *mut WORD)
        -> HICON;
}
extern "C" {
    pub fn ExtractAssociatedIconW(
        hInst: HINSTANCE,
        pszIconPath: LPWSTR,
        piIcon: *mut WORD,
    ) -> HICON;
}
extern "C" {
    pub fn ExtractAssociatedIconExA(
        hInst: HINSTANCE,
        pszIconPath: LPSTR,
        piIconIndex: *mut WORD,
        piIconId: *mut WORD,
    ) -> HICON;
}
extern "C" {
    pub fn ExtractAssociatedIconExW(
        hInst: HINSTANCE,
        pszIconPath: LPWSTR,
        piIconIndex: *mut WORD,
        piIconId: *mut WORD,
    ) -> HICON;
}
extern "C" {
    pub fn ExtractIconA(hInst: HINSTANCE, pszExeFileName: LPCSTR, nIconIndex: UINT) -> HICON;
}
extern "C" {
    pub fn ExtractIconW(hInst: HINSTANCE, pszExeFileName: LPCWSTR, nIconIndex: UINT) -> HICON;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRAGINFOA {
    pub uSize: UINT,
    pub pt: POINT,
    pub fNC: BOOL,
    pub lpFileList: PZZSTR,
    pub grfKeyState: DWORD,
}
pub type DRAGINFOA = _DRAGINFOA;
pub type LPDRAGINFOA = *mut _DRAGINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRAGINFOW {
    pub uSize: UINT,
    pub pt: POINT,
    pub fNC: BOOL,
    pub lpFileList: PZZWSTR,
    pub grfKeyState: DWORD,
}
pub type DRAGINFOW = _DRAGINFOW;
pub type LPDRAGINFOW = *mut _DRAGINFOW;
pub type DRAGINFO = DRAGINFOA;
pub type LPDRAGINFO = LPDRAGINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AppBarData {
    pub cbSize: DWORD,
    pub hWnd: HWND,
    pub uCallbackMessage: UINT,
    pub uEdge: UINT,
    pub rc: RECT,
    pub lParam: LPARAM,
}
pub type APPBARDATA = _AppBarData;
pub type PAPPBARDATA = *mut _AppBarData;
extern "C" {
    pub fn SHAppBarMessage(dwMessage: DWORD, pData: PAPPBARDATA) -> UINT_PTR;
}
extern "C" {
    pub fn DoEnvironmentSubstA(pszSrc: LPSTR, cchSrc: UINT) -> DWORD;
}
extern "C" {
    pub fn DoEnvironmentSubstW(pszSrc: LPWSTR, cchSrc: UINT) -> DWORD;
}
extern "C" {
    pub fn ExtractIconExA(
        lpszFile: LPCSTR,
        nIconIndex: ::std::os::raw::c_int,
        phiconLarge: *mut HICON,
        phiconSmall: *mut HICON,
        nIcons: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ExtractIconExW(
        lpszFile: LPCWSTR,
        nIconIndex: ::std::os::raw::c_int,
        phiconLarge: *mut HICON,
        phiconSmall: *mut HICON,
        nIcons: UINT,
    ) -> UINT;
}
pub type FILEOP_FLAGS = WORD;
pub type PRINTEROP_FLAGS = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEOPSTRUCTA {
    pub hwnd: HWND,
    pub wFunc: UINT,
    pub pFrom: PCZZSTR,
    pub pTo: PCZZSTR,
    pub fFlags: FILEOP_FLAGS,
    pub fAnyOperationsAborted: BOOL,
    pub hNameMappings: LPVOID,
    pub lpszProgressTitle: PCSTR,
}
pub type SHFILEOPSTRUCTA = _SHFILEOPSTRUCTA;
pub type LPSHFILEOPSTRUCTA = *mut _SHFILEOPSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEOPSTRUCTW {
    pub hwnd: HWND,
    pub wFunc: UINT,
    pub pFrom: PCZZWSTR,
    pub pTo: PCZZWSTR,
    pub fFlags: FILEOP_FLAGS,
    pub fAnyOperationsAborted: BOOL,
    pub hNameMappings: LPVOID,
    pub lpszProgressTitle: PCWSTR,
}
pub type SHFILEOPSTRUCTW = _SHFILEOPSTRUCTW;
pub type LPSHFILEOPSTRUCTW = *mut _SHFILEOPSTRUCTW;
pub type SHFILEOPSTRUCT = SHFILEOPSTRUCTA;
pub type LPSHFILEOPSTRUCT = LPSHFILEOPSTRUCTA;
extern "C" {
    pub fn SHFileOperationA(lpFileOp: LPSHFILEOPSTRUCTA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHFileOperationW(lpFileOp: LPSHFILEOPSTRUCTW) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHFreeNameMappings(hNameMappings: HANDLE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHNAMEMAPPINGA {
    pub pszOldPath: LPSTR,
    pub pszNewPath: LPSTR,
    pub cchOldPath: ::std::os::raw::c_int,
    pub cchNewPath: ::std::os::raw::c_int,
}
pub type SHNAMEMAPPINGA = _SHNAMEMAPPINGA;
pub type LPSHNAMEMAPPINGA = *mut _SHNAMEMAPPINGA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHNAMEMAPPINGW {
    pub pszOldPath: LPWSTR,
    pub pszNewPath: LPWSTR,
    pub cchOldPath: ::std::os::raw::c_int,
    pub cchNewPath: ::std::os::raw::c_int,
}
pub type SHNAMEMAPPINGW = _SHNAMEMAPPINGW;
pub type LPSHNAMEMAPPINGW = *mut _SHNAMEMAPPINGW;
pub type SHNAMEMAPPING = SHNAMEMAPPINGA;
pub type LPSHNAMEMAPPING = LPSHNAMEMAPPINGA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHELLEXECUTEINFOA {
    pub cbSize: DWORD,
    pub fMask: ULONG,
    pub hwnd: HWND,
    pub lpVerb: LPCSTR,
    pub lpFile: LPCSTR,
    pub lpParameters: LPCSTR,
    pub lpDirectory: LPCSTR,
    pub nShow: ::std::os::raw::c_int,
    pub hInstApp: HINSTANCE,
    pub lpIDList: *mut ::std::os::raw::c_void,
    pub lpClass: LPCSTR,
    pub hkeyClass: HKEY,
    pub dwHotKey: DWORD,
    pub __bindgen_anon_1: _SHELLEXECUTEINFOA__bindgen_ty_1,
    pub hProcess: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHELLEXECUTEINFOA__bindgen_ty_1 {
    pub hIcon: HANDLE,
    pub hMonitor: HANDLE,
}
pub type SHELLEXECUTEINFOA = _SHELLEXECUTEINFOA;
pub type LPSHELLEXECUTEINFOA = *mut _SHELLEXECUTEINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHELLEXECUTEINFOW {
    pub cbSize: DWORD,
    pub fMask: ULONG,
    pub hwnd: HWND,
    pub lpVerb: LPCWSTR,
    pub lpFile: LPCWSTR,
    pub lpParameters: LPCWSTR,
    pub lpDirectory: LPCWSTR,
    pub nShow: ::std::os::raw::c_int,
    pub hInstApp: HINSTANCE,
    pub lpIDList: *mut ::std::os::raw::c_void,
    pub lpClass: LPCWSTR,
    pub hkeyClass: HKEY,
    pub dwHotKey: DWORD,
    pub __bindgen_anon_1: _SHELLEXECUTEINFOW__bindgen_ty_1,
    pub hProcess: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHELLEXECUTEINFOW__bindgen_ty_1 {
    pub hIcon: HANDLE,
    pub hMonitor: HANDLE,
}
pub type SHELLEXECUTEINFOW = _SHELLEXECUTEINFOW;
pub type LPSHELLEXECUTEINFOW = *mut _SHELLEXECUTEINFOW;
pub type SHELLEXECUTEINFO = SHELLEXECUTEINFOA;
pub type LPSHELLEXECUTEINFO = LPSHELLEXECUTEINFOA;
extern "C" {
    pub fn ShellExecuteExA(pExecInfo: *mut SHELLEXECUTEINFOA) -> BOOL;
}
extern "C" {
    pub fn ShellExecuteExW(pExecInfo: *mut SHELLEXECUTEINFOW) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHCREATEPROCESSINFOW {
    pub cbSize: DWORD,
    pub fMask: ULONG,
    pub hwnd: HWND,
    pub pszFile: LPCWSTR,
    pub pszParameters: LPCWSTR,
    pub pszCurrentDirectory: LPCWSTR,
    pub hUserToken: HANDLE,
    pub lpProcessAttributes: LPSECURITY_ATTRIBUTES,
    pub lpThreadAttributes: LPSECURITY_ATTRIBUTES,
    pub bInheritHandles: BOOL,
    pub dwCreationFlags: DWORD,
    pub lpStartupInfo: LPSTARTUPINFOW,
    pub lpProcessInformation: LPPROCESS_INFORMATION,
}
pub type SHCREATEPROCESSINFOW = _SHCREATEPROCESSINFOW;
pub type PSHCREATEPROCESSINFOW = *mut _SHCREATEPROCESSINFOW;
extern "C" {
    pub fn SHCreateProcessAsUserW(pscpi: PSHCREATEPROCESSINFOW) -> BOOL;
}
extern "C" {
    pub fn SHEvaluateSystemCommandTemplate(
        pszCmdTemplate: PCWSTR,
        ppszApplication: *mut PWSTR,
        ppszCommandLine: *mut PWSTR,
        ppszParameters: *mut PWSTR,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ASSOCCLASS {
    ASSOCCLASS_SHELL_KEY = 0,
    ASSOCCLASS_PROGID_KEY = 1,
    ASSOCCLASS_PROGID_STR = 2,
    ASSOCCLASS_CLSID_KEY = 3,
    ASSOCCLASS_CLSID_STR = 4,
    ASSOCCLASS_APP_KEY = 5,
    ASSOCCLASS_APP_STR = 6,
    ASSOCCLASS_SYSTEM_STR = 7,
    ASSOCCLASS_FOLDER = 8,
    ASSOCCLASS_STAR = 9,
    ASSOCCLASS_FIXED_PROGID_STR = 10,
    ASSOCCLASS_PROTOCOL_STR = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASSOCIATIONELEMENT {
    pub ac: ASSOCCLASS,
    pub hkClass: HKEY,
    pub pszClass: PCWSTR,
}
extern "C" {
    pub fn AssocCreateForClasses(
        rgClasses: *const ASSOCIATIONELEMENT,
        cClasses: ULONG,
        riid: *const IID,
        ppv: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHQUERYRBINFO {
    pub cbSize: DWORD,
    pub i64Size: ::std::os::raw::c_longlong,
    pub i64NumItems: ::std::os::raw::c_longlong,
}
pub type SHQUERYRBINFO = _SHQUERYRBINFO;
pub type LPSHQUERYRBINFO = *mut _SHQUERYRBINFO;
extern "C" {
    pub fn SHQueryRecycleBinA(pszRootPath: LPCSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) -> HRESULT;
}
extern "C" {
    pub fn SHQueryRecycleBinW(pszRootPath: LPCWSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) -> HRESULT;
}
extern "C" {
    pub fn SHEmptyRecycleBinA(hwnd: HWND, pszRootPath: LPCSTR, dwFlags: DWORD) -> HRESULT;
}
extern "C" {
    pub fn SHEmptyRecycleBinW(hwnd: HWND, pszRootPath: LPCWSTR, dwFlags: DWORD) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum QUERY_USER_NOTIFICATION_STATE {
    QUNS_NOT_PRESENT = 1,
    QUNS_BUSY = 2,
    QUNS_RUNNING_D3D_FULL_SCREEN = 3,
    QUNS_PRESENTATION_MODE = 4,
    QUNS_ACCEPTS_NOTIFICATIONS = 5,
    QUNS_QUIET_TIME = 6,
    QUNS_APP = 7,
}
extern "C" {
    pub fn SHQueryUserNotificationState(pquns: *mut QUERY_USER_NOTIFICATION_STATE) -> HRESULT;
}
extern "C" {
    pub fn SHGetPropertyStoreForWindow(
        hwnd: HWND,
        riid: *const IID,
        ppv: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NOTIFYICONDATAA {
    pub cbSize: DWORD,
    pub hWnd: HWND,
    pub uID: UINT,
    pub uFlags: UINT,
    pub uCallbackMessage: UINT,
    pub hIcon: HICON,
    pub szTip: [CHAR; 128usize],
    pub dwState: DWORD,
    pub dwStateMask: DWORD,
    pub szInfo: [CHAR; 256usize],
    pub __bindgen_anon_1: _NOTIFYICONDATAA__bindgen_ty_1,
    pub szInfoTitle: [CHAR; 64usize],
    pub dwInfoFlags: DWORD,
    pub guidItem: GUID,
    pub hBalloonIcon: HICON,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NOTIFYICONDATAA__bindgen_ty_1 {
    pub uTimeout: UINT,
    pub uVersion: UINT,
}
pub type NOTIFYICONDATAA = _NOTIFYICONDATAA;
pub type PNOTIFYICONDATAA = *mut _NOTIFYICONDATAA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NOTIFYICONDATAW {
    pub cbSize: DWORD,
    pub hWnd: HWND,
    pub uID: UINT,
    pub uFlags: UINT,
    pub uCallbackMessage: UINT,
    pub hIcon: HICON,
    pub szTip: [WCHAR; 128usize],
    pub dwState: DWORD,
    pub dwStateMask: DWORD,
    pub szInfo: [WCHAR; 256usize],
    pub __bindgen_anon_1: _NOTIFYICONDATAW__bindgen_ty_1,
    pub szInfoTitle: [WCHAR; 64usize],
    pub dwInfoFlags: DWORD,
    pub guidItem: GUID,
    pub hBalloonIcon: HICON,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NOTIFYICONDATAW__bindgen_ty_1 {
    pub uTimeout: UINT,
    pub uVersion: UINT,
}
pub type NOTIFYICONDATAW = _NOTIFYICONDATAW;
pub type PNOTIFYICONDATAW = *mut _NOTIFYICONDATAW;
pub type NOTIFYICONDATA = NOTIFYICONDATAA;
pub type PNOTIFYICONDATA = PNOTIFYICONDATAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NOTIFYICONIDENTIFIER {
    pub cbSize: DWORD,
    pub hWnd: HWND,
    pub uID: UINT,
    pub guidItem: GUID,
}
pub type NOTIFYICONIDENTIFIER = _NOTIFYICONIDENTIFIER;
pub type PNOTIFYICONIDENTIFIER = *mut _NOTIFYICONIDENTIFIER;
extern "C" {
    pub fn Shell_NotifyIconA(dwMessage: DWORD, lpData: PNOTIFYICONDATAA) -> BOOL;
}
extern "C" {
    pub fn Shell_NotifyIconW(dwMessage: DWORD, lpData: PNOTIFYICONDATAW) -> BOOL;
}
extern "C" {
    pub fn Shell_NotifyIconGetRect(
        identifier: *const NOTIFYICONIDENTIFIER,
        iconLocation: *mut RECT,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEINFOA {
    pub hIcon: HICON,
    pub iIcon: ::std::os::raw::c_int,
    pub dwAttributes: DWORD,
    pub szDisplayName: [CHAR; 260usize],
    pub szTypeName: [CHAR; 80usize],
}
pub type SHFILEINFOA = _SHFILEINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEINFOW {
    pub hIcon: HICON,
    pub iIcon: ::std::os::raw::c_int,
    pub dwAttributes: DWORD,
    pub szDisplayName: [WCHAR; 260usize],
    pub szTypeName: [WCHAR; 80usize],
}
pub type SHFILEINFOW = _SHFILEINFOW;
pub type SHFILEINFO = SHFILEINFOA;
extern "C" {
    pub fn SHGetFileInfoA(
        pszPath: LPCSTR,
        dwFileAttributes: DWORD,
        psfi: *mut SHFILEINFOA,
        cbFileInfo: UINT,
        uFlags: UINT,
    ) -> DWORD_PTR;
}
extern "C" {
    pub fn SHGetFileInfoW(
        pszPath: LPCWSTR,
        dwFileAttributes: DWORD,
        psfi: *mut SHFILEINFOW,
        cbFileInfo: UINT,
        uFlags: UINT,
    ) -> DWORD_PTR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHSTOCKICONINFO {
    pub cbSize: DWORD,
    pub hIcon: HICON,
    pub iSysImageIndex: ::std::os::raw::c_int,
    pub iIcon: ::std::os::raw::c_int,
    pub szPath: [WCHAR; 260usize],
}
pub type SHSTOCKICONINFO = _SHSTOCKICONINFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SHSTOCKICONID {
    SIID_DOCNOASSOC = 0,
    SIID_DOCASSOC = 1,
    SIID_APPLICATION = 2,
    SIID_FOLDER = 3,
    SIID_FOLDEROPEN = 4,
    SIID_DRIVE525 = 5,
    SIID_DRIVE35 = 6,
    SIID_DRIVEREMOVE = 7,
    SIID_DRIVEFIXED = 8,
    SIID_DRIVENET = 9,
    SIID_DRIVENETDISABLED = 10,
    SIID_DRIVECD = 11,
    SIID_DRIVERAM = 12,
    SIID_WORLD = 13,
    SIID_SERVER = 15,
    SIID_PRINTER = 16,
    SIID_MYNETWORK = 17,
    SIID_FIND = 22,
    SIID_HELP = 23,
    SIID_SHARE = 28,
    SIID_LINK = 29,
    SIID_SLOWFILE = 30,
    SIID_RECYCLER = 31,
    SIID_RECYCLERFULL = 32,
    SIID_MEDIACDAUDIO = 40,
    SIID_LOCK = 47,
    SIID_AUTOLIST = 49,
    SIID_PRINTERNET = 50,
    SIID_SERVERSHARE = 51,
    SIID_PRINTERFAX = 52,
    SIID_PRINTERFAXNET = 53,
    SIID_PRINTERFILE = 54,
    SIID_STACK = 55,
    SIID_MEDIASVCD = 56,
    SIID_STUFFEDFOLDER = 57,
    SIID_DRIVEUNKNOWN = 58,
    SIID_DRIVEDVD = 59,
    SIID_MEDIADVD = 60,
    SIID_MEDIADVDRAM = 61,
    SIID_MEDIADVDRW = 62,
    SIID_MEDIADVDR = 63,
    SIID_MEDIADVDROM = 64,
    SIID_MEDIACDAUDIOPLUS = 65,
    SIID_MEDIACDRW = 66,
    SIID_MEDIACDR = 67,
    SIID_MEDIACDBURN = 68,
    SIID_MEDIABLANKCD = 69,
    SIID_MEDIACDROM = 70,
    SIID_AUDIOFILES = 71,
    SIID_IMAGEFILES = 72,
    SIID_VIDEOFILES = 73,
    SIID_MIXEDFILES = 74,
    SIID_FOLDERBACK = 75,
    SIID_FOLDERFRONT = 76,
    SIID_SHIELD = 77,
    SIID_WARNING = 78,
    SIID_INFO = 79,
    SIID_ERROR = 80,
    SIID_KEY = 81,
    SIID_SOFTWARE = 82,
    SIID_RENAME = 83,
    SIID_DELETE = 84,
    SIID_MEDIAAUDIODVD = 85,
    SIID_MEDIAMOVIEDVD = 86,
    SIID_MEDIAENHANCEDCD = 87,
    SIID_MEDIAENHANCEDDVD = 88,
    SIID_MEDIAHDDVD = 89,
    SIID_MEDIABLURAY = 90,
    SIID_MEDIAVCD = 91,
    SIID_MEDIADVDPLUSR = 92,
    SIID_MEDIADVDPLUSRW = 93,
    SIID_DESKTOPPC = 94,
    SIID_MOBILEPC = 95,
    SIID_USERS = 96,
    SIID_MEDIASMARTMEDIA = 97,
    SIID_MEDIACOMPACTFLASH = 98,
    SIID_DEVICECELLPHONE = 99,
    SIID_DEVICECAMERA = 100,
    SIID_DEVICEVIDEOCAMERA = 101,
    SIID_DEVICEAUDIOPLAYER = 102,
    SIID_NETWORKCONNECT = 103,
    SIID_INTERNET = 104,
    SIID_ZIPFILE = 105,
    SIID_SETTINGS = 106,
    SIID_DRIVEHDDVD = 132,
    SIID_DRIVEBD = 133,
    SIID_MEDIAHDDVDROM = 134,
    SIID_MEDIAHDDVDR = 135,
    SIID_MEDIAHDDVDRAM = 136,
    SIID_MEDIABDROM = 137,
    SIID_MEDIABDR = 138,
    SIID_MEDIABDRE = 139,
    SIID_CLUSTEREDDRIVE = 140,
    SIID_MAX_ICONS = 181,
}
extern "C" {
    pub fn SHGetStockIconInfo(
        siid: SHSTOCKICONID,
        uFlags: UINT,
        psii: *mut SHSTOCKICONINFO,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHGetDiskFreeSpaceExA(
        pszDirectoryName: LPCSTR,
        pulFreeBytesAvailableToCaller: *mut ULARGE_INTEGER,
        pulTotalNumberOfBytes: *mut ULARGE_INTEGER,
        pulTotalNumberOfFreeBytes: *mut ULARGE_INTEGER,
    ) -> BOOL;
}
extern "C" {
    pub fn SHGetDiskFreeSpaceExW(
        pszDirectoryName: LPCWSTR,
        pulFreeBytesAvailableToCaller: *mut ULARGE_INTEGER,
        pulTotalNumberOfBytes: *mut ULARGE_INTEGER,
        pulTotalNumberOfFreeBytes: *mut ULARGE_INTEGER,
    ) -> BOOL;
}
extern "C" {
    pub fn SHGetNewLinkInfoA(
        pszLinkTo: LPCSTR,
        pszDir: LPCSTR,
        pszName: LPSTR,
        pfMustCopy: *mut BOOL,
        uFlags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn SHGetNewLinkInfoW(
        pszLinkTo: LPCWSTR,
        pszDir: LPCWSTR,
        pszName: LPWSTR,
        pfMustCopy: *mut BOOL,
        uFlags: UINT,
    ) -> BOOL;
}
extern "C" {
    pub fn SHInvokePrinterCommandA(
        hwnd: HWND,
        uAction: UINT,
        lpBuf1: LPCSTR,
        lpBuf2: LPCSTR,
        fModal: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn SHInvokePrinterCommandW(
        hwnd: HWND,
        uAction: UINT,
        lpBuf1: LPCWSTR,
        lpBuf2: LPCWSTR,
        fModal: BOOL,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPEN_PRINTER_PROPS_INFOA {
    pub dwSize: DWORD,
    pub pszSheetName: LPSTR,
    pub uSheetIndex: UINT,
    pub dwFlags: DWORD,
    pub bModal: BOOL,
}
pub type OPEN_PRINTER_PROPS_INFOA = _OPEN_PRINTER_PROPS_INFOA;
pub type POPEN_PRINTER_PROPS_INFOA = *mut _OPEN_PRINTER_PROPS_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPEN_PRINTER_PROPS_INFOW {
    pub dwSize: DWORD,
    pub pszSheetName: LPWSTR,
    pub uSheetIndex: UINT,
    pub dwFlags: DWORD,
    pub bModal: BOOL,
}
pub type OPEN_PRINTER_PROPS_INFOW = _OPEN_PRINTER_PROPS_INFOW;
pub type POPEN_PRINTER_PROPS_INFOW = *mut _OPEN_PRINTER_PROPS_INFOW;
pub type OPEN_PRINTER_PROPS_INFO = OPEN_PRINTER_PROPS_INFOA;
pub type POPEN_PRINTER_PROPS_INFO = POPEN_PRINTER_PROPS_INFOA;
extern "C" {
    pub fn SHLoadNonloadedIconOverlayIdentifiers() -> HRESULT;
}
extern "C" {
    pub fn SHIsFileAvailableOffline(pwszPath: PCWSTR, pdwStatus: *mut DWORD) -> HRESULT;
}
extern "C" {
    pub fn SHSetLocalizedName(
        pszPath: PCWSTR,
        pszResModule: PCWSTR,
        idsRes: ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHRemoveLocalizedName(pszPath: PCWSTR) -> HRESULT;
}
extern "C" {
    pub fn SHGetLocalizedName(
        pszPath: PCWSTR,
        pszResModule: PWSTR,
        cch: UINT,
        pidsRes: *mut ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn ShellMessageBoxA(
        hAppInst: HINSTANCE,
        hWnd: HWND,
        lpcText: LPCSTR,
        lpcTitle: LPCSTR,
        fuStyle: UINT,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ShellMessageBoxW(
        hAppInst: HINSTANCE,
        hWnd: HWND,
        lpcText: LPCWSTR,
        lpcTitle: LPCWSTR,
        fuStyle: UINT,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IsLFNDriveA(pszPath: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn IsLFNDriveW(pszPath: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn SHEnumerateUnreadMailAccountsA(
        hKeyUser: HKEY,
        dwIndex: DWORD,
        pszMailAddress: LPSTR,
        cchMailAddress: ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHEnumerateUnreadMailAccountsW(
        hKeyUser: HKEY,
        dwIndex: DWORD,
        pszMailAddress: LPWSTR,
        cchMailAddress: ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHGetUnreadMailCountA(
        hKeyUser: HKEY,
        pszMailAddress: LPCSTR,
        pdwCount: *mut DWORD,
        pFileTime: *mut FILETIME,
        pszShellExecuteCommand: LPSTR,
        cchShellExecuteCommand: ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHGetUnreadMailCountW(
        hKeyUser: HKEY,
        pszMailAddress: LPCWSTR,
        pdwCount: *mut DWORD,
        pFileTime: *mut FILETIME,
        pszShellExecuteCommand: LPWSTR,
        cchShellExecuteCommand: ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHSetUnreadMailCountA(
        pszMailAddress: LPCSTR,
        dwCount: DWORD,
        pszShellExecuteCommand: LPCSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHSetUnreadMailCountW(
        pszMailAddress: LPCWSTR,
        dwCount: DWORD,
        pszShellExecuteCommand: LPCWSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn SHTestTokenMembership(hToken: HANDLE, ulRID: ULONG) -> BOOL;
}
extern "C" {
    pub fn SHGetImageList(
        iImageList: ::std::os::raw::c_int,
        riid: *const IID,
        ppvObj: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
pub type PFNCANSHAREFOLDERW =
    ::std::option::Option<unsafe extern "C" fn(pszPath: PCWSTR) -> HRESULT>;
pub type PFNSHOWSHAREFOLDERUIW =
    ::std::option::Option<unsafe extern "C" fn(hwndParent: HWND, pszPath: PCWSTR) -> HRESULT>;
extern "C" {
    pub fn InitNetworkAddressControl() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagNC_ADDRESS {
    pub pAddrInfo: *mut NET_ADDRESS_INFO_,
    pub PortNumber: USHORT,
    pub PrefixLength: BYTE,
}
pub type NC_ADDRESS = tagNC_ADDRESS;
pub type PNC_ADDRESS = *mut tagNC_ADDRESS;
extern "C" {
    pub fn SHGetDriveMedia(pszDrive: PCWSTR, pdwMediaContent: *mut DWORD) -> HRESULT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERF_DATA_BLOCK {
    pub Signature: [WCHAR; 4usize],
    pub LittleEndian: DWORD,
    pub Version: DWORD,
    pub Revision: DWORD,
    pub TotalByteLength: DWORD,
    pub HeaderLength: DWORD,
    pub NumObjectTypes: DWORD,
    pub DefaultObject: LONG,
    pub SystemTime: SYSTEMTIME,
    pub PerfTime: LARGE_INTEGER,
    pub PerfFreq: LARGE_INTEGER,
    pub PerfTime100nSec: LARGE_INTEGER,
    pub SystemNameLength: DWORD,
    pub SystemNameOffset: DWORD,
}
pub type PERF_DATA_BLOCK = _PERF_DATA_BLOCK;
pub type PPERF_DATA_BLOCK = *mut _PERF_DATA_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERF_OBJECT_TYPE {
    pub TotalByteLength: DWORD,
    pub DefinitionLength: DWORD,
    pub HeaderLength: DWORD,
    pub ObjectNameTitleIndex: DWORD,
    pub ObjectNameTitle: DWORD,
    pub ObjectHelpTitleIndex: DWORD,
    pub ObjectHelpTitle: DWORD,
    pub DetailLevel: DWORD,
    pub NumCounters: DWORD,
    pub DefaultCounter: LONG,
    pub NumInstances: LONG,
    pub CodePage: DWORD,
    pub PerfTime: LARGE_INTEGER,
    pub PerfFreq: LARGE_INTEGER,
}
pub type PERF_OBJECT_TYPE = _PERF_OBJECT_TYPE;
pub type PPERF_OBJECT_TYPE = *mut _PERF_OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERF_COUNTER_DEFINITION {
    pub ByteLength: DWORD,
    pub CounterNameTitleIndex: DWORD,
    pub CounterNameTitle: DWORD,
    pub CounterHelpTitleIndex: DWORD,
    pub CounterHelpTitle: DWORD,
    pub DefaultScale: LONG,
    pub DetailLevel: DWORD,
    pub CounterType: DWORD,
    pub CounterSize: DWORD,
    pub CounterOffset: DWORD,
}
pub type PERF_COUNTER_DEFINITION = _PERF_COUNTER_DEFINITION;
pub type PPERF_COUNTER_DEFINITION = *mut _PERF_COUNTER_DEFINITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERF_INSTANCE_DEFINITION {
    pub ByteLength: DWORD,
    pub ParentObjectTitleIndex: DWORD,
    pub ParentObjectInstance: DWORD,
    pub UniqueID: LONG,
    pub NameOffset: DWORD,
    pub NameLength: DWORD,
}
pub type PERF_INSTANCE_DEFINITION = _PERF_INSTANCE_DEFINITION;
pub type PPERF_INSTANCE_DEFINITION = *mut _PERF_INSTANCE_DEFINITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERF_COUNTER_BLOCK {
    pub ByteLength: DWORD,
}
pub type PERF_COUNTER_BLOCK = _PERF_COUNTER_BLOCK;
pub type PPERF_COUNTER_BLOCK = *mut _PERF_COUNTER_BLOCK;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type SOCKET = UINT_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fd_count: u_int,
    pub fd_array: [SOCKET; 64usize],
}
extern "C" {
    pub fn __WSAFDIsSet(arg1: SOCKET, arg2: *mut fd_set) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_short,
    pub h_length: ::std::os::raw::c_short,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_short,
    pub n_net: u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_proto: *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub S_un: in_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in_addr__bindgen_ty_1 {
    pub S_un_b: in_addr__bindgen_ty_1__bindgen_ty_1,
    pub S_un_w: in_addr__bindgen_ty_1__bindgen_ty_2,
    pub S_addr: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_1 {
    pub s_b1: UCHAR,
    pub s_b2: UCHAR,
    pub s_b3: UCHAR,
    pub s_b4: UCHAR,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_2 {
    pub s_w1: USHORT,
    pub s_w2: USHORT,
}
pub type IN_ADDR = in_addr;
pub type PIN_ADDR = *mut in_addr;
pub type LPIN_ADDR = *mut in_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: ::std::os::raw::c_short,
    pub sin_port: u_short,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WSAData {
    pub wVersion: WORD,
    pub wHighVersion: WORD,
    pub iMaxSockets: ::std::os::raw::c_ushort,
    pub iMaxUdpDg: ::std::os::raw::c_ushort,
    pub lpVendorInfo: *mut ::std::os::raw::c_char,
    pub szDescription: [::std::os::raw::c_char; 257usize],
    pub szSystemStatus: [::std::os::raw::c_char; 129usize],
}
pub type WSADATA = WSAData;
pub type LPWSADATA = *mut WSADATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: u_short,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: u_short,
    pub sp_protocol: u_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: u_short,
    pub l_linger: u_short,
}
extern "C" {
    pub fn accept(s: SOCKET, addr: *mut sockaddr, addrlen: *mut ::std::os::raw::c_int) -> SOCKET;
}
extern "C" {
    pub fn bind(
        s: SOCKET,
        addr: *const sockaddr,
        namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closesocket(s: SOCKET) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        s: SOCKET,
        name: *const sockaddr,
        namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioctlsocket(
        s: SOCKET,
        cmd: ::std::os::raw::c_long,
        argp: *mut u_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        s: SOCKET,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        s: SOCKET,
        name: *mut sockaddr,
        namelen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        s: SOCKET,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_char,
        optlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn htonl(hostlong: u_long) -> u_long;
}
extern "C" {
    pub fn htons(hostshort: u_short) -> u_short;
}
extern "C" {
    pub fn inet_addr(cp: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn inet_ntoa(in_: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn listen(s: SOCKET, backlog: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ntohl(netlong: u_long) -> u_long;
}
extern "C" {
    pub fn ntohs(netshort: u_short) -> u_short;
}
extern "C" {
    pub fn recv(
        s: SOCKET,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvfrom(
        s: SOCKET,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        from: *mut sockaddr,
        fromlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        nfds: ::std::os::raw::c_int,
        readfds: *mut fd_set,
        writefds: *mut fd_set,
        exceptfds: *mut fd_set,
        timeout: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        s: SOCKET,
        buf: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendto(
        s: SOCKET,
        buf: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        to: *const sockaddr,
        tolen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        s: SOCKET,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *const ::std::os::raw::c_char,
        optlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(s: SOCKET, how: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        af: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> SOCKET;
}
extern "C" {
    pub fn gethostbyaddr(
        addr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostname(
        name: *mut ::std::os::raw::c_char,
        namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyport(
        port: ::std::os::raw::c_int,
        proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyname(
        name: *const ::std::os::raw::c_char,
        proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getprotobynumber(proto: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(name: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn WSAStartup(wVersionRequired: WORD, lpWSAData: LPWSADATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSACleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSASetLastError(iError: ::std::os::raw::c_int);
}
extern "C" {
    pub fn WSAGetLastError() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSAIsBlocking() -> BOOL;
}
extern "C" {
    pub fn WSAUnhookBlockingHook() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSASetBlockingHook(lpBlockFunc: FARPROC) -> FARPROC;
}
extern "C" {
    pub fn WSACancelBlockingCall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSAAsyncGetServByName(
        hWnd: HWND,
        wMsg: u_int,
        name: *const ::std::os::raw::c_char,
        proto: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> HANDLE;
}
extern "C" {
    pub fn WSAAsyncGetServByPort(
        hWnd: HWND,
        wMsg: u_int,
        port: ::std::os::raw::c_int,
        proto: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> HANDLE;
}
extern "C" {
    pub fn WSAAsyncGetProtoByName(
        hWnd: HWND,
        wMsg: u_int,
        name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> HANDLE;
}
extern "C" {
    pub fn WSAAsyncGetProtoByNumber(
        hWnd: HWND,
        wMsg: u_int,
        number: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> HANDLE;
}
extern "C" {
    pub fn WSAAsyncGetHostByName(
        hWnd: HWND,
        wMsg: u_int,
        name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> HANDLE;
}
extern "C" {
    pub fn WSAAsyncGetHostByAddr(
        hWnd: HWND,
        wMsg: u_int,
        addr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> HANDLE;
}
extern "C" {
    pub fn WSACancelAsyncRequest(hAsyncTaskHandle: HANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSAAsyncSelect(
        s: SOCKET,
        hWnd: HWND,
        wMsg: u_int,
        lEvent: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WSARecvEx(
        s: SOCKET,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSMIT_FILE_BUFFERS {
    pub Head: PVOID,
    pub HeadLength: DWORD,
    pub Tail: PVOID,
    pub TailLength: DWORD,
}
pub type TRANSMIT_FILE_BUFFERS = _TRANSMIT_FILE_BUFFERS;
pub type PTRANSMIT_FILE_BUFFERS = *mut _TRANSMIT_FILE_BUFFERS;
pub type LPTRANSMIT_FILE_BUFFERS = *mut _TRANSMIT_FILE_BUFFERS;
extern "C" {
    pub fn TransmitFile(
        hSocket: SOCKET,
        hFile: HANDLE,
        nNumberOfBytesToWrite: DWORD,
        nNumberOfBytesPerSend: DWORD,
        lpOverlapped: LPOVERLAPPED,
        lpTransmitBuffers: LPTRANSMIT_FILE_BUFFERS,
        dwReserved: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AcceptEx(
        sListenSocket: SOCKET,
        sAcceptSocket: SOCKET,
        lpOutputBuffer: PVOID,
        dwReceiveDataLength: DWORD,
        dwLocalAddressLength: DWORD,
        dwRemoteAddressLength: DWORD,
        lpdwBytesReceived: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn GetAcceptExSockaddrs(
        lpOutputBuffer: PVOID,
        dwReceiveDataLength: DWORD,
        dwLocalAddressLength: DWORD,
        dwRemoteAddressLength: DWORD,
        LocalSockaddr: *mut *mut sockaddr,
        LocalSockaddrLength: LPINT,
        RemoteSockaddr: *mut *mut sockaddr,
        RemoteSockaddrLength: LPINT,
    );
}
pub type SOCKADDR = sockaddr;
pub type PSOCKADDR = *mut sockaddr;
pub type LPSOCKADDR = *mut sockaddr;
pub type SOCKADDR_IN = sockaddr_in;
pub type PSOCKADDR_IN = *mut sockaddr_in;
pub type LPSOCKADDR_IN = *mut sockaddr_in;
pub type LINGER = linger;
pub type PLINGER = *mut linger;
pub type LPLINGER = *mut linger;
pub type FD_SET = fd_set;
pub type PFD_SET = *mut fd_set;
pub type LPFD_SET = *mut fd_set;
pub type HOSTENT = hostent;
pub type PHOSTENT = *mut hostent;
pub type LPHOSTENT = *mut hostent;
pub type SERVENT = servent;
pub type PSERVENT = *mut servent;
pub type LPSERVENT = *mut servent;
pub type PROTOENT = protoent;
pub type PPROTOENT = *mut protoent;
pub type LPPROTOENT = *mut protoent;
pub type TIMEVAL = timeval;
pub type PTIMEVAL = *mut timeval;
pub type LPTIMEVAL = *mut timeval;
pub type ALG_ID = ::std::os::raw::c_uint;
pub type HCRYPTPROV = ULONG_PTR;
pub type HCRYPTKEY = ULONG_PTR;
pub type HCRYPTHASH = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMS_KEY_INFO {
    pub dwVersion: DWORD,
    pub Algid: ALG_ID,
    pub pbOID: *mut BYTE,
    pub cbOID: DWORD,
}
pub type CMS_KEY_INFO = _CMS_KEY_INFO;
pub type PCMS_KEY_INFO = *mut _CMS_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HMAC_Info {
    pub HashAlgid: ALG_ID,
    pub pbInnerString: *mut BYTE,
    pub cbInnerString: DWORD,
    pub pbOuterString: *mut BYTE,
    pub cbOuterString: DWORD,
}
pub type HMAC_INFO = _HMAC_Info;
pub type PHMAC_INFO = *mut _HMAC_Info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCHANNEL_ALG {
    pub dwUse: DWORD,
    pub Algid: ALG_ID,
    pub cBits: DWORD,
    pub dwFlags: DWORD,
    pub dwReserved: DWORD,
}
pub type SCHANNEL_ALG = _SCHANNEL_ALG;
pub type PSCHANNEL_ALG = *mut _SCHANNEL_ALG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROV_ENUMALGS {
    pub aiAlgid: ALG_ID,
    pub dwBitLen: DWORD,
    pub dwNameLen: DWORD,
    pub szName: [CHAR; 20usize],
}
pub type PROV_ENUMALGS = _PROV_ENUMALGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROV_ENUMALGS_EX {
    pub aiAlgid: ALG_ID,
    pub dwDefaultLen: DWORD,
    pub dwMinLen: DWORD,
    pub dwMaxLen: DWORD,
    pub dwProtocols: DWORD,
    pub dwNameLen: DWORD,
    pub szName: [CHAR; 20usize],
    pub dwLongNameLen: DWORD,
    pub szLongName: [CHAR; 40usize],
}
pub type PROV_ENUMALGS_EX = _PROV_ENUMALGS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PUBLICKEYSTRUC {
    pub bType: BYTE,
    pub bVersion: BYTE,
    pub reserved: WORD,
    pub aiKeyAlg: ALG_ID,
}
pub type BLOBHEADER = _PUBLICKEYSTRUC;
pub type PUBLICKEYSTRUC = _PUBLICKEYSTRUC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RSAPUBKEY {
    pub magic: DWORD,
    pub bitlen: DWORD,
    pub pubexp: DWORD,
}
pub type RSAPUBKEY = _RSAPUBKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PUBKEY {
    pub magic: DWORD,
    pub bitlen: DWORD,
}
pub type DHPUBKEY = _PUBKEY;
pub type DSSPUBKEY = _PUBKEY;
pub type KEAPUBKEY = _PUBKEY;
pub type TEKPUBKEY = _PUBKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DSSSEED {
    pub counter: DWORD,
    pub seed: [BYTE; 20usize],
}
pub type DSSSEED = _DSSSEED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PUBKEYVER3 {
    pub magic: DWORD,
    pub bitlenP: DWORD,
    pub bitlenQ: DWORD,
    pub bitlenJ: DWORD,
    pub DSSSeed: DSSSEED,
}
pub type DHPUBKEY_VER3 = _PUBKEYVER3;
pub type DSSPUBKEY_VER3 = _PUBKEYVER3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVKEYVER3 {
    pub magic: DWORD,
    pub bitlenP: DWORD,
    pub bitlenQ: DWORD,
    pub bitlenJ: DWORD,
    pub bitlenX: DWORD,
    pub DSSSeed: DSSSEED,
}
pub type DHPRIVKEY_VER3 = _PRIVKEYVER3;
pub type DSSPRIVKEY_VER3 = _PRIVKEYVER3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_TYPE_SUBTYPE {
    pub dwKeySpec: DWORD,
    pub Type: GUID,
    pub Subtype: GUID,
}
pub type KEY_TYPE_SUBTYPE = _KEY_TYPE_SUBTYPE;
pub type PKEY_TYPE_SUBTYPE = *mut _KEY_TYPE_SUBTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_FORTEZZA_DATA_PROP {
    pub SerialNumber: [::std::os::raw::c_uchar; 8usize],
    pub CertIndex: ::std::os::raw::c_int,
    pub CertLabel: [::std::os::raw::c_uchar; 36usize],
}
pub type CERT_FORTEZZA_DATA_PROP = _CERT_FORTEZZA_DATA_PROP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_RC4_KEY_STATE {
    pub Key: [::std::os::raw::c_uchar; 16usize],
    pub SBox: [::std::os::raw::c_uchar; 256usize],
    pub i: ::std::os::raw::c_uchar,
    pub j: ::std::os::raw::c_uchar,
}
pub type CRYPT_RC4_KEY_STATE = _CRYPT_RC4_KEY_STATE;
pub type PCRYPT_RC4_KEY_STATE = *mut _CRYPT_RC4_KEY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_DES_KEY_STATE {
    pub Key: [::std::os::raw::c_uchar; 8usize],
    pub IV: [::std::os::raw::c_uchar; 8usize],
    pub Feedback: [::std::os::raw::c_uchar; 8usize],
}
pub type CRYPT_DES_KEY_STATE = _CRYPT_DES_KEY_STATE;
pub type PCRYPT_DES_KEY_STATE = *mut _CRYPT_DES_KEY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_3DES_KEY_STATE {
    pub Key: [::std::os::raw::c_uchar; 24usize],
    pub IV: [::std::os::raw::c_uchar; 8usize],
    pub Feedback: [::std::os::raw::c_uchar; 8usize],
}
pub type CRYPT_3DES_KEY_STATE = _CRYPT_3DES_KEY_STATE;
pub type PCRYPT_3DES_KEY_STATE = *mut _CRYPT_3DES_KEY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_AES_128_KEY_STATE {
    pub Key: [::std::os::raw::c_uchar; 16usize],
    pub IV: [::std::os::raw::c_uchar; 16usize],
    pub EncryptionState: [[::std::os::raw::c_uchar; 16usize]; 11usize],
    pub DecryptionState: [[::std::os::raw::c_uchar; 16usize]; 11usize],
    pub Feedback: [::std::os::raw::c_uchar; 16usize],
}
pub type CRYPT_AES_128_KEY_STATE = _CRYPT_AES_128_KEY_STATE;
pub type PCRYPT_AES_128_KEY_STATE = *mut _CRYPT_AES_128_KEY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_AES_256_KEY_STATE {
    pub Key: [::std::os::raw::c_uchar; 32usize],
    pub IV: [::std::os::raw::c_uchar; 16usize],
    pub EncryptionState: [[::std::os::raw::c_uchar; 16usize]; 15usize],
    pub DecryptionState: [[::std::os::raw::c_uchar; 16usize]; 15usize],
    pub Feedback: [::std::os::raw::c_uchar; 16usize],
}
pub type CRYPT_AES_256_KEY_STATE = _CRYPT_AES_256_KEY_STATE;
pub type PCRYPT_AES_256_KEY_STATE = *mut _CRYPT_AES_256_KEY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPTOAPI_BLOB {
    pub cbData: DWORD,
    pub pbData: *mut BYTE,
}
pub type CRYPT_INTEGER_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_INTEGER_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_UINT_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_UINT_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_OBJID_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_OBJID_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CERT_NAME_BLOB = _CRYPTOAPI_BLOB;
pub type PCERT_NAME_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CERT_RDN_VALUE_BLOB = _CRYPTOAPI_BLOB;
pub type PCERT_RDN_VALUE_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CERT_BLOB = _CRYPTOAPI_BLOB;
pub type PCERT_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRL_BLOB = _CRYPTOAPI_BLOB;
pub type PCRL_BLOB = *mut _CRYPTOAPI_BLOB;
pub type DATA_BLOB = _CRYPTOAPI_BLOB;
pub type PDATA_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_DATA_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_DATA_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_HASH_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_HASH_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_DIGEST_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_DIGEST_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_DER_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_DER_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_ATTR_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_ATTR_BLOB = *mut _CRYPTOAPI_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMS_DH_KEY_INFO {
    pub dwVersion: DWORD,
    pub Algid: ALG_ID,
    pub pszContentEncObjId: LPSTR,
    pub PubInfo: CRYPT_DATA_BLOB,
    pub pReserved: *mut ::std::os::raw::c_void,
}
pub type CMS_DH_KEY_INFO = _CMS_DH_KEY_INFO;
pub type PCMS_DH_KEY_INFO = *mut _CMS_DH_KEY_INFO;
extern "C" {
    pub fn CryptAcquireContextA(
        phProv: *mut HCRYPTPROV,
        szContainer: LPCSTR,
        szProvider: LPCSTR,
        dwProvType: DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptAcquireContextW(
        phProv: *mut HCRYPTPROV,
        szContainer: LPCWSTR,
        szProvider: LPCWSTR,
        dwProvType: DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptGenKey(
        hProv: HCRYPTPROV,
        Algid: ALG_ID,
        dwFlags: DWORD,
        phKey: *mut HCRYPTKEY,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDeriveKey(
        hProv: HCRYPTPROV,
        Algid: ALG_ID,
        hBaseData: HCRYPTHASH,
        dwFlags: DWORD,
        phKey: *mut HCRYPTKEY,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDestroyKey(hKey: HCRYPTKEY) -> BOOL;
}
extern "C" {
    pub fn CryptSetKeyParam(
        hKey: HCRYPTKEY,
        dwParam: DWORD,
        pbData: *const BYTE,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetKeyParam(
        hKey: HCRYPTKEY,
        dwParam: DWORD,
        pbData: *mut BYTE,
        pdwDataLen: *mut DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSetHashParam(
        hHash: HCRYPTHASH,
        dwParam: DWORD,
        pbData: *const BYTE,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetHashParam(
        hHash: HCRYPTHASH,
        dwParam: DWORD,
        pbData: *mut BYTE,
        pdwDataLen: *mut DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSetProvParam(
        hProv: HCRYPTPROV,
        dwParam: DWORD,
        pbData: *const BYTE,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetProvParam(
        hProv: HCRYPTPROV,
        dwParam: DWORD,
        pbData: *mut BYTE,
        pdwDataLen: *mut DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGenRandom(hProv: HCRYPTPROV, dwLen: DWORD, pbBuffer: *mut BYTE) -> BOOL;
}
extern "C" {
    pub fn CryptGetUserKey(hProv: HCRYPTPROV, dwKeySpec: DWORD, phUserKey: *mut HCRYPTKEY) -> BOOL;
}
extern "C" {
    pub fn CryptExportKey(
        hKey: HCRYPTKEY,
        hExpKey: HCRYPTKEY,
        dwBlobType: DWORD,
        dwFlags: DWORD,
        pbData: *mut BYTE,
        pdwDataLen: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptImportKey(
        hProv: HCRYPTPROV,
        pbData: *const BYTE,
        dwDataLen: DWORD,
        hPubKey: HCRYPTKEY,
        dwFlags: DWORD,
        phKey: *mut HCRYPTKEY,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEncrypt(
        hKey: HCRYPTKEY,
        hHash: HCRYPTHASH,
        Final: BOOL,
        dwFlags: DWORD,
        pbData: *mut BYTE,
        pdwDataLen: *mut DWORD,
        dwBufLen: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDecrypt(
        hKey: HCRYPTKEY,
        hHash: HCRYPTHASH,
        Final: BOOL,
        dwFlags: DWORD,
        pbData: *mut BYTE,
        pdwDataLen: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptCreateHash(
        hProv: HCRYPTPROV,
        Algid: ALG_ID,
        hKey: HCRYPTKEY,
        dwFlags: DWORD,
        phHash: *mut HCRYPTHASH,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashData(
        hHash: HCRYPTHASH,
        pbData: *const BYTE,
        dwDataLen: DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashSessionKey(hHash: HCRYPTHASH, hKey: HCRYPTKEY, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptDestroyHash(hHash: HCRYPTHASH) -> BOOL;
}
extern "C" {
    pub fn CryptSignHashA(
        hHash: HCRYPTHASH,
        dwKeySpec: DWORD,
        szDescription: LPCSTR,
        dwFlags: DWORD,
        pbSignature: *mut BYTE,
        pdwSigLen: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSignHashW(
        hHash: HCRYPTHASH,
        dwKeySpec: DWORD,
        szDescription: LPCWSTR,
        dwFlags: DWORD,
        pbSignature: *mut BYTE,
        pdwSigLen: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifySignatureA(
        hHash: HCRYPTHASH,
        pbSignature: *const BYTE,
        dwSigLen: DWORD,
        hPubKey: HCRYPTKEY,
        szDescription: LPCSTR,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifySignatureW(
        hHash: HCRYPTHASH,
        pbSignature: *const BYTE,
        dwSigLen: DWORD,
        hPubKey: HCRYPTKEY,
        szDescription: LPCWSTR,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSetProviderA(pszProvName: LPCSTR, dwProvType: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptSetProviderW(pszProvName: LPCWSTR, dwProvType: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptSetProviderExA(
        pszProvName: LPCSTR,
        dwProvType: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSetProviderExW(
        pszProvName: LPCWSTR,
        dwProvType: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetDefaultProviderA(
        dwProvType: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        pszProvName: LPSTR,
        pcbProvName: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetDefaultProviderW(
        dwProvType: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        pszProvName: LPWSTR,
        pcbProvName: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEnumProviderTypesA(
        dwIndex: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        pdwProvType: *mut DWORD,
        szTypeName: LPSTR,
        pcbTypeName: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEnumProviderTypesW(
        dwIndex: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        pdwProvType: *mut DWORD,
        szTypeName: LPWSTR,
        pcbTypeName: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEnumProvidersA(
        dwIndex: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        pdwProvType: *mut DWORD,
        szProvName: LPSTR,
        pcbProvName: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEnumProvidersW(
        dwIndex: DWORD,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        pdwProvType: *mut DWORD,
        szProvName: LPWSTR,
        pcbProvName: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptContextAddRef(hProv: HCRYPTPROV, pdwReserved: *mut DWORD, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptDuplicateKey(
        hKey: HCRYPTKEY,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        phKey: *mut HCRYPTKEY,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDuplicateHash(
        hHash: HCRYPTHASH,
        pdwReserved: *mut DWORD,
        dwFlags: DWORD,
        phHash: *mut HCRYPTHASH,
    ) -> BOOL;
}
extern "C" {
    pub fn GetEncSChannel(pData: *mut *mut BYTE, dwDecSize: *mut DWORD) -> BOOL;
}
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __BCRYPT_KEY_LENGTHS_STRUCT {
    pub dwMinLength: ULONG,
    pub dwMaxLength: ULONG,
    pub dwIncrement: ULONG,
}
pub type BCRYPT_KEY_LENGTHS_STRUCT = __BCRYPT_KEY_LENGTHS_STRUCT;
pub type BCRYPT_AUTH_TAG_LENGTHS_STRUCT = BCRYPT_KEY_LENGTHS_STRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_OID {
    pub cbOID: ULONG,
    pub pbOID: PUCHAR,
}
pub type BCRYPT_OID = _BCRYPT_OID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_OID_LIST {
    pub dwOIDCount: ULONG,
    pub pOIDs: *mut BCRYPT_OID,
}
pub type BCRYPT_OID_LIST = _BCRYPT_OID_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_PKCS1_PADDING_INFO {
    pub pszAlgId: LPCWSTR,
}
pub type BCRYPT_PKCS1_PADDING_INFO = _BCRYPT_PKCS1_PADDING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_PSS_PADDING_INFO {
    pub pszAlgId: LPCWSTR,
    pub cbSalt: ULONG,
}
pub type BCRYPT_PSS_PADDING_INFO = _BCRYPT_PSS_PADDING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_OAEP_PADDING_INFO {
    pub pszAlgId: LPCWSTR,
    pub pbLabel: PUCHAR,
    pub cbLabel: ULONG,
}
pub type BCRYPT_OAEP_PADDING_INFO = _BCRYPT_OAEP_PADDING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO {
    pub cbSize: ULONG,
    pub dwInfoVersion: ULONG,
    pub pbNonce: PUCHAR,
    pub cbNonce: ULONG,
    pub pbAuthData: PUCHAR,
    pub cbAuthData: ULONG,
    pub pbTag: PUCHAR,
    pub cbTag: ULONG,
    pub pbMacContext: PUCHAR,
    pub cbMacContext: ULONG,
    pub cbAAD: ULONG,
    pub cbData: ULONGLONG,
    pub dwFlags: ULONG,
}
pub type BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;
pub type PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = *mut _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCryptBuffer {
    pub cbBuffer: ULONG,
    pub BufferType: ULONG,
    pub pvBuffer: PVOID,
}
pub type BCryptBuffer = _BCryptBuffer;
pub type PBCryptBuffer = *mut _BCryptBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCryptBufferDesc {
    pub ulVersion: ULONG,
    pub cBuffers: ULONG,
    pub pBuffers: PBCryptBuffer,
}
pub type BCryptBufferDesc = _BCryptBufferDesc;
pub type PBCryptBufferDesc = *mut _BCryptBufferDesc;
pub type BCRYPT_HANDLE = PVOID;
pub type BCRYPT_ALG_HANDLE = PVOID;
pub type BCRYPT_KEY_HANDLE = PVOID;
pub type BCRYPT_HASH_HANDLE = PVOID;
pub type BCRYPT_SECRET_HANDLE = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_KEY_BLOB {
    pub Magic: ULONG,
}
pub type BCRYPT_KEY_BLOB = _BCRYPT_KEY_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_RSAKEY_BLOB {
    pub Magic: ULONG,
    pub BitLength: ULONG,
    pub cbPublicExp: ULONG,
    pub cbModulus: ULONG,
    pub cbPrime1: ULONG,
    pub cbPrime2: ULONG,
}
pub type BCRYPT_RSAKEY_BLOB = _BCRYPT_RSAKEY_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_ECCKEY_BLOB {
    pub dwMagic: ULONG,
    pub cbKey: ULONG,
}
pub type BCRYPT_ECCKEY_BLOB = _BCRYPT_ECCKEY_BLOB;
pub type PBCRYPT_ECCKEY_BLOB = *mut _BCRYPT_ECCKEY_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_ECCKEY_BLOB {
    pub dwCurveType: ULONG,
    pub cbKey: ULONG,
}
pub type SSL_ECCKEY_BLOB = _SSL_ECCKEY_BLOB;
pub type PSSL_ECCKEY_BLOB = *mut _SSL_ECCKEY_BLOB;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECC_CURVE_TYPE_ENUM {
    BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 1,
    BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 2,
    BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ECC_CURVE_ALG_ID_ENUM {
    BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_ECCFULLKEY_BLOB {
    pub dwMagic: ULONG,
    pub dwVersion: ULONG,
    pub dwCurveType: ECC_CURVE_TYPE_ENUM,
    pub dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM,
    pub cbFieldLength: ULONG,
    pub cbSubgroupOrder: ULONG,
    pub cbCofactor: ULONG,
    pub cbSeed: ULONG,
}
pub type BCRYPT_ECCFULLKEY_BLOB = _BCRYPT_ECCFULLKEY_BLOB;
pub type PBCRYPT_ECCFULLKEY_BLOB = *mut _BCRYPT_ECCFULLKEY_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_DH_KEY_BLOB {
    pub dwMagic: ULONG,
    pub cbKey: ULONG,
}
pub type BCRYPT_DH_KEY_BLOB = _BCRYPT_DH_KEY_BLOB;
pub type PBCRYPT_DH_KEY_BLOB = *mut _BCRYPT_DH_KEY_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_DH_PARAMETER_HEADER {
    pub cbLength: ULONG,
    pub dwMagic: ULONG,
    pub cbKeyLength: ULONG,
}
pub type BCRYPT_DH_PARAMETER_HEADER = _BCRYPT_DH_PARAMETER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_DSA_KEY_BLOB {
    pub dwMagic: ULONG,
    pub cbKey: ULONG,
    pub Count: [UCHAR; 4usize],
    pub Seed: [UCHAR; 20usize],
    pub q: [UCHAR; 20usize],
}
pub type BCRYPT_DSA_KEY_BLOB = _BCRYPT_DSA_KEY_BLOB;
pub type PBCRYPT_DSA_KEY_BLOB = *mut _BCRYPT_DSA_KEY_BLOB;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HASHALGORITHM_ENUM {
    DSA_HASH_ALGORITHM_SHA1 = 0,
    DSA_HASH_ALGORITHM_SHA256 = 1,
    DSA_HASH_ALGORITHM_SHA512 = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DSAFIPSVERSION_ENUM {
    DSA_FIPS186_2 = 0,
    DSA_FIPS186_3 = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_DSA_KEY_BLOB_V2 {
    pub dwMagic: ULONG,
    pub cbKey: ULONG,
    pub hashAlgorithm: HASHALGORITHM_ENUM,
    pub standardVersion: DSAFIPSVERSION_ENUM,
    pub cbSeedLength: ULONG,
    pub cbGroupSize: ULONG,
    pub Count: [UCHAR; 4usize],
}
pub type BCRYPT_DSA_KEY_BLOB_V2 = _BCRYPT_DSA_KEY_BLOB_V2;
pub type PBCRYPT_DSA_KEY_BLOB_V2 = *mut _BCRYPT_DSA_KEY_BLOB_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_KEY_DATA_BLOB_HEADER {
    pub dwMagic: ULONG,
    pub dwVersion: ULONG,
    pub cbKeyData: ULONG,
}
pub type BCRYPT_KEY_DATA_BLOB_HEADER = _BCRYPT_KEY_DATA_BLOB_HEADER;
pub type PBCRYPT_KEY_DATA_BLOB_HEADER = *mut _BCRYPT_KEY_DATA_BLOB_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_DSA_PARAMETER_HEADER {
    pub cbLength: ULONG,
    pub dwMagic: ULONG,
    pub cbKeyLength: ULONG,
    pub Count: [UCHAR; 4usize],
    pub Seed: [UCHAR; 20usize],
    pub q: [UCHAR; 20usize],
}
pub type BCRYPT_DSA_PARAMETER_HEADER = _BCRYPT_DSA_PARAMETER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_DSA_PARAMETER_HEADER_V2 {
    pub cbLength: ULONG,
    pub dwMagic: ULONG,
    pub cbKeyLength: ULONG,
    pub hashAlgorithm: HASHALGORITHM_ENUM,
    pub standardVersion: DSAFIPSVERSION_ENUM,
    pub cbSeedLength: ULONG,
    pub cbGroupSize: ULONG,
    pub Count: [UCHAR; 4usize],
}
pub type BCRYPT_DSA_PARAMETER_HEADER_V2 = _BCRYPT_DSA_PARAMETER_HEADER_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_ECC_CURVE_NAMES {
    pub dwEccCurveNames: ULONG,
    pub pEccCurveNames: *mut LPWSTR,
}
pub type BCRYPT_ECC_CURVE_NAMES = _BCRYPT_ECC_CURVE_NAMES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BCRYPT_HASH_OPERATION_TYPE {
    BCRYPT_HASH_OPERATION_HASH_DATA = 1,
    BCRYPT_HASH_OPERATION_FINISH_HASH = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_MULTI_HASH_OPERATION {
    pub iHash: ULONG,
    pub hashOperation: BCRYPT_HASH_OPERATION_TYPE,
    pub pbBuffer: PUCHAR,
    pub cbBuffer: ULONG,
}
pub type BCRYPT_MULTI_HASH_OPERATION = _BCRYPT_MULTI_HASH_OPERATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BCRYPT_MULTI_OPERATION_TYPE {
    BCRYPT_OPERATION_TYPE_HASH = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_MULTI_OBJECT_LENGTH_STRUCT {
    pub cbPerObject: ULONG,
    pub cbPerElement: ULONG,
}
pub type BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = _BCRYPT_MULTI_OBJECT_LENGTH_STRUCT;
extern "C" {
    pub fn BCryptOpenAlgorithmProvider(
        phAlgorithm: *mut BCRYPT_ALG_HANDLE,
        pszAlgId: LPCWSTR,
        pszImplementation: LPCWSTR,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_ALGORITHM_IDENTIFIER {
    pub pszName: LPWSTR,
    pub dwClass: ULONG,
    pub dwFlags: ULONG,
}
pub type BCRYPT_ALGORITHM_IDENTIFIER = _BCRYPT_ALGORITHM_IDENTIFIER;
extern "C" {
    pub fn BCryptEnumAlgorithms(
        dwAlgOperations: ULONG,
        pAlgCount: *mut ULONG,
        ppAlgList: *mut *mut BCRYPT_ALGORITHM_IDENTIFIER,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_PROVIDER_NAME {
    pub pszProviderName: LPWSTR,
}
pub type BCRYPT_PROVIDER_NAME = _BCRYPT_PROVIDER_NAME;
extern "C" {
    pub fn BCryptEnumProviders(
        pszAlgId: LPCWSTR,
        pImplCount: *mut ULONG,
        ppImplList: *mut *mut BCRYPT_PROVIDER_NAME,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptGetProperty(
        hObject: BCRYPT_HANDLE,
        pszProperty: LPCWSTR,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptSetProperty(
        hObject: BCRYPT_HANDLE,
        pszProperty: LPCWSTR,
        pbInput: PUCHAR,
        cbInput: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptCloseAlgorithmProvider(hAlgorithm: BCRYPT_ALG_HANDLE, dwFlags: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptFreeBuffer(pvBuffer: PVOID);
}
extern "C" {
    pub fn BCryptGenerateSymmetricKey(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        phKey: *mut BCRYPT_KEY_HANDLE,
        pbKeyObject: PUCHAR,
        cbKeyObject: ULONG,
        pbSecret: PUCHAR,
        cbSecret: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptGenerateKeyPair(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        phKey: *mut BCRYPT_KEY_HANDLE,
        dwLength: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptEncrypt(
        hKey: BCRYPT_KEY_HANDLE,
        pbInput: PUCHAR,
        cbInput: ULONG,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbIV: PUCHAR,
        cbIV: ULONG,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDecrypt(
        hKey: BCRYPT_KEY_HANDLE,
        pbInput: PUCHAR,
        cbInput: ULONG,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbIV: PUCHAR,
        cbIV: ULONG,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptExportKey(
        hKey: BCRYPT_KEY_HANDLE,
        hExportKey: BCRYPT_KEY_HANDLE,
        pszBlobType: LPCWSTR,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptImportKey(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        hImportKey: BCRYPT_KEY_HANDLE,
        pszBlobType: LPCWSTR,
        phKey: *mut BCRYPT_KEY_HANDLE,
        pbKeyObject: PUCHAR,
        cbKeyObject: ULONG,
        pbInput: PUCHAR,
        cbInput: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptImportKeyPair(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        hImportKey: BCRYPT_KEY_HANDLE,
        pszBlobType: LPCWSTR,
        phKey: *mut BCRYPT_KEY_HANDLE,
        pbInput: PUCHAR,
        cbInput: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDuplicateKey(
        hKey: BCRYPT_KEY_HANDLE,
        phNewKey: *mut BCRYPT_KEY_HANDLE,
        pbKeyObject: PUCHAR,
        cbKeyObject: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptFinalizeKeyPair(hKey: BCRYPT_KEY_HANDLE, dwFlags: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDestroyKey(hKey: BCRYPT_KEY_HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDestroySecret(hSecret: BCRYPT_SECRET_HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptSignHash(
        hKey: BCRYPT_KEY_HANDLE,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbInput: PUCHAR,
        cbInput: ULONG,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptVerifySignature(
        hKey: BCRYPT_KEY_HANDLE,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbHash: PUCHAR,
        cbHash: ULONG,
        pbSignature: PUCHAR,
        cbSignature: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptSecretAgreement(
        hPrivKey: BCRYPT_KEY_HANDLE,
        hPubKey: BCRYPT_KEY_HANDLE,
        phAgreedSecret: *mut BCRYPT_SECRET_HANDLE,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDeriveKey(
        hSharedSecret: BCRYPT_SECRET_HANDLE,
        pwszKDF: LPCWSTR,
        pParameterList: *mut BCryptBufferDesc,
        pbDerivedKey: PUCHAR,
        cbDerivedKey: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptKeyDerivation(
        hKey: BCRYPT_KEY_HANDLE,
        pParameterList: *mut BCryptBufferDesc,
        pbDerivedKey: PUCHAR,
        cbDerivedKey: ULONG,
        pcbResult: *mut ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptCreateHash(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        phHash: *mut BCRYPT_HASH_HANDLE,
        pbHashObject: PUCHAR,
        cbHashObject: ULONG,
        pbSecret: PUCHAR,
        cbSecret: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptHashData(
        hHash: BCRYPT_HASH_HANDLE,
        pbInput: PUCHAR,
        cbInput: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptFinishHash(
        hHash: BCRYPT_HASH_HANDLE,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptCreateMultiHash(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        phHash: *mut BCRYPT_HASH_HANDLE,
        nHashes: ULONG,
        pbHashObject: PUCHAR,
        cbHashObject: ULONG,
        pbSecret: PUCHAR,
        cbSecret: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptProcessMultiOperations(
        hObject: BCRYPT_HANDLE,
        operationType: BCRYPT_MULTI_OPERATION_TYPE,
        pOperations: PVOID,
        cbOperations: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDuplicateHash(
        hHash: BCRYPT_HASH_HANDLE,
        phNewHash: *mut BCRYPT_HASH_HANDLE,
        pbHashObject: PUCHAR,
        cbHashObject: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDestroyHash(hHash: BCRYPT_HASH_HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptHash(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        pbSecret: PUCHAR,
        cbSecret: ULONG,
        pbInput: PUCHAR,
        cbInput: ULONG,
        pbOutput: PUCHAR,
        cbOutput: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptGenRandom(
        hAlgorithm: BCRYPT_ALG_HANDLE,
        pbBuffer: PUCHAR,
        cbBuffer: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDeriveKeyCapi(
        hHash: BCRYPT_HASH_HANDLE,
        hTargetAlg: BCRYPT_ALG_HANDLE,
        pbDerivedKey: PUCHAR,
        cbDerivedKey: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDeriveKeyPBKDF2(
        hPrf: BCRYPT_ALG_HANDLE,
        pbPassword: PUCHAR,
        cbPassword: ULONG,
        pbSalt: PUCHAR,
        cbSalt: ULONG,
        cIterations: ULONGLONG,
        pbDerivedKey: PUCHAR,
        cbDerivedKey: ULONG,
        dwFlags: ULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BCRYPT_INTERFACE_VERSION {
    pub MajorVersion: USHORT,
    pub MinorVersion: USHORT,
}
pub type BCRYPT_INTERFACE_VERSION = _BCRYPT_INTERFACE_VERSION;
pub type PBCRYPT_INTERFACE_VERSION = *mut _BCRYPT_INTERFACE_VERSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_INTERFACE_REG {
    pub dwInterface: ULONG,
    pub dwFlags: ULONG,
    pub cFunctions: ULONG,
    pub rgpszFunctions: *mut PWSTR,
}
pub type CRYPT_INTERFACE_REG = _CRYPT_INTERFACE_REG;
pub type PCRYPT_INTERFACE_REG = *mut _CRYPT_INTERFACE_REG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_IMAGE_REG {
    pub pszImage: PWSTR,
    pub cInterfaces: ULONG,
    pub rgpInterfaces: *mut PCRYPT_INTERFACE_REG,
}
pub type CRYPT_IMAGE_REG = _CRYPT_IMAGE_REG;
pub type PCRYPT_IMAGE_REG = *mut _CRYPT_IMAGE_REG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PROVIDER_REG {
    pub cAliases: ULONG,
    pub rgpszAliases: *mut PWSTR,
    pub pUM: PCRYPT_IMAGE_REG,
    pub pKM: PCRYPT_IMAGE_REG,
}
pub type CRYPT_PROVIDER_REG = _CRYPT_PROVIDER_REG;
pub type PCRYPT_PROVIDER_REG = *mut _CRYPT_PROVIDER_REG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PROVIDERS {
    pub cProviders: ULONG,
    pub rgpszProviders: *mut PWSTR,
}
pub type CRYPT_PROVIDERS = _CRYPT_PROVIDERS;
pub type PCRYPT_PROVIDERS = *mut _CRYPT_PROVIDERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTEXT_CONFIG {
    pub dwFlags: ULONG,
    pub dwReserved: ULONG,
}
pub type CRYPT_CONTEXT_CONFIG = _CRYPT_CONTEXT_CONFIG;
pub type PCRYPT_CONTEXT_CONFIG = *mut _CRYPT_CONTEXT_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTEXT_FUNCTION_CONFIG {
    pub dwFlags: ULONG,
    pub dwReserved: ULONG,
}
pub type CRYPT_CONTEXT_FUNCTION_CONFIG = _CRYPT_CONTEXT_FUNCTION_CONFIG;
pub type PCRYPT_CONTEXT_FUNCTION_CONFIG = *mut _CRYPT_CONTEXT_FUNCTION_CONFIG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTEXTS {
    pub cContexts: ULONG,
    pub rgpszContexts: *mut PWSTR,
}
pub type CRYPT_CONTEXTS = _CRYPT_CONTEXTS;
pub type PCRYPT_CONTEXTS = *mut _CRYPT_CONTEXTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTEXT_FUNCTIONS {
    pub cFunctions: ULONG,
    pub rgpszFunctions: *mut PWSTR,
}
pub type CRYPT_CONTEXT_FUNCTIONS = _CRYPT_CONTEXT_FUNCTIONS;
pub type PCRYPT_CONTEXT_FUNCTIONS = *mut _CRYPT_CONTEXT_FUNCTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS {
    pub cProviders: ULONG,
    pub rgpszProviders: *mut PWSTR,
}
pub type CRYPT_CONTEXT_FUNCTION_PROVIDERS = _CRYPT_CONTEXT_FUNCTION_PROVIDERS;
pub type PCRYPT_CONTEXT_FUNCTION_PROVIDERS = *mut _CRYPT_CONTEXT_FUNCTION_PROVIDERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PROPERTY_REF {
    pub pszProperty: PWSTR,
    pub cbValue: ULONG,
    pub pbValue: PUCHAR,
}
pub type CRYPT_PROPERTY_REF = _CRYPT_PROPERTY_REF;
pub type PCRYPT_PROPERTY_REF = *mut _CRYPT_PROPERTY_REF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_IMAGE_REF {
    pub pszImage: PWSTR,
    pub dwFlags: ULONG,
}
pub type CRYPT_IMAGE_REF = _CRYPT_IMAGE_REF;
pub type PCRYPT_IMAGE_REF = *mut _CRYPT_IMAGE_REF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PROVIDER_REF {
    pub dwInterface: ULONG,
    pub pszFunction: PWSTR,
    pub pszProvider: PWSTR,
    pub cProperties: ULONG,
    pub rgpProperties: *mut PCRYPT_PROPERTY_REF,
    pub pUM: PCRYPT_IMAGE_REF,
    pub pKM: PCRYPT_IMAGE_REF,
}
pub type CRYPT_PROVIDER_REF = _CRYPT_PROVIDER_REF;
pub type PCRYPT_PROVIDER_REF = *mut _CRYPT_PROVIDER_REF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PROVIDER_REFS {
    pub cProviders: ULONG,
    pub rgpProviders: *mut PCRYPT_PROVIDER_REF,
}
pub type CRYPT_PROVIDER_REFS = _CRYPT_PROVIDER_REFS;
pub type PCRYPT_PROVIDER_REFS = *mut _CRYPT_PROVIDER_REFS;
extern "C" {
    pub fn BCryptQueryProviderRegistration(
        pszProvider: LPCWSTR,
        dwMode: ULONG,
        dwInterface: ULONG,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_PROVIDER_REG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptEnumRegisteredProviders(
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_PROVIDERS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptCreateContext(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        pConfig: PCRYPT_CONTEXT_CONFIG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptDeleteContext(dwTable: ULONG, pszContext: LPCWSTR) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptEnumContexts(
        dwTable: ULONG,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_CONTEXTS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptConfigureContext(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        pConfig: PCRYPT_CONTEXT_CONFIG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptQueryContextConfiguration(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_CONTEXT_CONFIG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptAddContextFunction(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        dwPosition: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptRemoveContextFunction(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptEnumContextFunctions(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_CONTEXT_FUNCTIONS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptConfigureContextFunction(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        pConfig: PCRYPT_CONTEXT_FUNCTION_CONFIG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptQueryContextFunctionConfiguration(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_CONTEXT_FUNCTION_CONFIG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptEnumContextFunctionProviders(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_CONTEXT_FUNCTION_PROVIDERS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptSetContextFunctionProperty(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        pszProperty: LPCWSTR,
        cbValue: ULONG,
        pbValue: PUCHAR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptQueryContextFunctionProperty(
        dwTable: ULONG,
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        pszProperty: LPCWSTR,
        pcbValue: *mut ULONG,
        ppbValue: *mut PUCHAR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptRegisterConfigChangeNotify(phEvent: *mut HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptUnregisterConfigChangeNotify(hEvent: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptResolveProviders(
        pszContext: LPCWSTR,
        dwInterface: ULONG,
        pszFunction: LPCWSTR,
        pszProvider: LPCWSTR,
        dwMode: ULONG,
        dwFlags: ULONG,
        pcbBuffer: *mut ULONG,
        ppBuffer: *mut PCRYPT_PROVIDER_REFS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn BCryptGetFipsAlgorithmMode(pfEnabled: *mut BOOLEAN) -> NTSTATUS;
}
extern "C" {
    pub fn CngGetFipsAlgorithmMode() -> BOOLEAN;
}
pub type SECURITY_STATUS = LONG;
pub type PFN_NCRYPT_ALLOC = ::std::option::Option<unsafe extern "C" fn(cbSize: SIZE_T) -> LPVOID>;
pub type PFN_NCRYPT_FREE = ::std::option::Option<unsafe extern "C" fn(pv: LPVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NCRYPT_ALLOC_PARA {
    pub cbSize: DWORD,
    pub pfnAlloc: PFN_NCRYPT_ALLOC,
    pub pfnFree: PFN_NCRYPT_FREE,
}
pub type NCryptBuffer = BCryptBuffer;
pub type PNCryptBuffer = *mut BCryptBuffer;
pub type NCryptBufferDesc = BCryptBufferDesc;
pub type PNCryptBufferDesc = *mut BCryptBufferDesc;
pub type NCRYPT_HANDLE = ULONG_PTR;
pub type NCRYPT_PROV_HANDLE = ULONG_PTR;
pub type NCRYPT_KEY_HANDLE = ULONG_PTR;
pub type NCRYPT_HASH_HANDLE = ULONG_PTR;
pub type NCRYPT_SECRET_HANDLE = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_CIPHER_PADDING_INFO {
    pub cbSize: ULONG,
    pub dwFlags: DWORD,
    pub pbIV: PUCHAR,
    pub cbIV: ULONG,
    pub pbOtherInfo: PUCHAR,
    pub cbOtherInfo: ULONG,
}
pub type NCRYPT_CIPHER_PADDING_INFO = _NCRYPT_CIPHER_PADDING_INFO;
pub type PNCRYPT_CIPHER_PADDING_INFO = *mut _NCRYPT_CIPHER_PADDING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_PLATFORM_ATTEST_PADDING_INFO {
    pub magic: ULONG,
    pub pcrMask: ULONG,
}
pub type NCRYPT_PLATFORM_ATTEST_PADDING_INFO = _NCRYPT_PLATFORM_ATTEST_PADDING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_KEY_ATTEST_PADDING_INFO {
    pub magic: ULONG,
    pub pbKeyBlob: PUCHAR,
    pub cbKeyBlob: ULONG,
    pub pbKeyAuth: PUCHAR,
    pub cbKeyAuth: ULONG,
}
pub type NCRYPT_KEY_ATTEST_PADDING_INFO = _NCRYPT_KEY_ATTEST_PADDING_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES {
    pub Version: ULONG,
    pub Flags: ULONG,
    pub cbPublicKeyBlob: ULONG,
}
pub type NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES;
pub type PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = *mut _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT {
    pub Magic: ULONG,
    pub Version: ULONG,
    pub cbSignature: ULONG,
    pub cbReport: ULONG,
    pub cbAttributes: ULONG,
}
pub type NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT;
pub type PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT = *mut _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS {
    pub Version: ULONG,
    pub TrustletId: ULONGLONG,
    pub MinSvn: ULONG,
    pub FlagsMask: ULONG,
    pub FlagsExpected: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS {
    #[inline]
    pub fn AllowDebugging(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowDebugging(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowDebugging: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowDebugging: u32 = unsafe { ::std::mem::transmute(AllowDebugging) };
            AllowDebugging as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS =
    _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS;
pub type PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS =
    *mut _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER {
    pub Version: ULONG,
    pub KeyUsage: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cbAlgName: ULONG,
    pub cbNonce: ULONG,
    pub cbAuthTag: ULONG,
    pub cbWrappingKey: ULONG,
    pub cbIsolatedKey: ULONG,
}
impl _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER {
    #[inline]
    pub fn PerBootKey(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerBootKey(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PerBootKey: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PerBootKey: u32 = unsafe { ::std::mem::transmute(PerBootKey) };
            PerBootKey as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER;
pub type PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER = *mut _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE {
    pub Header: NCRYPT_EXPORTED_ISOLATED_KEY_HEADER,
}
pub type NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE;
pub type PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = *mut _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT {
    pub Magic: UINT32,
    pub Version: UINT32,
    pub HeaderSize: UINT32,
    pub cbCertifyInfo: UINT32,
    pub cbSignature: UINT32,
    pub cbTpmPublic: UINT32,
}
pub type NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT =
    __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT;
pub type PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT =
    *mut __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT {
    pub Magic: ULONG,
    pub Version: ULONG,
    pub pcrAlg: ULONG,
    pub cbSignature: ULONG,
    pub cbQuote: ULONG,
    pub cbPcrs: ULONG,
}
pub type NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT;
pub type PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT =
    *mut _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT;
extern "C" {
    pub fn NCryptOpenStorageProvider(
        phProvider: *mut NCRYPT_PROV_HANDLE,
        pszProviderName: LPCWSTR,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCryptAlgorithmName {
    pub pszName: LPWSTR,
    pub dwClass: DWORD,
    pub dwAlgOperations: DWORD,
    pub dwFlags: DWORD,
}
pub type NCryptAlgorithmName = _NCryptAlgorithmName;
extern "C" {
    pub fn NCryptEnumAlgorithms(
        hProvider: NCRYPT_PROV_HANDLE,
        dwAlgOperations: DWORD,
        pdwAlgCount: *mut DWORD,
        ppAlgList: *mut *mut NCryptAlgorithmName,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptIsAlgSupported(
        hProvider: NCRYPT_PROV_HANDLE,
        pszAlgId: LPCWSTR,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NCryptKeyName {
    pub pszName: LPWSTR,
    pub pszAlgid: LPWSTR,
    pub dwLegacyKeySpec: DWORD,
    pub dwFlags: DWORD,
}
extern "C" {
    pub fn NCryptEnumKeys(
        hProvider: NCRYPT_PROV_HANDLE,
        pszScope: LPCWSTR,
        ppKeyName: *mut *mut NCryptKeyName,
        ppEnumState: *mut PVOID,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NCryptProviderName {
    pub pszName: LPWSTR,
    pub pszComment: LPWSTR,
}
extern "C" {
    pub fn NCryptEnumStorageProviders(
        pdwProviderCount: *mut DWORD,
        ppProviderList: *mut *mut NCryptProviderName,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptFreeBuffer(pvInput: PVOID) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptOpenKey(
        hProvider: NCRYPT_PROV_HANDLE,
        phKey: *mut NCRYPT_KEY_HANDLE,
        pszKeyName: LPCWSTR,
        dwLegacyKeySpec: DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptCreatePersistedKey(
        hProvider: NCRYPT_PROV_HANDLE,
        phKey: *mut NCRYPT_KEY_HANDLE,
        pszAlgId: LPCWSTR,
        pszKeyName: LPCWSTR,
        dwLegacyKeySpec: DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_UI_POLICY {
    pub dwVersion: DWORD,
    pub dwFlags: DWORD,
    pub pszCreationTitle: LPCWSTR,
    pub pszFriendlyName: LPCWSTR,
    pub pszDescription: LPCWSTR,
}
pub type NCRYPT_UI_POLICY = __NCRYPT_UI_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_KEY_ACCESS_POLICY_BLOB {
    pub dwVersion: DWORD,
    pub dwPolicyFlags: DWORD,
    pub cbUserSid: DWORD,
    pub cbApplicationSid: DWORD,
}
pub type NCRYPT_KEY_ACCESS_POLICY_BLOB = __NCRYPT_KEY_ACCESS_POLICY_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_SUPPORTED_LENGTHS {
    pub dwMinLength: DWORD,
    pub dwMaxLength: DWORD,
    pub dwIncrement: DWORD,
    pub dwDefaultLength: DWORD,
}
pub type NCRYPT_SUPPORTED_LENGTHS = __NCRYPT_SUPPORTED_LENGTHS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO {
    pub dwVersion: DWORD,
    pub iExpiration: INT32,
    pub pabNonce: [BYTE; 32usize],
    pub pabPolicyRef: [BYTE; 32usize],
    pub pabHMAC: [BYTE; 32usize],
}
pub type NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = __NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_PCP_TPM_FW_VERSION_INFO {
    pub major1: UINT16,
    pub major2: UINT16,
    pub minor1: UINT16,
    pub minor2: UINT16,
}
pub type NCRYPT_PCP_TPM_FW_VERSION_INFO = __NCRYPT_PCP_TPM_FW_VERSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NCRYPT_PCP_RAW_POLICYDIGEST {
    pub dwVersion: DWORD,
    pub cbDigest: DWORD,
}
pub type NCRYPT_PCP_RAW_POLICYDIGEST_INFO = __NCRYPT_PCP_RAW_POLICYDIGEST;
extern "C" {
    pub fn NCryptGetProperty(
        hObject: NCRYPT_HANDLE,
        pszProperty: LPCWSTR,
        pbOutput: PBYTE,
        cbOutput: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptSetProperty(
        hObject: NCRYPT_HANDLE,
        pszProperty: LPCWSTR,
        pbInput: PBYTE,
        cbInput: DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptFinalizeKey(hKey: NCRYPT_KEY_HANDLE, dwFlags: DWORD) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptEncrypt(
        hKey: NCRYPT_KEY_HANDLE,
        pbInput: PBYTE,
        cbInput: DWORD,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbOutput: PBYTE,
        cbOutput: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptDecrypt(
        hKey: NCRYPT_KEY_HANDLE,
        pbInput: PBYTE,
        cbInput: DWORD,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbOutput: PBYTE,
        cbOutput: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NCRYPT_KEY_BLOB_HEADER {
    pub cbSize: ULONG,
    pub dwMagic: ULONG,
    pub cbAlgName: ULONG,
    pub cbKeyData: ULONG,
}
pub type NCRYPT_KEY_BLOB_HEADER = _NCRYPT_KEY_BLOB_HEADER;
pub type PNCRYPT_KEY_BLOB_HEADER = *mut _NCRYPT_KEY_BLOB_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER {
    pub magic: DWORD,
    pub cbHeader: DWORD,
    pub cbPublic: DWORD,
    pub cbPrivate: DWORD,
    pub cbName: DWORD,
}
pub type PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = *mut NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER;
extern "C" {
    pub fn NCryptImportKey(
        hProvider: NCRYPT_PROV_HANDLE,
        hImportKey: NCRYPT_KEY_HANDLE,
        pszBlobType: LPCWSTR,
        pParameterList: *mut NCryptBufferDesc,
        phKey: *mut NCRYPT_KEY_HANDLE,
        pbData: PBYTE,
        cbData: DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptExportKey(
        hKey: NCRYPT_KEY_HANDLE,
        hExportKey: NCRYPT_KEY_HANDLE,
        pszBlobType: LPCWSTR,
        pParameterList: *mut NCryptBufferDesc,
        pbOutput: PBYTE,
        cbOutput: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptSignHash(
        hKey: NCRYPT_KEY_HANDLE,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbHashValue: PBYTE,
        cbHashValue: DWORD,
        pbSignature: PBYTE,
        cbSignature: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptVerifySignature(
        hKey: NCRYPT_KEY_HANDLE,
        pPaddingInfo: *mut ::std::os::raw::c_void,
        pbHashValue: PBYTE,
        cbHashValue: DWORD,
        pbSignature: PBYTE,
        cbSignature: DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptDeleteKey(hKey: NCRYPT_KEY_HANDLE, dwFlags: DWORD) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptFreeObject(hObject: NCRYPT_HANDLE) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptIsKeyHandle(hKey: NCRYPT_KEY_HANDLE) -> BOOL;
}
extern "C" {
    pub fn NCryptTranslateHandle(
        phProvider: *mut NCRYPT_PROV_HANDLE,
        phKey: *mut NCRYPT_KEY_HANDLE,
        hLegacyProv: HCRYPTPROV,
        hLegacyKey: HCRYPTKEY,
        dwLegacyKeySpec: DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptNotifyChangeKey(
        hProvider: NCRYPT_PROV_HANDLE,
        phEvent: *mut HANDLE,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptSecretAgreement(
        hPrivKey: NCRYPT_KEY_HANDLE,
        hPubKey: NCRYPT_KEY_HANDLE,
        phAgreedSecret: *mut NCRYPT_SECRET_HANDLE,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptDeriveKey(
        hSharedSecret: NCRYPT_SECRET_HANDLE,
        pwszKDF: LPCWSTR,
        pParameterList: *mut NCryptBufferDesc,
        pbDerivedKey: PBYTE,
        cbDerivedKey: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: ULONG,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptKeyDerivation(
        hKey: NCRYPT_KEY_HANDLE,
        pParameterList: *mut NCryptBufferDesc,
        pbDerivedKey: PUCHAR,
        cbDerivedKey: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: ULONG,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptCreateClaim(
        hSubjectKey: NCRYPT_KEY_HANDLE,
        hAuthorityKey: NCRYPT_KEY_HANDLE,
        dwClaimType: DWORD,
        pParameterList: *mut NCryptBufferDesc,
        pbClaimBlob: PBYTE,
        cbClaimBlob: DWORD,
        pcbResult: *mut DWORD,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
extern "C" {
    pub fn NCryptVerifyClaim(
        hSubjectKey: NCRYPT_KEY_HANDLE,
        hAuthorityKey: NCRYPT_KEY_HANDLE,
        dwClaimType: DWORD,
        pParameterList: *mut NCryptBufferDesc,
        pbClaimBlob: PBYTE,
        cbClaimBlob: DWORD,
        pOutput: *mut NCryptBufferDesc,
        dwFlags: DWORD,
    ) -> SECURITY_STATUS;
}
pub type HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = ULONG_PTR;
pub type HCRYPTPROV_LEGACY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_BIT_BLOB {
    pub cbData: DWORD,
    pub pbData: *mut BYTE,
    pub cUnusedBits: DWORD,
}
pub type CRYPT_BIT_BLOB = _CRYPT_BIT_BLOB;
pub type PCRYPT_BIT_BLOB = *mut _CRYPT_BIT_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ALGORITHM_IDENTIFIER {
    pub pszObjId: LPSTR,
    pub Parameters: CRYPT_OBJID_BLOB,
}
pub type CRYPT_ALGORITHM_IDENTIFIER = _CRYPT_ALGORITHM_IDENTIFIER;
pub type PCRYPT_ALGORITHM_IDENTIFIER = *mut _CRYPT_ALGORITHM_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_OBJID_TABLE {
    pub dwAlgId: DWORD,
    pub pszObjId: LPCSTR,
}
pub type CRYPT_OBJID_TABLE = _CRYPT_OBJID_TABLE;
pub type PCRYPT_OBJID_TABLE = *mut _CRYPT_OBJID_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_HASH_INFO {
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Hash: CRYPT_HASH_BLOB,
}
pub type CRYPT_HASH_INFO = _CRYPT_HASH_INFO;
pub type PCRYPT_HASH_INFO = *mut _CRYPT_HASH_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_EXTENSION {
    pub pszObjId: LPSTR,
    pub fCritical: BOOL,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type CERT_EXTENSION = _CERT_EXTENSION;
pub type PCERT_EXTENSION = *mut _CERT_EXTENSION;
pub type PCCERT_EXTENSION = *const CERT_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ATTRIBUTE_TYPE_VALUE {
    pub pszObjId: LPSTR,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type CRYPT_ATTRIBUTE_TYPE_VALUE = _CRYPT_ATTRIBUTE_TYPE_VALUE;
pub type PCRYPT_ATTRIBUTE_TYPE_VALUE = *mut _CRYPT_ATTRIBUTE_TYPE_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ATTRIBUTE {
    pub pszObjId: LPSTR,
    pub cValue: DWORD,
    pub rgValue: PCRYPT_ATTR_BLOB,
}
pub type CRYPT_ATTRIBUTE = _CRYPT_ATTRIBUTE;
pub type PCRYPT_ATTRIBUTE = *mut _CRYPT_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ATTRIBUTES {
    pub cAttr: DWORD,
    pub rgAttr: PCRYPT_ATTRIBUTE,
}
pub type CRYPT_ATTRIBUTES = _CRYPT_ATTRIBUTES;
pub type PCRYPT_ATTRIBUTES = *mut _CRYPT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_RDN_ATTR {
    pub pszObjId: LPSTR,
    pub dwValueType: DWORD,
    pub Value: CERT_RDN_VALUE_BLOB,
}
pub type CERT_RDN_ATTR = _CERT_RDN_ATTR;
pub type PCERT_RDN_ATTR = *mut _CERT_RDN_ATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_RDN {
    pub cRDNAttr: DWORD,
    pub rgRDNAttr: PCERT_RDN_ATTR,
}
pub type CERT_RDN = _CERT_RDN;
pub type PCERT_RDN = *mut _CERT_RDN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_NAME_INFO {
    pub cRDN: DWORD,
    pub rgRDN: PCERT_RDN,
}
pub type CERT_NAME_INFO = _CERT_NAME_INFO;
pub type PCERT_NAME_INFO = *mut _CERT_NAME_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_NAME_VALUE {
    pub dwValueType: DWORD,
    pub Value: CERT_RDN_VALUE_BLOB,
}
pub type CERT_NAME_VALUE = _CERT_NAME_VALUE;
pub type PCERT_NAME_VALUE = *mut _CERT_NAME_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_PUBLIC_KEY_INFO {
    pub Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub PublicKey: CRYPT_BIT_BLOB,
}
pub type CERT_PUBLIC_KEY_INFO = _CERT_PUBLIC_KEY_INFO;
pub type PCERT_PUBLIC_KEY_INFO = *mut _CERT_PUBLIC_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ECC_PRIVATE_KEY_INFO {
    pub dwVersion: DWORD,
    pub PrivateKey: CRYPT_DER_BLOB,
    pub szCurveOid: LPSTR,
    pub PublicKey: CRYPT_BIT_BLOB,
}
pub type CRYPT_ECC_PRIVATE_KEY_INFO = _CRYPT_ECC_PRIVATE_KEY_INFO;
pub type PCRYPT_ECC_PRIVATE_KEY_INFO = *mut _CRYPT_ECC_PRIVATE_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PRIVATE_KEY_INFO {
    pub Version: DWORD,
    pub Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub PrivateKey: CRYPT_DER_BLOB,
    pub pAttributes: PCRYPT_ATTRIBUTES,
}
pub type CRYPT_PRIVATE_KEY_INFO = _CRYPT_PRIVATE_KEY_INFO;
pub type PCRYPT_PRIVATE_KEY_INFO = *mut _CRYPT_PRIVATE_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO {
    pub EncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedPrivateKey: CRYPT_DATA_BLOB,
}
pub type CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;
pub type PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = *mut _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;
pub type PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
        EncryptedPrivateKey: CRYPT_DATA_BLOB,
        pbClearTextKey: *mut BYTE,
        pcbClearTextKey: *mut DWORD,
        pVoidDecryptFunc: LPVOID,
    ) -> BOOL,
>;
pub type PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pAlgorithm: *mut CRYPT_ALGORITHM_IDENTIFIER,
        pClearTextPrivateKey: *mut CRYPT_DATA_BLOB,
        pbEncryptedKey: *mut BYTE,
        pcbEncryptedKey: *mut DWORD,
        pVoidEncryptFunc: LPVOID,
    ) -> BOOL,
>;
pub type PCRYPT_RESOLVE_HCRYPTPROV_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pPrivateKeyInfo: *mut CRYPT_PRIVATE_KEY_INFO,
        phCryptProv: *mut HCRYPTPROV,
        pVoidResolveFunc: LPVOID,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PKCS8_IMPORT_PARAMS {
    pub PrivateKey: CRYPT_DIGEST_BLOB,
    pub pResolvehCryptProvFunc: PCRYPT_RESOLVE_HCRYPTPROV_FUNC,
    pub pVoidResolveFunc: LPVOID,
    pub pDecryptPrivateKeyFunc: PCRYPT_DECRYPT_PRIVATE_KEY_FUNC,
    pub pVoidDecryptFunc: LPVOID,
}
pub type CRYPT_PKCS8_IMPORT_PARAMS = _CRYPT_PKCS8_IMPORT_PARAMS;
pub type PCRYPT_PKCS8_IMPORT_PARAMS = *mut _CRYPT_PKCS8_IMPORT_PARAMS;
pub type CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = _CRYPT_PKCS8_IMPORT_PARAMS;
pub type PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = *mut _CRYPT_PKCS8_IMPORT_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PKCS8_EXPORT_PARAMS {
    pub hCryptProv: HCRYPTPROV,
    pub dwKeySpec: DWORD,
    pub pszPrivateKeyObjId: LPSTR,
    pub pEncryptPrivateKeyFunc: PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC,
    pub pVoidEncryptFunc: LPVOID,
}
pub type CRYPT_PKCS8_EXPORT_PARAMS = _CRYPT_PKCS8_EXPORT_PARAMS;
pub type PCRYPT_PKCS8_EXPORT_PARAMS = *mut _CRYPT_PKCS8_EXPORT_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_INFO {
    pub dwVersion: DWORD,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
    pub SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Issuer: CERT_NAME_BLOB,
    pub NotBefore: FILETIME,
    pub NotAfter: FILETIME,
    pub Subject: CERT_NAME_BLOB,
    pub SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pub IssuerUniqueId: CRYPT_BIT_BLOB,
    pub SubjectUniqueId: CRYPT_BIT_BLOB,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CERT_INFO = _CERT_INFO;
pub type PCERT_INFO = *mut _CERT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_ENTRY {
    pub SerialNumber: CRYPT_INTEGER_BLOB,
    pub RevocationDate: FILETIME,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CRL_ENTRY = _CRL_ENTRY;
pub type PCRL_ENTRY = *mut _CRL_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_INFO {
    pub dwVersion: DWORD,
    pub SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Issuer: CERT_NAME_BLOB,
    pub ThisUpdate: FILETIME,
    pub NextUpdate: FILETIME,
    pub cCRLEntry: DWORD,
    pub rgCRLEntry: PCRL_ENTRY,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CRL_INFO = _CRL_INFO;
pub type PCRL_INFO = *mut _CRL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_OR_CRL_BLOB {
    pub dwChoice: DWORD,
    pub cbEncoded: DWORD,
    pub pbEncoded: *mut BYTE,
}
pub type CERT_OR_CRL_BLOB = _CERT_OR_CRL_BLOB;
pub type PCERT_OR_CRL_BLOB = *mut _CERT_OR_CRL_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_OR_CRL_BUNDLE {
    pub cItem: DWORD,
    pub rgItem: PCERT_OR_CRL_BLOB,
}
pub type CERT_OR_CRL_BUNDLE = _CERT_OR_CRL_BUNDLE;
pub type PCERT_OR_CRL_BUNDLE = *mut _CERT_OR_CRL_BUNDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REQUEST_INFO {
    pub dwVersion: DWORD,
    pub Subject: CERT_NAME_BLOB,
    pub SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pub cAttribute: DWORD,
    pub rgAttribute: PCRYPT_ATTRIBUTE,
}
pub type CERT_REQUEST_INFO = _CERT_REQUEST_INFO;
pub type PCERT_REQUEST_INFO = *mut _CERT_REQUEST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_KEYGEN_REQUEST_INFO {
    pub dwVersion: DWORD,
    pub SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pub pwszChallengeString: LPWSTR,
}
pub type CERT_KEYGEN_REQUEST_INFO = _CERT_KEYGEN_REQUEST_INFO;
pub type PCERT_KEYGEN_REQUEST_INFO = *mut _CERT_KEYGEN_REQUEST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SIGNED_CONTENT_INFO {
    pub ToBeSigned: CRYPT_DER_BLOB,
    pub SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Signature: CRYPT_BIT_BLOB,
}
pub type CERT_SIGNED_CONTENT_INFO = _CERT_SIGNED_CONTENT_INFO;
pub type PCERT_SIGNED_CONTENT_INFO = *mut _CERT_SIGNED_CONTENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_USAGE {
    pub cUsageIdentifier: DWORD,
    pub rgpszUsageIdentifier: *mut LPSTR,
}
pub type CTL_USAGE = _CTL_USAGE;
pub type PCTL_USAGE = *mut _CTL_USAGE;
pub type CERT_ENHKEY_USAGE = _CTL_USAGE;
pub type PCERT_ENHKEY_USAGE = *mut _CTL_USAGE;
pub type PCCTL_USAGE = *const CTL_USAGE;
pub type PCCERT_ENHKEY_USAGE = *const CERT_ENHKEY_USAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_ENTRY {
    pub SubjectIdentifier: CRYPT_DATA_BLOB,
    pub cAttribute: DWORD,
    pub rgAttribute: PCRYPT_ATTRIBUTE,
}
pub type CTL_ENTRY = _CTL_ENTRY;
pub type PCTL_ENTRY = *mut _CTL_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_INFO {
    pub dwVersion: DWORD,
    pub SubjectUsage: CTL_USAGE,
    pub ListIdentifier: CRYPT_DATA_BLOB,
    pub SequenceNumber: CRYPT_INTEGER_BLOB,
    pub ThisUpdate: FILETIME,
    pub NextUpdate: FILETIME,
    pub SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub cCTLEntry: DWORD,
    pub rgCTLEntry: PCTL_ENTRY,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CTL_INFO = _CTL_INFO;
pub type PCTL_INFO = *mut _CTL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIME_STAMP_REQUEST_INFO {
    pub pszTimeStampAlgorithm: LPSTR,
    pub pszContentType: LPSTR,
    pub Content: CRYPT_OBJID_BLOB,
    pub cAttribute: DWORD,
    pub rgAttribute: PCRYPT_ATTRIBUTE,
}
pub type CRYPT_TIME_STAMP_REQUEST_INFO = _CRYPT_TIME_STAMP_REQUEST_INFO;
pub type PCRYPT_TIME_STAMP_REQUEST_INFO = *mut _CRYPT_TIME_STAMP_REQUEST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ENROLLMENT_NAME_VALUE_PAIR {
    pub pwszName: LPWSTR,
    pub pwszValue: LPWSTR,
}
pub type CRYPT_ENROLLMENT_NAME_VALUE_PAIR = _CRYPT_ENROLLMENT_NAME_VALUE_PAIR;
pub type PCRYPT_ENROLLMENT_NAME_VALUE_PAIR = *mut _CRYPT_ENROLLMENT_NAME_VALUE_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CSP_PROVIDER {
    pub dwKeySpec: DWORD,
    pub pwszProviderName: LPWSTR,
    pub Signature: CRYPT_BIT_BLOB,
}
pub type CRYPT_CSP_PROVIDER = _CRYPT_CSP_PROVIDER;
pub type PCRYPT_CSP_PROVIDER = *mut _CRYPT_CSP_PROVIDER;
extern "C" {
    pub fn CryptFormatObject(
        dwCertEncodingType: DWORD,
        dwFormatType: DWORD,
        dwFormatStrType: DWORD,
        pFormatStruct: *mut ::std::os::raw::c_void,
        lpszStructType: LPCSTR,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        pbFormat: *mut ::std::os::raw::c_void,
        pcbFormat: *mut DWORD,
    ) -> BOOL;
}
pub type PFN_CRYPT_ALLOC = ::std::option::Option<unsafe extern "C" fn(cbSize: usize) -> LPVOID>;
pub type PFN_CRYPT_FREE = ::std::option::Option<unsafe extern "C" fn(pv: LPVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ENCODE_PARA {
    pub cbSize: DWORD,
    pub pfnAlloc: PFN_CRYPT_ALLOC,
    pub pfnFree: PFN_CRYPT_FREE,
}
pub type CRYPT_ENCODE_PARA = _CRYPT_ENCODE_PARA;
pub type PCRYPT_ENCODE_PARA = *mut _CRYPT_ENCODE_PARA;
extern "C" {
    pub fn CryptEncodeObjectEx(
        dwCertEncodingType: DWORD,
        lpszStructType: LPCSTR,
        pvStructInfo: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pEncodePara: PCRYPT_ENCODE_PARA,
        pvEncoded: *mut ::std::os::raw::c_void,
        pcbEncoded: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEncodeObject(
        dwCertEncodingType: DWORD,
        lpszStructType: LPCSTR,
        pvStructInfo: *const ::std::os::raw::c_void,
        pbEncoded: *mut BYTE,
        pcbEncoded: *mut DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_DECODE_PARA {
    pub cbSize: DWORD,
    pub pfnAlloc: PFN_CRYPT_ALLOC,
    pub pfnFree: PFN_CRYPT_FREE,
}
pub type CRYPT_DECODE_PARA = _CRYPT_DECODE_PARA;
pub type PCRYPT_DECODE_PARA = *mut _CRYPT_DECODE_PARA;
extern "C" {
    pub fn CryptDecodeObjectEx(
        dwCertEncodingType: DWORD,
        lpszStructType: LPCSTR,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        dwFlags: DWORD,
        pDecodePara: PCRYPT_DECODE_PARA,
        pvStructInfo: *mut ::std::os::raw::c_void,
        pcbStructInfo: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDecodeObject(
        dwCertEncodingType: DWORD,
        lpszStructType: LPCSTR,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        dwFlags: DWORD,
        pvStructInfo: *mut ::std::os::raw::c_void,
        pcbStructInfo: *mut DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_EXTENSIONS {
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CERT_EXTENSIONS = _CERT_EXTENSIONS;
pub type PCERT_EXTENSIONS = *mut _CERT_EXTENSIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_AUTHORITY_KEY_ID_INFO {
    pub KeyId: CRYPT_DATA_BLOB,
    pub CertIssuer: CERT_NAME_BLOB,
    pub CertSerialNumber: CRYPT_INTEGER_BLOB,
}
pub type CERT_AUTHORITY_KEY_ID_INFO = _CERT_AUTHORITY_KEY_ID_INFO;
pub type PCERT_AUTHORITY_KEY_ID_INFO = *mut _CERT_AUTHORITY_KEY_ID_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_PRIVATE_KEY_VALIDITY {
    pub NotBefore: FILETIME,
    pub NotAfter: FILETIME,
}
pub type CERT_PRIVATE_KEY_VALIDITY = _CERT_PRIVATE_KEY_VALIDITY;
pub type PCERT_PRIVATE_KEY_VALIDITY = *mut _CERT_PRIVATE_KEY_VALIDITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_KEY_ATTRIBUTES_INFO {
    pub KeyId: CRYPT_DATA_BLOB,
    pub IntendedKeyUsage: CRYPT_BIT_BLOB,
    pub pPrivateKeyUsagePeriod: PCERT_PRIVATE_KEY_VALIDITY,
}
pub type CERT_KEY_ATTRIBUTES_INFO = _CERT_KEY_ATTRIBUTES_INFO;
pub type PCERT_KEY_ATTRIBUTES_INFO = *mut _CERT_KEY_ATTRIBUTES_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_ID {
    pub cCertPolicyElementId: DWORD,
    pub rgpszCertPolicyElementId: *mut LPSTR,
}
pub type CERT_POLICY_ID = _CERT_POLICY_ID;
pub type PCERT_POLICY_ID = *mut _CERT_POLICY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_KEY_USAGE_RESTRICTION_INFO {
    pub cCertPolicyId: DWORD,
    pub rgCertPolicyId: PCERT_POLICY_ID,
    pub RestrictedKeyUsage: CRYPT_BIT_BLOB,
}
pub type CERT_KEY_USAGE_RESTRICTION_INFO = _CERT_KEY_USAGE_RESTRICTION_INFO;
pub type PCERT_KEY_USAGE_RESTRICTION_INFO = *mut _CERT_KEY_USAGE_RESTRICTION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_OTHER_NAME {
    pub pszObjId: LPSTR,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type CERT_OTHER_NAME = _CERT_OTHER_NAME;
pub type PCERT_OTHER_NAME = *mut _CERT_OTHER_NAME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_ALT_NAME_ENTRY {
    pub dwAltNameChoice: DWORD,
    pub __bindgen_anon_1: _CERT_ALT_NAME_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_ALT_NAME_ENTRY__bindgen_ty_1 {
    pub pOtherName: PCERT_OTHER_NAME,
    pub pwszRfc822Name: LPWSTR,
    pub pwszDNSName: LPWSTR,
    pub DirectoryName: CERT_NAME_BLOB,
    pub pwszURL: LPWSTR,
    pub IPAddress: CRYPT_DATA_BLOB,
    pub pszRegisteredID: LPSTR,
}
pub type CERT_ALT_NAME_ENTRY = _CERT_ALT_NAME_ENTRY;
pub type PCERT_ALT_NAME_ENTRY = *mut _CERT_ALT_NAME_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_ALT_NAME_INFO {
    pub cAltEntry: DWORD,
    pub rgAltEntry: PCERT_ALT_NAME_ENTRY,
}
pub type CERT_ALT_NAME_INFO = _CERT_ALT_NAME_INFO;
pub type PCERT_ALT_NAME_INFO = *mut _CERT_ALT_NAME_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_BASIC_CONSTRAINTS_INFO {
    pub SubjectType: CRYPT_BIT_BLOB,
    pub fPathLenConstraint: BOOL,
    pub dwPathLenConstraint: DWORD,
    pub cSubtreesConstraint: DWORD,
    pub rgSubtreesConstraint: *mut CERT_NAME_BLOB,
}
pub type CERT_BASIC_CONSTRAINTS_INFO = _CERT_BASIC_CONSTRAINTS_INFO;
pub type PCERT_BASIC_CONSTRAINTS_INFO = *mut _CERT_BASIC_CONSTRAINTS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_BASIC_CONSTRAINTS2_INFO {
    pub fCA: BOOL,
    pub fPathLenConstraint: BOOL,
    pub dwPathLenConstraint: DWORD,
}
pub type CERT_BASIC_CONSTRAINTS2_INFO = _CERT_BASIC_CONSTRAINTS2_INFO;
pub type PCERT_BASIC_CONSTRAINTS2_INFO = *mut _CERT_BASIC_CONSTRAINTS2_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_QUALIFIER_INFO {
    pub pszPolicyQualifierId: LPSTR,
    pub Qualifier: CRYPT_OBJID_BLOB,
}
pub type CERT_POLICY_QUALIFIER_INFO = _CERT_POLICY_QUALIFIER_INFO;
pub type PCERT_POLICY_QUALIFIER_INFO = *mut _CERT_POLICY_QUALIFIER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_INFO {
    pub pszPolicyIdentifier: LPSTR,
    pub cPolicyQualifier: DWORD,
    pub rgPolicyQualifier: *mut CERT_POLICY_QUALIFIER_INFO,
}
pub type CERT_POLICY_INFO = _CERT_POLICY_INFO;
pub type PCERT_POLICY_INFO = *mut _CERT_POLICY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICIES_INFO {
    pub cPolicyInfo: DWORD,
    pub rgPolicyInfo: *mut CERT_POLICY_INFO,
}
pub type CERT_POLICIES_INFO = _CERT_POLICIES_INFO;
pub type PCERT_POLICIES_INFO = *mut _CERT_POLICIES_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {
    pub pszOrganization: LPSTR,
    pub cNoticeNumbers: DWORD,
    pub rgNoticeNumbers: *mut ::std::os::raw::c_int,
}
pub type CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
pub type PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = *mut _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_QUALIFIER_USER_NOTICE {
    pub pNoticeReference: *mut CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,
    pub pszDisplayText: LPWSTR,
}
pub type CERT_POLICY_QUALIFIER_USER_NOTICE = _CERT_POLICY_QUALIFIER_USER_NOTICE;
pub type PCERT_POLICY_QUALIFIER_USER_NOTICE = *mut _CERT_POLICY_QUALIFIER_USER_NOTICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPS_URLS {
    pub pszURL: LPWSTR,
    pub pAlgorithm: *mut CRYPT_ALGORITHM_IDENTIFIER,
    pub pDigest: *mut CRYPT_DATA_BLOB,
}
pub type CPS_URLS = _CPS_URLS;
pub type PCPS_URLS = *mut _CPS_URLS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY95_QUALIFIER1 {
    pub pszPracticesReference: LPWSTR,
    pub pszNoticeIdentifier: LPSTR,
    pub pszNSINoticeIdentifier: LPSTR,
    pub cCPSURLs: DWORD,
    pub rgCPSURLs: *mut CPS_URLS,
}
pub type CERT_POLICY95_QUALIFIER1 = _CERT_POLICY95_QUALIFIER1;
pub type PCERT_POLICY95_QUALIFIER1 = *mut _CERT_POLICY95_QUALIFIER1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_MAPPING {
    pub pszIssuerDomainPolicy: LPSTR,
    pub pszSubjectDomainPolicy: LPSTR,
}
pub type CERT_POLICY_MAPPING = _CERT_POLICY_MAPPING;
pub type PCERT_POLICY_MAPPING = *mut _CERT_POLICY_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_MAPPINGS_INFO {
    pub cPolicyMapping: DWORD,
    pub rgPolicyMapping: PCERT_POLICY_MAPPING,
}
pub type CERT_POLICY_MAPPINGS_INFO = _CERT_POLICY_MAPPINGS_INFO;
pub type PCERT_POLICY_MAPPINGS_INFO = *mut _CERT_POLICY_MAPPINGS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_POLICY_CONSTRAINTS_INFO {
    pub fRequireExplicitPolicy: BOOL,
    pub dwRequireExplicitPolicySkipCerts: DWORD,
    pub fInhibitPolicyMapping: BOOL,
    pub dwInhibitPolicyMappingSkipCerts: DWORD,
}
pub type CERT_POLICY_CONSTRAINTS_INFO = _CERT_POLICY_CONSTRAINTS_INFO;
pub type PCERT_POLICY_CONSTRAINTS_INFO = *mut _CERT_POLICY_CONSTRAINTS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY {
    pub pszObjId: LPSTR,
    pub cValue: DWORD,
    pub rgValue: PCRYPT_DER_BLOB,
}
pub type CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
pub type PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = *mut _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CONTENT_INFO {
    pub pszObjId: LPSTR,
    pub Content: CRYPT_DER_BLOB,
}
pub type CRYPT_CONTENT_INFO = _CRYPT_CONTENT_INFO;
pub type PCRYPT_CONTENT_INFO = *mut _CRYPT_CONTENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_SEQUENCE_OF_ANY {
    pub cValue: DWORD,
    pub rgValue: PCRYPT_DER_BLOB,
}
pub type CRYPT_SEQUENCE_OF_ANY = _CRYPT_SEQUENCE_OF_ANY;
pub type PCRYPT_SEQUENCE_OF_ANY = *mut _CRYPT_SEQUENCE_OF_ANY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_AUTHORITY_KEY_ID2_INFO {
    pub KeyId: CRYPT_DATA_BLOB,
    pub AuthorityCertIssuer: CERT_ALT_NAME_INFO,
    pub AuthorityCertSerialNumber: CRYPT_INTEGER_BLOB,
}
pub type CERT_AUTHORITY_KEY_ID2_INFO = _CERT_AUTHORITY_KEY_ID2_INFO;
pub type PCERT_AUTHORITY_KEY_ID2_INFO = *mut _CERT_AUTHORITY_KEY_ID2_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_ACCESS_DESCRIPTION {
    pub pszAccessMethod: LPSTR,
    pub AccessLocation: CERT_ALT_NAME_ENTRY,
}
pub type CERT_ACCESS_DESCRIPTION = _CERT_ACCESS_DESCRIPTION;
pub type PCERT_ACCESS_DESCRIPTION = *mut _CERT_ACCESS_DESCRIPTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_AUTHORITY_INFO_ACCESS {
    pub cAccDescr: DWORD,
    pub rgAccDescr: PCERT_ACCESS_DESCRIPTION,
}
pub type CERT_AUTHORITY_INFO_ACCESS = _CERT_AUTHORITY_INFO_ACCESS;
pub type PCERT_AUTHORITY_INFO_ACCESS = *mut _CERT_AUTHORITY_INFO_ACCESS;
pub type CERT_SUBJECT_INFO_ACCESS = _CERT_AUTHORITY_INFO_ACCESS;
pub type PCERT_SUBJECT_INFO_ACCESS = *mut _CERT_AUTHORITY_INFO_ACCESS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CRL_DIST_POINT_NAME {
    pub dwDistPointNameChoice: DWORD,
    pub __bindgen_anon_1: _CRL_DIST_POINT_NAME__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CRL_DIST_POINT_NAME__bindgen_ty_1 {
    pub FullName: CERT_ALT_NAME_INFO,
}
pub type CRL_DIST_POINT_NAME = _CRL_DIST_POINT_NAME;
pub type PCRL_DIST_POINT_NAME = *mut _CRL_DIST_POINT_NAME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CRL_DIST_POINT {
    pub DistPointName: CRL_DIST_POINT_NAME,
    pub ReasonFlags: CRYPT_BIT_BLOB,
    pub CRLIssuer: CERT_ALT_NAME_INFO,
}
pub type CRL_DIST_POINT = _CRL_DIST_POINT;
pub type PCRL_DIST_POINT = *mut _CRL_DIST_POINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_DIST_POINTS_INFO {
    pub cDistPoint: DWORD,
    pub rgDistPoint: PCRL_DIST_POINT,
}
pub type CRL_DIST_POINTS_INFO = _CRL_DIST_POINTS_INFO;
pub type PCRL_DIST_POINTS_INFO = *mut _CRL_DIST_POINTS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CROSS_CERT_DIST_POINTS_INFO {
    pub dwSyncDeltaTime: DWORD,
    pub cDistPoint: DWORD,
    pub rgDistPoint: PCERT_ALT_NAME_INFO,
}
pub type CROSS_CERT_DIST_POINTS_INFO = _CROSS_CERT_DIST_POINTS_INFO;
pub type PCROSS_CERT_DIST_POINTS_INFO = *mut _CROSS_CERT_DIST_POINTS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_PAIR {
    pub Forward: CERT_BLOB,
    pub Reverse: CERT_BLOB,
}
pub type CERT_PAIR = _CERT_PAIR;
pub type PCERT_PAIR = *mut _CERT_PAIR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CRL_ISSUING_DIST_POINT {
    pub DistPointName: CRL_DIST_POINT_NAME,
    pub fOnlyContainsUserCerts: BOOL,
    pub fOnlyContainsCACerts: BOOL,
    pub OnlySomeReasonFlags: CRYPT_BIT_BLOB,
    pub fIndirectCRL: BOOL,
}
pub type CRL_ISSUING_DIST_POINT = _CRL_ISSUING_DIST_POINT;
pub type PCRL_ISSUING_DIST_POINT = *mut _CRL_ISSUING_DIST_POINT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_GENERAL_SUBTREE {
    pub Base: CERT_ALT_NAME_ENTRY,
    pub dwMinimum: DWORD,
    pub fMaximum: BOOL,
    pub dwMaximum: DWORD,
}
pub type CERT_GENERAL_SUBTREE = _CERT_GENERAL_SUBTREE;
pub type PCERT_GENERAL_SUBTREE = *mut _CERT_GENERAL_SUBTREE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_NAME_CONSTRAINTS_INFO {
    pub cPermittedSubtree: DWORD,
    pub rgPermittedSubtree: PCERT_GENERAL_SUBTREE,
    pub cExcludedSubtree: DWORD,
    pub rgExcludedSubtree: PCERT_GENERAL_SUBTREE,
}
pub type CERT_NAME_CONSTRAINTS_INFO = _CERT_NAME_CONSTRAINTS_INFO;
pub type PCERT_NAME_CONSTRAINTS_INFO = *mut _CERT_NAME_CONSTRAINTS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_DSS_PARAMETERS {
    pub p: CRYPT_UINT_BLOB,
    pub q: CRYPT_UINT_BLOB,
    pub g: CRYPT_UINT_BLOB,
}
pub type CERT_DSS_PARAMETERS = _CERT_DSS_PARAMETERS;
pub type PCERT_DSS_PARAMETERS = *mut _CERT_DSS_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_DH_PARAMETERS {
    pub p: CRYPT_UINT_BLOB,
    pub g: CRYPT_UINT_BLOB,
}
pub type CERT_DH_PARAMETERS = _CERT_DH_PARAMETERS;
pub type PCERT_DH_PARAMETERS = *mut _CERT_DH_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_ECC_SIGNATURE {
    pub r: CRYPT_UINT_BLOB,
    pub s: CRYPT_UINT_BLOB,
}
pub type CERT_ECC_SIGNATURE = _CERT_ECC_SIGNATURE;
pub type PCERT_ECC_SIGNATURE = *mut _CERT_ECC_SIGNATURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_X942_DH_VALIDATION_PARAMS {
    pub seed: CRYPT_BIT_BLOB,
    pub pgenCounter: DWORD,
}
pub type CERT_X942_DH_VALIDATION_PARAMS = _CERT_X942_DH_VALIDATION_PARAMS;
pub type PCERT_X942_DH_VALIDATION_PARAMS = *mut _CERT_X942_DH_VALIDATION_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_X942_DH_PARAMETERS {
    pub p: CRYPT_UINT_BLOB,
    pub g: CRYPT_UINT_BLOB,
    pub q: CRYPT_UINT_BLOB,
    pub j: CRYPT_UINT_BLOB,
    pub pValidationParams: PCERT_X942_DH_VALIDATION_PARAMS,
}
pub type CERT_X942_DH_PARAMETERS = _CERT_X942_DH_PARAMETERS;
pub type PCERT_X942_DH_PARAMETERS = *mut _CERT_X942_DH_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_X942_OTHER_INFO {
    pub pszContentEncryptionObjId: LPSTR,
    pub rgbCounter: [BYTE; 4usize],
    pub rgbKeyLength: [BYTE; 4usize],
    pub PubInfo: CRYPT_DATA_BLOB,
}
pub type CRYPT_X942_OTHER_INFO = _CRYPT_X942_OTHER_INFO;
pub type PCRYPT_X942_OTHER_INFO = *mut _CRYPT_X942_OTHER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ECC_CMS_SHARED_INFO {
    pub Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EntityUInfo: CRYPT_DATA_BLOB,
    pub rgbSuppPubInfo: [BYTE; 4usize],
}
pub type CRYPT_ECC_CMS_SHARED_INFO = _CRYPT_ECC_CMS_SHARED_INFO;
pub type PCRYPT_ECC_CMS_SHARED_INFO = *mut _CRYPT_ECC_CMS_SHARED_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_RC2_CBC_PARAMETERS {
    pub dwVersion: DWORD,
    pub fIV: BOOL,
    pub rgbIV: [BYTE; 8usize],
}
pub type CRYPT_RC2_CBC_PARAMETERS = _CRYPT_RC2_CBC_PARAMETERS;
pub type PCRYPT_RC2_CBC_PARAMETERS = *mut _CRYPT_RC2_CBC_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_SMIME_CAPABILITY {
    pub pszObjId: LPSTR,
    pub Parameters: CRYPT_OBJID_BLOB,
}
pub type CRYPT_SMIME_CAPABILITY = _CRYPT_SMIME_CAPABILITY;
pub type PCRYPT_SMIME_CAPABILITY = *mut _CRYPT_SMIME_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_SMIME_CAPABILITIES {
    pub cCapability: DWORD,
    pub rgCapability: PCRYPT_SMIME_CAPABILITY,
}
pub type CRYPT_SMIME_CAPABILITIES = _CRYPT_SMIME_CAPABILITIES;
pub type PCRYPT_SMIME_CAPABILITIES = *mut _CRYPT_SMIME_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_QC_STATEMENT {
    pub pszStatementId: LPSTR,
    pub StatementInfo: CRYPT_OBJID_BLOB,
}
pub type CERT_QC_STATEMENT = _CERT_QC_STATEMENT;
pub type PCERT_QC_STATEMENT = *mut _CERT_QC_STATEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_QC_STATEMENTS_EXT_INFO {
    pub cStatement: DWORD,
    pub rgStatement: PCERT_QC_STATEMENT,
}
pub type CERT_QC_STATEMENTS_EXT_INFO = _CERT_QC_STATEMENTS_EXT_INFO;
pub type PCERT_QC_STATEMENTS_EXT_INFO = *mut _CERT_QC_STATEMENTS_EXT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_MASK_GEN_ALGORITHM {
    pub pszObjId: LPSTR,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
}
pub type CRYPT_MASK_GEN_ALGORITHM = _CRYPT_MASK_GEN_ALGORITHM;
pub type PCRYPT_MASK_GEN_ALGORITHM = *mut _CRYPT_MASK_GEN_ALGORITHM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_RSA_SSA_PSS_PARAMETERS {
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    pub dwSaltLength: DWORD,
    pub dwTrailerField: DWORD,
}
pub type CRYPT_RSA_SSA_PSS_PARAMETERS = _CRYPT_RSA_SSA_PSS_PARAMETERS;
pub type PCRYPT_RSA_SSA_PSS_PARAMETERS = *mut _CRYPT_RSA_SSA_PSS_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PSOURCE_ALGORITHM {
    pub pszObjId: LPSTR,
    pub EncodingParameters: CRYPT_DATA_BLOB,
}
pub type CRYPT_PSOURCE_ALGORITHM = _CRYPT_PSOURCE_ALGORITHM;
pub type PCRYPT_PSOURCE_ALGORITHM = *mut _CRYPT_PSOURCE_ALGORITHM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_RSAES_OAEP_PARAMETERS {
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    pub PSourceAlgorithm: CRYPT_PSOURCE_ALGORITHM,
}
pub type CRYPT_RSAES_OAEP_PARAMETERS = _CRYPT_RSAES_OAEP_PARAMETERS;
pub type PCRYPT_RSAES_OAEP_PARAMETERS = *mut _CRYPT_RSAES_OAEP_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_TAGGED_ATTRIBUTE {
    pub dwBodyPartID: DWORD,
    pub Attribute: CRYPT_ATTRIBUTE,
}
pub type CMC_TAGGED_ATTRIBUTE = _CMC_TAGGED_ATTRIBUTE;
pub type PCMC_TAGGED_ATTRIBUTE = *mut _CMC_TAGGED_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_TAGGED_CERT_REQUEST {
    pub dwBodyPartID: DWORD,
    pub SignedCertRequest: CRYPT_DER_BLOB,
}
pub type CMC_TAGGED_CERT_REQUEST = _CMC_TAGGED_CERT_REQUEST;
pub type PCMC_TAGGED_CERT_REQUEST = *mut _CMC_TAGGED_CERT_REQUEST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMC_TAGGED_REQUEST {
    pub dwTaggedRequestChoice: DWORD,
    pub __bindgen_anon_1: _CMC_TAGGED_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMC_TAGGED_REQUEST__bindgen_ty_1 {
    pub pTaggedCertRequest: PCMC_TAGGED_CERT_REQUEST,
}
pub type CMC_TAGGED_REQUEST = _CMC_TAGGED_REQUEST;
pub type PCMC_TAGGED_REQUEST = *mut _CMC_TAGGED_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_TAGGED_CONTENT_INFO {
    pub dwBodyPartID: DWORD,
    pub EncodedContentInfo: CRYPT_DER_BLOB,
}
pub type CMC_TAGGED_CONTENT_INFO = _CMC_TAGGED_CONTENT_INFO;
pub type PCMC_TAGGED_CONTENT_INFO = *mut _CMC_TAGGED_CONTENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_TAGGED_OTHER_MSG {
    pub dwBodyPartID: DWORD,
    pub pszObjId: LPSTR,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type CMC_TAGGED_OTHER_MSG = _CMC_TAGGED_OTHER_MSG;
pub type PCMC_TAGGED_OTHER_MSG = *mut _CMC_TAGGED_OTHER_MSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_DATA_INFO {
    pub cTaggedAttribute: DWORD,
    pub rgTaggedAttribute: PCMC_TAGGED_ATTRIBUTE,
    pub cTaggedRequest: DWORD,
    pub rgTaggedRequest: PCMC_TAGGED_REQUEST,
    pub cTaggedContentInfo: DWORD,
    pub rgTaggedContentInfo: PCMC_TAGGED_CONTENT_INFO,
    pub cTaggedOtherMsg: DWORD,
    pub rgTaggedOtherMsg: PCMC_TAGGED_OTHER_MSG,
}
pub type CMC_DATA_INFO = _CMC_DATA_INFO;
pub type PCMC_DATA_INFO = *mut _CMC_DATA_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_RESPONSE_INFO {
    pub cTaggedAttribute: DWORD,
    pub rgTaggedAttribute: PCMC_TAGGED_ATTRIBUTE,
    pub cTaggedContentInfo: DWORD,
    pub rgTaggedContentInfo: PCMC_TAGGED_CONTENT_INFO,
    pub cTaggedOtherMsg: DWORD,
    pub rgTaggedOtherMsg: PCMC_TAGGED_OTHER_MSG,
}
pub type CMC_RESPONSE_INFO = _CMC_RESPONSE_INFO;
pub type PCMC_RESPONSE_INFO = *mut _CMC_RESPONSE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_PEND_INFO {
    pub PendToken: CRYPT_DATA_BLOB,
    pub PendTime: FILETIME,
}
pub type CMC_PEND_INFO = _CMC_PEND_INFO;
pub type PCMC_PEND_INFO = *mut _CMC_PEND_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMC_STATUS_INFO {
    pub dwStatus: DWORD,
    pub cBodyList: DWORD,
    pub rgdwBodyList: *mut DWORD,
    pub pwszStatusString: LPWSTR,
    pub dwOtherInfoChoice: DWORD,
    pub __bindgen_anon_1: _CMC_STATUS_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMC_STATUS_INFO__bindgen_ty_1 {
    pub dwFailInfo: DWORD,
    pub pPendInfo: PCMC_PEND_INFO,
}
pub type CMC_STATUS_INFO = _CMC_STATUS_INFO;
pub type PCMC_STATUS_INFO = *mut _CMC_STATUS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_ADD_EXTENSIONS_INFO {
    pub dwCmcDataReference: DWORD,
    pub cCertReference: DWORD,
    pub rgdwCertReference: *mut DWORD,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CMC_ADD_EXTENSIONS_INFO = _CMC_ADD_EXTENSIONS_INFO;
pub type PCMC_ADD_EXTENSIONS_INFO = *mut _CMC_ADD_EXTENSIONS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMC_ADD_ATTRIBUTES_INFO {
    pub dwCmcDataReference: DWORD,
    pub cCertReference: DWORD,
    pub rgdwCertReference: *mut DWORD,
    pub cAttribute: DWORD,
    pub rgAttribute: PCRYPT_ATTRIBUTE,
}
pub type CMC_ADD_ATTRIBUTES_INFO = _CMC_ADD_ATTRIBUTES_INFO;
pub type PCMC_ADD_ATTRIBUTES_INFO = *mut _CMC_ADD_ATTRIBUTES_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_TEMPLATE_EXT {
    pub pszObjId: LPSTR,
    pub dwMajorVersion: DWORD,
    pub fMinorVersion: BOOL,
    pub dwMinorVersion: DWORD,
}
pub type CERT_TEMPLATE_EXT = _CERT_TEMPLATE_EXT;
pub type PCERT_TEMPLATE_EXT = *mut _CERT_TEMPLATE_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_HASHED_URL {
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Hash: CRYPT_HASH_BLOB,
    pub pwszUrl: LPWSTR,
}
pub type CERT_HASHED_URL = _CERT_HASHED_URL;
pub type PCERT_HASHED_URL = *mut _CERT_HASHED_URL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_DETAILS {
    pub pwszMimeType: LPWSTR,
    pub cHashedUrl: DWORD,
    pub rgHashedUrl: PCERT_HASHED_URL,
}
pub type CERT_LOGOTYPE_DETAILS = _CERT_LOGOTYPE_DETAILS;
pub type PCERT_LOGOTYPE_DETAILS = *mut _CERT_LOGOTYPE_DETAILS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_REFERENCE {
    pub cHashedUrl: DWORD,
    pub rgHashedUrl: PCERT_HASHED_URL,
}
pub type CERT_LOGOTYPE_REFERENCE = _CERT_LOGOTYPE_REFERENCE;
pub type PCERT_LOGOTYPE_REFERENCE = *mut _CERT_LOGOTYPE_REFERENCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_LOGOTYPE_IMAGE_INFO {
    pub dwLogotypeImageInfoChoice: DWORD,
    pub dwFileSize: DWORD,
    pub dwXSize: DWORD,
    pub dwYSize: DWORD,
    pub dwLogotypeImageResolutionChoice: DWORD,
    pub __bindgen_anon_1: _CERT_LOGOTYPE_IMAGE_INFO__bindgen_ty_1,
    pub pwszLanguage: LPWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_LOGOTYPE_IMAGE_INFO__bindgen_ty_1 {
    pub dwNumBits: DWORD,
    pub dwTableSize: DWORD,
}
pub type CERT_LOGOTYPE_IMAGE_INFO = _CERT_LOGOTYPE_IMAGE_INFO;
pub type PCERT_LOGOTYPE_IMAGE_INFO = *mut _CERT_LOGOTYPE_IMAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_IMAGE {
    pub LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pub pLogotypeImageInfo: PCERT_LOGOTYPE_IMAGE_INFO,
}
pub type CERT_LOGOTYPE_IMAGE = _CERT_LOGOTYPE_IMAGE;
pub type PCERT_LOGOTYPE_IMAGE = *mut _CERT_LOGOTYPE_IMAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_AUDIO_INFO {
    pub dwFileSize: DWORD,
    pub dwPlayTime: DWORD,
    pub dwChannels: DWORD,
    pub dwSampleRate: DWORD,
    pub pwszLanguage: LPWSTR,
}
pub type CERT_LOGOTYPE_AUDIO_INFO = _CERT_LOGOTYPE_AUDIO_INFO;
pub type PCERT_LOGOTYPE_AUDIO_INFO = *mut _CERT_LOGOTYPE_AUDIO_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_AUDIO {
    pub LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pub pLogotypeAudioInfo: PCERT_LOGOTYPE_AUDIO_INFO,
}
pub type CERT_LOGOTYPE_AUDIO = _CERT_LOGOTYPE_AUDIO;
pub type PCERT_LOGOTYPE_AUDIO = *mut _CERT_LOGOTYPE_AUDIO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_DATA {
    pub cLogotypeImage: DWORD,
    pub rgLogotypeImage: PCERT_LOGOTYPE_IMAGE,
    pub cLogotypeAudio: DWORD,
    pub rgLogotypeAudio: PCERT_LOGOTYPE_AUDIO,
}
pub type CERT_LOGOTYPE_DATA = _CERT_LOGOTYPE_DATA;
pub type PCERT_LOGOTYPE_DATA = *mut _CERT_LOGOTYPE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_LOGOTYPE_INFO {
    pub dwLogotypeInfoChoice: DWORD,
    pub __bindgen_anon_1: _CERT_LOGOTYPE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_LOGOTYPE_INFO__bindgen_ty_1 {
    pub pLogotypeDirectInfo: PCERT_LOGOTYPE_DATA,
    pub pLogotypeIndirectInfo: PCERT_LOGOTYPE_REFERENCE,
}
pub type CERT_LOGOTYPE_INFO = _CERT_LOGOTYPE_INFO;
pub type PCERT_LOGOTYPE_INFO = *mut _CERT_LOGOTYPE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_OTHER_LOGOTYPE_INFO {
    pub pszObjId: LPSTR,
    pub LogotypeInfo: CERT_LOGOTYPE_INFO,
}
pub type CERT_OTHER_LOGOTYPE_INFO = _CERT_OTHER_LOGOTYPE_INFO;
pub type PCERT_OTHER_LOGOTYPE_INFO = *mut _CERT_OTHER_LOGOTYPE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LOGOTYPE_EXT_INFO {
    pub cCommunityLogo: DWORD,
    pub rgCommunityLogo: PCERT_LOGOTYPE_INFO,
    pub pIssuerLogo: PCERT_LOGOTYPE_INFO,
    pub pSubjectLogo: PCERT_LOGOTYPE_INFO,
    pub cOtherLogo: DWORD,
    pub rgOtherLogo: PCERT_OTHER_LOGOTYPE_INFO,
}
pub type CERT_LOGOTYPE_EXT_INFO = _CERT_LOGOTYPE_EXT_INFO;
pub type PCERT_LOGOTYPE_EXT_INFO = *mut _CERT_LOGOTYPE_EXT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_BIOMETRIC_DATA {
    pub dwTypeOfBiometricDataChoice: DWORD,
    pub __bindgen_anon_1: _CERT_BIOMETRIC_DATA__bindgen_ty_1,
    pub HashedUrl: CERT_HASHED_URL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_BIOMETRIC_DATA__bindgen_ty_1 {
    pub dwPredefined: DWORD,
    pub pszObjId: LPSTR,
}
pub type CERT_BIOMETRIC_DATA = _CERT_BIOMETRIC_DATA;
pub type PCERT_BIOMETRIC_DATA = *mut _CERT_BIOMETRIC_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_BIOMETRIC_EXT_INFO {
    pub cBiometricData: DWORD,
    pub rgBiometricData: PCERT_BIOMETRIC_DATA,
}
pub type CERT_BIOMETRIC_EXT_INFO = _CERT_BIOMETRIC_EXT_INFO;
pub type PCERT_BIOMETRIC_EXT_INFO = *mut _CERT_BIOMETRIC_EXT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_SIGNATURE_INFO {
    pub SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Signature: CRYPT_BIT_BLOB,
    pub cCertEncoded: DWORD,
    pub rgCertEncoded: PCERT_BLOB,
}
pub type OCSP_SIGNATURE_INFO = _OCSP_SIGNATURE_INFO;
pub type POCSP_SIGNATURE_INFO = *mut _OCSP_SIGNATURE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_SIGNED_REQUEST_INFO {
    pub ToBeSigned: CRYPT_DER_BLOB,
    pub pOptionalSignatureInfo: POCSP_SIGNATURE_INFO,
}
pub type OCSP_SIGNED_REQUEST_INFO = _OCSP_SIGNED_REQUEST_INFO;
pub type POCSP_SIGNED_REQUEST_INFO = *mut _OCSP_SIGNED_REQUEST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_CERT_ID {
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub IssuerNameHash: CRYPT_HASH_BLOB,
    pub IssuerKeyHash: CRYPT_HASH_BLOB,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
}
pub type OCSP_CERT_ID = _OCSP_CERT_ID;
pub type POCSP_CERT_ID = *mut _OCSP_CERT_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_REQUEST_ENTRY {
    pub CertId: OCSP_CERT_ID,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type OCSP_REQUEST_ENTRY = _OCSP_REQUEST_ENTRY;
pub type POCSP_REQUEST_ENTRY = *mut _OCSP_REQUEST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_REQUEST_INFO {
    pub dwVersion: DWORD,
    pub pRequestorName: PCERT_ALT_NAME_ENTRY,
    pub cRequestEntry: DWORD,
    pub rgRequestEntry: POCSP_REQUEST_ENTRY,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type OCSP_REQUEST_INFO = _OCSP_REQUEST_INFO;
pub type POCSP_REQUEST_INFO = *mut _OCSP_REQUEST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_RESPONSE_INFO {
    pub dwStatus: DWORD,
    pub pszObjId: LPSTR,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type OCSP_RESPONSE_INFO = _OCSP_RESPONSE_INFO;
pub type POCSP_RESPONSE_INFO = *mut _OCSP_RESPONSE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_BASIC_SIGNED_RESPONSE_INFO {
    pub ToBeSigned: CRYPT_DER_BLOB,
    pub SignatureInfo: OCSP_SIGNATURE_INFO,
}
pub type OCSP_BASIC_SIGNED_RESPONSE_INFO = _OCSP_BASIC_SIGNED_RESPONSE_INFO;
pub type POCSP_BASIC_SIGNED_RESPONSE_INFO = *mut _OCSP_BASIC_SIGNED_RESPONSE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OCSP_BASIC_REVOKED_INFO {
    pub RevocationDate: FILETIME,
    pub dwCrlReasonCode: DWORD,
}
pub type OCSP_BASIC_REVOKED_INFO = _OCSP_BASIC_REVOKED_INFO;
pub type POCSP_BASIC_REVOKED_INFO = *mut _OCSP_BASIC_REVOKED_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OCSP_BASIC_RESPONSE_ENTRY {
    pub CertId: OCSP_CERT_ID,
    pub dwCertStatus: DWORD,
    pub __bindgen_anon_1: _OCSP_BASIC_RESPONSE_ENTRY__bindgen_ty_1,
    pub ThisUpdate: FILETIME,
    pub NextUpdate: FILETIME,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OCSP_BASIC_RESPONSE_ENTRY__bindgen_ty_1 {
    pub pRevokedInfo: POCSP_BASIC_REVOKED_INFO,
}
pub type OCSP_BASIC_RESPONSE_ENTRY = _OCSP_BASIC_RESPONSE_ENTRY;
pub type POCSP_BASIC_RESPONSE_ENTRY = *mut _OCSP_BASIC_RESPONSE_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OCSP_BASIC_RESPONSE_INFO {
    pub dwVersion: DWORD,
    pub dwResponderIdChoice: DWORD,
    pub __bindgen_anon_1: _OCSP_BASIC_RESPONSE_INFO__bindgen_ty_1,
    pub ProducedAt: FILETIME,
    pub cResponseEntry: DWORD,
    pub rgResponseEntry: POCSP_BASIC_RESPONSE_ENTRY,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OCSP_BASIC_RESPONSE_INFO__bindgen_ty_1 {
    pub ByNameResponderId: CERT_NAME_BLOB,
    pub ByKeyResponderId: CRYPT_HASH_BLOB,
}
pub type OCSP_BASIC_RESPONSE_INFO = _OCSP_BASIC_RESPONSE_INFO;
pub type POCSP_BASIC_RESPONSE_INFO = *mut _OCSP_BASIC_RESPONSE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SUPPORTED_ALGORITHM_INFO {
    pub Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub IntendedKeyUsage: CRYPT_BIT_BLOB,
    pub IntendedCertPolicies: CERT_POLICIES_INFO,
}
pub type CERT_SUPPORTED_ALGORITHM_INFO = _CERT_SUPPORTED_ALGORITHM_INFO;
pub type PCERT_SUPPORTED_ALGORITHM_INFO = *mut _CERT_SUPPORTED_ALGORITHM_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_TPM_SPECIFICATION_INFO {
    pub pwszFamily: LPWSTR,
    pub dwLevel: DWORD,
    pub dwRevision: DWORD,
}
pub type CERT_TPM_SPECIFICATION_INFO = _CERT_TPM_SPECIFICATION_INFO;
pub type PCERT_TPM_SPECIFICATION_INFO = *mut _CERT_TPM_SPECIFICATION_INFO;
pub type HCRYPTOIDFUNCSET = *mut ::std::os::raw::c_void;
pub type HCRYPTOIDFUNCADDR = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_OID_FUNC_ENTRY {
    pub pszOID: LPCSTR,
    pub pvFuncAddr: *mut ::std::os::raw::c_void,
}
pub type CRYPT_OID_FUNC_ENTRY = _CRYPT_OID_FUNC_ENTRY;
pub type PCRYPT_OID_FUNC_ENTRY = *mut _CRYPT_OID_FUNC_ENTRY;
extern "C" {
    pub fn CryptInstallOIDFunctionAddress(
        hModule: HMODULE,
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        cFuncEntry: DWORD,
        rgFuncEntry: *const CRYPT_OID_FUNC_ENTRY,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptInitOIDFunctionSet(pszFuncName: LPCSTR, dwFlags: DWORD) -> HCRYPTOIDFUNCSET;
}
extern "C" {
    pub fn CryptGetOIDFunctionAddress(
        hFuncSet: HCRYPTOIDFUNCSET,
        dwEncodingType: DWORD,
        pszOID: LPCSTR,
        dwFlags: DWORD,
        ppvFuncAddr: *mut *mut ::std::os::raw::c_void,
        phFuncAddr: *mut HCRYPTOIDFUNCADDR,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetDefaultOIDDllList(
        hFuncSet: HCRYPTOIDFUNCSET,
        dwEncodingType: DWORD,
        pwszDllList: *mut WCHAR,
        pcchDllList: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetDefaultOIDFunctionAddress(
        hFuncSet: HCRYPTOIDFUNCSET,
        dwEncodingType: DWORD,
        pwszDll: LPCWSTR,
        dwFlags: DWORD,
        ppvFuncAddr: *mut *mut ::std::os::raw::c_void,
        phFuncAddr: *mut HCRYPTOIDFUNCADDR,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptFreeOIDFunctionAddress(hFuncAddr: HCRYPTOIDFUNCADDR, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptRegisterOIDFunction(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
        pwszDll: LPCWSTR,
        pszOverrideFuncName: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptUnregisterOIDFunction(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptRegisterDefaultOIDFunction(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        dwIndex: DWORD,
        pwszDll: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptUnregisterDefaultOIDFunction(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pwszDll: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSetOIDFunctionValue(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
        pwszValueName: LPCWSTR,
        dwValueType: DWORD,
        pbValueData: *const BYTE,
        cbValueData: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetOIDFunctionValue(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
        pwszValueName: LPCWSTR,
        pdwValueType: *mut DWORD,
        pbValueData: *mut BYTE,
        pcbValueData: *mut DWORD,
    ) -> BOOL;
}
pub type PFN_CRYPT_ENUM_OID_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
        cValue: DWORD,
        rgdwValueType: *const DWORD,
        rgpwszValueName: *const LPCWSTR,
        rgpbValueData: *const *const BYTE,
        rgcbValueData: *const DWORD,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptEnumOIDFunction(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
        dwFlags: DWORD,
        pvArg: *mut ::std::os::raw::c_void,
        pfnEnumOIDFunc: PFN_CRYPT_ENUM_OID_FUNC,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CRYPT_OID_INFO {
    pub cbSize: DWORD,
    pub pszOID: LPCSTR,
    pub pwszName: LPCWSTR,
    pub dwGroupId: DWORD,
    pub __bindgen_anon_1: _CRYPT_OID_INFO__bindgen_ty_1,
    pub ExtraInfo: CRYPT_DATA_BLOB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CRYPT_OID_INFO__bindgen_ty_1 {
    pub dwValue: DWORD,
    pub Algid: ALG_ID,
    pub dwLength: DWORD,
}
pub type CRYPT_OID_INFO = _CRYPT_OID_INFO;
pub type PCRYPT_OID_INFO = *mut _CRYPT_OID_INFO;
pub type CCRYPT_OID_INFO = CRYPT_OID_INFO;
pub type PCCRYPT_OID_INFO = *const CRYPT_OID_INFO;
extern "C" {
    pub fn CryptFindOIDInfo(
        dwKeyType: DWORD,
        pvKey: *mut ::std::os::raw::c_void,
        dwGroupId: DWORD,
    ) -> PCCRYPT_OID_INFO;
}
extern "C" {
    pub fn CryptRegisterOIDInfo(pInfo: PCCRYPT_OID_INFO, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptUnregisterOIDInfo(pInfo: PCCRYPT_OID_INFO) -> BOOL;
}
pub type PFN_CRYPT_ENUM_OID_INFO = ::std::option::Option<
    unsafe extern "C" fn(pInfo: PCCRYPT_OID_INFO, pvArg: *mut ::std::os::raw::c_void) -> BOOL,
>;
extern "C" {
    pub fn CryptEnumOIDInfo(
        dwGroupId: DWORD,
        dwFlags: DWORD,
        pvArg: *mut ::std::os::raw::c_void,
        pfnEnumOIDInfo: PFN_CRYPT_ENUM_OID_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptFindLocalizedName(pwszCryptName: LPCWSTR) -> LPCWSTR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_STRONG_SIGN_SERIALIZED_INFO {
    pub dwFlags: DWORD,
    pub pwszCNGSignHashAlgids: LPWSTR,
    pub pwszCNGPubKeyMinBitLengths: LPWSTR,
}
pub type CERT_STRONG_SIGN_SERIALIZED_INFO = _CERT_STRONG_SIGN_SERIALIZED_INFO;
pub type PCERT_STRONG_SIGN_SERIALIZED_INFO = *mut _CERT_STRONG_SIGN_SERIALIZED_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_STRONG_SIGN_PARA {
    pub cbSize: DWORD,
    pub dwInfoChoice: DWORD,
    pub __bindgen_anon_1: _CERT_STRONG_SIGN_PARA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_STRONG_SIGN_PARA__bindgen_ty_1 {
    pub pvInfo: *mut ::std::os::raw::c_void,
    pub pSerializedInfo: PCERT_STRONG_SIGN_SERIALIZED_INFO,
    pub pszOID: LPSTR,
}
pub type CERT_STRONG_SIGN_PARA = _CERT_STRONG_SIGN_PARA;
pub type PCERT_STRONG_SIGN_PARA = *mut _CERT_STRONG_SIGN_PARA;
pub type PCCERT_STRONG_SIGN_PARA = *const CERT_STRONG_SIGN_PARA;
pub type HCRYPTMSG = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_ISSUER_SERIAL_NUMBER {
    pub Issuer: CERT_NAME_BLOB,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
}
pub type CERT_ISSUER_SERIAL_NUMBER = _CERT_ISSUER_SERIAL_NUMBER;
pub type PCERT_ISSUER_SERIAL_NUMBER = *mut _CERT_ISSUER_SERIAL_NUMBER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_ID {
    pub dwIdChoice: DWORD,
    pub __bindgen_anon_1: _CERT_ID__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_ID__bindgen_ty_1 {
    pub IssuerSerialNumber: CERT_ISSUER_SERIAL_NUMBER,
    pub KeyId: CRYPT_HASH_BLOB,
    pub HashId: CRYPT_HASH_BLOB,
}
pub type CERT_ID = _CERT_ID;
pub type PCERT_ID = *mut _CERT_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_SIGNER_ENCODE_INFO {
    pub cbSize: DWORD,
    pub pCertInfo: PCERT_INFO,
    pub __bindgen_anon_1: _CMSG_SIGNER_ENCODE_INFO__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvHashAuxInfo: *mut ::std::os::raw::c_void,
    pub cAuthAttr: DWORD,
    pub rgAuthAttr: PCRYPT_ATTRIBUTE,
    pub cUnauthAttr: DWORD,
    pub rgUnauthAttr: PCRYPT_ATTRIBUTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_SIGNER_ENCODE_INFO__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type CMSG_SIGNER_ENCODE_INFO = _CMSG_SIGNER_ENCODE_INFO;
pub type PCMSG_SIGNER_ENCODE_INFO = *mut _CMSG_SIGNER_ENCODE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_SIGNED_ENCODE_INFO {
    pub cbSize: DWORD,
    pub cSigners: DWORD,
    pub rgSigners: PCMSG_SIGNER_ENCODE_INFO,
    pub cCertEncoded: DWORD,
    pub rgCertEncoded: PCERT_BLOB,
    pub cCrlEncoded: DWORD,
    pub rgCrlEncoded: PCRL_BLOB,
}
pub type CMSG_SIGNED_ENCODE_INFO = _CMSG_SIGNED_ENCODE_INFO;
pub type PCMSG_SIGNED_ENCODE_INFO = *mut _CMSG_SIGNED_ENCODE_INFO;
pub type CMSG_RECIPIENT_ENCODE_INFO = _CMSG_RECIPIENT_ENCODE_INFO;
pub type PCMSG_RECIPIENT_ENCODE_INFO = *mut _CMSG_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_ENVELOPED_ENCODE_INFO {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub cRecipients: DWORD,
    pub rgpRecipients: *mut PCERT_INFO,
}
pub type CMSG_ENVELOPED_ENCODE_INFO = _CMSG_ENVELOPED_ENCODE_INFO;
pub type PCMSG_ENVELOPED_ENCODE_INFO = *mut _CMSG_ENVELOPED_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
    pub cbSize: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub RecipientPublicKey: CRYPT_BIT_BLOB,
    pub RecipientId: CERT_ID,
}
pub type CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
pub type PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = *mut _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
    pub cbSize: DWORD,
    pub RecipientPublicKey: CRYPT_BIT_BLOB,
    pub RecipientId: CERT_ID,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
pub type CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
pub type PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = *mut _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
    pub cbSize: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyWrapAuxInfo: *mut ::std::os::raw::c_void,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub dwKeySpec: DWORD,
    pub dwKeyChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO__bindgen_ty_1,
    pub UserKeyingMaterial: CRYPT_DATA_BLOB,
    pub cRecipientEncryptedKeys: DWORD,
    pub rgpRecipientEncryptedKeys: *mut PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO__bindgen_ty_1 {
    pub pEphemeralAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
    pub pSenderId: PCERT_ID,
}
pub type CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
pub type PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = *mut _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
    pub cbSize: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub hCryptProv: HCRYPTPROV,
    pub dwKeyChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO__bindgen_ty_1,
    pub KeyId: CRYPT_DATA_BLOB,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO__bindgen_ty_1 {
    pub hKeyEncryptionKey: HCRYPTKEY,
    pub pvKeyEncryptionKey: *mut ::std::os::raw::c_void,
}
pub type CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
pub type PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = *mut _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_RECIPIENT_ENCODE_INFO {
    pub dwRecipientChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_RECIPIENT_ENCODE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_RECIPIENT_ENCODE_INFO__bindgen_ty_1 {
    pub pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
    pub pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
    pub pMailList: PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_RC2_AUX_INFO {
    pub cbSize: DWORD,
    pub dwBitLen: DWORD,
}
pub type CMSG_RC2_AUX_INFO = _CMSG_RC2_AUX_INFO;
pub type PCMSG_RC2_AUX_INFO = *mut _CMSG_RC2_AUX_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
    pub cbSize: DWORD,
    pub dwFlags: DWORD,
}
pub type CMSG_SP3_COMPATIBLE_AUX_INFO = _CMSG_SP3_COMPATIBLE_AUX_INFO;
pub type PCMSG_SP3_COMPATIBLE_AUX_INFO = *mut _CMSG_SP3_COMPATIBLE_AUX_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_RC4_AUX_INFO {
    pub cbSize: DWORD,
    pub dwBitLen: DWORD,
}
pub type CMSG_RC4_AUX_INFO = _CMSG_RC4_AUX_INFO;
pub type PCMSG_RC4_AUX_INFO = *mut _CMSG_RC4_AUX_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO {
    pub cbSize: DWORD,
    pub SignedInfo: CMSG_SIGNED_ENCODE_INFO,
    pub EnvelopedInfo: CMSG_ENVELOPED_ENCODE_INFO,
}
pub type CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;
pub type PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = *mut _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_HASHED_ENCODE_INFO {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvHashAuxInfo: *mut ::std::os::raw::c_void,
}
pub type CMSG_HASHED_ENCODE_INFO = _CMSG_HASHED_ENCODE_INFO;
pub type PCMSG_HASHED_ENCODE_INFO = *mut _CMSG_HASHED_ENCODE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_ENCRYPTED_ENCODE_INFO {
    pub cbSize: DWORD,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvEncryptionAuxInfo: *mut ::std::os::raw::c_void,
}
pub type CMSG_ENCRYPTED_ENCODE_INFO = _CMSG_ENCRYPTED_ENCODE_INFO;
pub type PCMSG_ENCRYPTED_ENCODE_INFO = *mut _CMSG_ENCRYPTED_ENCODE_INFO;
pub type PFN_CMSG_STREAM_OUTPUT = ::std::option::Option<
    unsafe extern "C" fn(
        pvArg: *const ::std::os::raw::c_void,
        pbData: *mut BYTE,
        cbData: DWORD,
        fFinal: BOOL,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_STREAM_INFO {
    pub cbContent: DWORD,
    pub pfnStreamOutput: PFN_CMSG_STREAM_OUTPUT,
    pub pvArg: *mut ::std::os::raw::c_void,
}
pub type CMSG_STREAM_INFO = _CMSG_STREAM_INFO;
pub type PCMSG_STREAM_INFO = *mut _CMSG_STREAM_INFO;
extern "C" {
    pub fn CryptMsgOpenToEncode(
        dwMsgEncodingType: DWORD,
        dwFlags: DWORD,
        dwMsgType: DWORD,
        pvMsgEncodeInfo: *const ::std::os::raw::c_void,
        pszInnerContentObjID: LPSTR,
        pStreamInfo: PCMSG_STREAM_INFO,
    ) -> HCRYPTMSG;
}
extern "C" {
    pub fn CryptMsgCalculateEncodedLength(
        dwMsgEncodingType: DWORD,
        dwFlags: DWORD,
        dwMsgType: DWORD,
        pvMsgEncodeInfo: *const ::std::os::raw::c_void,
        pszInnerContentObjID: LPSTR,
        cbData: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CryptMsgOpenToDecode(
        dwMsgEncodingType: DWORD,
        dwFlags: DWORD,
        dwMsgType: DWORD,
        hCryptProv: HCRYPTPROV_LEGACY,
        pRecipientInfo: PCERT_INFO,
        pStreamInfo: PCMSG_STREAM_INFO,
    ) -> HCRYPTMSG;
}
extern "C" {
    pub fn CryptMsgDuplicate(hCryptMsg: HCRYPTMSG) -> HCRYPTMSG;
}
extern "C" {
    pub fn CryptMsgClose(hCryptMsg: HCRYPTMSG) -> BOOL;
}
extern "C" {
    pub fn CryptMsgUpdate(
        hCryptMsg: HCRYPTMSG,
        pbData: *const BYTE,
        cbData: DWORD,
        fFinal: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgGetParam(
        hCryptMsg: HCRYPTMSG,
        dwParamType: DWORD,
        dwIndex: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_SIGNER_INFO {
    pub dwVersion: DWORD,
    pub Issuer: CERT_NAME_BLOB,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedHash: CRYPT_DATA_BLOB,
    pub AuthAttrs: CRYPT_ATTRIBUTES,
    pub UnauthAttrs: CRYPT_ATTRIBUTES,
}
pub type CMSG_SIGNER_INFO = _CMSG_SIGNER_INFO;
pub type PCMSG_SIGNER_INFO = *mut _CMSG_SIGNER_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CMS_SIGNER_INFO {
    pub dwVersion: DWORD,
    pub SignerId: CERT_ID,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedHash: CRYPT_DATA_BLOB,
    pub AuthAttrs: CRYPT_ATTRIBUTES,
    pub UnauthAttrs: CRYPT_ATTRIBUTES,
}
pub type CMSG_CMS_SIGNER_INFO = _CMSG_CMS_SIGNER_INFO;
pub type PCMSG_CMS_SIGNER_INFO = *mut _CMSG_CMS_SIGNER_INFO;
pub type CMSG_ATTR = CRYPT_ATTRIBUTES;
pub type PCMSG_ATTR = *mut CRYPT_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_TRANS_RECIPIENT_INFO {
    pub dwVersion: DWORD,
    pub RecipientId: CERT_ID,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
}
pub type CMSG_KEY_TRANS_RECIPIENT_INFO = _CMSG_KEY_TRANS_RECIPIENT_INFO;
pub type PCMSG_KEY_TRANS_RECIPIENT_INFO = *mut _CMSG_KEY_TRANS_RECIPIENT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
    pub RecipientId: CERT_ID,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
pub type CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
pub type PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = *mut _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_AGREE_RECIPIENT_INFO {
    pub dwVersion: DWORD,
    pub dwOriginatorChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_KEY_AGREE_RECIPIENT_INFO__bindgen_ty_1,
    pub UserKeyingMaterial: CRYPT_DATA_BLOB,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub cRecipientEncryptedKeys: DWORD,
    pub rgpRecipientEncryptedKeys: *mut PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_KEY_AGREE_RECIPIENT_INFO__bindgen_ty_1 {
    pub OriginatorCertId: CERT_ID,
    pub OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
}
pub type CMSG_KEY_AGREE_RECIPIENT_INFO = _CMSG_KEY_AGREE_RECIPIENT_INFO;
pub type PCMSG_KEY_AGREE_RECIPIENT_INFO = *mut _CMSG_KEY_AGREE_RECIPIENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_MAIL_LIST_RECIPIENT_INFO {
    pub dwVersion: DWORD,
    pub KeyId: CRYPT_DATA_BLOB,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
pub type CMSG_MAIL_LIST_RECIPIENT_INFO = _CMSG_MAIL_LIST_RECIPIENT_INFO;
pub type PCMSG_MAIL_LIST_RECIPIENT_INFO = *mut _CMSG_MAIL_LIST_RECIPIENT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CMS_RECIPIENT_INFO {
    pub dwRecipientChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_CMS_RECIPIENT_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CMS_RECIPIENT_INFO__bindgen_ty_1 {
    pub pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_INFO,
    pub pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_INFO,
    pub pMailList: PCMSG_MAIL_LIST_RECIPIENT_INFO,
}
pub type CMSG_CMS_RECIPIENT_INFO = _CMSG_CMS_RECIPIENT_INFO;
pub type PCMSG_CMS_RECIPIENT_INFO = *mut _CMSG_CMS_RECIPIENT_INFO;
extern "C" {
    pub fn CryptMsgControl(
        hCryptMsg: HCRYPTMSG,
        dwFlags: DWORD,
        dwCtrlType: DWORD,
        pvCtrlPara: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub dwSignerIndex: DWORD,
    pub dwSignerType: DWORD,
    pub pvSigner: *mut ::std::os::raw::c_void,
}
pub type CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;
pub type PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = *mut _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_DECRYPT_PARA__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub dwRecipientIndex: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_DECRYPT_PARA__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type CMSG_CTRL_DECRYPT_PARA = _CMSG_CTRL_DECRYPT_PARA;
pub type PCMSG_CTRL_DECRYPT_PARA = *mut _CMSG_CTRL_DECRYPT_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_INFO,
    pub dwRecipientIndex: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
pub type PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = *mut _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_INFO,
    pub dwRecipientIndex: DWORD,
    pub dwRecipientEncryptedKeyIndex: DWORD,
    pub OriginatorPublicKey: CRYPT_BIT_BLOB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
pub type PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = *mut _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV,
    pub pMailList: PCMSG_MAIL_LIST_RECIPIENT_INFO,
    pub dwRecipientIndex: DWORD,
    pub dwKeyChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA__bindgen_ty_1 {
    pub hKeyEncryptionKey: HCRYPTKEY,
    pub pvKeyEncryptionKey: *mut ::std::os::raw::c_void,
}
pub type CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
pub type PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = *mut _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA {
    pub cbSize: DWORD,
    pub dwSignerIndex: DWORD,
    pub blob: CRYPT_DATA_BLOB,
}
pub type CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;
pub type PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = *mut _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA {
    pub cbSize: DWORD,
    pub dwSignerIndex: DWORD,
    pub dwUnauthAttrIndex: DWORD,
}
pub type CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;
pub type PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = *mut _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;
extern "C" {
    pub fn CryptMsgVerifyCountersignatureEncoded(
        hCryptProv: HCRYPTPROV_LEGACY,
        dwEncodingType: DWORD,
        pbSignerInfo: PBYTE,
        cbSignerInfo: DWORD,
        pbSignerInfoCountersignature: PBYTE,
        cbSignerInfoCountersignature: DWORD,
        pciCountersigner: PCERT_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgVerifyCountersignatureEncodedEx(
        hCryptProv: HCRYPTPROV_LEGACY,
        dwEncodingType: DWORD,
        pbSignerInfo: PBYTE,
        cbSignerInfo: DWORD,
        pbSignerInfoCountersignature: PBYTE,
        cbSignerInfoCountersignature: DWORD,
        dwSignerType: DWORD,
        pvSigner: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
        pvExtra: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgCountersign(
        hCryptMsg: HCRYPTMSG,
        dwIndex: DWORD,
        cCountersigners: DWORD,
        rgCountersigners: PCMSG_SIGNER_ENCODE_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgCountersignEncoded(
        dwEncodingType: DWORD,
        pbSignerInfo: PBYTE,
        cbSignerInfo: DWORD,
        cCountersigners: DWORD,
        rgCountersigners: PCMSG_SIGNER_ENCODE_INFO,
        pbCountersignature: PBYTE,
        pcbCountersignature: PDWORD,
    ) -> BOOL;
}
pub type PFN_CMSG_ALLOC =
    ::std::option::Option<unsafe extern "C" fn(cb: usize) -> *mut ::std::os::raw::c_void>;
pub type PFN_CMSG_FREE =
    ::std::option::Option<unsafe extern "C" fn(pv: *mut ::std::os::raw::c_void)>;
pub type PFN_CMSG_GEN_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        phCryptProv: *mut HCRYPTPROV,
        paiEncrypt: PCRYPT_ALGORITHM_IDENTIFIER,
        pvEncryptAuxInfo: PVOID,
        pPublicKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pfnAlloc: PFN_CMSG_ALLOC,
        phEncryptKey: *mut HCRYPTKEY,
        ppbEncryptParameters: *mut PBYTE,
        pcbEncryptParameters: PDWORD,
    ) -> BOOL,
>;
pub type PFN_CMSG_EXPORT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        hEncryptKey: HCRYPTKEY,
        pPublicKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pbData: PBYTE,
        pcbData: PDWORD,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        dwKeySpec: DWORD,
        paiEncrypt: PCRYPT_ALGORITHM_IDENTIFIER,
        paiPubKey: PCRYPT_ALGORITHM_IDENTIFIER,
        pbEncodedKey: PBYTE,
        cbEncodedKey: DWORD,
        phEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CONTENT_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub cRecipients: DWORD,
    pub rgCmsRecipients: PCMSG_RECIPIENT_ENCODE_INFO,
    pub pfnAlloc: PFN_CMSG_ALLOC,
    pub pfnFree: PFN_CMSG_FREE,
    pub dwEncryptFlags: DWORD,
    pub __bindgen_anon_1: _CMSG_CONTENT_ENCRYPT_INFO__bindgen_ty_1,
    pub dwFlags: DWORD,
    pub fCNG: BOOL,
    pub pbCNGContentEncryptKeyObject: *mut BYTE,
    pub pbContentEncryptKey: *mut BYTE,
    pub cbContentEncryptKey: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CONTENT_ENCRYPT_INFO__bindgen_ty_1 {
    pub hContentEncryptKey: HCRYPTKEY,
    pub hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
}
pub type CMSG_CONTENT_ENCRYPT_INFO = _CMSG_CONTENT_ENCRYPT_INFO;
pub type PCMSG_CONTENT_ENCRYPT_INFO = *mut _CMSG_CONTENT_ENCRYPT_INFO;
pub type PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_KEY_TRANS_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub dwRecipientIndex: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub dwFlags: DWORD,
}
pub type CMSG_KEY_TRANS_ENCRYPT_INFO = _CMSG_KEY_TRANS_ENCRYPT_INFO;
pub type PCMSG_KEY_TRANS_ENCRYPT_INFO = *mut _CMSG_KEY_TRANS_ENCRYPT_INFO;
pub type PFN_CMSG_EXPORT_KEY_TRANS = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        pKeyTransEncodeInfo: PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
        pKeyTransEncryptInfo: PCMSG_KEY_TRANS_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub EncryptedKey: CRYPT_DATA_BLOB,
}
pub type CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
pub type PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = *mut _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_AGREE_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub dwRecipientIndex: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub UserKeyingMaterial: CRYPT_DATA_BLOB,
    pub dwOriginatorChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_KEY_AGREE_ENCRYPT_INFO__bindgen_ty_1,
    pub cKeyAgreeKeyEncryptInfo: DWORD,
    pub rgpKeyAgreeKeyEncryptInfo: *mut PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    pub dwFlags: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_KEY_AGREE_ENCRYPT_INFO__bindgen_ty_1 {
    pub OriginatorCertId: CERT_ID,
    pub OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
}
pub type CMSG_KEY_AGREE_ENCRYPT_INFO = _CMSG_KEY_AGREE_ENCRYPT_INFO;
pub type PCMSG_KEY_AGREE_ENCRYPT_INFO = *mut _CMSG_KEY_AGREE_ENCRYPT_INFO;
pub type PFN_CMSG_EXPORT_KEY_AGREE = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        pKeyAgreeEncodeInfo: PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
        pKeyAgreeEncryptInfo: PCMSG_KEY_AGREE_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_MAIL_LIST_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub dwRecipientIndex: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub dwFlags: DWORD,
}
pub type CMSG_MAIL_LIST_ENCRYPT_INFO = _CMSG_MAIL_LIST_ENCRYPT_INFO;
pub type PCMSG_MAIL_LIST_ENCRYPT_INFO = *mut _CMSG_MAIL_LIST_ENCRYPT_INFO;
pub type PFN_CMSG_EXPORT_MAIL_LIST = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        pMailListEncodeInfo: PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
        pMailListEncryptInfo: PCMSG_MAIL_LIST_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_KEY_TRANS = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptionAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pKeyTransDecryptPara: PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phContentEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_KEY_AGREE = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptionAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pKeyAgreeDecryptPara: PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phContentEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_MAIL_LIST = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptionAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pMailListDecryptPara: PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phContentEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_CNG_CONTENT_DECRYPT_INFO {
    pub cbSize: DWORD,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pfnAlloc: PFN_CMSG_ALLOC,
    pub pfnFree: PFN_CMSG_FREE,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
    pub pbContentEncryptKey: *mut BYTE,
    pub cbContentEncryptKey: DWORD,
    pub hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    pub pbCNGContentEncryptKeyObject: *mut BYTE,
}
pub type CMSG_CNG_CONTENT_DECRYPT_INFO = _CMSG_CNG_CONTENT_DECRYPT_INFO;
pub type PCMSG_CNG_CONTENT_DECRYPT_INFO = *mut _CMSG_CNG_CONTENT_DECRYPT_INFO;
pub type PFN_CMSG_CNG_IMPORT_KEY_TRANS = ::std::option::Option<
    unsafe extern "C" fn(
        pCNGContentDecryptInfo: PCMSG_CNG_CONTENT_DECRYPT_INFO,
        pKeyTransDecryptPara: PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CMSG_CNG_IMPORT_KEY_AGREE = ::std::option::Option<
    unsafe extern "C" fn(
        pCNGContentDecryptInfo: PCMSG_CNG_CONTENT_DECRYPT_INFO,
        pKeyAgreeDecryptPara: PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        pCNGContentDecryptInfo: PCMSG_CNG_CONTENT_DECRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type HCERTSTORE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CONTEXT {
    pub dwCertEncodingType: DWORD,
    pub pbCertEncoded: *mut BYTE,
    pub cbCertEncoded: DWORD,
    pub pCertInfo: PCERT_INFO,
    pub hCertStore: HCERTSTORE,
}
pub type CERT_CONTEXT = _CERT_CONTEXT;
pub type PCERT_CONTEXT = *mut _CERT_CONTEXT;
pub type PCCERT_CONTEXT = *const CERT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_CONTEXT {
    pub dwCertEncodingType: DWORD,
    pub pbCrlEncoded: *mut BYTE,
    pub cbCrlEncoded: DWORD,
    pub pCrlInfo: PCRL_INFO,
    pub hCertStore: HCERTSTORE,
}
pub type CRL_CONTEXT = _CRL_CONTEXT;
pub type PCRL_CONTEXT = *mut _CRL_CONTEXT;
pub type PCCRL_CONTEXT = *const CRL_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_CONTEXT {
    pub dwMsgAndCertEncodingType: DWORD,
    pub pbCtlEncoded: *mut BYTE,
    pub cbCtlEncoded: DWORD,
    pub pCtlInfo: PCTL_INFO,
    pub hCertStore: HCERTSTORE,
    pub hCryptMsg: HCRYPTMSG,
    pub pbCtlContent: *mut BYTE,
    pub cbCtlContent: DWORD,
}
pub type CTL_CONTEXT = _CTL_CONTEXT;
pub type PCTL_CONTEXT = *mut _CTL_CONTEXT;
pub type PCCTL_CONTEXT = *const CTL_CONTEXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CertKeyType {
    KeyTypeOther = 0,
    KeyTypeVirtualSmartCard = 1,
    KeyTypePhysicalSmartCard = 2,
    KeyTypePassport = 3,
    KeyTypePassportRemote = 4,
    KeyTypePassportSmartCard = 5,
    KeyTypeHardware = 6,
    KeyTypeSoftware = 7,
    KeyTypeSelfSigned = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_KEY_PROV_PARAM {
    pub dwParam: DWORD,
    pub pbData: *mut BYTE,
    pub cbData: DWORD,
    pub dwFlags: DWORD,
}
pub type CRYPT_KEY_PROV_PARAM = _CRYPT_KEY_PROV_PARAM;
pub type PCRYPT_KEY_PROV_PARAM = *mut _CRYPT_KEY_PROV_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_KEY_PROV_INFO {
    pub pwszContainerName: LPWSTR,
    pub pwszProvName: LPWSTR,
    pub dwProvType: DWORD,
    pub dwFlags: DWORD,
    pub cProvParam: DWORD,
    pub rgProvParam: PCRYPT_KEY_PROV_PARAM,
    pub dwKeySpec: DWORD,
}
pub type CRYPT_KEY_PROV_INFO = _CRYPT_KEY_PROV_INFO;
pub type PCRYPT_KEY_PROV_INFO = *mut _CRYPT_KEY_PROV_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_KEY_CONTEXT {
    pub cbSize: DWORD,
    pub __bindgen_anon_1: _CERT_KEY_CONTEXT__bindgen_ty_1,
    pub dwKeySpec: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_KEY_CONTEXT__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type CERT_KEY_CONTEXT = _CERT_KEY_CONTEXT;
pub type PCERT_KEY_CONTEXT = *mut _CERT_KEY_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ROOT_INFO_LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type ROOT_INFO_LUID = _ROOT_INFO_LUID;
pub type PROOT_INFO_LUID = *mut _ROOT_INFO_LUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_SMART_CARD_ROOT_INFO {
    pub rgbCardID: [BYTE; 16usize],
    pub luid: ROOT_INFO_LUID,
}
pub type CRYPT_SMART_CARD_ROOT_INFO = _CRYPT_SMART_CARD_ROOT_INFO;
pub type PCRYPT_SMART_CARD_ROOT_INFO = *mut _CRYPT_SMART_CARD_ROOT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_SYSTEM_STORE_RELOCATE_PARA {
    pub __bindgen_anon_1: _CERT_SYSTEM_STORE_RELOCATE_PARA__bindgen_ty_1,
    pub __bindgen_anon_2: _CERT_SYSTEM_STORE_RELOCATE_PARA__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_SYSTEM_STORE_RELOCATE_PARA__bindgen_ty_1 {
    pub hKeyBase: HKEY,
    pub pvBase: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_SYSTEM_STORE_RELOCATE_PARA__bindgen_ty_2 {
    pub pvSystemStore: *mut ::std::os::raw::c_void,
    pub pszSystemStore: LPCSTR,
    pub pwszSystemStore: LPCWSTR,
}
pub type CERT_SYSTEM_STORE_RELOCATE_PARA = _CERT_SYSTEM_STORE_RELOCATE_PARA;
pub type PCERT_SYSTEM_STORE_RELOCATE_PARA = *mut _CERT_SYSTEM_STORE_RELOCATE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA {
    pub hKeyBase: HKEY,
    pub pwszRegPath: LPWSTR,
}
pub type CERT_REGISTRY_STORE_CLIENT_GPT_PARA = _CERT_REGISTRY_STORE_CLIENT_GPT_PARA;
pub type PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = *mut _CERT_REGISTRY_STORE_CLIENT_GPT_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REGISTRY_STORE_ROAMING_PARA {
    pub hKey: HKEY,
    pub pwszStoreDirectory: LPWSTR,
}
pub type CERT_REGISTRY_STORE_ROAMING_PARA = _CERT_REGISTRY_STORE_ROAMING_PARA;
pub type PCERT_REGISTRY_STORE_ROAMING_PARA = *mut _CERT_REGISTRY_STORE_ROAMING_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_LDAP_STORE_OPENED_PARA {
    pub pvLdapSessionHandle: *mut ::std::os::raw::c_void,
    pub pwszLdapUrl: LPCWSTR,
}
pub type CERT_LDAP_STORE_OPENED_PARA = _CERT_LDAP_STORE_OPENED_PARA;
pub type PCERT_LDAP_STORE_OPENED_PARA = *mut _CERT_LDAP_STORE_OPENED_PARA;
extern "C" {
    pub fn CertOpenStore(
        lpszStoreProvider: LPCSTR,
        dwEncodingType: DWORD,
        hCryptProv: HCRYPTPROV_LEGACY,
        dwFlags: DWORD,
        pvPara: *const ::std::os::raw::c_void,
    ) -> HCERTSTORE;
}
pub type HCERTSTOREPROV = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_STORE_PROV_INFO {
    pub cbSize: DWORD,
    pub cStoreProvFunc: DWORD,
    pub rgpvStoreProvFunc: *mut *mut ::std::os::raw::c_void,
    pub hStoreProv: HCERTSTOREPROV,
    pub dwStoreProvFlags: DWORD,
    pub hStoreProvFuncAddr2: HCRYPTOIDFUNCADDR,
}
pub type CERT_STORE_PROV_INFO = _CERT_STORE_PROV_INFO;
pub type PCERT_STORE_PROV_INFO = *mut _CERT_STORE_PROV_INFO;
pub type PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        lpszStoreProvider: LPCSTR,
        dwEncodingType: DWORD,
        hCryptProv: HCRYPTPROV_LEGACY,
        dwFlags: DWORD,
        pvPara: *const ::std::os::raw::c_void,
        hCertStore: HCERTSTORE,
        pStoreProvInfo: PCERT_STORE_PROV_INFO,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_CLOSE =
    ::std::option::Option<unsafe extern "C" fn(hStoreProv: HCERTSTOREPROV, dwFlags: DWORD)>;
pub type PFN_CERT_STORE_PROV_READ_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pStoreCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
        ppProvCertContext: *mut PCCERT_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_WRITE_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_DELETE_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_READ_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pStoreCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
        ppProvCrlContext: *mut PCCRL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_WRITE_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_DELETE_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_READ_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pStoreCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
        ppProvCtlContext: *mut PCCTL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_WRITE_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_DELETE_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        dwFlags: DWORD,
        dwCtrlType: DWORD,
        pvCtrlPara: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_STORE_PROV_FIND_INFO {
    pub cbSize: DWORD,
    pub dwMsgAndCertEncodingType: DWORD,
    pub dwFindFlags: DWORD,
    pub dwFindType: DWORD,
    pub pvFindPara: *const ::std::os::raw::c_void,
}
pub type CERT_STORE_PROV_FIND_INFO = _CERT_STORE_PROV_FIND_INFO;
pub type PCERT_STORE_PROV_FIND_INFO = *mut _CERT_STORE_PROV_FIND_INFO;
pub type CCERT_STORE_PROV_FIND_INFO = CERT_STORE_PROV_FIND_INFO;
pub type PCCERT_STORE_PROV_FIND_INFO = *const CERT_STORE_PROV_FIND_INFO;
pub type PFN_CERT_STORE_PROV_FIND_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pFindInfo: PCCERT_STORE_PROV_FIND_INFO,
        pPrevCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
        ppvStoreProvFindInfo: *mut *mut ::std::os::raw::c_void,
        ppProvCertContext: *mut PCCERT_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FREE_FIND_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        pvStoreProvFindInfo: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FIND_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pFindInfo: PCCERT_STORE_PROV_FIND_INFO,
        pPrevCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
        ppvStoreProvFindInfo: *mut *mut ::std::os::raw::c_void,
        ppProvCrlContext: *mut PCCRL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FREE_FIND_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        pvStoreProvFindInfo: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FIND_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pFindInfo: PCCERT_STORE_PROV_FIND_INFO,
        pPrevCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
        ppvStoreProvFindInfo: *mut *mut ::std::os::raw::c_void,
        ppProvCtlContext: *mut PCCTL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FREE_FIND_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        pvStoreProvFindInfo: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL,
>;
extern "C" {
    pub fn CertDuplicateStore(hCertStore: HCERTSTORE) -> HCERTSTORE;
}
extern "C" {
    pub fn CertSaveStore(
        hCertStore: HCERTSTORE,
        dwEncodingType: DWORD,
        dwSaveAs: DWORD,
        dwSaveTo: DWORD,
        pvSaveToPara: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertCloseStore(hCertStore: HCERTSTORE, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CertGetSubjectCertificateFromStore(
        hCertStore: HCERTSTORE,
        dwCertEncodingType: DWORD,
        pCertId: PCERT_INFO,
    ) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CertEnumCertificatesInStore(
        hCertStore: HCERTSTORE,
        pPrevCertContext: PCCERT_CONTEXT,
    ) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CertFindCertificateInStore(
        hCertStore: HCERTSTORE,
        dwCertEncodingType: DWORD,
        dwFindFlags: DWORD,
        dwFindType: DWORD,
        pvFindPara: *const ::std::os::raw::c_void,
        pPrevCertContext: PCCERT_CONTEXT,
    ) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CertGetIssuerCertificateFromStore(
        hCertStore: HCERTSTORE,
        pSubjectContext: PCCERT_CONTEXT,
        pPrevIssuerContext: PCCERT_CONTEXT,
        pdwFlags: *mut DWORD,
    ) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CertVerifySubjectCertificateContext(
        pSubject: PCCERT_CONTEXT,
        pIssuer: PCCERT_CONTEXT,
        pdwFlags: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertDuplicateCertificateContext(pCertContext: PCCERT_CONTEXT) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CertCreateCertificateContext(
        dwCertEncodingType: DWORD,
        pbCertEncoded: *const BYTE,
        cbCertEncoded: DWORD,
    ) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CertFreeCertificateContext(pCertContext: PCCERT_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CertSetCertificateContextProperty(
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetCertificateContextProperty(
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertEnumCertificateContextProperties(
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CertCreateCTLEntryFromCertificateContextProperties(
        pCertContext: PCCERT_CONTEXT,
        cOptAttr: DWORD,
        rgOptAttr: PCRYPT_ATTRIBUTE,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pCtlEntry: PCTL_ENTRY,
        pcbCtlEntry: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertSetCertificateContextPropertiesFromCTLEntry(
        pCertContext: PCCERT_CONTEXT,
        pCtlEntry: PCTL_ENTRY,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetCRLFromStore(
        hCertStore: HCERTSTORE,
        pIssuerContext: PCCERT_CONTEXT,
        pPrevCrlContext: PCCRL_CONTEXT,
        pdwFlags: *mut DWORD,
    ) -> PCCRL_CONTEXT;
}
extern "C" {
    pub fn CertEnumCRLsInStore(
        hCertStore: HCERTSTORE,
        pPrevCrlContext: PCCRL_CONTEXT,
    ) -> PCCRL_CONTEXT;
}
extern "C" {
    pub fn CertFindCRLInStore(
        hCertStore: HCERTSTORE,
        dwCertEncodingType: DWORD,
        dwFindFlags: DWORD,
        dwFindType: DWORD,
        pvFindPara: *const ::std::os::raw::c_void,
        pPrevCrlContext: PCCRL_CONTEXT,
    ) -> PCCRL_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_FIND_ISSUED_FOR_PARA {
    pub pSubjectCert: PCCERT_CONTEXT,
    pub pIssuerCert: PCCERT_CONTEXT,
}
pub type CRL_FIND_ISSUED_FOR_PARA = _CRL_FIND_ISSUED_FOR_PARA;
pub type PCRL_FIND_ISSUED_FOR_PARA = *mut _CRL_FIND_ISSUED_FOR_PARA;
extern "C" {
    pub fn CertDuplicateCRLContext(pCrlContext: PCCRL_CONTEXT) -> PCCRL_CONTEXT;
}
extern "C" {
    pub fn CertCreateCRLContext(
        dwCertEncodingType: DWORD,
        pbCrlEncoded: *const BYTE,
        cbCrlEncoded: DWORD,
    ) -> PCCRL_CONTEXT;
}
extern "C" {
    pub fn CertFreeCRLContext(pCrlContext: PCCRL_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CertSetCRLContextProperty(
        pCrlContext: PCCRL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetCRLContextProperty(
        pCrlContext: PCCRL_CONTEXT,
        dwPropId: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertEnumCRLContextProperties(pCrlContext: PCCRL_CONTEXT, dwPropId: DWORD) -> DWORD;
}
extern "C" {
    pub fn CertFindCertificateInCRL(
        pCert: PCCERT_CONTEXT,
        pCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        ppCrlEntry: *mut PCRL_ENTRY,
    ) -> BOOL;
}
extern "C" {
    pub fn CertIsValidCRLForCertificate(
        pCert: PCCERT_CONTEXT,
        pCrl: PCCRL_CONTEXT,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddEncodedCertificateToStore(
        hCertStore: HCERTSTORE,
        dwCertEncodingType: DWORD,
        pbCertEncoded: *const BYTE,
        cbCertEncoded: DWORD,
        dwAddDisposition: DWORD,
        ppCertContext: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddCertificateContextToStore(
        hCertStore: HCERTSTORE,
        pCertContext: PCCERT_CONTEXT,
        dwAddDisposition: DWORD,
        ppStoreContext: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddSerializedElementToStore(
        hCertStore: HCERTSTORE,
        pbElement: *const BYTE,
        cbElement: DWORD,
        dwAddDisposition: DWORD,
        dwFlags: DWORD,
        dwContextTypeFlags: DWORD,
        pdwContextType: *mut DWORD,
        ppvContext: *mut *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertDeleteCertificateFromStore(pCertContext: PCCERT_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CertAddEncodedCRLToStore(
        hCertStore: HCERTSTORE,
        dwCertEncodingType: DWORD,
        pbCrlEncoded: *const BYTE,
        cbCrlEncoded: DWORD,
        dwAddDisposition: DWORD,
        ppCrlContext: *mut PCCRL_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddCRLContextToStore(
        hCertStore: HCERTSTORE,
        pCrlContext: PCCRL_CONTEXT,
        dwAddDisposition: DWORD,
        ppStoreContext: *mut PCCRL_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertDeleteCRLFromStore(pCrlContext: PCCRL_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CertSerializeCertificateStoreElement(
        pCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
        pbElement: *mut BYTE,
        pcbElement: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertSerializeCRLStoreElement(
        pCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
        pbElement: *mut BYTE,
        pcbElement: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertDuplicateCTLContext(pCtlContext: PCCTL_CONTEXT) -> PCCTL_CONTEXT;
}
extern "C" {
    pub fn CertCreateCTLContext(
        dwMsgAndCertEncodingType: DWORD,
        pbCtlEncoded: *const BYTE,
        cbCtlEncoded: DWORD,
    ) -> PCCTL_CONTEXT;
}
extern "C" {
    pub fn CertFreeCTLContext(pCtlContext: PCCTL_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CertSetCTLContextProperty(
        pCtlContext: PCCTL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetCTLContextProperty(
        pCtlContext: PCCTL_CONTEXT,
        dwPropId: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertEnumCTLContextProperties(pCtlContext: PCCTL_CONTEXT, dwPropId: DWORD) -> DWORD;
}
extern "C" {
    pub fn CertEnumCTLsInStore(
        hCertStore: HCERTSTORE,
        pPrevCtlContext: PCCTL_CONTEXT,
    ) -> PCCTL_CONTEXT;
}
extern "C" {
    pub fn CertFindSubjectInCTL(
        dwEncodingType: DWORD,
        dwSubjectType: DWORD,
        pvSubject: *mut ::std::os::raw::c_void,
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
    ) -> PCTL_ENTRY;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_ANY_SUBJECT_INFO {
    pub SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub SubjectIdentifier: CRYPT_DATA_BLOB,
}
pub type CTL_ANY_SUBJECT_INFO = _CTL_ANY_SUBJECT_INFO;
pub type PCTL_ANY_SUBJECT_INFO = *mut _CTL_ANY_SUBJECT_INFO;
extern "C" {
    pub fn CertFindCTLInStore(
        hCertStore: HCERTSTORE,
        dwMsgAndCertEncodingType: DWORD,
        dwFindFlags: DWORD,
        dwFindType: DWORD,
        pvFindPara: *const ::std::os::raw::c_void,
        pPrevCtlContext: PCCTL_CONTEXT,
    ) -> PCCTL_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_FIND_USAGE_PARA {
    pub cbSize: DWORD,
    pub SubjectUsage: CTL_USAGE,
    pub ListIdentifier: CRYPT_DATA_BLOB,
    pub pSigner: PCERT_INFO,
}
pub type CTL_FIND_USAGE_PARA = _CTL_FIND_USAGE_PARA;
pub type PCTL_FIND_USAGE_PARA = *mut _CTL_FIND_USAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_FIND_SUBJECT_PARA {
    pub cbSize: DWORD,
    pub pUsagePara: PCTL_FIND_USAGE_PARA,
    pub dwSubjectType: DWORD,
    pub pvSubject: *mut ::std::os::raw::c_void,
}
pub type CTL_FIND_SUBJECT_PARA = _CTL_FIND_SUBJECT_PARA;
pub type PCTL_FIND_SUBJECT_PARA = *mut _CTL_FIND_SUBJECT_PARA;
extern "C" {
    pub fn CertAddEncodedCTLToStore(
        hCertStore: HCERTSTORE,
        dwMsgAndCertEncodingType: DWORD,
        pbCtlEncoded: *const BYTE,
        cbCtlEncoded: DWORD,
        dwAddDisposition: DWORD,
        ppCtlContext: *mut PCCTL_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddCTLContextToStore(
        hCertStore: HCERTSTORE,
        pCtlContext: PCCTL_CONTEXT,
        dwAddDisposition: DWORD,
        ppStoreContext: *mut PCCTL_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertSerializeCTLStoreElement(
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
        pbElement: *mut BYTE,
        pcbElement: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertDeleteCTLFromStore(pCtlContext: PCCTL_CONTEXT) -> BOOL;
}
extern "C" {
    pub fn CertAddCertificateLinkToStore(
        hCertStore: HCERTSTORE,
        pCertContext: PCCERT_CONTEXT,
        dwAddDisposition: DWORD,
        ppStoreContext: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddCRLLinkToStore(
        hCertStore: HCERTSTORE,
        pCrlContext: PCCRL_CONTEXT,
        dwAddDisposition: DWORD,
        ppStoreContext: *mut PCCRL_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddCTLLinkToStore(
        hCertStore: HCERTSTORE,
        pCtlContext: PCCTL_CONTEXT,
        dwAddDisposition: DWORD,
        ppStoreContext: *mut PCCTL_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddStoreToCollection(
        hCollectionStore: HCERTSTORE,
        hSiblingStore: HCERTSTORE,
        dwUpdateFlags: DWORD,
        dwPriority: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertRemoveStoreFromCollection(hCollectionStore: HCERTSTORE, hSiblingStore: HCERTSTORE);
}
extern "C" {
    pub fn CertControlStore(
        hCertStore: HCERTSTORE,
        dwFlags: DWORD,
        dwCtrlType: DWORD,
        pvCtrlPara: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertSetStoreProperty(
        hCertStore: HCERTSTORE,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetStoreProperty(
        hCertStore: HCERTSTORE,
        dwPropId: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL;
}
pub type PFN_CERT_CREATE_CONTEXT_SORT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        cbTotalEncoded: DWORD,
        cbRemainEncoded: DWORD,
        cEntry: DWORD,
        pvSort: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CREATE_CONTEXT_PARA {
    pub cbSize: DWORD,
    pub pfnFree: PFN_CRYPT_FREE,
    pub pvFree: *mut ::std::os::raw::c_void,
    pub pfnSort: PFN_CERT_CREATE_CONTEXT_SORT_FUNC,
    pub pvSort: *mut ::std::os::raw::c_void,
}
pub type CERT_CREATE_CONTEXT_PARA = _CERT_CREATE_CONTEXT_PARA;
pub type PCERT_CREATE_CONTEXT_PARA = *mut _CERT_CREATE_CONTEXT_PARA;
extern "C" {
    pub fn CertCreateContext(
        dwContextType: DWORD,
        dwEncodingType: DWORD,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        dwFlags: DWORD,
        pCreatePara: PCERT_CREATE_CONTEXT_PARA,
    ) -> *const ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SYSTEM_STORE_INFO {
    pub cbSize: DWORD,
}
pub type CERT_SYSTEM_STORE_INFO = _CERT_SYSTEM_STORE_INFO;
pub type PCERT_SYSTEM_STORE_INFO = *mut _CERT_SYSTEM_STORE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_PHYSICAL_STORE_INFO {
    pub cbSize: DWORD,
    pub pszOpenStoreProvider: LPSTR,
    pub dwOpenEncodingType: DWORD,
    pub dwOpenFlags: DWORD,
    pub OpenParameters: CRYPT_DATA_BLOB,
    pub dwFlags: DWORD,
    pub dwPriority: DWORD,
}
pub type CERT_PHYSICAL_STORE_INFO = _CERT_PHYSICAL_STORE_INFO;
pub type PCERT_PHYSICAL_STORE_INFO = *mut _CERT_PHYSICAL_STORE_INFO;
extern "C" {
    pub fn CertRegisterSystemStore(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pStoreInfo: PCERT_SYSTEM_STORE_INFO,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertRegisterPhysicalStore(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pwszStoreName: LPCWSTR,
        pStoreInfo: PCERT_PHYSICAL_STORE_INFO,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CertUnregisterSystemStore(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertUnregisterPhysicalStore(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pwszStoreName: LPCWSTR,
    ) -> BOOL;
}
pub type PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = ::std::option::Option<
    unsafe extern "C" fn(
        pwszStoreLocation: LPCWSTR,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_ENUM_SYSTEM_STORE = ::std::option::Option<
    unsafe extern "C" fn(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pStoreInfo: PCERT_SYSTEM_STORE_INFO,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_ENUM_PHYSICAL_STORE = ::std::option::Option<
    unsafe extern "C" fn(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pwszStoreName: LPCWSTR,
        pStoreInfo: PCERT_PHYSICAL_STORE_INFO,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
extern "C" {
    pub fn CertEnumSystemStoreLocation(
        dwFlags: DWORD,
        pvArg: *mut ::std::os::raw::c_void,
        pfnEnum: PFN_CERT_ENUM_SYSTEM_STORE_LOCATION,
    ) -> BOOL;
}
extern "C" {
    pub fn CertEnumSystemStore(
        dwFlags: DWORD,
        pvSystemStoreLocationPara: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
        pfnEnum: PFN_CERT_ENUM_SYSTEM_STORE,
    ) -> BOOL;
}
extern "C" {
    pub fn CertEnumPhysicalStore(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pvArg: *mut ::std::os::raw::c_void,
        pfnEnum: PFN_CERT_ENUM_PHYSICAL_STORE,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetEnhancedKeyUsage(
        pCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
        pUsage: PCERT_ENHKEY_USAGE,
        pcbUsage: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertSetEnhancedKeyUsage(
        pCertContext: PCCERT_CONTEXT,
        pUsage: PCERT_ENHKEY_USAGE,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddEnhancedKeyUsageIdentifier(
        pCertContext: PCCERT_CONTEXT,
        pszUsageIdentifier: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CertRemoveEnhancedKeyUsageIdentifier(
        pCertContext: PCCERT_CONTEXT,
        pszUsageIdentifier: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetValidUsages(
        cCerts: DWORD,
        rghCerts: *mut PCCERT_CONTEXT,
        cNumOIDs: *mut ::std::os::raw::c_int,
        rghOIDs: *mut LPSTR,
        pcbOIDs: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgGetAndVerifySigner(
        hCryptMsg: HCRYPTMSG,
        cSignerStore: DWORD,
        rghSignerStore: *mut HCERTSTORE,
        dwFlags: DWORD,
        ppSigner: *mut PCCERT_CONTEXT,
        pdwSignerIndex: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgSignCTL(
        dwMsgEncodingType: DWORD,
        pbCtlContent: *mut BYTE,
        cbCtlContent: DWORD,
        pSignInfo: PCMSG_SIGNED_ENCODE_INFO,
        dwFlags: DWORD,
        pbEncoded: *mut BYTE,
        pcbEncoded: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMsgEncodeAndSignCTL(
        dwMsgEncodingType: DWORD,
        pCtlInfo: PCTL_INFO,
        pSignInfo: PCMSG_SIGNED_ENCODE_INFO,
        dwFlags: DWORD,
        pbEncoded: *mut BYTE,
        pcbEncoded: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertFindSubjectInSortedCTL(
        pSubjectIdentifier: PCRYPT_DATA_BLOB,
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pEncodedAttributes: PCRYPT_DER_BLOB,
    ) -> BOOL;
}
extern "C" {
    pub fn CertEnumSubjectInSortedCTL(
        pCtlContext: PCCTL_CONTEXT,
        ppvNextSubject: *mut *mut ::std::os::raw::c_void,
        pSubjectIdentifier: PCRYPT_DER_BLOB,
        pEncodedAttributes: PCRYPT_DER_BLOB,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_VERIFY_USAGE_PARA {
    pub cbSize: DWORD,
    pub ListIdentifier: CRYPT_DATA_BLOB,
    pub cCtlStore: DWORD,
    pub rghCtlStore: *mut HCERTSTORE,
    pub cSignerStore: DWORD,
    pub rghSignerStore: *mut HCERTSTORE,
}
pub type CTL_VERIFY_USAGE_PARA = _CTL_VERIFY_USAGE_PARA;
pub type PCTL_VERIFY_USAGE_PARA = *mut _CTL_VERIFY_USAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_VERIFY_USAGE_STATUS {
    pub cbSize: DWORD,
    pub dwError: DWORD,
    pub dwFlags: DWORD,
    pub ppCtl: *mut PCCTL_CONTEXT,
    pub dwCtlEntryIndex: DWORD,
    pub ppSigner: *mut PCCERT_CONTEXT,
    pub dwSignerIndex: DWORD,
}
pub type CTL_VERIFY_USAGE_STATUS = _CTL_VERIFY_USAGE_STATUS;
pub type PCTL_VERIFY_USAGE_STATUS = *mut _CTL_VERIFY_USAGE_STATUS;
extern "C" {
    pub fn CertVerifyCTLUsage(
        dwEncodingType: DWORD,
        dwSubjectType: DWORD,
        pvSubject: *mut ::std::os::raw::c_void,
        pSubjectUsage: PCTL_USAGE,
        dwFlags: DWORD,
        pVerifyUsagePara: PCTL_VERIFY_USAGE_PARA,
        pVerifyUsageStatus: PCTL_VERIFY_USAGE_STATUS,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_CRL_INFO {
    pub cbSize: DWORD,
    pub pBaseCrlContext: PCCRL_CONTEXT,
    pub pDeltaCrlContext: PCCRL_CONTEXT,
    pub pCrlEntry: PCRL_ENTRY,
    pub fDeltaCrlEntry: BOOL,
}
pub type CERT_REVOCATION_CRL_INFO = _CERT_REVOCATION_CRL_INFO;
pub type PCERT_REVOCATION_CRL_INFO = *mut _CERT_REVOCATION_CRL_INFO;
pub type CERT_REVOCATION_CHAIN_PARA = _CERT_REVOCATION_CHAIN_PARA;
pub type PCERT_REVOCATION_CHAIN_PARA = *mut _CERT_REVOCATION_CHAIN_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_PARA {
    pub cbSize: DWORD,
    pub pIssuerCert: PCCERT_CONTEXT,
    pub cCertStore: DWORD,
    pub rgCertStore: *mut HCERTSTORE,
    pub hCrlStore: HCERTSTORE,
    pub pftTimeToUse: LPFILETIME,
}
pub type CERT_REVOCATION_PARA = _CERT_REVOCATION_PARA;
pub type PCERT_REVOCATION_PARA = *mut _CERT_REVOCATION_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_STATUS {
    pub cbSize: DWORD,
    pub dwIndex: DWORD,
    pub dwError: DWORD,
    pub dwReason: DWORD,
    pub fHasFreshnessTime: BOOL,
    pub dwFreshnessTime: DWORD,
}
pub type CERT_REVOCATION_STATUS = _CERT_REVOCATION_STATUS;
pub type PCERT_REVOCATION_STATUS = *mut _CERT_REVOCATION_STATUS;
extern "C" {
    pub fn CertVerifyRevocation(
        dwEncodingType: DWORD,
        dwRevType: DWORD,
        cContext: DWORD,
        rgpvContext: *mut PVOID,
        dwFlags: DWORD,
        pRevPara: PCERT_REVOCATION_PARA,
        pRevStatus: PCERT_REVOCATION_STATUS,
    ) -> BOOL;
}
extern "C" {
    pub fn CertCompareIntegerBlob(pInt1: PCRYPT_INTEGER_BLOB, pInt2: PCRYPT_INTEGER_BLOB) -> BOOL;
}
extern "C" {
    pub fn CertCompareCertificate(
        dwCertEncodingType: DWORD,
        pCertId1: PCERT_INFO,
        pCertId2: PCERT_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CertCompareCertificateName(
        dwCertEncodingType: DWORD,
        pCertName1: PCERT_NAME_BLOB,
        pCertName2: PCERT_NAME_BLOB,
    ) -> BOOL;
}
extern "C" {
    pub fn CertIsRDNAttrsInCertificateName(
        dwCertEncodingType: DWORD,
        dwFlags: DWORD,
        pCertName: PCERT_NAME_BLOB,
        pRDN: PCERT_RDN,
    ) -> BOOL;
}
extern "C" {
    pub fn CertComparePublicKeyInfo(
        dwCertEncodingType: DWORD,
        pPublicKey1: PCERT_PUBLIC_KEY_INFO,
        pPublicKey2: PCERT_PUBLIC_KEY_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetPublicKeyLength(
        dwCertEncodingType: DWORD,
        pPublicKey: PCERT_PUBLIC_KEY_INFO,
    ) -> DWORD;
}
extern "C" {
    pub fn CryptVerifyCertificateSignature(
        hCryptProv: HCRYPTPROV_LEGACY,
        dwCertEncodingType: DWORD,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        pPublicKey: PCERT_PUBLIC_KEY_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifyCertificateSignatureEx(
        hCryptProv: HCRYPTPROV_LEGACY,
        dwCertEncodingType: DWORD,
        dwSubjectType: DWORD,
        pvSubject: *mut ::std::os::raw::c_void,
        dwIssuerType: DWORD,
        pvIssuer: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
        pvExtra: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO {
    pub CertSignHashCNGAlgPropData: CRYPT_DATA_BLOB,
    pub CertIssuerPubKeyBitLengthPropData: CRYPT_DATA_BLOB,
}
pub type CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO =
    _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO;
pub type PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO =
    *mut _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO {
    pub cCNGHashAlgid: DWORD,
    pub rgpwszCNGHashAlgid: *mut PCWSTR,
    pub dwWeakIndex: DWORD,
}
pub type CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO;
pub type PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = *mut _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO;
extern "C" {
    pub fn CertIsStrongHashToSign(
        pStrongSignPara: PCCERT_STRONG_SIGN_PARA,
        pwszCNGHashAlgid: LPCWSTR,
        pSigningCert: PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashToBeSigned(
        hCryptProv: HCRYPTPROV_LEGACY,
        dwCertEncodingType: DWORD,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashCertificate(
        hCryptProv: HCRYPTPROV_LEGACY,
        Algid: ALG_ID,
        dwFlags: DWORD,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashCertificate2(
        pwszCNGHashAlgid: LPCWSTR,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pbEncoded: *const BYTE,
        cbEncoded: DWORD,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSignCertificate(
        hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
        dwKeySpec: DWORD,
        dwCertEncodingType: DWORD,
        pbEncodedToBeSigned: *const BYTE,
        cbEncodedToBeSigned: DWORD,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pvHashAuxInfo: *const ::std::os::raw::c_void,
        pbSignature: *mut BYTE,
        pcbSignature: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSignAndEncodeCertificate(
        hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
        dwKeySpec: DWORD,
        dwCertEncodingType: DWORD,
        lpszStructType: LPCSTR,
        pvStructInfo: *const ::std::os::raw::c_void,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pvHashAuxInfo: *const ::std::os::raw::c_void,
        pbEncoded: *mut BYTE,
        pcbEncoded: *mut DWORD,
    ) -> BOOL;
}
pub type PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwCertEncodingType: DWORD,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        ppvDecodedSignPara: *mut *mut ::std::os::raw::c_void,
        ppwszCNGHashAlgid: *mut LPWSTR,
    ) -> BOOL,
>;
pub type PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hKey: NCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pvDecodedSignPara: *mut ::std::os::raw::c_void,
        pwszCNGPubKeyAlgid: LPCWSTR,
        pwszCNGHashAlgid: LPCWSTR,
        pbComputedHash: *mut BYTE,
        cbComputedHash: DWORD,
        pbSignature: *mut BYTE,
        pcbSignature: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwCertEncodingType: DWORD,
        pPubKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pvDecodedSignPara: *mut ::std::os::raw::c_void,
        pwszCNGPubKeyAlgid: LPCWSTR,
        pwszCNGHashAlgid: LPCWSTR,
        pbComputedHash: *mut BYTE,
        cbComputedHash: DWORD,
        pbSignature: *mut BYTE,
        cbSignature: DWORD,
    ) -> BOOL,
>;
extern "C" {
    pub fn CertVerifyTimeValidity(pTimeToVerify: LPFILETIME, pCertInfo: PCERT_INFO) -> LONG;
}
extern "C" {
    pub fn CertVerifyCRLTimeValidity(pTimeToVerify: LPFILETIME, pCrlInfo: PCRL_INFO) -> LONG;
}
extern "C" {
    pub fn CertVerifyValidityNesting(pSubjectInfo: PCERT_INFO, pIssuerInfo: PCERT_INFO) -> BOOL;
}
extern "C" {
    pub fn CertVerifyCRLRevocation(
        dwCertEncodingType: DWORD,
        pCertId: PCERT_INFO,
        cCrlInfo: DWORD,
        rgpCrlInfo: *mut PCRL_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAlgIdToOID(dwAlgId: DWORD) -> LPCSTR;
}
extern "C" {
    pub fn CertOIDToAlgId(pszObjId: LPCSTR) -> DWORD;
}
extern "C" {
    pub fn CertFindExtension(
        pszObjId: LPCSTR,
        cExtensions: DWORD,
        rgExtensions: *mut CERT_EXTENSION,
    ) -> PCERT_EXTENSION;
}
extern "C" {
    pub fn CertFindAttribute(
        pszObjId: LPCSTR,
        cAttr: DWORD,
        rgAttr: *mut CRYPT_ATTRIBUTE,
    ) -> PCRYPT_ATTRIBUTE;
}
extern "C" {
    pub fn CertFindRDNAttr(pszObjId: LPCSTR, pName: PCERT_NAME_INFO) -> PCERT_RDN_ATTR;
}
extern "C" {
    pub fn CertGetIntendedKeyUsage(
        dwCertEncodingType: DWORD,
        pCertInfo: PCERT_INFO,
        pbKeyUsage: *mut BYTE,
        cbKeyUsage: DWORD,
    ) -> BOOL;
}
pub type HCRYPTDEFAULTCONTEXT = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn CryptInstallDefaultContext(
        hCryptProv: HCRYPTPROV,
        dwDefaultType: DWORD,
        pvDefaultPara: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phDefaultContext: *mut HCRYPTDEFAULTCONTEXT,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA {
    pub cOID: DWORD,
    pub rgpszOID: *mut LPSTR,
}
pub type CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;
pub type PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = *mut _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;
extern "C" {
    pub fn CryptUninstallDefaultContext(
        hDefaultContext: HCRYPTDEFAULTCONTEXT,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptExportPublicKeyInfo(
        hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
        dwKeySpec: DWORD,
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptExportPublicKeyInfoEx(
        hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
        dwKeySpec: DWORD,
        dwCertEncodingType: DWORD,
        pszPublicKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL;
}
pub type PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hNCryptKey: NCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pszPublicKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptExportPublicKeyInfoFromBCryptKeyHandle(
        hBCryptKey: BCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pszPublicKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL;
}
pub type PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hBCryptKey: BCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pszPublicKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptImportPublicKeyInfo(
        hCryptProv: HCRYPTPROV,
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        phKey: *mut HCRYPTKEY,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptImportPublicKeyInfoEx(
        hCryptProv: HCRYPTPROV,
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        aiKeyAlg: ALG_ID,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        phKey: *mut HCRYPTKEY,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptImportPublicKeyInfoEx2(
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        phKey: *mut BCRYPT_KEY_HANDLE,
    ) -> BOOL;
}
pub type PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        phKey: *mut BCRYPT_KEY_HANDLE,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptAcquireCertificatePrivateKey(
        pCert: PCCERT_CONTEXT,
        dwFlags: DWORD,
        pvParameters: *mut ::std::os::raw::c_void,
        phCryptProvOrNCryptKey: *mut HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
        pdwKeySpec: *mut DWORD,
        pfCallerFreeProvOrNCryptKey: *mut BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptFindCertificateKeyProvInfo(
        pCert: PCCERT_CONTEXT,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
pub type PFN_IMPORT_PRIV_KEY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        pPrivateKeyInfo: *mut CRYPT_PRIVATE_KEY_INFO,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptImportPKCS8(
        sPrivateKeyAndParams: CRYPT_PKCS8_IMPORT_PARAMS,
        dwFlags: DWORD,
        phCryptProv: *mut HCRYPTPROV,
        pvAuxInfo: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
pub type PFN_EXPORT_PRIV_KEY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        dwKeySpec: DWORD,
        pszPrivateKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pPrivateKeyInfo: *mut CRYPT_PRIVATE_KEY_INFO,
        pcbPrivateKeyInfo: *mut DWORD,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptExportPKCS8(
        hCryptProv: HCRYPTPROV,
        dwKeySpec: DWORD,
        pszPrivateKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pbPrivateKeyBlob: *mut BYTE,
        pcbPrivateKeyBlob: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptExportPKCS8Ex(
        psExportParams: *mut CRYPT_PKCS8_EXPORT_PARAMS,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pbPrivateKeyBlob: *mut BYTE,
        pcbPrivateKeyBlob: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashPublicKeyInfo(
        hCryptProv: HCRYPTPROV_LEGACY,
        Algid: ALG_ID,
        dwFlags: DWORD,
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertRDNValueToStrA(
        dwValueType: DWORD,
        pValue: PCERT_RDN_VALUE_BLOB,
        psz: LPSTR,
        csz: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CertRDNValueToStrW(
        dwValueType: DWORD,
        pValue: PCERT_RDN_VALUE_BLOB,
        psz: LPWSTR,
        csz: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CertNameToStrA(
        dwCertEncodingType: DWORD,
        pName: PCERT_NAME_BLOB,
        dwStrType: DWORD,
        psz: LPSTR,
        csz: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CertNameToStrW(
        dwCertEncodingType: DWORD,
        pName: PCERT_NAME_BLOB,
        dwStrType: DWORD,
        psz: LPWSTR,
        csz: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CertStrToNameA(
        dwCertEncodingType: DWORD,
        pszX500: LPCSTR,
        dwStrType: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pbEncoded: *mut BYTE,
        pcbEncoded: *mut DWORD,
        ppszError: *mut LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CertStrToNameW(
        dwCertEncodingType: DWORD,
        pszX500: LPCWSTR,
        dwStrType: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pbEncoded: *mut BYTE,
        pcbEncoded: *mut DWORD,
        ppszError: *mut LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn CertGetNameStringA(
        pCertContext: PCCERT_CONTEXT,
        dwType: DWORD,
        dwFlags: DWORD,
        pvTypePara: *mut ::std::os::raw::c_void,
        pszNameString: LPSTR,
        cchNameString: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CertGetNameStringW(
        pCertContext: PCCERT_CONTEXT,
        dwType: DWORD,
        dwFlags: DWORD,
        pvTypePara: *mut ::std::os::raw::c_void,
        pszNameString: LPWSTR,
        cchNameString: DWORD,
    ) -> DWORD;
}
pub type PFN_CRYPT_GET_SIGNER_CERTIFICATE = ::std::option::Option<
    unsafe extern "C" fn(
        pvGetArg: *mut ::std::os::raw::c_void,
        dwCertEncodingType: DWORD,
        pSignerId: PCERT_INFO,
        hMsgCertStore: HCERTSTORE,
    ) -> PCCERT_CONTEXT,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_SIGN_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgEncodingType: DWORD,
    pub pSigningCert: PCCERT_CONTEXT,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvHashAuxInfo: *mut ::std::os::raw::c_void,
    pub cMsgCert: DWORD,
    pub rgpMsgCert: *mut PCCERT_CONTEXT,
    pub cMsgCrl: DWORD,
    pub rgpMsgCrl: *mut PCCRL_CONTEXT,
    pub cAuthAttr: DWORD,
    pub rgAuthAttr: PCRYPT_ATTRIBUTE,
    pub cUnauthAttr: DWORD,
    pub rgUnauthAttr: PCRYPT_ATTRIBUTE,
    pub dwFlags: DWORD,
    pub dwInnerContentType: DWORD,
}
pub type CRYPT_SIGN_MESSAGE_PARA = _CRYPT_SIGN_MESSAGE_PARA;
pub type PCRYPT_SIGN_MESSAGE_PARA = *mut _CRYPT_SIGN_MESSAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_VERIFY_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgAndCertEncodingType: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub pfnGetSignerCertificate: PFN_CRYPT_GET_SIGNER_CERTIFICATE,
    pub pvGetArg: *mut ::std::os::raw::c_void,
}
pub type CRYPT_VERIFY_MESSAGE_PARA = _CRYPT_VERIFY_MESSAGE_PARA;
pub type PCRYPT_VERIFY_MESSAGE_PARA = *mut _CRYPT_VERIFY_MESSAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ENCRYPT_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgEncodingType: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub dwFlags: DWORD,
    pub dwInnerContentType: DWORD,
}
pub type CRYPT_ENCRYPT_MESSAGE_PARA = _CRYPT_ENCRYPT_MESSAGE_PARA;
pub type PCRYPT_ENCRYPT_MESSAGE_PARA = *mut _CRYPT_ENCRYPT_MESSAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_DECRYPT_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgAndCertEncodingType: DWORD,
    pub cCertStore: DWORD,
    pub rghCertStore: *mut HCERTSTORE,
}
pub type CRYPT_DECRYPT_MESSAGE_PARA = _CRYPT_DECRYPT_MESSAGE_PARA;
pub type PCRYPT_DECRYPT_MESSAGE_PARA = *mut _CRYPT_DECRYPT_MESSAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_HASH_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgEncodingType: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvHashAuxInfo: *mut ::std::os::raw::c_void,
}
pub type CRYPT_HASH_MESSAGE_PARA = _CRYPT_HASH_MESSAGE_PARA;
pub type PCRYPT_HASH_MESSAGE_PARA = *mut _CRYPT_HASH_MESSAGE_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CRYPT_KEY_SIGN_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgAndCertEncodingType: DWORD,
    pub __bindgen_anon_1: _CRYPT_KEY_SIGN_MESSAGE_PARA__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvHashAuxInfo: *mut ::std::os::raw::c_void,
    pub PubKeyAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CRYPT_KEY_SIGN_MESSAGE_PARA__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type CRYPT_KEY_SIGN_MESSAGE_PARA = _CRYPT_KEY_SIGN_MESSAGE_PARA;
pub type PCRYPT_KEY_SIGN_MESSAGE_PARA = *mut _CRYPT_KEY_SIGN_MESSAGE_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_KEY_VERIFY_MESSAGE_PARA {
    pub cbSize: DWORD,
    pub dwMsgEncodingType: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
}
pub type CRYPT_KEY_VERIFY_MESSAGE_PARA = _CRYPT_KEY_VERIFY_MESSAGE_PARA;
pub type PCRYPT_KEY_VERIFY_MESSAGE_PARA = *mut _CRYPT_KEY_VERIFY_MESSAGE_PARA;
extern "C" {
    pub fn CryptSignMessage(
        pSignPara: PCRYPT_SIGN_MESSAGE_PARA,
        fDetachedSignature: BOOL,
        cToBeSigned: DWORD,
        rgpbToBeSigned: *mut *const BYTE,
        rgcbToBeSigned: *mut DWORD,
        pbSignedBlob: *mut BYTE,
        pcbSignedBlob: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifyMessageSignature(
        pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA,
        dwSignerIndex: DWORD,
        pbSignedBlob: *const BYTE,
        cbSignedBlob: DWORD,
        pbDecoded: *mut BYTE,
        pcbDecoded: *mut DWORD,
        ppSignerCert: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetMessageSignerCount(
        dwMsgEncodingType: DWORD,
        pbSignedBlob: *const BYTE,
        cbSignedBlob: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn CryptGetMessageCertificates(
        dwMsgAndCertEncodingType: DWORD,
        hCryptProv: HCRYPTPROV_LEGACY,
        dwFlags: DWORD,
        pbSignedBlob: *const BYTE,
        cbSignedBlob: DWORD,
    ) -> HCERTSTORE;
}
extern "C" {
    pub fn CryptVerifyDetachedMessageSignature(
        pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA,
        dwSignerIndex: DWORD,
        pbDetachedSignBlob: *const BYTE,
        cbDetachedSignBlob: DWORD,
        cToBeSigned: DWORD,
        rgpbToBeSigned: *mut *const BYTE,
        rgcbToBeSigned: *mut DWORD,
        ppSignerCert: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptEncryptMessage(
        pEncryptPara: PCRYPT_ENCRYPT_MESSAGE_PARA,
        cRecipientCert: DWORD,
        rgpRecipientCert: *mut PCCERT_CONTEXT,
        pbToBeEncrypted: *const BYTE,
        cbToBeEncrypted: DWORD,
        pbEncryptedBlob: *mut BYTE,
        pcbEncryptedBlob: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDecryptMessage(
        pDecryptPara: PCRYPT_DECRYPT_MESSAGE_PARA,
        pbEncryptedBlob: *const BYTE,
        cbEncryptedBlob: DWORD,
        pbDecrypted: *mut BYTE,
        pcbDecrypted: *mut DWORD,
        ppXchgCert: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSignAndEncryptMessage(
        pSignPara: PCRYPT_SIGN_MESSAGE_PARA,
        pEncryptPara: PCRYPT_ENCRYPT_MESSAGE_PARA,
        cRecipientCert: DWORD,
        rgpRecipientCert: *mut PCCERT_CONTEXT,
        pbToBeSignedAndEncrypted: *const BYTE,
        cbToBeSignedAndEncrypted: DWORD,
        pbSignedAndEncryptedBlob: *mut BYTE,
        pcbSignedAndEncryptedBlob: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDecryptAndVerifyMessageSignature(
        pDecryptPara: PCRYPT_DECRYPT_MESSAGE_PARA,
        pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA,
        dwSignerIndex: DWORD,
        pbEncryptedBlob: *const BYTE,
        cbEncryptedBlob: DWORD,
        pbDecrypted: *mut BYTE,
        pcbDecrypted: *mut DWORD,
        ppXchgCert: *mut PCCERT_CONTEXT,
        ppSignerCert: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptDecodeMessage(
        dwMsgTypeFlags: DWORD,
        pDecryptPara: PCRYPT_DECRYPT_MESSAGE_PARA,
        pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA,
        dwSignerIndex: DWORD,
        pbEncodedBlob: *const BYTE,
        cbEncodedBlob: DWORD,
        dwPrevInnerContentType: DWORD,
        pdwMsgType: *mut DWORD,
        pdwInnerContentType: *mut DWORD,
        pbDecoded: *mut BYTE,
        pcbDecoded: *mut DWORD,
        ppXchgCert: *mut PCCERT_CONTEXT,
        ppSignerCert: *mut PCCERT_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptHashMessage(
        pHashPara: PCRYPT_HASH_MESSAGE_PARA,
        fDetachedHash: BOOL,
        cToBeHashed: DWORD,
        rgpbToBeHashed: *mut *const BYTE,
        rgcbToBeHashed: *mut DWORD,
        pbHashedBlob: *mut BYTE,
        pcbHashedBlob: *mut DWORD,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifyMessageHash(
        pHashPara: PCRYPT_HASH_MESSAGE_PARA,
        pbHashedBlob: *mut BYTE,
        cbHashedBlob: DWORD,
        pbToBeHashed: *mut BYTE,
        pcbToBeHashed: *mut DWORD,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifyDetachedMessageHash(
        pHashPara: PCRYPT_HASH_MESSAGE_PARA,
        pbDetachedHashBlob: *mut BYTE,
        cbDetachedHashBlob: DWORD,
        cToBeHashed: DWORD,
        rgpbToBeHashed: *mut *const BYTE,
        rgcbToBeHashed: *mut DWORD,
        pbComputedHash: *mut BYTE,
        pcbComputedHash: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSignMessageWithKey(
        pSignPara: PCRYPT_KEY_SIGN_MESSAGE_PARA,
        pbToBeSigned: *const BYTE,
        cbToBeSigned: DWORD,
        pbSignedBlob: *mut BYTE,
        pcbSignedBlob: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifyMessageSignatureWithKey(
        pVerifyPara: PCRYPT_KEY_VERIFY_MESSAGE_PARA,
        pPublicKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pbSignedBlob: *const BYTE,
        cbSignedBlob: DWORD,
        pbDecoded: *mut BYTE,
        pcbDecoded: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertOpenSystemStoreA(
        hProv: HCRYPTPROV_LEGACY,
        szSubsystemProtocol: LPCSTR,
    ) -> HCERTSTORE;
}
extern "C" {
    pub fn CertOpenSystemStoreW(
        hProv: HCRYPTPROV_LEGACY,
        szSubsystemProtocol: LPCWSTR,
    ) -> HCERTSTORE;
}
extern "C" {
    pub fn CertAddEncodedCertificateToSystemStoreA(
        szCertStoreName: LPCSTR,
        pbCertEncoded: *const BYTE,
        cbCertEncoded: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CertAddEncodedCertificateToSystemStoreW(
        szCertStoreName: LPCWSTR,
        pbCertEncoded: *const BYTE,
        cbCertEncoded: DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN {
    pub cCerts: DWORD,
    pub certs: PCERT_BLOB,
    pub keyLocatorInfo: CRYPT_KEY_PROV_INFO,
}
pub type CERT_CHAIN = _CERT_CHAIN;
pub type PCERT_CHAIN = *mut _CERT_CHAIN;
extern "C" {
    pub fn FindCertsByIssuer(
        pCertChains: PCERT_CHAIN,
        pcbCertChains: *mut DWORD,
        pcCertChains: *mut DWORD,
        pbEncodedIssuerName: *mut BYTE,
        cbEncodedIssuerName: DWORD,
        pwszPurpose: LPCWSTR,
        dwKeySpec: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CryptQueryObject(
        dwObjectType: DWORD,
        pvObject: *const ::std::os::raw::c_void,
        dwExpectedContentTypeFlags: DWORD,
        dwExpectedFormatTypeFlags: DWORD,
        dwFlags: DWORD,
        pdwMsgAndCertEncodingType: *mut DWORD,
        pdwContentType: *mut DWORD,
        pdwFormatType: *mut DWORD,
        phCertStore: *mut HCERTSTORE,
        phMsg: *mut HCRYPTMSG,
        ppvContext: *mut *const ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptMemAlloc(cbSize: ULONG) -> LPVOID;
}
extern "C" {
    pub fn CryptMemRealloc(pv: LPVOID, cbSize: ULONG) -> LPVOID;
}
extern "C" {
    pub fn CryptMemFree(pv: LPVOID);
}
pub type HCRYPTASYNC = HANDLE;
pub type PHCRYPTASYNC = *mut HANDLE;
pub type PFN_CRYPT_ASYNC_PARAM_FREE_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pszParamOid: LPSTR, pvParam: LPVOID)>;
extern "C" {
    pub fn CryptCreateAsyncHandle(dwFlags: DWORD, phAsync: PHCRYPTASYNC) -> BOOL;
}
extern "C" {
    pub fn CryptSetAsyncParam(
        hAsync: HCRYPTASYNC,
        pszParamOid: LPSTR,
        pvParam: LPVOID,
        pfnFree: PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptGetAsyncParam(
        hAsync: HCRYPTASYNC,
        pszParamOid: LPSTR,
        ppvParam: *mut LPVOID,
        ppfnFree: *mut PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptCloseAsyncHandle(hAsync: HCRYPTASYNC) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_BLOB_ARRAY {
    pub cBlob: DWORD,
    pub rgBlob: PCRYPT_DATA_BLOB,
}
pub type CRYPT_BLOB_ARRAY = _CRYPT_BLOB_ARRAY;
pub type PCRYPT_BLOB_ARRAY = *mut _CRYPT_BLOB_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_CREDENTIALS {
    pub cbSize: DWORD,
    pub pszCredentialsOid: LPCSTR,
    pub pvCredentials: LPVOID,
}
pub type CRYPT_CREDENTIALS = _CRYPT_CREDENTIALS;
pub type PCRYPT_CREDENTIALS = *mut _CRYPT_CREDENTIALS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PASSWORD_CREDENTIALSA {
    pub cbSize: DWORD,
    pub pszUsername: LPSTR,
    pub pszPassword: LPSTR,
}
pub type CRYPT_PASSWORD_CREDENTIALSA = _CRYPT_PASSWORD_CREDENTIALSA;
pub type PCRYPT_PASSWORD_CREDENTIALSA = *mut _CRYPT_PASSWORD_CREDENTIALSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PASSWORD_CREDENTIALSW {
    pub cbSize: DWORD,
    pub pszUsername: LPWSTR,
    pub pszPassword: LPWSTR,
}
pub type CRYPT_PASSWORD_CREDENTIALSW = _CRYPT_PASSWORD_CREDENTIALSW;
pub type PCRYPT_PASSWORD_CREDENTIALSW = *mut _CRYPT_PASSWORD_CREDENTIALSW;
pub type CRYPT_PASSWORD_CREDENTIALS = CRYPT_PASSWORD_CREDENTIALSA;
pub type PCRYPT_PASSWORD_CREDENTIALS = PCRYPT_PASSWORD_CREDENTIALSA;
pub type PFN_FREE_ENCODED_OBJECT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pszObjectOid: LPCSTR, pObject: PCRYPT_BLOB_ARRAY, pvFreeContext: LPVOID),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPTNET_URL_CACHE_PRE_FETCH_INFO {
    pub cbSize: DWORD,
    pub dwObjectType: DWORD,
    pub dwError: DWORD,
    pub dwReserved: DWORD,
    pub ThisUpdateTime: FILETIME,
    pub NextUpdateTime: FILETIME,
    pub PublishTime: FILETIME,
}
pub type CRYPTNET_URL_CACHE_PRE_FETCH_INFO = _CRYPTNET_URL_CACHE_PRE_FETCH_INFO;
pub type PCRYPTNET_URL_CACHE_PRE_FETCH_INFO = *mut _CRYPTNET_URL_CACHE_PRE_FETCH_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPTNET_URL_CACHE_FLUSH_INFO {
    pub cbSize: DWORD,
    pub dwExemptSeconds: DWORD,
    pub ExpireTime: FILETIME,
}
pub type CRYPTNET_URL_CACHE_FLUSH_INFO = _CRYPTNET_URL_CACHE_FLUSH_INFO;
pub type PCRYPTNET_URL_CACHE_FLUSH_INFO = *mut _CRYPTNET_URL_CACHE_FLUSH_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPTNET_URL_CACHE_RESPONSE_INFO {
    pub cbSize: DWORD,
    pub wResponseType: WORD,
    pub wResponseFlags: WORD,
    pub LastModifiedTime: FILETIME,
    pub dwMaxAge: DWORD,
    pub pwszETag: LPCWSTR,
    pub dwProxyId: DWORD,
}
pub type CRYPTNET_URL_CACHE_RESPONSE_INFO = _CRYPTNET_URL_CACHE_RESPONSE_INFO;
pub type PCRYPTNET_URL_CACHE_RESPONSE_INFO = *mut _CRYPTNET_URL_CACHE_RESPONSE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_RETRIEVE_AUX_INFO {
    pub cbSize: DWORD,
    pub pLastSyncTime: *mut FILETIME,
    pub dwMaxUrlRetrievalByteCount: DWORD,
    pub pPreFetchInfo: PCRYPTNET_URL_CACHE_PRE_FETCH_INFO,
    pub pFlushInfo: PCRYPTNET_URL_CACHE_FLUSH_INFO,
    pub ppResponseInfo: *mut PCRYPTNET_URL_CACHE_RESPONSE_INFO,
    pub pwszCacheFileNamePrefix: LPWSTR,
    pub pftCacheResync: LPFILETIME,
    pub fProxyCacheRetrieval: BOOL,
    pub dwHttpStatusCode: DWORD,
    pub ppwszErrorResponseHeaders: *mut LPWSTR,
    pub ppErrorContentBlob: *mut PCRYPT_DATA_BLOB,
}
pub type CRYPT_RETRIEVE_AUX_INFO = _CRYPT_RETRIEVE_AUX_INFO;
pub type PCRYPT_RETRIEVE_AUX_INFO = *mut _CRYPT_RETRIEVE_AUX_INFO;
extern "C" {
    pub fn CryptRetrieveObjectByUrlA(
        pszUrl: LPCSTR,
        pszObjectOid: LPCSTR,
        dwRetrievalFlags: DWORD,
        dwTimeout: DWORD,
        ppvObject: *mut LPVOID,
        hAsyncRetrieve: HCRYPTASYNC,
        pCredentials: PCRYPT_CREDENTIALS,
        pvVerify: LPVOID,
        pAuxInfo: PCRYPT_RETRIEVE_AUX_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptRetrieveObjectByUrlW(
        pszUrl: LPCWSTR,
        pszObjectOid: LPCSTR,
        dwRetrievalFlags: DWORD,
        dwTimeout: DWORD,
        ppvObject: *mut LPVOID,
        hAsyncRetrieve: HCRYPTASYNC,
        pCredentials: PCRYPT_CREDENTIALS,
        pvVerify: LPVOID,
        pAuxInfo: PCRYPT_RETRIEVE_AUX_INFO,
    ) -> BOOL;
}
pub type PFN_CRYPT_CANCEL_RETRIEVAL = ::std::option::Option<
    unsafe extern "C" fn(dwFlags: DWORD, pvArg: *mut ::std::os::raw::c_void) -> BOOL,
>;
extern "C" {
    pub fn CryptInstallCancelRetrieval(
        pfnCancel: PFN_CRYPT_CANCEL_RETRIEVAL,
        pvArg: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptUninstallCancelRetrieval(
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptCancelAsyncRetrieval(hAsyncRetrieval: HCRYPTASYNC) -> BOOL;
}
pub type PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pvCompletion: LPVOID,
        dwCompletionCode: DWORD,
        pszUrl: LPCSTR,
        pszObjectOid: LPSTR,
        pvObject: LPVOID,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ASYNC_RETRIEVAL_COMPLETION {
    pub pfnCompletion: PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC,
    pub pvCompletion: LPVOID,
}
pub type CRYPT_ASYNC_RETRIEVAL_COMPLETION = _CRYPT_ASYNC_RETRIEVAL_COMPLETION;
pub type PCRYPT_ASYNC_RETRIEVAL_COMPLETION = *mut _CRYPT_ASYNC_RETRIEVAL_COMPLETION;
pub type PFN_CANCEL_ASYNC_RETRIEVAL_FUNC =
    ::std::option::Option<unsafe extern "C" fn(hAsyncRetrieve: HCRYPTASYNC) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_URL_ARRAY {
    pub cUrl: DWORD,
    pub rgwszUrl: *mut LPWSTR,
}
pub type CRYPT_URL_ARRAY = _CRYPT_URL_ARRAY;
pub type PCRYPT_URL_ARRAY = *mut _CRYPT_URL_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_URL_INFO {
    pub cbSize: DWORD,
    pub dwSyncDeltaTime: DWORD,
    pub cGroup: DWORD,
    pub rgcGroupEntry: *mut DWORD,
}
pub type CRYPT_URL_INFO = _CRYPT_URL_INFO;
pub type PCRYPT_URL_INFO = *mut _CRYPT_URL_INFO;
extern "C" {
    pub fn CryptGetObjectUrl(
        pszUrlOid: LPCSTR,
        pvPara: LPVOID,
        dwFlags: DWORD,
        pUrlArray: PCRYPT_URL_ARRAY,
        pcbUrlArray: *mut DWORD,
        pUrlInfo: PCRYPT_URL_INFO,
        pcbUrlInfo: *mut DWORD,
        pvReserved: LPVOID,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CRL_CONTEXT_PAIR {
    pub pCertContext: PCCERT_CONTEXT,
    pub pCrlContext: PCCRL_CONTEXT,
}
pub type CERT_CRL_CONTEXT_PAIR = _CERT_CRL_CONTEXT_PAIR;
pub type PCERT_CRL_CONTEXT_PAIR = *mut _CERT_CRL_CONTEXT_PAIR;
pub type PCCERT_CRL_CONTEXT_PAIR = *const CERT_CRL_CONTEXT_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO {
    pub cbSize: DWORD,
    pub iDeltaCrlIndicator: ::std::os::raw::c_int,
    pub pftCacheResync: LPFILETIME,
    pub pLastSyncTime: LPFILETIME,
    pub pMaxAgeTime: LPFILETIME,
    pub pChainPara: PCERT_REVOCATION_CHAIN_PARA,
    pub pDeltaCrlIndicator: PCRYPT_INTEGER_BLOB,
}
pub type CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;
pub type PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = *mut _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;
extern "C" {
    pub fn CryptGetTimeValidObject(
        pszTimeValidOid: LPCSTR,
        pvPara: LPVOID,
        pIssuer: PCCERT_CONTEXT,
        pftValidFor: LPFILETIME,
        dwFlags: DWORD,
        dwTimeout: DWORD,
        ppvObject: *mut LPVOID,
        pCredentials: PCRYPT_CREDENTIALS,
        pExtraInfo: PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptFlushTimeValidObject(
        pszFlushTimeValidOid: LPCSTR,
        pvPara: LPVOID,
        pIssuer: PCCERT_CONTEXT,
        dwFlags: DWORD,
        pvReserved: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn CertCreateSelfSignCertificate(
        hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE,
        pSubjectIssuerBlob: PCERT_NAME_BLOB,
        dwFlags: DWORD,
        pKeyProvInfo: PCRYPT_KEY_PROV_INFO,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pStartTime: PSYSTEMTIME,
        pEndTime: PSYSTEMTIME,
        pExtensions: PCERT_EXTENSIONS,
    ) -> PCCERT_CONTEXT;
}
extern "C" {
    pub fn CryptGetKeyIdentifierProperty(
        pKeyIdentifier: *const CRYPT_HASH_BLOB,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pwszComputerName: LPCWSTR,
        pvReserved: *mut ::std::os::raw::c_void,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptSetKeyIdentifierProperty(
        pKeyIdentifier: *const CRYPT_HASH_BLOB,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pwszComputerName: LPCWSTR,
        pvReserved: *mut ::std::os::raw::c_void,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL;
}
pub type PFN_CRYPT_ENUM_KEYID_PROP = ::std::option::Option<
    unsafe extern "C" fn(
        pKeyIdentifier: *const CRYPT_HASH_BLOB,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
        cProp: DWORD,
        rgdwPropId: *mut DWORD,
        rgpvData: *mut *mut ::std::os::raw::c_void,
        rgcbData: *mut DWORD,
    ) -> BOOL,
>;
extern "C" {
    pub fn CryptEnumKeyIdentifierProperties(
        pKeyIdentifier: *const CRYPT_HASH_BLOB,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pwszComputerName: LPCWSTR,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
        pfnEnum: PFN_CRYPT_ENUM_KEYID_PROP,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptCreateKeyIdentifierFromCSP(
        dwCertEncodingType: DWORD,
        pszPubKeyOID: LPCSTR,
        pPubKeyStruc: *const PUBLICKEYSTRUC,
        cbPubKeyStruc: DWORD,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pbHash: *mut BYTE,
        pcbHash: *mut DWORD,
    ) -> BOOL;
}
pub type HCERTCHAINENGINE = HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_ENGINE_CONFIG {
    pub cbSize: DWORD,
    pub hRestrictedRoot: HCERTSTORE,
    pub hRestrictedTrust: HCERTSTORE,
    pub hRestrictedOther: HCERTSTORE,
    pub cAdditionalStore: DWORD,
    pub rghAdditionalStore: *mut HCERTSTORE,
    pub dwFlags: DWORD,
    pub dwUrlRetrievalTimeout: DWORD,
    pub MaximumCachedCertificates: DWORD,
    pub CycleDetectionModulus: DWORD,
    pub hExclusiveRoot: HCERTSTORE,
    pub hExclusiveTrustedPeople: HCERTSTORE,
    pub dwExclusiveFlags: DWORD,
}
pub type CERT_CHAIN_ENGINE_CONFIG = _CERT_CHAIN_ENGINE_CONFIG;
pub type PCERT_CHAIN_ENGINE_CONFIG = *mut _CERT_CHAIN_ENGINE_CONFIG;
extern "C" {
    pub fn CertCreateCertificateChainEngine(
        pConfig: PCERT_CHAIN_ENGINE_CONFIG,
        phChainEngine: *mut HCERTCHAINENGINE,
    ) -> BOOL;
}
extern "C" {
    pub fn CertFreeCertificateChainEngine(hChainEngine: HCERTCHAINENGINE);
}
extern "C" {
    pub fn CertResyncCertificateChainEngine(hChainEngine: HCERTCHAINENGINE) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_TRUST_STATUS {
    pub dwErrorStatus: DWORD,
    pub dwInfoStatus: DWORD,
}
pub type CERT_TRUST_STATUS = _CERT_TRUST_STATUS;
pub type PCERT_TRUST_STATUS = *mut _CERT_TRUST_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_INFO {
    pub cbSize: DWORD,
    pub dwRevocationResult: DWORD,
    pub pszRevocationOid: LPCSTR,
    pub pvOidSpecificInfo: LPVOID,
    pub fHasFreshnessTime: BOOL,
    pub dwFreshnessTime: DWORD,
    pub pCrlInfo: PCERT_REVOCATION_CRL_INFO,
}
pub type CERT_REVOCATION_INFO = _CERT_REVOCATION_INFO;
pub type PCERT_REVOCATION_INFO = *mut _CERT_REVOCATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_TRUST_LIST_INFO {
    pub cbSize: DWORD,
    pub pCtlEntry: PCTL_ENTRY,
    pub pCtlContext: PCCTL_CONTEXT,
}
pub type CERT_TRUST_LIST_INFO = _CERT_TRUST_LIST_INFO;
pub type PCERT_TRUST_LIST_INFO = *mut _CERT_TRUST_LIST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_ELEMENT {
    pub cbSize: DWORD,
    pub pCertContext: PCCERT_CONTEXT,
    pub TrustStatus: CERT_TRUST_STATUS,
    pub pRevocationInfo: PCERT_REVOCATION_INFO,
    pub pIssuanceUsage: PCERT_ENHKEY_USAGE,
    pub pApplicationUsage: PCERT_ENHKEY_USAGE,
    pub pwszExtendedErrorInfo: LPCWSTR,
}
pub type CERT_CHAIN_ELEMENT = _CERT_CHAIN_ELEMENT;
pub type PCERT_CHAIN_ELEMENT = *mut _CERT_CHAIN_ELEMENT;
pub type PCCERT_CHAIN_ELEMENT = *const CERT_CHAIN_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SIMPLE_CHAIN {
    pub cbSize: DWORD,
    pub TrustStatus: CERT_TRUST_STATUS,
    pub cElement: DWORD,
    pub rgpElement: *mut PCERT_CHAIN_ELEMENT,
    pub pTrustListInfo: PCERT_TRUST_LIST_INFO,
    pub fHasRevocationFreshnessTime: BOOL,
    pub dwRevocationFreshnessTime: DWORD,
}
pub type CERT_SIMPLE_CHAIN = _CERT_SIMPLE_CHAIN;
pub type PCERT_SIMPLE_CHAIN = *mut _CERT_SIMPLE_CHAIN;
pub type PCCERT_SIMPLE_CHAIN = *const CERT_SIMPLE_CHAIN;
pub type CERT_CHAIN_CONTEXT = _CERT_CHAIN_CONTEXT;
pub type PCERT_CHAIN_CONTEXT = *mut _CERT_CHAIN_CONTEXT;
pub type PCCERT_CHAIN_CONTEXT = *const CERT_CHAIN_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_CONTEXT {
    pub cbSize: DWORD,
    pub TrustStatus: CERT_TRUST_STATUS,
    pub cChain: DWORD,
    pub rgpChain: *mut PCERT_SIMPLE_CHAIN,
    pub cLowerQualityChainContext: DWORD,
    pub rgpLowerQualityChainContext: *mut PCCERT_CHAIN_CONTEXT,
    pub fHasRevocationFreshnessTime: BOOL,
    pub dwRevocationFreshnessTime: DWORD,
    pub dwCreateFlags: DWORD,
    pub ChainId: GUID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_USAGE_MATCH {
    pub dwType: DWORD,
    pub Usage: CERT_ENHKEY_USAGE,
}
pub type CERT_USAGE_MATCH = _CERT_USAGE_MATCH;
pub type PCERT_USAGE_MATCH = *mut _CERT_USAGE_MATCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_USAGE_MATCH {
    pub dwType: DWORD,
    pub Usage: CTL_USAGE,
}
pub type CTL_USAGE_MATCH = _CTL_USAGE_MATCH;
pub type PCTL_USAGE_MATCH = *mut _CTL_USAGE_MATCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_PARA {
    pub cbSize: DWORD,
    pub RequestedUsage: CERT_USAGE_MATCH,
}
pub type CERT_CHAIN_PARA = _CERT_CHAIN_PARA;
pub type PCERT_CHAIN_PARA = *mut _CERT_CHAIN_PARA;
extern "C" {
    pub fn CertGetCertificateChain(
        hChainEngine: HCERTCHAINENGINE,
        pCertContext: PCCERT_CONTEXT,
        pTime: LPFILETIME,
        hAdditionalStore: HCERTSTORE,
        pChainPara: PCERT_CHAIN_PARA,
        dwFlags: DWORD,
        pvReserved: LPVOID,
        ppChainContext: *mut PCCERT_CHAIN_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertFreeCertificateChain(pChainContext: PCCERT_CHAIN_CONTEXT);
}
extern "C" {
    pub fn CertDuplicateCertificateChain(
        pChainContext: PCCERT_CHAIN_CONTEXT,
    ) -> PCCERT_CHAIN_CONTEXT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_CHAIN_PARA {
    pub cbSize: DWORD,
    pub hChainEngine: HCERTCHAINENGINE,
    pub hAdditionalStore: HCERTSTORE,
    pub dwChainFlags: DWORD,
    pub dwUrlRetrievalTimeout: DWORD,
    pub pftCurrentTime: LPFILETIME,
    pub pftCacheResync: LPFILETIME,
    pub cbMaxUrlRetrievalByteCount: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_REVOCATION_INFO {
    pub pCrlEntry: PCRL_ENTRY,
    pub pCrlContext: PCCRL_CONTEXT,
    pub pCrlIssuerChain: PCCERT_CHAIN_CONTEXT,
}
pub type CRL_REVOCATION_INFO = _CRL_REVOCATION_INFO;
pub type PCRL_REVOCATION_INFO = *mut _CRL_REVOCATION_INFO;
extern "C" {
    pub fn CertFindChainInStore(
        hCertStore: HCERTSTORE,
        dwCertEncodingType: DWORD,
        dwFindFlags: DWORD,
        dwFindType: DWORD,
        pvFindPara: *const ::std::os::raw::c_void,
        pPrevChainContext: PCCERT_CHAIN_CONTEXT,
    ) -> PCCERT_CHAIN_CONTEXT;
}
pub type PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(pCert: PCCERT_CONTEXT, pvFindArg: *mut ::std::os::raw::c_void) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_FIND_BY_ISSUER_PARA {
    pub cbSize: DWORD,
    pub pszUsageIdentifier: LPCSTR,
    pub dwKeySpec: DWORD,
    pub dwAcquirePrivateKeyFlags: DWORD,
    pub cIssuer: DWORD,
    pub rgIssuer: *mut CERT_NAME_BLOB,
    pub pfnFindCallback: PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK,
    pub pvFindArg: *mut ::std::os::raw::c_void,
}
pub type CERT_CHAIN_FIND_ISSUER_PARA = _CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub type PCERT_CHAIN_FIND_ISSUER_PARA = *mut _CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub type CERT_CHAIN_FIND_BY_ISSUER_PARA = _CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub type PCERT_CHAIN_FIND_BY_ISSUER_PARA = *mut _CERT_CHAIN_FIND_BY_ISSUER_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_POLICY_PARA {
    pub cbSize: DWORD,
    pub dwFlags: DWORD,
    pub pvExtraPolicyPara: *mut ::std::os::raw::c_void,
}
pub type CERT_CHAIN_POLICY_PARA = _CERT_CHAIN_POLICY_PARA;
pub type PCERT_CHAIN_POLICY_PARA = *mut _CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_POLICY_STATUS {
    pub cbSize: DWORD,
    pub dwError: DWORD,
    pub lChainIndex: LONG,
    pub lElementIndex: LONG,
    pub pvExtraPolicyStatus: *mut ::std::os::raw::c_void,
}
pub type CERT_CHAIN_POLICY_STATUS = _CERT_CHAIN_POLICY_STATUS;
pub type PCERT_CHAIN_POLICY_STATUS = *mut _CERT_CHAIN_POLICY_STATUS;
extern "C" {
    pub fn CertVerifyCertificateChainPolicy(
        pszPolicyOID: LPCSTR,
        pChainContext: PCCERT_CHAIN_CONTEXT,
        pPolicyPara: PCERT_CHAIN_POLICY_PARA,
        pPolicyStatus: PCERT_CHAIN_POLICY_STATUS,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA {
    pub cbSize: DWORD,
    pub dwRegPolicySettings: DWORD,
    pub pSignerInfo: PCMSG_SIGNER_INFO,
}
pub type AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;
pub type PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA =
    *mut _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS {
    pub cbSize: DWORD,
    pub fCommercial: BOOL,
}
pub type AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub type PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS =
    *mut _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA {
    pub cbSize: DWORD,
    pub dwRegPolicySettings: DWORD,
    pub fCommercial: BOOL,
}
pub type AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA =
    _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;
pub type PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA =
    *mut _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HTTPSPolicyCallbackData {
    pub __bindgen_anon_1: _HTTPSPolicyCallbackData__bindgen_ty_1,
    pub dwAuthType: DWORD,
    pub fdwChecks: DWORD,
    pub pwszServerName: *mut WCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HTTPSPolicyCallbackData__bindgen_ty_1 {
    pub cbStruct: DWORD,
    pub cbSize: DWORD,
}
pub type HTTPSPolicyCallbackData = _HTTPSPolicyCallbackData;
pub type PHTTPSPolicyCallbackData = *mut _HTTPSPolicyCallbackData;
pub type SSL_EXTRA_CERT_CHAIN_POLICY_PARA = _HTTPSPolicyCallbackData;
pub type PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = *mut _HTTPSPolicyCallbackData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EV_EXTRA_CERT_CHAIN_POLICY_PARA {
    pub cbSize: DWORD,
    pub dwRootProgramQualifierFlags: DWORD,
}
pub type EV_EXTRA_CERT_CHAIN_POLICY_PARA = _EV_EXTRA_CERT_CHAIN_POLICY_PARA;
pub type PEV_EXTRA_CERT_CHAIN_POLICY_PARA = *mut _EV_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EV_EXTRA_CERT_CHAIN_POLICY_STATUS {
    pub cbSize: DWORD,
    pub dwQualifiers: DWORD,
    pub dwIssuanceUsageIndex: DWORD,
}
pub type EV_EXTRA_CERT_CHAIN_POLICY_STATUS = _EV_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub type PEV_EXTRA_CERT_CHAIN_POLICY_STATUS = *mut _EV_EXTRA_CERT_CHAIN_POLICY_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS {
    pub cbSize: DWORD,
    pub dwErrorLevel: DWORD,
    pub dwErrorCategory: DWORD,
    pub dwReserved: DWORD,
    pub wszErrorText: [WCHAR; 256usize],
}
pub type SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub type PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = *mut _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA {
    pub cbSize: DWORD,
    pub dwReserved: DWORD,
    pub pwszServerName: LPWSTR,
    pub rgpszHpkpValue: [LPSTR; 2usize],
}
pub type SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA =
    _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
pub type PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA =
    *mut _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA {
    pub cbSize: DWORD,
    pub dwReserved: DWORD,
    pub pwszServerName: PCWSTR,
}
pub type SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
pub type PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = *mut _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS {
    pub cbSize: DWORD,
    pub lError: LONG,
    pub wszErrorText: [WCHAR; 512usize],
}
pub type SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub type PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS =
    *mut _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
extern "C" {
    pub fn CryptStringToBinaryA(
        pszString: LPCSTR,
        cchString: DWORD,
        dwFlags: DWORD,
        pbBinary: *mut BYTE,
        pcbBinary: *mut DWORD,
        pdwSkip: *mut DWORD,
        pdwFlags: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptStringToBinaryW(
        pszString: LPCWSTR,
        cchString: DWORD,
        dwFlags: DWORD,
        pbBinary: *mut BYTE,
        pcbBinary: *mut DWORD,
        pdwSkip: *mut DWORD,
        pdwFlags: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptBinaryToStringA(
        pbBinary: *const BYTE,
        cbBinary: DWORD,
        dwFlags: DWORD,
        pszString: LPSTR,
        pcchString: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptBinaryToStringW(
        pbBinary: *const BYTE,
        cbBinary: DWORD,
        dwFlags: DWORD,
        pszString: LPWSTR,
        pcchString: *mut DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PKCS12_PBE_PARAMS {
    pub iIterations: ::std::os::raw::c_int,
    pub cbSalt: ULONG,
}
pub type CRYPT_PKCS12_PBE_PARAMS = _CRYPT_PKCS12_PBE_PARAMS;
extern "C" {
    pub fn PFXImportCertStore(
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        dwFlags: DWORD,
    ) -> HCERTSTORE;
}
extern "C" {
    pub fn PFXIsPFXBlob(pPFX: *mut CRYPT_DATA_BLOB) -> BOOL;
}
extern "C" {
    pub fn PFXVerifyPassword(
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PFXExportCertStoreEx(
        hStore: HCERTSTORE,
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        pvPara: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PKCS12_PBES2_EXPORT_PARAMS {
    pub dwSize: DWORD,
    pub hNcryptDescriptor: PVOID,
    pub pwszPbes2Alg: LPWSTR,
}
pub type PKCS12_PBES2_EXPORT_PARAMS = _PKCS12_PBES2_EXPORT_PARAMS;
pub type PPKCS12_PBES2_EXPORT_PARAMS = *mut _PKCS12_PBES2_EXPORT_PARAMS;
extern "C" {
    pub fn PFXExportCertStore(
        hStore: HCERTSTORE,
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        dwFlags: DWORD,
    ) -> BOOL;
}
pub type HCERT_SERVER_OCSP_RESPONSE = *mut ::std::os::raw::c_void;
pub type CERT_SERVER_OCSP_RESPONSE_CONTEXT = _CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub type PCERT_SERVER_OCSP_RESPONSE_CONTEXT = *mut _CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub type PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = *const CERT_SERVER_OCSP_RESPONSE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT {
    pub cbSize: DWORD,
    pub pbEncodedOcspResponse: *mut BYTE,
    pub cbEncodedOcspResponse: DWORD,
}
pub type PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        pChainContext: PCCERT_CHAIN_CONTEXT,
        pServerOcspResponseContext: PCCERT_SERVER_OCSP_RESPONSE_CONTEXT,
        pNewCrlContext: PCCRL_CONTEXT,
        pPrevCrlContext: PCCRL_CONTEXT,
        pvArg: PVOID,
        dwWriteOcspFileError: DWORD,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA {
    pub cbSize: DWORD,
    pub dwFlags: DWORD,
    pub pcbUsedSize: *mut DWORD,
    pub pwszOcspDirectory: PWSTR,
    pub pfnUpdateCallback: PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK,
    pub pvUpdateCallbackArg: PVOID,
}
pub type CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA;
pub type PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = *mut _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA;
extern "C" {
    pub fn CertOpenServerOcspResponse(
        pChainContext: PCCERT_CHAIN_CONTEXT,
        dwFlags: DWORD,
        pOpenPara: PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA,
    ) -> HCERT_SERVER_OCSP_RESPONSE;
}
extern "C" {
    pub fn CertAddRefServerOcspResponse(hServerOcspResponse: HCERT_SERVER_OCSP_RESPONSE);
}
extern "C" {
    pub fn CertCloseServerOcspResponse(
        hServerOcspResponse: HCERT_SERVER_OCSP_RESPONSE,
        dwFlags: DWORD,
    );
}
extern "C" {
    pub fn CertGetServerOcspResponseContext(
        hServerOcspResponse: HCERT_SERVER_OCSP_RESPONSE,
        dwFlags: DWORD,
        pvReserved: LPVOID,
    ) -> PCCERT_SERVER_OCSP_RESPONSE_CONTEXT;
}
extern "C" {
    pub fn CertAddRefServerOcspResponseContext(
        pServerOcspResponseContext: PCCERT_SERVER_OCSP_RESPONSE_CONTEXT,
    );
}
extern "C" {
    pub fn CertFreeServerOcspResponseContext(
        pServerOcspResponseContext: PCCERT_SERVER_OCSP_RESPONSE_CONTEXT,
    );
}
extern "C" {
    pub fn CertRetrieveLogoOrBiometricInfo(
        pCertContext: PCCERT_CONTEXT,
        lpszLogoOrBiometricType: LPCSTR,
        dwRetrievalFlags: DWORD,
        dwTimeout: DWORD,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        ppbData: *mut *mut BYTE,
        pcbData: *mut DWORD,
        ppwszMimeType: *mut LPWSTR,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SELECT_CHAIN_PARA {
    pub hChainEngine: HCERTCHAINENGINE,
    pub pTime: PFILETIME,
    pub hAdditionalStore: HCERTSTORE,
    pub pChainPara: PCERT_CHAIN_PARA,
    pub dwFlags: DWORD,
}
pub type CERT_SELECT_CHAIN_PARA = _CERT_SELECT_CHAIN_PARA;
pub type PCERT_SELECT_CHAIN_PARA = *mut _CERT_SELECT_CHAIN_PARA;
pub type PCCERT_SELECT_CHAIN_PARA = *const CERT_SELECT_CHAIN_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SELECT_CRITERIA {
    pub dwType: DWORD,
    pub cPara: DWORD,
    pub ppPara: *mut *mut ::std::os::raw::c_void,
}
pub type CERT_SELECT_CRITERIA = _CERT_SELECT_CRITERIA;
pub type PCERT_SELECT_CRITERIA = *mut _CERT_SELECT_CRITERIA;
pub type PCCERT_SELECT_CRITERIA = *const CERT_SELECT_CRITERIA;
extern "C" {
    pub fn CertSelectCertificateChains(
        pSelectionContext: LPCGUID,
        dwFlags: DWORD,
        pChainParameters: PCCERT_SELECT_CHAIN_PARA,
        cCriteria: DWORD,
        rgpCriteria: PCCERT_SELECT_CRITERIA,
        hStore: HCERTSTORE,
        pcSelection: PDWORD,
        pprgpSelection: *mut *mut PCCERT_CHAIN_CONTEXT,
    ) -> BOOL;
}
extern "C" {
    pub fn CertFreeCertificateChainList(prgpSelection: *mut PCCERT_CHAIN_CONTEXT);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIMESTAMP_REQUEST {
    pub dwVersion: DWORD,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub HashedMessage: CRYPT_DER_BLOB,
    pub pszTSAPolicyId: LPSTR,
    pub Nonce: CRYPT_INTEGER_BLOB,
    pub fCertReq: BOOL,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CRYPT_TIMESTAMP_REQUEST = _CRYPT_TIMESTAMP_REQUEST;
pub type PCRYPT_TIMESTAMP_REQUEST = *mut _CRYPT_TIMESTAMP_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIMESTAMP_RESPONSE {
    pub dwStatus: DWORD,
    pub cFreeText: DWORD,
    pub rgFreeText: *mut LPWSTR,
    pub FailureInfo: CRYPT_BIT_BLOB,
    pub ContentInfo: CRYPT_DER_BLOB,
}
pub type CRYPT_TIMESTAMP_RESPONSE = _CRYPT_TIMESTAMP_RESPONSE;
pub type PCRYPT_TIMESTAMP_RESPONSE = *mut _CRYPT_TIMESTAMP_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIMESTAMP_ACCURACY {
    pub dwSeconds: DWORD,
    pub dwMillis: DWORD,
    pub dwMicros: DWORD,
}
pub type CRYPT_TIMESTAMP_ACCURACY = _CRYPT_TIMESTAMP_ACCURACY;
pub type PCRYPT_TIMESTAMP_ACCURACY = *mut _CRYPT_TIMESTAMP_ACCURACY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIMESTAMP_INFO {
    pub dwVersion: DWORD,
    pub pszTSAPolicyId: LPSTR,
    pub HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub HashedMessage: CRYPT_DER_BLOB,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
    pub ftTime: FILETIME,
    pub pvAccuracy: PCRYPT_TIMESTAMP_ACCURACY,
    pub fOrdering: BOOL,
    pub Nonce: CRYPT_DER_BLOB,
    pub Tsa: CRYPT_DER_BLOB,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CRYPT_TIMESTAMP_INFO = _CRYPT_TIMESTAMP_INFO;
pub type PCRYPT_TIMESTAMP_INFO = *mut _CRYPT_TIMESTAMP_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIMESTAMP_CONTEXT {
    pub cbEncoded: DWORD,
    pub pbEncoded: *mut BYTE,
    pub pTimeStamp: PCRYPT_TIMESTAMP_INFO,
}
pub type CRYPT_TIMESTAMP_CONTEXT = _CRYPT_TIMESTAMP_CONTEXT;
pub type PCRYPT_TIMESTAMP_CONTEXT = *mut _CRYPT_TIMESTAMP_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_TIMESTAMP_PARA {
    pub pszTSAPolicyId: LPCSTR,
    pub fRequestCerts: BOOL,
    pub Nonce: CRYPT_INTEGER_BLOB,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type CRYPT_TIMESTAMP_PARA = _CRYPT_TIMESTAMP_PARA;
pub type PCRYPT_TIMESTAMP_PARA = *mut _CRYPT_TIMESTAMP_PARA;
extern "C" {
    pub fn CryptRetrieveTimeStamp(
        wszUrl: LPCWSTR,
        dwRetrievalFlags: DWORD,
        dwTimeout: DWORD,
        pszHashId: LPCSTR,
        pPara: *const CRYPT_TIMESTAMP_PARA,
        pbData: *const BYTE,
        cbData: DWORD,
        ppTsContext: *mut PCRYPT_TIMESTAMP_CONTEXT,
        ppTsSigner: *mut PCCERT_CONTEXT,
        phStore: *mut HCERTSTORE,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptVerifyTimeStampSignature(
        pbTSContentInfo: *const BYTE,
        cbTSContentInfo: DWORD,
        pbData: *const BYTE,
        cbData: DWORD,
        hAdditionalStore: HCERTSTORE,
        ppTsContext: *mut PCRYPT_TIMESTAMP_CONTEXT,
        ppTsSigner: *mut PCCERT_CONTEXT,
        phStore: *mut HCERTSTORE,
    ) -> BOOL;
}
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: LPVOID,
        rgIdentifierOrNameList: *mut PCERT_NAME_BLOB,
        dwIdentifierOrNameListCount: DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = ::std::option::Option<
    unsafe extern "C" fn(
        pPluginContext: LPVOID,
        pIdentifier: PCRYPT_DATA_BLOB,
        dwNameType: DWORD,
        pNameBlob: PCERT_NAME_BLOB,
        ppbContent: *mut PBYTE,
        pcbContent: *mut DWORD,
        ppwszPassword: *mut PCWSTR,
        ppIdentifier: *mut PCRYPT_DATA_BLOB,
    ) -> BOOL,
>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE =
    ::std::option::Option<unsafe extern "C" fn(dwReason: DWORD, pPluginContext: LPVOID)>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD =
    ::std::option::Option<unsafe extern "C" fn(pPluginContext: LPVOID, pwszPassword: PCWSTR)>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE =
    ::std::option::Option<unsafe extern "C" fn(pPluginContext: LPVOID, pbData: PBYTE)>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = ::std::option::Option<
    unsafe extern "C" fn(pPluginContext: LPVOID, pIdentifier: PCRYPT_DATA_BLOB),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE {
    pub cbSize: DWORD,
    pub pfnGet: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pub pfnRelease: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pub pfnFreePassword: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pub pfnFree: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pub pfnFreeIdentifier: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
}
pub type CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;
pub type PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = *mut _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = ::std::option::Option<
    unsafe extern "C" fn(
        pfnFlush: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH,
        pContext: LPVOID,
        pdwExpectedObjectCount: *mut DWORD,
        ppFuncTable: *mut PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE,
        ppPluginContext: *mut *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
extern "C" {
    pub fn CertIsWeakHash(
        dwHashUseType: DWORD,
        pwszCNGHashAlgid: LPCWSTR,
        dwChainFlags: DWORD,
        pSignerChainContext: PCCERT_CHAIN_CONTEXT,
        pTimeStamp: LPFILETIME,
        pwszFileName: LPCWSTR,
    ) -> BOOL;
}
pub type PFN_CERT_IS_WEAK_HASH = ::std::option::Option<
    unsafe extern "C" fn(
        dwHashUseType: DWORD,
        pwszCNGHashAlgid: LPCWSTR,
        dwChainFlags: DWORD,
        pSignerChainContext: PCCERT_CHAIN_CONTEXT,
        pTimeStamp: LPFILETIME,
        pwszFileName: LPCWSTR,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPTPROTECT_PROMPTSTRUCT {
    pub cbSize: DWORD,
    pub dwPromptFlags: DWORD,
    pub hwndApp: HWND,
    pub szPrompt: LPCWSTR,
}
pub type CRYPTPROTECT_PROMPTSTRUCT = _CRYPTPROTECT_PROMPTSTRUCT;
pub type PCRYPTPROTECT_PROMPTSTRUCT = *mut _CRYPTPROTECT_PROMPTSTRUCT;
extern "C" {
    pub fn CryptProtectData(
        pDataIn: *mut DATA_BLOB,
        szDataDescr: LPCWSTR,
        pOptionalEntropy: *mut DATA_BLOB,
        pvReserved: PVOID,
        pPromptStruct: *mut CRYPTPROTECT_PROMPTSTRUCT,
        dwFlags: DWORD,
        pDataOut: *mut DATA_BLOB,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptUnprotectData(
        pDataIn: *mut DATA_BLOB,
        ppszDataDescr: *mut LPWSTR,
        pOptionalEntropy: *mut DATA_BLOB,
        pvReserved: PVOID,
        pPromptStruct: *mut CRYPTPROTECT_PROMPTSTRUCT,
        dwFlags: DWORD,
        pDataOut: *mut DATA_BLOB,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptProtectDataNoUI(
        pDataIn: *mut DATA_BLOB,
        szDataDescr: LPCWSTR,
        pOptionalEntropy: *mut DATA_BLOB,
        pvReserved: PVOID,
        pPromptStruct: *mut CRYPTPROTECT_PROMPTSTRUCT,
        dwFlags: DWORD,
        pbOptionalPassword: *const BYTE,
        cbOptionalPassword: DWORD,
        pDataOut: *mut DATA_BLOB,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptUnprotectDataNoUI(
        pDataIn: *mut DATA_BLOB,
        ppszDataDescr: *mut LPWSTR,
        pOptionalEntropy: *mut DATA_BLOB,
        pvReserved: PVOID,
        pPromptStruct: *mut CRYPTPROTECT_PROMPTSTRUCT,
        dwFlags: DWORD,
        pbOptionalPassword: *const BYTE,
        cbOptionalPassword: DWORD,
        pDataOut: *mut DATA_BLOB,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptUpdateProtectedState(
        pOldSid: PSID,
        pwszOldPassword: LPCWSTR,
        dwFlags: DWORD,
        pdwSuccessCount: *mut DWORD,
        pdwFailureCount: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CryptProtectMemory(pDataIn: LPVOID, cbDataIn: DWORD, dwFlags: DWORD) -> BOOL;
}
extern "C" {
    pub fn CryptUnprotectMemory(pDataIn: LPVOID, cbDataIn: DWORD, dwFlags: DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERTIFICATE_BLOB {
    pub dwCertEncodingType: DWORD,
    pub cbData: DWORD,
    pub pbData: PBYTE,
}
pub type EFS_CERTIFICATE_BLOB = _CERTIFICATE_BLOB;
pub type PEFS_CERTIFICATE_BLOB = *mut _CERTIFICATE_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_HASH_BLOB {
    pub cbData: DWORD,
    pub pbData: PBYTE,
}
pub type EFS_HASH_BLOB = _EFS_HASH_BLOB;
pub type PEFS_HASH_BLOB = *mut _EFS_HASH_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_RPC_BLOB {
    pub cbData: DWORD,
    pub pbData: PBYTE,
}
pub type EFS_RPC_BLOB = _EFS_RPC_BLOB;
pub type PEFS_RPC_BLOB = *mut _EFS_RPC_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_PIN_BLOB {
    pub cbPadding: DWORD,
    pub cbData: DWORD,
    pub pbData: PBYTE,
}
pub type EFS_PIN_BLOB = _EFS_PIN_BLOB;
pub type PEFS_PIN_BLOB = *mut _EFS_PIN_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_KEY_INFO {
    pub dwVersion: DWORD,
    pub Entropy: ULONG,
    pub Algorithm: ALG_ID,
    pub KeyLength: ULONG,
}
pub type EFS_KEY_INFO = _EFS_KEY_INFO;
pub type PEFS_KEY_INFO = *mut _EFS_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_COMPATIBILITY_INFO {
    pub EfsVersion: DWORD,
}
pub type EFS_COMPATIBILITY_INFO = _EFS_COMPATIBILITY_INFO;
pub type PEFS_COMPATIBILITY_INFO = *mut _EFS_COMPATIBILITY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_VERSION_INFO {
    pub EfsVersion: DWORD,
    pub SubVersion: DWORD,
}
pub type EFS_VERSION_INFO = _EFS_VERSION_INFO;
pub type PEFS_VERSION_INFO = *mut _EFS_VERSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_DECRYPTION_STATUS_INFO {
    pub dwDecryptionError: DWORD,
    pub dwHashOffset: DWORD,
    pub cbHash: DWORD,
}
pub type EFS_DECRYPTION_STATUS_INFO = _EFS_DECRYPTION_STATUS_INFO;
pub type PEFS_DECRYPTION_STATUS_INFO = *mut _EFS_DECRYPTION_STATUS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EFS_ENCRYPTION_STATUS_INFO {
    pub bHasCurrentKey: BOOL,
    pub dwEncryptionError: DWORD,
}
pub type EFS_ENCRYPTION_STATUS_INFO = _EFS_ENCRYPTION_STATUS_INFO;
pub type PEFS_ENCRYPTION_STATUS_INFO = *mut _EFS_ENCRYPTION_STATUS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_CERTIFICATE {
    pub cbTotalLength: DWORD,
    pub pUserSid: *mut SID,
    pub pCertBlob: PEFS_CERTIFICATE_BLOB,
}
pub type ENCRYPTION_CERTIFICATE = _ENCRYPTION_CERTIFICATE;
pub type PENCRYPTION_CERTIFICATE = *mut _ENCRYPTION_CERTIFICATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_CERTIFICATE_HASH {
    pub cbTotalLength: DWORD,
    pub pUserSid: *mut SID,
    pub pHash: PEFS_HASH_BLOB,
    pub lpDisplayInformation: LPWSTR,
}
pub type ENCRYPTION_CERTIFICATE_HASH = _ENCRYPTION_CERTIFICATE_HASH;
pub type PENCRYPTION_CERTIFICATE_HASH = *mut _ENCRYPTION_CERTIFICATE_HASH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_CERTIFICATE_HASH_LIST {
    pub nCert_Hash: DWORD,
    pub pUsers: *mut PENCRYPTION_CERTIFICATE_HASH,
}
pub type ENCRYPTION_CERTIFICATE_HASH_LIST = _ENCRYPTION_CERTIFICATE_HASH_LIST;
pub type PENCRYPTION_CERTIFICATE_HASH_LIST = *mut _ENCRYPTION_CERTIFICATE_HASH_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_CERTIFICATE_LIST {
    pub nUsers: DWORD,
    pub pUsers: *mut PENCRYPTION_CERTIFICATE,
}
pub type ENCRYPTION_CERTIFICATE_LIST = _ENCRYPTION_CERTIFICATE_LIST;
pub type PENCRYPTION_CERTIFICATE_LIST = *mut _ENCRYPTION_CERTIFICATE_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_FILE_METADATA_SIGNATURE {
    pub dwEfsAccessType: DWORD,
    pub pCertificatesAdded: PENCRYPTION_CERTIFICATE_HASH_LIST,
    pub pEncryptionCertificate: PENCRYPTION_CERTIFICATE,
    pub pEfsStreamSignature: PEFS_RPC_BLOB,
}
pub type ENCRYPTED_FILE_METADATA_SIGNATURE = _ENCRYPTED_FILE_METADATA_SIGNATURE;
pub type PENCRYPTED_FILE_METADATA_SIGNATURE = *mut _ENCRYPTED_FILE_METADATA_SIGNATURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_PROTECTOR {
    pub cbTotalLength: DWORD,
    pub pUserSid: *mut SID,
    pub lpProtectorDescriptor: LPWSTR,
}
pub type ENCRYPTION_PROTECTOR = _ENCRYPTION_PROTECTOR;
pub type PENCRYPTION_PROTECTOR = *mut _ENCRYPTION_PROTECTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_PROTECTOR_LIST {
    pub nProtectors: DWORD,
    pub pProtectors: *mut PENCRYPTION_PROTECTOR,
}
pub type ENCRYPTION_PROTECTOR_LIST = _ENCRYPTION_PROTECTOR_LIST;
pub type PENCRYPTION_PROTECTOR_LIST = *mut _ENCRYPTION_PROTECTOR_LIST;
extern "C" {
    pub fn QueryUsersOnEncryptedFile(
        lpFileName: LPCWSTR,
        pUsers: *mut PENCRYPTION_CERTIFICATE_HASH_LIST,
    ) -> DWORD;
}
extern "C" {
    pub fn QueryRecoveryAgentsOnEncryptedFile(
        lpFileName: LPCWSTR,
        pRecoveryAgents: *mut PENCRYPTION_CERTIFICATE_HASH_LIST,
    ) -> DWORD;
}
extern "C" {
    pub fn RemoveUsersFromEncryptedFile(
        lpFileName: LPCWSTR,
        pHashes: PENCRYPTION_CERTIFICATE_HASH_LIST,
    ) -> DWORD;
}
extern "C" {
    pub fn AddUsersToEncryptedFile(
        lpFileName: LPCWSTR,
        pEncryptionCertificates: PENCRYPTION_CERTIFICATE_LIST,
    ) -> DWORD;
}
extern "C" {
    pub fn SetUserFileEncryptionKey(pEncryptionCertificate: PENCRYPTION_CERTIFICATE) -> DWORD;
}
extern "C" {
    pub fn SetUserFileEncryptionKeyEx(
        pEncryptionCertificate: PENCRYPTION_CERTIFICATE,
        dwCapabilities: DWORD,
        dwFlags: DWORD,
        pvReserved: LPVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn FreeEncryptionCertificateHashList(pUsers: PENCRYPTION_CERTIFICATE_HASH_LIST);
}
extern "C" {
    pub fn EncryptionDisable(DirPath: LPCWSTR, Disable: BOOL) -> BOOL;
}
extern "C" {
    pub fn DuplicateEncryptionInfoFile(
        SrcFileName: LPCWSTR,
        DstFileName: LPCWSTR,
        dwCreationDistribution: DWORD,
        dwAttributes: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> DWORD;
}
extern "C" {
    pub fn GetEncryptedFileMetadata(
        lpFileName: LPCWSTR,
        pcbMetadata: PDWORD,
        ppbMetadata: *mut PBYTE,
    ) -> DWORD;
}
extern "C" {
    pub fn SetEncryptedFileMetadata(
        lpFileName: LPCWSTR,
        pbOldMetadata: PBYTE,
        pbNewMetadata: PBYTE,
        pOwnerHash: PENCRYPTION_CERTIFICATE_HASH,
        dwOperation: DWORD,
        pCertificatesAdded: PENCRYPTION_CERTIFICATE_HASH_LIST,
    ) -> DWORD;
}
extern "C" {
    pub fn FreeEncryptedFileMetadata(pbMetadata: PBYTE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RPC_IMPORT_CONTEXT_P {
    pub LookupContext: RPC_NS_HANDLE,
    pub ProposedHandle: RPC_BINDING_HANDLE,
    pub Bindings: *mut RPC_BINDING_VECTOR,
}
pub type PRPC_IMPORT_CONTEXT_P = *mut RPC_IMPORT_CONTEXT_P;
extern "C" {
    pub fn I_RpcNsGetBuffer(Message: PRPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcNsSendReceive(Message: PRPC_MESSAGE, Handle: *mut RPC_BINDING_HANDLE)
        -> RPC_STATUS;
}
extern "C" {
    pub fn I_RpcNsRaiseException(Message: PRPC_MESSAGE, Status: RPC_STATUS);
}
extern "C" {
    pub fn I_RpcReBindBuffer(Message: PRPC_MESSAGE) -> RPC_STATUS;
}
extern "C" {
    pub fn I_NsServerBindSearch() -> RPC_STATUS;
}
extern "C" {
    pub fn I_NsClientBindSearch() -> RPC_STATUS;
}
extern "C" {
    pub fn I_NsClientBindDone();
}
pub type byte = ::std::os::raw::c_uchar;
pub type cs_byte = byte;
pub type boolean = ::std::os::raw::c_uchar;
extern "C" {
    pub fn MIDL_user_allocate(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MIDL_user_free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn I_RpcDefaultAllocate(
        bh: handle_t,
        size: usize,
        RealAlloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn I_RpcDefaultFree(
        bh: handle_t,
        arg1: *mut ::std::os::raw::c_void,
        RealFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
pub type NDR_CCONTEXT = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_SCONTEXT {
    pub pad: [*mut ::std::os::raw::c_void; 2usize],
    pub userContext: *mut ::std::os::raw::c_void,
}
pub type NDR_SCONTEXT = *mut _NDR_SCONTEXT;
pub type NDR_RUNDOWN =
    ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
pub type NDR_NOTIFY_ROUTINE = ::std::option::Option<unsafe extern "C" fn()>;
pub type NDR_NOTIFY2_ROUTINE = ::std::option::Option<unsafe extern "C" fn(flag: boolean)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCONTEXT_QUEUE {
    pub NumberOfObjects: ::std::os::raw::c_ulong,
    pub ArrayOfObjects: *mut NDR_SCONTEXT,
}
pub type SCONTEXT_QUEUE = _SCONTEXT_QUEUE;
pub type PSCONTEXT_QUEUE = *mut _SCONTEXT_QUEUE;
extern "C" {
    pub fn NDRCContextBinding(CContext: NDR_CCONTEXT) -> RPC_BINDING_HANDLE;
}
extern "C" {
    pub fn NDRCContextMarshall(CContext: NDR_CCONTEXT, pBuff: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn NDRCContextUnmarshall(
        pCContext: *mut NDR_CCONTEXT,
        hBinding: RPC_BINDING_HANDLE,
        pBuff: *mut ::std::os::raw::c_void,
        DataRepresentation: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn NDRCContextUnmarshall2(
        pCContext: *mut NDR_CCONTEXT,
        hBinding: RPC_BINDING_HANDLE,
        pBuff: *mut ::std::os::raw::c_void,
        DataRepresentation: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn NDRSContextMarshall(
        CContext: NDR_SCONTEXT,
        pBuff: *mut ::std::os::raw::c_void,
        userRunDownIn: NDR_RUNDOWN,
    );
}
extern "C" {
    pub fn NDRSContextUnmarshall(
        pBuff: *mut ::std::os::raw::c_void,
        DataRepresentation: ::std::os::raw::c_ulong,
    ) -> NDR_SCONTEXT;
}
extern "C" {
    pub fn NDRSContextMarshallEx(
        BindingHandle: RPC_BINDING_HANDLE,
        CContext: NDR_SCONTEXT,
        pBuff: *mut ::std::os::raw::c_void,
        userRunDownIn: NDR_RUNDOWN,
    );
}
extern "C" {
    pub fn NDRSContextMarshall2(
        BindingHandle: RPC_BINDING_HANDLE,
        CContext: NDR_SCONTEXT,
        pBuff: *mut ::std::os::raw::c_void,
        userRunDownIn: NDR_RUNDOWN,
        CtxGuard: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn NDRSContextUnmarshallEx(
        BindingHandle: RPC_BINDING_HANDLE,
        pBuff: *mut ::std::os::raw::c_void,
        DataRepresentation: ::std::os::raw::c_ulong,
    ) -> NDR_SCONTEXT;
}
extern "C" {
    pub fn NDRSContextUnmarshall2(
        BindingHandle: RPC_BINDING_HANDLE,
        pBuff: *mut ::std::os::raw::c_void,
        DataRepresentation: ::std::os::raw::c_ulong,
        CtxGuard: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_ulong,
    ) -> NDR_SCONTEXT;
}
extern "C" {
    pub fn RpcSsDestroyClientContext(ContextHandle: *mut *mut ::std::os::raw::c_void);
}
pub type error_status_t = ::std::os::raw::c_ulong;
pub type RPC_BUFPTR = *mut ::std::os::raw::c_uchar;
pub type RPC_LENGTH = ::std::os::raw::c_ulong;
pub type EXPR_EVAL = ::std::option::Option<unsafe extern "C" fn(arg1: *mut _MIDL_STUB_MESSAGE)>;
pub type PFORMAT_STRING = *const ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARRAY_INFO {
    pub Dimension: ::std::os::raw::c_long,
    pub BufferConformanceMark: *mut ::std::os::raw::c_ulong,
    pub BufferVarianceMark: *mut ::std::os::raw::c_ulong,
    pub MaxCountArray: *mut ::std::os::raw::c_ulong,
    pub OffsetArray: *mut ::std::os::raw::c_ulong,
    pub ActualCountArray: *mut ::std::os::raw::c_ulong,
}
pub type PARRAY_INFO = *mut ARRAY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_ASYNC_MESSAGE {
    _unused: [u8; 0],
}
pub type PNDR_ASYNC_MESSAGE = *mut _NDR_ASYNC_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CORRELATION_INFO {
    _unused: [u8; 0],
}
pub type PNDR_CORRELATION_INFO = *mut _NDR_CORRELATION_INFO;
pub type MIDL_SYNTAX_INFO = _MIDL_SYNTAX_INFO;
pub type PMIDL_SYNTAX_INFO = *mut _MIDL_SYNTAX_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDR_ALLOC_ALL_NODES_CONTEXT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDR_POINTER_QUEUE_STATE {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_PROC_CONTEXT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_STUB_MESSAGE {
    pub RpcMsg: PRPC_MESSAGE,
    pub Buffer: *mut ::std::os::raw::c_uchar,
    pub BufferStart: *mut ::std::os::raw::c_uchar,
    pub BufferEnd: *mut ::std::os::raw::c_uchar,
    pub BufferMark: *mut ::std::os::raw::c_uchar,
    pub BufferLength: ::std::os::raw::c_ulong,
    pub MemorySize: ::std::os::raw::c_ulong,
    pub Memory: *mut ::std::os::raw::c_uchar,
    pub IsClient: ::std::os::raw::c_uchar,
    pub Pad: ::std::os::raw::c_uchar,
    pub uFlags2: ::std::os::raw::c_ushort,
    pub ReuseBuffer: ::std::os::raw::c_int,
    pub pAllocAllNodesContext: *mut NDR_ALLOC_ALL_NODES_CONTEXT,
    pub pPointerQueueState: *mut NDR_POINTER_QUEUE_STATE,
    pub IgnoreEmbeddedPointers: ::std::os::raw::c_int,
    pub PointerBufferMark: *mut ::std::os::raw::c_uchar,
    pub CorrDespIncrement: ::std::os::raw::c_uchar,
    pub uFlags: ::std::os::raw::c_uchar,
    pub UniquePtrCount: ::std::os::raw::c_ushort,
    pub MaxCount: ULONG_PTR,
    pub Offset: ::std::os::raw::c_ulong,
    pub ActualCount: ::std::os::raw::c_ulong,
    pub pfnAllocate:
        ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
    pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub StackTop: *mut ::std::os::raw::c_uchar,
    pub pPresentedType: *mut ::std::os::raw::c_uchar,
    pub pTransmitType: *mut ::std::os::raw::c_uchar,
    pub SavedHandle: handle_t,
    pub StubDesc: *const _MIDL_STUB_DESC,
    pub FullPtrXlatTables: *mut _FULL_PTR_XLAT_TABLES,
    pub FullPtrRefId: ::std::os::raw::c_ulong,
    pub PointerLength: ::std::os::raw::c_ulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub dwDestContext: ::std::os::raw::c_ulong,
    pub pvDestContext: *mut ::std::os::raw::c_void,
    pub SavedContextHandles: *mut NDR_SCONTEXT,
    pub ParamNumber: ::std::os::raw::c_long,
    pub pRpcChannelBuffer: *mut IRpcChannelBuffer,
    pub pArrayInfo: PARRAY_INFO,
    pub SizePtrCountArray: *mut ::std::os::raw::c_ulong,
    pub SizePtrOffsetArray: *mut ::std::os::raw::c_ulong,
    pub SizePtrLengthArray: *mut ::std::os::raw::c_ulong,
    pub pArgQueue: *mut ::std::os::raw::c_void,
    pub dwStubPhase: ::std::os::raw::c_ulong,
    pub LowStackMark: *mut ::std::os::raw::c_void,
    pub pAsyncMsg: PNDR_ASYNC_MESSAGE,
    pub pCorrInfo: PNDR_CORRELATION_INFO,
    pub pCorrMemory: *mut ::std::os::raw::c_uchar,
    pub pMemoryList: *mut ::std::os::raw::c_void,
    pub pCSInfo: INT_PTR,
    pub ConformanceMark: *mut ::std::os::raw::c_uchar,
    pub VarianceMark: *mut ::std::os::raw::c_uchar,
    pub Unused: INT_PTR,
    pub pContext: *mut _NDR_PROC_CONTEXT,
    pub ContextHandleHash: *mut ::std::os::raw::c_void,
    pub pUserMarshalList: *mut ::std::os::raw::c_void,
    pub Reserved51_3: INT_PTR,
    pub Reserved51_4: INT_PTR,
    pub Reserved51_5: INT_PTR,
}
impl _MIDL_STUB_MESSAGE {
    #[inline]
    pub fn fInDontFree(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fInDontFree(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fDontCallFreeInst(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDontCallFreeInst(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUnused1(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fUnused1(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasReturn(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fHasReturn(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasExtensions(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fHasExtensions(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasNewCorrDesc(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fHasNewCorrDesc(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fIsIn(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fIsIn(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fIsOut(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fIsOut(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fIsOicf(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fIsOicf(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fBufferValid(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fBufferValid(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasMemoryValidateCallback(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fHasMemoryValidateCallback(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fInFree(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fInFree(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fNeedMCCP(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fNeedMCCP(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUnused2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_fUnused2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fUnused3(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_fUnused3(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fInDontFree: ::std::os::raw::c_int,
        fDontCallFreeInst: ::std::os::raw::c_int,
        fUnused1: ::std::os::raw::c_int,
        fHasReturn: ::std::os::raw::c_int,
        fHasExtensions: ::std::os::raw::c_int,
        fHasNewCorrDesc: ::std::os::raw::c_int,
        fIsIn: ::std::os::raw::c_int,
        fIsOut: ::std::os::raw::c_int,
        fIsOicf: ::std::os::raw::c_int,
        fBufferValid: ::std::os::raw::c_int,
        fHasMemoryValidateCallback: ::std::os::raw::c_int,
        fInFree: ::std::os::raw::c_int,
        fNeedMCCP: ::std::os::raw::c_int,
        fUnused2: ::std::os::raw::c_int,
        fUnused3: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fInDontFree: u32 = unsafe { ::std::mem::transmute(fInDontFree) };
            fInDontFree as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fDontCallFreeInst: u32 = unsafe { ::std::mem::transmute(fDontCallFreeInst) };
            fDontCallFreeInst as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fUnused1: u32 = unsafe { ::std::mem::transmute(fUnused1) };
            fUnused1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fHasReturn: u32 = unsafe { ::std::mem::transmute(fHasReturn) };
            fHasReturn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fHasExtensions: u32 = unsafe { ::std::mem::transmute(fHasExtensions) };
            fHasExtensions as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fHasNewCorrDesc: u32 = unsafe { ::std::mem::transmute(fHasNewCorrDesc) };
            fHasNewCorrDesc as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fIsIn: u32 = unsafe { ::std::mem::transmute(fIsIn) };
            fIsIn as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fIsOut: u32 = unsafe { ::std::mem::transmute(fIsOut) };
            fIsOut as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fIsOicf: u32 = unsafe { ::std::mem::transmute(fIsOicf) };
            fIsOicf as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fBufferValid: u32 = unsafe { ::std::mem::transmute(fBufferValid) };
            fBufferValid as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let fHasMemoryValidateCallback: u32 =
                unsafe { ::std::mem::transmute(fHasMemoryValidateCallback) };
            fHasMemoryValidateCallback as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fInFree: u32 = unsafe { ::std::mem::transmute(fInFree) };
            fInFree as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fNeedMCCP: u32 = unsafe { ::std::mem::transmute(fNeedMCCP) };
            fNeedMCCP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let fUnused2: u32 = unsafe { ::std::mem::transmute(fUnused2) };
            fUnused2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let fUnused3: u32 = unsafe { ::std::mem::transmute(fUnused3) };
            fUnused3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MIDL_STUB_MESSAGE = _MIDL_STUB_MESSAGE;
pub type PMIDL_STUB_MESSAGE = *mut _MIDL_STUB_MESSAGE;
pub type GENERIC_BINDING_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type GENERIC_UNBIND_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_uchar),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_BINDING_ROUTINE_PAIR {
    pub pfnBind: GENERIC_BINDING_ROUTINE,
    pub pfnUnbind: GENERIC_UNBIND_ROUTINE,
}
pub type GENERIC_BINDING_ROUTINE_PAIR = _GENERIC_BINDING_ROUTINE_PAIR;
pub type PGENERIC_BINDING_ROUTINE_PAIR = *mut _GENERIC_BINDING_ROUTINE_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __GENERIC_BINDING_INFO {
    pub pObj: *mut ::std::os::raw::c_void,
    pub Size: ::std::os::raw::c_uint,
    pub pfnBind: GENERIC_BINDING_ROUTINE,
    pub pfnUnbind: GENERIC_UNBIND_ROUTINE,
}
pub type GENERIC_BINDING_INFO = __GENERIC_BINDING_INFO;
pub type PGENERIC_BINDING_INFO = *mut __GENERIC_BINDING_INFO;
pub type XMIT_HELPER_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(arg1: PMIDL_STUB_MESSAGE)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XMIT_ROUTINE_QUINTUPLE {
    pub pfnTranslateToXmit: XMIT_HELPER_ROUTINE,
    pub pfnTranslateFromXmit: XMIT_HELPER_ROUTINE,
    pub pfnFreeXmit: XMIT_HELPER_ROUTINE,
    pub pfnFreeInst: XMIT_HELPER_ROUTINE,
}
pub type XMIT_ROUTINE_QUINTUPLE = _XMIT_ROUTINE_QUINTUPLE;
pub type PXMIT_ROUTINE_QUINTUPLE = *mut _XMIT_ROUTINE_QUINTUPLE;
pub type USER_MARSHAL_SIZING_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_ulong,
>;
pub type USER_MARSHAL_MARSHALLING_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_uchar,
>;
pub type USER_MARSHAL_UNMARSHALLING_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_uchar,
>;
pub type USER_MARSHAL_FREEING_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USER_MARSHAL_ROUTINE_QUADRUPLE {
    pub pfnBufferSize: USER_MARSHAL_SIZING_ROUTINE,
    pub pfnMarshall: USER_MARSHAL_MARSHALLING_ROUTINE,
    pub pfnUnmarshall: USER_MARSHAL_UNMARSHALLING_ROUTINE,
    pub pfnFree: USER_MARSHAL_FREEING_ROUTINE,
}
pub type USER_MARSHAL_ROUTINE_QUADRUPLE = _USER_MARSHAL_ROUTINE_QUADRUPLE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _USER_MARSHAL_CB_TYPE {
    USER_MARSHAL_CB_BUFFER_SIZE = 0,
    USER_MARSHAL_CB_MARSHALL = 1,
    USER_MARSHAL_CB_UNMARSHALL = 2,
    USER_MARSHAL_CB_FREE = 3,
}
pub use self::_USER_MARSHAL_CB_TYPE as USER_MARSHAL_CB_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USER_MARSHAL_CB {
    pub Flags: ::std::os::raw::c_ulong,
    pub pStubMsg: PMIDL_STUB_MESSAGE,
    pub pReserve: PFORMAT_STRING,
    pub Signature: ::std::os::raw::c_ulong,
    pub CBType: USER_MARSHAL_CB_TYPE,
    pub pFormat: PFORMAT_STRING,
    pub pTypeFormat: PFORMAT_STRING,
}
pub type USER_MARSHAL_CB = _USER_MARSHAL_CB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MALLOC_FREE_STRUCT {
    pub pfnAllocate:
        ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
    pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
pub type MALLOC_FREE_STRUCT = _MALLOC_FREE_STRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMM_FAULT_OFFSETS {
    pub CommOffset: ::std::os::raw::c_short,
    pub FaultOffset: ::std::os::raw::c_short,
}
pub type COMM_FAULT_OFFSETS = _COMM_FAULT_OFFSETS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _IDL_CS_CONVERT {
    IDL_CS_NO_CONVERT = 0,
    IDL_CS_IN_PLACE_CONVERT = 1,
    IDL_CS_NEW_BUFFER_CONVERT = 2,
}
pub use self::_IDL_CS_CONVERT as IDL_CS_CONVERT;
pub type CS_TYPE_NET_SIZE_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        hBinding: RPC_BINDING_HANDLE,
        ulNetworkCodeSet: ::std::os::raw::c_ulong,
        ulLocalBufferSize: ::std::os::raw::c_ulong,
        conversionType: *mut IDL_CS_CONVERT,
        pulNetworkBufferSize: *mut ::std::os::raw::c_ulong,
        pStatus: *mut error_status_t,
    ),
>;
pub type CS_TYPE_LOCAL_SIZE_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        hBinding: RPC_BINDING_HANDLE,
        ulNetworkCodeSet: ::std::os::raw::c_ulong,
        ulNetworkBufferSize: ::std::os::raw::c_ulong,
        conversionType: *mut IDL_CS_CONVERT,
        pulLocalBufferSize: *mut ::std::os::raw::c_ulong,
        pStatus: *mut error_status_t,
    ),
>;
pub type CS_TYPE_TO_NETCS_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        hBinding: RPC_BINDING_HANDLE,
        ulNetworkCodeSet: ::std::os::raw::c_ulong,
        pLocalData: *mut ::std::os::raw::c_void,
        ulLocalDataLength: ::std::os::raw::c_ulong,
        pNetworkData: *mut byte,
        pulNetworkDataLength: *mut ::std::os::raw::c_ulong,
        pStatus: *mut error_status_t,
    ),
>;
pub type CS_TYPE_FROM_NETCS_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        hBinding: RPC_BINDING_HANDLE,
        ulNetworkCodeSet: ::std::os::raw::c_ulong,
        pNetworkData: *mut byte,
        ulNetworkDataLength: ::std::os::raw::c_ulong,
        ulLocalBufferSize: ::std::os::raw::c_ulong,
        pLocalData: *mut ::std::os::raw::c_void,
        pulLocalDataLength: *mut ::std::os::raw::c_ulong,
        pStatus: *mut error_status_t,
    ),
>;
pub type CS_TAG_GETTING_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        hBinding: RPC_BINDING_HANDLE,
        fServerSide: ::std::os::raw::c_int,
        pulSendingTag: *mut ::std::os::raw::c_ulong,
        pulDesiredReceivingTag: *mut ::std::os::raw::c_ulong,
        pulReceivingTag: *mut ::std::os::raw::c_ulong,
        pStatus: *mut error_status_t,
    ),
>;
extern "C" {
    pub fn RpcCsGetTags(
        hBinding: RPC_BINDING_HANDLE,
        fServerSide: ::std::os::raw::c_int,
        pulSendingTag: *mut ::std::os::raw::c_ulong,
        pulDesiredReceivingTag: *mut ::std::os::raw::c_ulong,
        pulReceivingTag: *mut ::std::os::raw::c_ulong,
        pStatus: *mut error_status_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CS_SIZE_CONVERT_ROUTINES {
    pub pfnNetSize: CS_TYPE_NET_SIZE_ROUTINE,
    pub pfnToNetCs: CS_TYPE_TO_NETCS_ROUTINE,
    pub pfnLocalSize: CS_TYPE_LOCAL_SIZE_ROUTINE,
    pub pfnFromNetCs: CS_TYPE_FROM_NETCS_ROUTINE,
}
pub type NDR_CS_SIZE_CONVERT_ROUTINES = _NDR_CS_SIZE_CONVERT_ROUTINES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CS_ROUTINES {
    pub pSizeConvertRoutines: *mut NDR_CS_SIZE_CONVERT_ROUTINES,
    pub pTagGettingRoutines: *mut CS_TAG_GETTING_ROUTINE,
}
pub type NDR_CS_ROUTINES = _NDR_CS_ROUTINES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_EXPR_DESC {
    pub pOffset: *const ::std::os::raw::c_ushort,
    pub pFormatExpr: PFORMAT_STRING,
}
pub type NDR_EXPR_DESC = _NDR_EXPR_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MIDL_STUB_DESC {
    pub RpcInterfaceInformation: *mut ::std::os::raw::c_void,
    pub pfnAllocate:
        ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
    pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub IMPLICIT_HANDLE_INFO: _MIDL_STUB_DESC__bindgen_ty_1,
    pub apfnNdrRundownRoutines: *const NDR_RUNDOWN,
    pub aGenericBindingRoutinePairs: *const GENERIC_BINDING_ROUTINE_PAIR,
    pub apfnExprEval: *const EXPR_EVAL,
    pub aXmitQuintuple: *const XMIT_ROUTINE_QUINTUPLE,
    pub pFormatTypes: *const ::std::os::raw::c_uchar,
    pub fCheckBounds: ::std::os::raw::c_int,
    pub Version: ::std::os::raw::c_ulong,
    pub pMallocFreeStruct: *mut MALLOC_FREE_STRUCT,
    pub MIDLVersion: ::std::os::raw::c_long,
    pub CommFaultOffsets: *const COMM_FAULT_OFFSETS,
    pub aUserMarshalQuadruple: *const USER_MARSHAL_ROUTINE_QUADRUPLE,
    pub NotifyRoutineTable: *const NDR_NOTIFY_ROUTINE,
    pub mFlags: ULONG_PTR,
    pub CsRoutineTables: *const NDR_CS_ROUTINES,
    pub ProxyServerInfo: *mut ::std::os::raw::c_void,
    pub pExprInfo: *const NDR_EXPR_DESC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MIDL_STUB_DESC__bindgen_ty_1 {
    pub pAutoHandle: *mut handle_t,
    pub pPrimitiveHandle: *mut handle_t,
    pub pGenericBindingInfo: PGENERIC_BINDING_INFO,
}
pub type MIDL_STUB_DESC = _MIDL_STUB_DESC;
pub type PMIDL_STUB_DESC = *const MIDL_STUB_DESC;
pub type PMIDL_XMIT_TYPE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug)]
pub struct _MIDL_FORMAT_STRING {
    pub Pad: ::std::os::raw::c_short,
    pub Format: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
pub type MIDL_FORMAT_STRING = _MIDL_FORMAT_STRING;
pub type STUB_THUNK = ::std::option::Option<unsafe extern "C" fn(arg1: PMIDL_STUB_MESSAGE)>;
pub type SERVER_ROUTINE = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_METHOD_PROPERTY {
    pub Id: ::std::os::raw::c_ulong,
    pub Value: ULONG_PTR,
}
pub type MIDL_METHOD_PROPERTY = _MIDL_METHOD_PROPERTY;
pub type PMIDL_METHOD_PROPERTY = *mut _MIDL_METHOD_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_METHOD_PROPERTY_MAP {
    pub Count: ::std::os::raw::c_ulong,
    pub Properties: *const MIDL_METHOD_PROPERTY,
}
pub type MIDL_METHOD_PROPERTY_MAP = _MIDL_METHOD_PROPERTY_MAP;
pub type PMIDL_METHOD_PROPERTY_MAP = *mut _MIDL_METHOD_PROPERTY_MAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_INTERFACE_METHOD_PROPERTIES {
    pub MethodCount: ::std::os::raw::c_ushort,
    pub MethodProperties: *const *const MIDL_METHOD_PROPERTY_MAP,
}
pub type MIDL_INTERFACE_METHOD_PROPERTIES = _MIDL_INTERFACE_METHOD_PROPERTIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_SERVER_INFO_ {
    pub pStubDesc: PMIDL_STUB_DESC,
    pub DispatchTable: *const SERVER_ROUTINE,
    pub ProcString: PFORMAT_STRING,
    pub FmtStringOffset: *const ::std::os::raw::c_ushort,
    pub ThunkTable: *const STUB_THUNK,
    pub pTransferSyntax: PRPC_SYNTAX_IDENTIFIER,
    pub nCount: ULONG_PTR,
    pub pSyntaxInfo: PMIDL_SYNTAX_INFO,
}
pub type MIDL_SERVER_INFO = _MIDL_SERVER_INFO_;
pub type PMIDL_SERVER_INFO = *mut _MIDL_SERVER_INFO_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_STUBLESS_PROXY_INFO {
    pub pStubDesc: PMIDL_STUB_DESC,
    pub ProcFormatString: PFORMAT_STRING,
    pub FormatStringOffset: *const ::std::os::raw::c_ushort,
    pub pTransferSyntax: PRPC_SYNTAX_IDENTIFIER,
    pub nCount: ULONG_PTR,
    pub pSyntaxInfo: PMIDL_SYNTAX_INFO,
}
pub type MIDL_STUBLESS_PROXY_INFO = _MIDL_STUBLESS_PROXY_INFO;
pub type PMIDL_STUBLESS_PROXY_INFO = *mut MIDL_STUBLESS_PROXY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_SYNTAX_INFO {
    pub TransferSyntax: RPC_SYNTAX_IDENTIFIER,
    pub DispatchTable: *mut RPC_DISPATCH_TABLE,
    pub ProcString: PFORMAT_STRING,
    pub FmtStringOffset: *const ::std::os::raw::c_ushort,
    pub TypeString: PFORMAT_STRING,
    pub aUserMarshalQuadruple: *const ::std::os::raw::c_void,
    pub pMethodProperties: *const MIDL_INTERFACE_METHOD_PROPERTIES,
    pub pReserved2: ULONG_PTR,
}
pub type PARAM_OFFSETTABLE = *mut ::std::os::raw::c_ushort;
pub type PPARAM_OFFSETTABLE = *mut ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLIENT_CALL_RETURN {
    pub Pointer: *mut ::std::os::raw::c_void,
    pub Simple: LONG_PTR,
}
pub type CLIENT_CALL_RETURN = _CLIENT_CALL_RETURN;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum XLAT_SIDE {
    XLAT_SERVER = 1,
    XLAT_CLIENT = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FULL_PTR_XLAT_TABLES {
    pub RefIdToPointer: *mut ::std::os::raw::c_void,
    pub PointerToRefId: *mut ::std::os::raw::c_void,
    pub NextRefId: ::std::os::raw::c_ulong,
    pub XlatSide: XLAT_SIDE,
}
pub type FULL_PTR_XLAT_TABLES = _FULL_PTR_XLAT_TABLES;
pub type PFULL_PTR_XLAT_TABLES = *mut _FULL_PTR_XLAT_TABLES;
impl _system_handle_t {
    pub const SYSTEM_HANDLE_MAX: _system_handle_t = _system_handle_t::SYSTEM_HANDLE_PIPE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _system_handle_t {
    SYSTEM_HANDLE_FILE = 0,
    SYSTEM_HANDLE_SEMAPHORE = 1,
    SYSTEM_HANDLE_EVENT = 2,
    SYSTEM_HANDLE_MUTEX = 3,
    SYSTEM_HANDLE_PROCESS = 4,
    SYSTEM_HANDLE_TOKEN = 5,
    SYSTEM_HANDLE_SECTION = 6,
    SYSTEM_HANDLE_REG_KEY = 7,
    SYSTEM_HANDLE_THREAD = 8,
    SYSTEM_HANDLE_COMPOSITION_OBJECT = 9,
    SYSTEM_HANDLE_SOCKET = 10,
    SYSTEM_HANDLE_JOB = 11,
    SYSTEM_HANDLE_PIPE = 12,
    SYSTEM_HANDLE_INVALID = 255,
}
pub use self::_system_handle_t as system_handle_t;
pub const MidlInterceptionInfoVersionOne: _bindgen_ty_1 =
    _bindgen_ty_1::MidlInterceptionInfoVersionOne;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    MidlInterceptionInfoVersionOne = 1,
}
pub const MidlWinrtTypeSerializationInfoVersionOne: _bindgen_ty_2 =
    _bindgen_ty_2::MidlWinrtTypeSerializationInfoVersionOne;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    MidlWinrtTypeSerializationInfoVersionOne = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_INTERCEPTION_INFO {
    pub Version: ::std::os::raw::c_ulong,
    pub ProcString: PFORMAT_STRING,
    pub ProcFormatOffsetTable: *const ::std::os::raw::c_ushort,
    pub ProcCount: ::std::os::raw::c_ulong,
    pub TypeString: PFORMAT_STRING,
}
pub type MIDL_INTERCEPTION_INFO = _MIDL_INTERCEPTION_INFO;
pub type PMIDL_INTERCEPTION_INFO = *mut _MIDL_INTERCEPTION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_WINRT_TYPE_SERIALIZATION_INFO {
    pub Version: ::std::os::raw::c_ulong,
    pub TypeFormatString: PFORMAT_STRING,
    pub FormatStringSize: ::std::os::raw::c_ushort,
    pub TypeOffset: ::std::os::raw::c_ushort,
    pub StubDesc: PMIDL_STUB_DESC,
}
pub type MIDL_WINRT_TYPE_SERIALIZATION_INFO = _MIDL_WINRT_TYPE_SERIALIZATION_INFO;
pub type PMIDL_WINRT_TYPE_SERIALIZATION_INFO = *mut _MIDL_WINRT_TYPE_SERIALIZATION_INFO;
extern "C" {
    pub fn NdrClientGetSupportedSyntaxes(
        pInf: *mut RPC_CLIENT_INTERFACE,
        pCount: *mut ::std::os::raw::c_ulong,
        pArr: *mut *mut MIDL_SYNTAX_INFO,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn NdrServerGetSupportedSyntaxes(
        pInf: *mut RPC_SERVER_INTERFACE,
        pCount: *mut ::std::os::raw::c_ulong,
        pArr: *mut *mut MIDL_SYNTAX_INFO,
        pPreferSyntaxIndex: *mut ::std::os::raw::c_ulong,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn NdrSimpleTypeMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        FormatChar: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn NdrPointerMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrCsArrayMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrCsTagMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrSimpleStructMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantStructMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantVaryingStructMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrComplexStructMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrFixedArrayMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantArrayMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantVaryingArrayMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrVaryingArrayMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrComplexArrayMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrNonConformantStringMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantStringMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrEncapsulatedUnionMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrNonEncapsulatedUnionMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrByteCountPointerMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrXmitOrRepAsMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrUserMarshalMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrInterfacePointerMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrClientContextMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ContextHandle: NDR_CCONTEXT,
        fCheck: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn NdrServerContextMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ContextHandle: NDR_SCONTEXT,
        RundownRoutine: NDR_RUNDOWN,
    );
}
extern "C" {
    pub fn NdrServerContextNewMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ContextHandle: NDR_SCONTEXT,
        RundownRoutine: NDR_RUNDOWN,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrSimpleTypeUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        FormatChar: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn NdrCsArrayUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrCsTagUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrRangeUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrCorrelationInitialize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_void,
        CacheSize: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn NdrCorrelationPass(pStubMsg: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrCorrelationFree(pStubMsg: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrPointerUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrSimpleStructUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantStructUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantVaryingStructUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrComplexStructUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrFixedArrayUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantArrayUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantVaryingArrayUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrVaryingArrayUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrComplexArrayUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrNonConformantStringUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrConformantStringUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrEncapsulatedUnionUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrNonEncapsulatedUnionUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrByteCountPointerUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrXmitOrRepAsUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrUserMarshalUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrInterfacePointerUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
        fMustAlloc: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrClientContextUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pContextHandle: *mut NDR_CCONTEXT,
        BindHandle: RPC_BINDING_HANDLE,
    );
}
extern "C" {
    pub fn NdrServerContextUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE) -> NDR_SCONTEXT;
}
extern "C" {
    pub fn NdrContextHandleInitialize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> NDR_SCONTEXT;
}
extern "C" {
    pub fn NdrServerContextNewUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> NDR_SCONTEXT;
}
extern "C" {
    pub fn NdrPointerBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrCsArrayBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrCsTagBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrSimpleStructBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantStructBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantVaryingStructBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrComplexStructBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrFixedArrayBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantArrayBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantVaryingArrayBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrVaryingArrayBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrComplexArrayBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantStringBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrNonConformantStringBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrEncapsulatedUnionBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrNonEncapsulatedUnionBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrByteCountPointerBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrXmitOrRepAsBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrUserMarshalBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrInterfacePointerBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrContextHandleSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrPointerMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrContextHandleMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrCsArrayMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrCsTagMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrSimpleStructMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrConformantStructMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrConformantVaryingStructMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrComplexStructMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrFixedArrayMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrConformantArrayMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrConformantVaryingArrayMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrVaryingArrayMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrComplexArrayMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrConformantStringMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrNonConformantStringMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrEncapsulatedUnionMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrNonEncapsulatedUnionMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrXmitOrRepAsMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrUserMarshalMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrInterfacePointerMemorySize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn NdrPointerFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrCsArrayFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrSimpleStructFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantStructFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantVaryingStructFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrComplexStructFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrFixedArrayFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantArrayFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConformantVaryingArrayFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrVaryingArrayFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrComplexArrayFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrEncapsulatedUnionFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrNonEncapsulatedUnionFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrByteCountPointerFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrXmitOrRepAsFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrUserMarshalFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrInterfacePointerFree(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_uchar,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrConvert2(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
        NumberParams: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn NdrConvert(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING);
}
extern "C" {
    pub fn NdrUserMarshalSimpleTypeConvert(
        pFlags: *mut ::std::os::raw::c_ulong,
        pBuffer: *mut ::std::os::raw::c_uchar,
        FormatChar: ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrClientInitializeNew(
        pRpcMsg: PRPC_MESSAGE,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
        ProcNum: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn NdrServerInitializeNew(
        pRpcMsg: PRPC_MESSAGE,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrServerInitializePartial(
        pRpcMsg: PRPC_MESSAGE,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
        RequestedBufferSize: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn NdrClientInitialize(
        pRpcMsg: PRPC_MESSAGE,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
        ProcNum: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn NdrServerInitialize(
        pRpcMsg: PRPC_MESSAGE,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrServerInitializeUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
        pRpcMsg: PRPC_MESSAGE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrServerInitializeMarshall(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrGetBuffer(
        pStubMsg: PMIDL_STUB_MESSAGE,
        BufferLength: ::std::os::raw::c_ulong,
        Handle: RPC_BINDING_HANDLE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrNsGetBuffer(
        pStubMsg: PMIDL_STUB_MESSAGE,
        BufferLength: ::std::os::raw::c_ulong,
        Handle: RPC_BINDING_HANDLE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrSendReceive(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pBufferEnd: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrNsSendReceive(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pBufferEnd: *mut ::std::os::raw::c_uchar,
        pAutoHandle: *mut RPC_BINDING_HANDLE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn NdrFreeBuffer(pStubMsg: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrGetDcomProtocolVersion(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pVersion: *mut RPC_VERSION,
    ) -> HRESULT;
}
extern "C" {
    pub fn NdrClientCall2(
        pStubDescriptor: PMIDL_STUB_DESC,
        pFormat: PFORMAT_STRING,
        ...
    ) -> CLIENT_CALL_RETURN;
}
extern "C" {
    pub fn NdrClientCall(
        pStubDescriptor: PMIDL_STUB_DESC,
        pFormat: PFORMAT_STRING,
        ...
    ) -> CLIENT_CALL_RETURN;
}
extern "C" {
    pub fn NdrAsyncClientCall(
        pStubDescriptor: PMIDL_STUB_DESC,
        pFormat: PFORMAT_STRING,
        ...
    ) -> CLIENT_CALL_RETURN;
}
extern "C" {
    pub fn NdrDcomAsyncClientCall(
        pStubDescriptor: PMIDL_STUB_DESC,
        pFormat: PFORMAT_STRING,
        ...
    ) -> CLIENT_CALL_RETURN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum STUB_PHASE {
    STUB_UNMARSHAL = 0,
    STUB_CALL_SERVER = 1,
    STUB_MARSHAL = 2,
    STUB_CALL_SERVER_NO_HRESULT = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PROXY_PHASE {
    PROXY_CALCSIZE = 0,
    PROXY_GETBUFFER = 1,
    PROXY_MARSHAL = 2,
    PROXY_SENDRECEIVE = 3,
    PROXY_UNMARSHAL = 4,
}
extern "C" {
    pub fn NdrAsyncServerCall(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn NdrAsyncStubCall(
        pThis: *mut IRpcStubBuffer,
        pChannel: *mut IRpcChannelBuffer,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn NdrDcomAsyncStubCall(
        pThis: *mut IRpcStubBuffer,
        pChannel: *mut IRpcChannelBuffer,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn NdrStubCall2(
        pThis: *mut ::std::os::raw::c_void,
        pChannel: *mut ::std::os::raw::c_void,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn NdrServerCall2(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn NdrStubCall(
        pThis: *mut ::std::os::raw::c_void,
        pChannel: *mut ::std::os::raw::c_void,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn NdrServerCall(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn NdrServerUnmarshall(
        pChannel: *mut ::std::os::raw::c_void,
        pRpcMsg: PRPC_MESSAGE,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pStubDescriptor: PMIDL_STUB_DESC,
        pFormat: PFORMAT_STRING,
        pParamList: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NdrServerMarshall(
        pThis: *mut ::std::os::raw::c_void,
        pChannel: *mut ::std::os::raw::c_void,
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn NdrMapCommAndFaultStatus(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pCommStatus: *mut ::std::os::raw::c_ulong,
        pFaultStatus: *mut ::std::os::raw::c_ulong,
        Status: RPC_STATUS,
    ) -> RPC_STATUS;
}
pub type RPC_SS_THREAD_HANDLE = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn RpcSsAllocate(Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RpcSsDisableAllocate();
}
extern "C" {
    pub fn RpcSsEnableAllocate();
}
extern "C" {
    pub fn RpcSsFree(NodeToFree: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn RpcSsGetThreadHandle() -> RPC_SS_THREAD_HANDLE;
}
extern "C" {
    pub fn RpcSsSetClientAllocFree(
        ClientAlloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        ClientFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn RpcSsSetThreadHandle(Id: RPC_SS_THREAD_HANDLE);
}
extern "C" {
    pub fn RpcSsSwapClientAllocFree(
        ClientAlloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        ClientFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        OldClientAlloc: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        OldClientFree: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    pub fn RpcSmAllocate(Size: usize, pStatus: *mut RPC_STATUS) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RpcSmClientFree(pNodeToFree: *mut ::std::os::raw::c_void) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmDestroyClientContext(ContextHandle: *mut *mut ::std::os::raw::c_void)
        -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmDisableAllocate() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmEnableAllocate() -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmFree(NodeToFree: *mut ::std::os::raw::c_void) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmGetThreadHandle(pStatus: *mut RPC_STATUS) -> RPC_SS_THREAD_HANDLE;
}
extern "C" {
    pub fn RpcSmSetClientAllocFree(
        ClientAlloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        ClientFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmSetThreadHandle(Id: RPC_SS_THREAD_HANDLE) -> RPC_STATUS;
}
extern "C" {
    pub fn RpcSmSwapClientAllocFree(
        ClientAlloc: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        ClientFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        OldClientAlloc: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        OldClientFree: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn NdrRpcSsEnableAllocate(pMessage: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrRpcSsDisableAllocate(pMessage: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrRpcSmSetClientToOsf(pMessage: PMIDL_STUB_MESSAGE);
}
extern "C" {
    pub fn NdrRpcSmClientAllocate(Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn NdrRpcSmClientFree(NodeToFree: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn NdrRpcSsDefaultAllocate(Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn NdrRpcSsDefaultFree(NodeToFree: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn NdrFullPointerXlatInit(
        NumberOfPointers: ::std::os::raw::c_ulong,
        XlatSide: XLAT_SIDE,
    ) -> PFULL_PTR_XLAT_TABLES;
}
extern "C" {
    pub fn NdrFullPointerXlatFree(pXlatTables: PFULL_PTR_XLAT_TABLES);
}
extern "C" {
    pub fn NdrAllocate(pStubMsg: PMIDL_STUB_MESSAGE, Len: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn NdrClearOutParameters(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pFormat: PFORMAT_STRING,
        ArgAddr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn NdrOleAllocate(Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn NdrOleFree(NodeToFree: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_USER_MARSHAL_INFO_LEVEL1 {
    pub Buffer: *mut ::std::os::raw::c_void,
    pub BufferSize: ::std::os::raw::c_ulong,
    pub pfnAllocate:
        ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>,
    pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub pRpcChannelBuffer: *mut IRpcChannelBuffer,
    pub Reserved: [ULONG_PTR; 5usize],
}
pub type NDR_USER_MARSHAL_INFO_LEVEL1 = _NDR_USER_MARSHAL_INFO_LEVEL1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NDR_USER_MARSHAL_INFO {
    pub InformationLevel: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: _NDR_USER_MARSHAL_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NDR_USER_MARSHAL_INFO__bindgen_ty_1 {
    pub Level1: NDR_USER_MARSHAL_INFO_LEVEL1,
}
pub type NDR_USER_MARSHAL_INFO = _NDR_USER_MARSHAL_INFO;
extern "C" {
    pub fn NdrGetUserMarshalInfo(
        pFlags: *mut ::std::os::raw::c_ulong,
        InformationLevel: ::std::os::raw::c_ulong,
        pMarshalInfo: *mut NDR_USER_MARSHAL_INFO,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn NdrCreateServerInterfaceFromStub(
        pStub: *mut IRpcStubBuffer,
        pServerIf: *mut RPC_SERVER_INTERFACE,
    ) -> RPC_STATUS;
}
extern "C" {
    pub fn NdrClientCall3(
        pProxyInfo: *mut MIDL_STUBLESS_PROXY_INFO,
        nProcNum: ::std::os::raw::c_ulong,
        pReturnValue: *mut ::std::os::raw::c_void,
        ...
    ) -> CLIENT_CALL_RETURN;
}
extern "C" {
    pub fn Ndr64AsyncClientCall(
        pProxyInfo: *mut MIDL_STUBLESS_PROXY_INFO,
        nProcNum: ::std::os::raw::c_ulong,
        pReturnValue: *mut ::std::os::raw::c_void,
        ...
    ) -> CLIENT_CALL_RETURN;
}
extern "C" {
    pub fn Ndr64DcomAsyncClientCall(
        pProxyInfo: *mut MIDL_STUBLESS_PROXY_INFO,
        nProcNum: ::std::os::raw::c_ulong,
        pReturnValue: *mut ::std::os::raw::c_void,
        ...
    ) -> CLIENT_CALL_RETURN;
}
extern "C" {
    pub fn Ndr64AsyncServerCall(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn Ndr64AsyncServerCall64(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn Ndr64AsyncServerCallAll(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn Ndr64AsyncStubCall(
        pThis: *mut IRpcStubBuffer,
        pChannel: *mut IRpcChannelBuffer,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn Ndr64DcomAsyncStubCall(
        pThis: *mut IRpcStubBuffer,
        pChannel: *mut IRpcChannelBuffer,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn NdrStubCall3(
        pThis: *mut ::std::os::raw::c_void,
        pChannel: *mut ::std::os::raw::c_void,
        pRpcMsg: PRPC_MESSAGE,
        pdwStubPhase: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn NdrServerCallAll(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn NdrServerCallNdr64(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn NdrServerCall3(pRpcMsg: PRPC_MESSAGE);
}
extern "C" {
    pub fn NdrPartialIgnoreClientMarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn NdrPartialIgnoreServerUnmarshall(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn NdrPartialIgnoreClientBufferSize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        pMemory: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn NdrPartialIgnoreServerInitialize(
        pStubMsg: PMIDL_STUB_MESSAGE,
        ppMemory: *mut *mut ::std::os::raw::c_void,
        pFormat: PFORMAT_STRING,
    );
}
extern "C" {
    pub fn RpcUserFree(AsyncHandle: handle_t, pBuffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub static mut __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type LPCOLESTR = *const OLECHAR;
pub type DOUBLE = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COAUTHIDENTITY {
    pub User: *mut USHORT,
    pub UserLength: ULONG,
    pub Domain: *mut USHORT,
    pub DomainLength: ULONG,
    pub Password: *mut USHORT,
    pub PasswordLength: ULONG,
    pub Flags: ULONG,
}
pub type COAUTHIDENTITY = _COAUTHIDENTITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COAUTHINFO {
    pub dwAuthnSvc: DWORD,
    pub dwAuthzSvc: DWORD,
    pub pwszServerPrincName: LPWSTR,
    pub dwAuthnLevel: DWORD,
    pub dwImpersonationLevel: DWORD,
    pub pAuthIdentityData: *mut COAUTHIDENTITY,
    pub dwCapabilities: DWORD,
}
pub type COAUTHINFO = _COAUTHINFO;
pub type SCODE = LONG;
pub type PSCODE = *mut SCODE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagMEMCTX {
    MEMCTX_TASK = 1,
    MEMCTX_SHARED = 2,
    MEMCTX_MACSYSTEM = 3,
    MEMCTX_UNKNOWN = -1,
    MEMCTX_SAME = -2,
}
pub use self::tagMEMCTX as MEMCTX;
impl tagCLSCTX {
    pub const CLSCTX_ACTIVATE_32_BIT_SERVER: tagCLSCTX = tagCLSCTX::CLSCTX_ACTIVATE_X86_SERVER;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCLSCTX {
    CLSCTX_INPROC_SERVER = 1,
    CLSCTX_INPROC_HANDLER = 2,
    CLSCTX_LOCAL_SERVER = 4,
    CLSCTX_INPROC_SERVER16 = 8,
    CLSCTX_REMOTE_SERVER = 16,
    CLSCTX_INPROC_HANDLER16 = 32,
    CLSCTX_RESERVED1 = 64,
    CLSCTX_RESERVED2 = 128,
    CLSCTX_RESERVED3 = 256,
    CLSCTX_RESERVED4 = 512,
    CLSCTX_NO_CODE_DOWNLOAD = 1024,
    CLSCTX_RESERVED5 = 2048,
    CLSCTX_NO_CUSTOM_MARSHAL = 4096,
    CLSCTX_ENABLE_CODE_DOWNLOAD = 8192,
    CLSCTX_NO_FAILURE_LOG = 16384,
    CLSCTX_DISABLE_AAA = 32768,
    CLSCTX_ENABLE_AAA = 65536,
    CLSCTX_FROM_DEFAULT_CONTEXT = 131072,
    CLSCTX_ACTIVATE_X86_SERVER = 262144,
    CLSCTX_ACTIVATE_64_BIT_SERVER = 524288,
    CLSCTX_ENABLE_CLOAKING = 1048576,
    CLSCTX_APPCONTAINER = 4194304,
    CLSCTX_ACTIVATE_AAA_AS_IU = 8388608,
    CLSCTX_RESERVED6 = 16777216,
    CLSCTX_ACTIVATE_ARM32_SERVER = 33554432,
    CLSCTX_ALLOW_LOWER_TRUST_REGISTRATION = 67108864,
    CLSCTX_PS_DLL = -2147483648,
}
pub use self::tagCLSCTX as CLSCTX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagMSHLFLAGS {
    MSHLFLAGS_NORMAL = 0,
    MSHLFLAGS_TABLESTRONG = 1,
    MSHLFLAGS_TABLEWEAK = 2,
    MSHLFLAGS_NOPING = 4,
    MSHLFLAGS_RESERVED1 = 8,
    MSHLFLAGS_RESERVED2 = 16,
    MSHLFLAGS_RESERVED3 = 32,
    MSHLFLAGS_RESERVED4 = 64,
}
pub use self::tagMSHLFLAGS as MSHLFLAGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagMSHCTX {
    MSHCTX_LOCAL = 0,
    MSHCTX_NOSHAREDMEM = 1,
    MSHCTX_DIFFERENTMACHINE = 2,
    MSHCTX_INPROC = 3,
    MSHCTX_CROSSCTX = 4,
    MSHCTX_CONTAINER = 5,
}
pub use self::tagMSHCTX as MSHCTX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BYTE_BLOB {
    pub clSize: ULONG,
    pub abData: [byte; 1usize],
}
pub type BYTE_BLOB = _BYTE_BLOB;
pub type UP_BYTE_BLOB = *mut BYTE_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WORD_BLOB {
    pub clSize: ULONG,
    pub asData: [::std::os::raw::c_ushort; 1usize],
}
pub type WORD_BLOB = _WORD_BLOB;
pub type UP_WORD_BLOB = *mut WORD_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DWORD_BLOB {
    pub clSize: ULONG,
    pub alData: [ULONG; 1usize],
}
pub type DWORD_BLOB = _DWORD_BLOB;
pub type UP_DWORD_BLOB = *mut DWORD_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLAGGED_BYTE_BLOB {
    pub fFlags: ULONG,
    pub clSize: ULONG,
    pub abData: [byte; 1usize],
}
pub type FLAGGED_BYTE_BLOB = _FLAGGED_BYTE_BLOB;
pub type UP_FLAGGED_BYTE_BLOB = *mut FLAGGED_BYTE_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLAGGED_WORD_BLOB {
    pub fFlags: ULONG,
    pub clSize: ULONG,
    pub asData: [::std::os::raw::c_ushort; 1usize],
}
pub type FLAGGED_WORD_BLOB = _FLAGGED_WORD_BLOB;
pub type UP_FLAGGED_WORD_BLOB = *mut FLAGGED_WORD_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BYTE_SIZEDARR {
    pub clSize: ULONG,
    pub pData: *mut byte,
}
pub type BYTE_SIZEDARR = _BYTE_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHORT_SIZEDARR {
    pub clSize: ULONG,
    pub pData: *mut ::std::os::raw::c_ushort,
}
pub type WORD_SIZEDARR = _SHORT_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONG_SIZEDARR {
    pub clSize: ULONG,
    pub pData: *mut ULONG,
}
pub type DWORD_SIZEDARR = _LONG_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HYPER_SIZEDARR {
    pub clSize: ULONG,
    pub pData: *mut ::std::os::raw::c_longlong,
}
pub type HYPER_SIZEDARR = _HYPER_SIZEDARR;
extern "C" {
    pub static mut IWinTypesBase_v0_1_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut IWinTypesBase_v0_1_s_ifspec: RPC_IF_HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBLOB {
    pub cbSize: ULONG,
    pub pBlobData: *mut BYTE,
}
pub type BLOB = tagBLOB;
pub type LPBLOB = *mut tagBLOB;
extern "C" {
    pub static mut __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemHGLOBAL {
    pub fNullHGlobal: LONG,
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemHGLOBAL = tagRemHGLOBAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemHMETAFILEPICT {
    pub mm: LONG,
    pub xExt: LONG,
    pub yExt: LONG,
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemHMETAFILEPICT = tagRemHMETAFILEPICT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemHENHMETAFILE {
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemHENHMETAFILE = tagRemHENHMETAFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemHBITMAP {
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemHBITMAP = tagRemHBITMAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemHPALETTE {
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemHPALETTE = tagRemHPALETTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemBRUSH {
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemHBRUSH = tagRemBRUSH;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagDVASPECT {
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8,
}
pub use self::tagDVASPECT as DVASPECT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSTGC {
    STGC_DEFAULT = 0,
    STGC_OVERWRITE = 1,
    STGC_ONLYIFCURRENT = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    STGC_CONSOLIDATE = 8,
}
pub use self::tagSTGC as STGC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSTGMOVE {
    STGMOVE_MOVE = 0,
    STGMOVE_COPY = 1,
    STGMOVE_SHALLOWCOPY = 2,
}
pub use self::tagSTGMOVE as STGMOVE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSTATFLAG {
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1,
    STATFLAG_NOOPEN = 2,
}
pub use self::tagSTATFLAG as STATFLAG;
pub type HCONTEXT = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userCLIPFORMAT {
    pub fContext: LONG,
    pub u: _userCLIPFORMAT___MIDL_IWinTypes_0001,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userCLIPFORMAT___MIDL_IWinTypes_0001 {
    pub dwValue: DWORD,
    pub pwszName: *mut u16,
}
pub type userCLIPFORMAT = _userCLIPFORMAT;
pub type wireCLIPFORMAT = *mut userCLIPFORMAT;
pub type CLIPFORMAT = WORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GDI_NONREMOTE {
    pub fContext: LONG,
    pub u: _GDI_NONREMOTE___MIDL_IWinTypes_0002,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDI_NONREMOTE___MIDL_IWinTypes_0002 {
    pub hInproc: LONG,
    pub hRemote: *mut DWORD_BLOB,
}
pub type GDI_NONREMOTE = _GDI_NONREMOTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userHGLOBAL {
    pub fContext: LONG,
    pub u: _userHGLOBAL___MIDL_IWinTypes_0003,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userHGLOBAL___MIDL_IWinTypes_0003 {
    pub hInproc: LONG,
    pub hRemote: *mut FLAGGED_BYTE_BLOB,
    pub hInproc64: ::std::os::raw::c_longlong,
}
pub type userHGLOBAL = _userHGLOBAL;
pub type wireHGLOBAL = *mut userHGLOBAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userHMETAFILE {
    pub fContext: LONG,
    pub u: _userHMETAFILE___MIDL_IWinTypes_0004,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userHMETAFILE___MIDL_IWinTypes_0004 {
    pub hInproc: LONG,
    pub hRemote: *mut BYTE_BLOB,
    pub hInproc64: ::std::os::raw::c_longlong,
}
pub type userHMETAFILE = _userHMETAFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _remoteMETAFILEPICT {
    pub mm: LONG,
    pub xExt: LONG,
    pub yExt: LONG,
    pub hMF: *mut userHMETAFILE,
}
pub type remoteMETAFILEPICT = _remoteMETAFILEPICT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userHMETAFILEPICT {
    pub fContext: LONG,
    pub u: _userHMETAFILEPICT___MIDL_IWinTypes_0005,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userHMETAFILEPICT___MIDL_IWinTypes_0005 {
    pub hInproc: LONG,
    pub hRemote: *mut remoteMETAFILEPICT,
    pub hInproc64: ::std::os::raw::c_longlong,
}
pub type userHMETAFILEPICT = _userHMETAFILEPICT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userHENHMETAFILE {
    pub fContext: LONG,
    pub u: _userHENHMETAFILE___MIDL_IWinTypes_0006,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userHENHMETAFILE___MIDL_IWinTypes_0006 {
    pub hInproc: LONG,
    pub hRemote: *mut BYTE_BLOB,
    pub hInproc64: ::std::os::raw::c_longlong,
}
pub type userHENHMETAFILE = _userHENHMETAFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _userBITMAP {
    pub bmType: LONG,
    pub bmWidth: LONG,
    pub bmHeight: LONG,
    pub bmWidthBytes: LONG,
    pub bmPlanes: WORD,
    pub bmBitsPixel: WORD,
    pub cbSize: ULONG,
    pub pBuffer: [byte; 1usize],
}
pub type userBITMAP = _userBITMAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userHBITMAP {
    pub fContext: LONG,
    pub u: _userHBITMAP___MIDL_IWinTypes_0007,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userHBITMAP___MIDL_IWinTypes_0007 {
    pub hInproc: LONG,
    pub hRemote: *mut userBITMAP,
    pub hInproc64: ::std::os::raw::c_longlong,
}
pub type userHBITMAP = _userHBITMAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userHPALETTE {
    pub fContext: LONG,
    pub u: _userHPALETTE___MIDL_IWinTypes_0008,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userHPALETTE___MIDL_IWinTypes_0008 {
    pub hInproc: LONG,
    pub hRemote: *mut LOGPALETTE,
    pub hInproc64: ::std::os::raw::c_longlong,
}
pub type userHPALETTE = _userHPALETTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RemotableHandle {
    pub fContext: LONG,
    pub u: _RemotableHandle___MIDL_IWinTypes_0009,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RemotableHandle___MIDL_IWinTypes_0009 {
    pub hInproc: LONG,
    pub hRemote: LONG,
}
pub type RemotableHandle = _RemotableHandle;
pub type wireHWND = *mut RemotableHandle;
pub type wireHMENU = *mut RemotableHandle;
pub type wireHACCEL = *mut RemotableHandle;
pub type wireHBRUSH = *mut RemotableHandle;
pub type wireHFONT = *mut RemotableHandle;
pub type wireHDC = *mut RemotableHandle;
pub type wireHICON = *mut RemotableHandle;
pub type wireHRGN = *mut RemotableHandle;
pub type wireHMONITOR = *mut RemotableHandle;
pub type wireHBITMAP = *mut userHBITMAP;
pub type wireHPALETTE = *mut userHPALETTE;
pub type wireHENHMETAFILE = *mut userHENHMETAFILE;
pub type wireHMETAFILE = *mut userHMETAFILE;
pub type wireHMETAFILEPICT = *mut userHMETAFILEPICT;
pub type HMETAFILEPICT = *mut ::std::os::raw::c_void;
extern "C" {
    pub static mut IWinTypes_v0_1_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut IWinTypes_v0_1_s_ifspec: RPC_IF_HANDLE;
}
pub type DATE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagCY {
    pub __bindgen_anon_1: tagCY__bindgen_ty_1,
    pub int64: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCY__bindgen_ty_1 {
    pub Lo: ULONG,
    pub Hi: LONG,
}
pub type CY = tagCY;
pub type LPCY = *mut CY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagDEC {
    pub wReserved: USHORT,
    pub __bindgen_anon_1: tagDEC__bindgen_ty_1,
    pub Hi32: ULONG,
    pub __bindgen_anon_2: tagDEC__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_1 {
    pub __bindgen_anon_1: tagDEC__bindgen_ty_1__bindgen_ty_1,
    pub signscale: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_1__bindgen_ty_1 {
    pub scale: BYTE,
    pub sign: BYTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_2 {
    pub __bindgen_anon_1: tagDEC__bindgen_ty_2__bindgen_ty_1,
    pub Lo64: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_2__bindgen_ty_1 {
    pub Lo32: ULONG,
    pub Mid32: ULONG,
}
pub type DECIMAL = tagDEC;
pub type LPDECIMAL = *mut DECIMAL;
pub type wireBSTR = *mut FLAGGED_WORD_BLOB;
pub type BSTR = *mut OLECHAR;
pub type LPBSTR = *mut BSTR;
pub type VARIANT_BOOL = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBSTRBLOB {
    pub cbSize: ULONG,
    pub pData: *mut BYTE,
}
pub type BSTRBLOB = tagBSTRBLOB;
pub type LPBSTRBLOB = *mut tagBSTRBLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCLIPDATA {
    pub cbSize: ULONG,
    pub ulClipFmt: LONG,
    pub pClipData: *mut BYTE,
}
pub type CLIPDATA = tagCLIPDATA;
pub type VARTYPE = ::std::os::raw::c_ushort;
impl VARENUM {
    pub const VT_ILLEGALMASKED: VARENUM = VARENUM::VT_BSTR_BLOB;
}
impl VARENUM {
    pub const VT_TYPEMASK: VARENUM = VARENUM::VT_BSTR_BLOB;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_INT_PTR = 37,
    VT_UINT_PTR = 38,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VERSIONED_STREAM = 73,
    VT_BSTR_BLOB = 4095,
    VT_VECTOR = 4096,
    VT_ARRAY = 8192,
    VT_BYREF = 16384,
    VT_RESERVED = 32768,
    VT_ILLEGAL = 65535,
}
pub type PROPID = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagpropertykey {
    pub fmtid: GUID,
    pub pid: DWORD,
}
pub type PROPERTYKEY = _tagpropertykey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCSPLATFORM {
    pub dwPlatformId: DWORD,
    pub dwVersionHi: DWORD,
    pub dwVersionLo: DWORD,
    pub dwProcessorArch: DWORD,
}
pub type CSPLATFORM = tagCSPLATFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagQUERYCONTEXT {
    pub dwContext: DWORD,
    pub Platform: CSPLATFORM,
    pub Locale: LCID,
    pub dwVersionHi: DWORD,
    pub dwVersionLo: DWORD,
}
pub type QUERYCONTEXT = tagQUERYCONTEXT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagTYSPEC {
    TYSPEC_CLSID = 0,
    TYSPEC_FILEEXT = 1,
    TYSPEC_MIMETYPE = 2,
    TYSPEC_FILENAME = 3,
    TYSPEC_PROGID = 4,
    TYSPEC_PACKAGENAME = 5,
    TYSPEC_OBJECTID = 6,
}
pub use self::tagTYSPEC as TYSPEC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __MIDL___MIDL_itf_wtypes_0000_0001_0001 {
    pub tyspec: DWORD,
    pub tagged_union:
        __MIDL___MIDL_itf_wtypes_0000_0001_0001___MIDL___MIDL_itf_wtypes_0000_0001_0005,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __MIDL___MIDL_itf_wtypes_0000_0001_0001___MIDL___MIDL_itf_wtypes_0000_0001_0005 { pub clsid : CLSID , pub pFileExt : LPOLESTR , pub pMimeType : LPOLESTR , pub pProgId : LPOLESTR , pub pFileName : LPOLESTR , pub ByName : __MIDL___MIDL_itf_wtypes_0000_0001_0001___MIDL___MIDL_itf_wtypes_0000_0001_0005__bindgen_ty_1 , pub ByObjectId : __MIDL___MIDL_itf_wtypes_0000_0001_0001___MIDL___MIDL_itf_wtypes_0000_0001_0005__bindgen_ty_2 , }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __MIDL___MIDL_itf_wtypes_0000_0001_0001___MIDL___MIDL_itf_wtypes_0000_0001_0005__bindgen_ty_1
{
    pub pPackageName: LPOLESTR,
    pub PolicyId: GUID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __MIDL___MIDL_itf_wtypes_0000_0001_0001___MIDL___MIDL_itf_wtypes_0000_0001_0005__bindgen_ty_2
{
    pub ObjectId: GUID,
    pub PolicyId: GUID,
}
pub type uCLSSPEC = __MIDL___MIDL_itf_wtypes_0000_0001_0001;
extern "C" {
    pub static mut __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static GUID_DEVINTERFACE_DISK: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_CDROM: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_PARTITION: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_TAPE: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_WRITEONCEDISK: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_VOLUME: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_MEDIUMCHANGER: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_FLOPPY: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_CDCHANGER: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_STORAGEPORT: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_VMLUN: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_SES: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_ZNSDISK: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_SERVICE_VOLUME: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_HIDDEN_VOLUME: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE: GUID;
}
extern "C" {
    pub static GUID_SCM_PD_HEALTH_NOTIFICATION: GUID;
}
extern "C" {
    pub static GUID_SCM_PD_PASSTHROUGH_INVDIMM: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_COMPORT: GUID;
}
extern "C" {
    pub static GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HOTPLUG_INFO {
    pub Size: DWORD,
    pub MediaRemovable: BOOLEAN,
    pub MediaHotplug: BOOLEAN,
    pub DeviceHotplug: BOOLEAN,
    pub WriteCacheEnableOverride: BOOLEAN,
}
pub type STORAGE_HOTPLUG_INFO = _STORAGE_HOTPLUG_INFO;
pub type PSTORAGE_HOTPLUG_INFO = *mut _STORAGE_HOTPLUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBER {
    pub DeviceType: DWORD,
    pub DeviceNumber: DWORD,
    pub PartitionNumber: DWORD,
}
pub type STORAGE_DEVICE_NUMBER = _STORAGE_DEVICE_NUMBER;
pub type PSTORAGE_DEVICE_NUMBER = *mut _STORAGE_DEVICE_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBERS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumberOfDevices: DWORD,
    pub Devices: [STORAGE_DEVICE_NUMBER; 1usize],
}
pub type STORAGE_DEVICE_NUMBERS = _STORAGE_DEVICE_NUMBERS;
pub type PSTORAGE_DEVICE_NUMBERS = *mut _STORAGE_DEVICE_NUMBERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBER_EX {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub DeviceType: DWORD,
    pub DeviceNumber: DWORD,
    pub DeviceGuid: GUID,
    pub PartitionNumber: DWORD,
}
pub type STORAGE_DEVICE_NUMBER_EX = _STORAGE_DEVICE_NUMBER_EX;
pub type PSTORAGE_DEVICE_NUMBER_EX = *mut _STORAGE_DEVICE_NUMBER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_BUS_RESET_REQUEST {
    pub PathId: BYTE,
}
pub type STORAGE_BUS_RESET_REQUEST = _STORAGE_BUS_RESET_REQUEST;
pub type PSTORAGE_BUS_RESET_REQUEST = *mut _STORAGE_BUS_RESET_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STORAGE_BREAK_RESERVATION_REQUEST {
    pub Length: DWORD,
    pub _unused: BYTE,
    pub PathId: BYTE,
    pub TargetId: BYTE,
    pub Lun: BYTE,
}
pub type PSTORAGE_BREAK_RESERVATION_REQUEST = *mut STORAGE_BREAK_RESERVATION_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PREVENT_MEDIA_REMOVAL {
    pub PreventMediaRemoval: BOOLEAN,
}
pub type PREVENT_MEDIA_REMOVAL = _PREVENT_MEDIA_REMOVAL;
pub type PPREVENT_MEDIA_REMOVAL = *mut _PREVENT_MEDIA_REMOVAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLASS_MEDIA_CHANGE_CONTEXT {
    pub MediaChangeCount: DWORD,
    pub NewState: DWORD,
}
pub type CLASS_MEDIA_CHANGE_CONTEXT = _CLASS_MEDIA_CHANGE_CONTEXT;
pub type PCLASS_MEDIA_CHANGE_CONTEXT = *mut _CLASS_MEDIA_CHANGE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_STATISTICS {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub RecoveredWrites: LARGE_INTEGER,
    pub UnrecoveredWrites: LARGE_INTEGER,
    pub RecoveredReads: LARGE_INTEGER,
    pub UnrecoveredReads: LARGE_INTEGER,
    pub CompressionRatioReads: BYTE,
    pub CompressionRatioWrites: BYTE,
}
pub type TAPE_STATISTICS = _TAPE_STATISTICS;
pub type PTAPE_STATISTICS = *mut _TAPE_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_GET_STATISTICS {
    pub Operation: DWORD,
}
pub type TAPE_GET_STATISTICS = _TAPE_GET_STATISTICS;
pub type PTAPE_GET_STATISTICS = *mut _TAPE_GET_STATISTICS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_MEDIA_TYPE {
    DDS_4mm = 32,
    MiniQic = 33,
    Travan = 34,
    QIC = 35,
    MP_8mm = 36,
    AME_8mm = 37,
    AIT1_8mm = 38,
    DLT = 39,
    NCTP = 40,
    IBM_3480 = 41,
    IBM_3490E = 42,
    IBM_Magstar_3590 = 43,
    IBM_Magstar_MP = 44,
    STK_DATA_D3 = 45,
    SONY_DTF = 46,
    DV_6mm = 47,
    DMI = 48,
    SONY_D2 = 49,
    CLEANER_CARTRIDGE = 50,
    CD_ROM = 51,
    CD_R = 52,
    CD_RW = 53,
    DVD_ROM = 54,
    DVD_R = 55,
    DVD_RW = 56,
    MO_3_RW = 57,
    MO_5_WO = 58,
    MO_5_RW = 59,
    MO_5_LIMDOW = 60,
    PC_5_WO = 61,
    PC_5_RW = 62,
    PD_5_RW = 63,
    ABL_5_WO = 64,
    PINNACLE_APEX_5_RW = 65,
    SONY_12_WO = 66,
    PHILIPS_12_WO = 67,
    HITACHI_12_WO = 68,
    CYGNET_12_WO = 69,
    KODAK_14_WO = 70,
    MO_NFR_525 = 71,
    NIKON_12_RW = 72,
    IOMEGA_ZIP = 73,
    IOMEGA_JAZ = 74,
    SYQUEST_EZ135 = 75,
    SYQUEST_EZFLYER = 76,
    SYQUEST_SYJET = 77,
    AVATAR_F2 = 78,
    MP2_8mm = 79,
    DST_S = 80,
    DST_M = 81,
    DST_L = 82,
    VXATape_1 = 83,
    VXATape_2 = 84,
    STK_9840 = 85,
    LTO_Ultrium = 86,
    LTO_Accelis = 87,
    DVD_RAM = 88,
    AIT_8mm = 89,
    ADR_1 = 90,
    ADR_2 = 91,
    STK_9940 = 92,
    SAIT = 93,
    VXATape = 94,
}
pub use self::_STORAGE_MEDIA_TYPE as STORAGE_MEDIA_TYPE;
pub type PSTORAGE_MEDIA_TYPE = *mut _STORAGE_MEDIA_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0,
    BusTypeScsi = 1,
    BusTypeAtapi = 2,
    BusTypeAta = 3,
    BusType1394 = 4,
    BusTypeSsa = 5,
    BusTypeFibre = 6,
    BusTypeUsb = 7,
    BusTypeRAID = 8,
    BusTypeiScsi = 9,
    BusTypeSas = 10,
    BusTypeSata = 11,
    BusTypeSd = 12,
    BusTypeMmc = 13,
    BusTypeVirtual = 14,
    BusTypeFileBackedVirtual = 15,
    BusTypeSpaces = 16,
    BusTypeNvme = 17,
    BusTypeSCM = 18,
    BusTypeUfs = 19,
    BusTypeMax = 20,
    BusTypeMaxReserved = 127,
}
pub use self::_STORAGE_BUS_TYPE as STORAGE_BUS_TYPE;
pub type PSTORAGE_BUS_TYPE = *mut _STORAGE_BUS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_MEDIA_INFO {
    pub DeviceSpecific: _DEVICE_MEDIA_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_MEDIA_INFO__bindgen_ty_1 {
    pub DiskInfo: _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_1,
    pub RemovableDiskInfo: _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_2,
    pub TapeInfo: _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub Cylinders: LARGE_INTEGER,
    pub MediaType: STORAGE_MEDIA_TYPE,
    pub TracksPerCylinder: DWORD,
    pub SectorsPerTrack: DWORD,
    pub BytesPerSector: DWORD,
    pub NumberMediaSides: DWORD,
    pub MediaCharacteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_2 {
    pub Cylinders: LARGE_INTEGER,
    pub MediaType: STORAGE_MEDIA_TYPE,
    pub TracksPerCylinder: DWORD,
    pub SectorsPerTrack: DWORD,
    pub BytesPerSector: DWORD,
    pub NumberMediaSides: DWORD,
    pub MediaCharacteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_3 {
    pub MediaType: STORAGE_MEDIA_TYPE,
    pub MediaCharacteristics: DWORD,
    pub CurrentBlockSize: DWORD,
    pub BusType: STORAGE_BUS_TYPE,
    pub BusSpecificData: _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub ScsiInformation: _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_MEDIA_INFO__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub MediumType: BYTE,
    pub DensityCode: BYTE,
}
pub type DEVICE_MEDIA_INFO = _DEVICE_MEDIA_INFO;
pub type PDEVICE_MEDIA_INFO = *mut _DEVICE_MEDIA_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GET_MEDIA_TYPES {
    pub DeviceType: DWORD,
    pub MediaInfoCount: DWORD,
    pub MediaInfo: [DEVICE_MEDIA_INFO; 1usize],
}
pub type GET_MEDIA_TYPES = _GET_MEDIA_TYPES;
pub type PGET_MEDIA_TYPES = *mut _GET_MEDIA_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PREDICT_FAILURE {
    pub PredictFailure: DWORD,
    pub VendorSpecific: [BYTE; 512usize],
}
pub type STORAGE_PREDICT_FAILURE = _STORAGE_PREDICT_FAILURE;
pub type PSTORAGE_PREDICT_FAILURE = *mut _STORAGE_PREDICT_FAILURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_FAILURE_PREDICTION_CONFIG {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Set: BOOLEAN,
    pub Enabled: BOOLEAN,
    pub Reserved: WORD,
}
pub type STORAGE_FAILURE_PREDICTION_CONFIG = _STORAGE_FAILURE_PREDICTION_CONFIG;
pub type PSTORAGE_FAILURE_PREDICTION_CONFIG = *mut _STORAGE_FAILURE_PREDICTION_CONFIG;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_QUERY_TYPE {
    PropertyStandardQuery = 0,
    PropertyExistsQuery = 1,
    PropertyMaskQuery = 2,
    PropertyQueryMaxDefined = 3,
}
pub use self::_STORAGE_QUERY_TYPE as STORAGE_QUERY_TYPE;
pub type PSTORAGE_QUERY_TYPE = *mut _STORAGE_QUERY_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_SET_TYPE {
    PropertyStandardSet = 0,
    PropertyExistsSet = 1,
    PropertySetMaxDefined = 2,
}
pub use self::_STORAGE_SET_TYPE as STORAGE_SET_TYPE;
pub type PSTORAGE_SET_TYPE = *mut _STORAGE_SET_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_PROPERTY_ID {
    StorageDeviceProperty = 0,
    StorageAdapterProperty = 1,
    StorageDeviceIdProperty = 2,
    StorageDeviceUniqueIdProperty = 3,
    StorageDeviceWriteCacheProperty = 4,
    StorageMiniportProperty = 5,
    StorageAccessAlignmentProperty = 6,
    StorageDeviceSeekPenaltyProperty = 7,
    StorageDeviceTrimProperty = 8,
    StorageDeviceWriteAggregationProperty = 9,
    StorageDeviceDeviceTelemetryProperty = 10,
    StorageDeviceLBProvisioningProperty = 11,
    StorageDevicePowerProperty = 12,
    StorageDeviceCopyOffloadProperty = 13,
    StorageDeviceResiliencyProperty = 14,
    StorageDeviceMediumProductType = 15,
    StorageAdapterRpmbProperty = 16,
    StorageAdapterCryptoProperty = 17,
    StorageDeviceIoCapabilityProperty = 48,
    StorageAdapterProtocolSpecificProperty = 49,
    StorageDeviceProtocolSpecificProperty = 50,
    StorageAdapterTemperatureProperty = 51,
    StorageDeviceTemperatureProperty = 52,
    StorageAdapterPhysicalTopologyProperty = 53,
    StorageDevicePhysicalTopologyProperty = 54,
    StorageDeviceAttributesProperty = 55,
    StorageDeviceManagementStatus = 56,
    StorageAdapterSerialNumberProperty = 57,
    StorageDeviceLocationProperty = 58,
    StorageDeviceNumaProperty = 59,
    StorageDeviceZonedDeviceProperty = 60,
    StorageDeviceUnsafeShutdownCount = 61,
    StorageDeviceEnduranceProperty = 62,
    StorageDeviceLedStateProperty = 63,
    StorageDeviceSelfEncryptionProperty = 64,
    StorageFruIdProperty = 65,
}
pub use self::_STORAGE_PROPERTY_ID as STORAGE_PROPERTY_ID;
pub type PSTORAGE_PROPERTY_ID = *mut _STORAGE_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROPERTY_QUERY {
    pub PropertyId: STORAGE_PROPERTY_ID,
    pub QueryType: STORAGE_QUERY_TYPE,
    pub AdditionalParameters: [BYTE; 1usize],
}
pub type STORAGE_PROPERTY_QUERY = _STORAGE_PROPERTY_QUERY;
pub type PSTORAGE_PROPERTY_QUERY = *mut _STORAGE_PROPERTY_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROPERTY_SET {
    pub PropertyId: STORAGE_PROPERTY_ID,
    pub SetType: STORAGE_SET_TYPE,
    pub AdditionalParameters: [BYTE; 1usize],
}
pub type STORAGE_PROPERTY_SET = _STORAGE_PROPERTY_SET;
pub type PSTORAGE_PROPERTY_SET = *mut _STORAGE_PROPERTY_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DESCRIPTOR_HEADER {
    pub Version: DWORD,
    pub Size: DWORD,
}
pub type STORAGE_DESCRIPTOR_HEADER = _STORAGE_DESCRIPTOR_HEADER;
pub type PSTORAGE_DESCRIPTOR_HEADER = *mut _STORAGE_DESCRIPTOR_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceType: BYTE,
    pub DeviceTypeModifier: BYTE,
    pub RemovableMedia: BOOLEAN,
    pub CommandQueueing: BOOLEAN,
    pub VendorIdOffset: DWORD,
    pub ProductIdOffset: DWORD,
    pub ProductRevisionOffset: DWORD,
    pub SerialNumberOffset: DWORD,
    pub BusType: STORAGE_BUS_TYPE,
    pub RawPropertiesLength: DWORD,
    pub RawDeviceProperties: [BYTE; 1usize],
}
pub type STORAGE_DEVICE_DESCRIPTOR = _STORAGE_DEVICE_DESCRIPTOR;
pub type PSTORAGE_DEVICE_DESCRIPTOR = *mut _STORAGE_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ADAPTER_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub MaximumTransferLength: DWORD,
    pub MaximumPhysicalPages: DWORD,
    pub AlignmentMask: DWORD,
    pub AdapterUsesPio: BOOLEAN,
    pub AdapterScansDown: BOOLEAN,
    pub CommandQueueing: BOOLEAN,
    pub AcceleratedTransfer: BOOLEAN,
    pub BusType: BYTE,
    pub BusMajorVersion: WORD,
    pub BusMinorVersion: WORD,
    pub SrbType: BYTE,
    pub AddressType: BYTE,
}
pub type STORAGE_ADAPTER_DESCRIPTOR = _STORAGE_ADAPTER_DESCRIPTOR;
pub type PSTORAGE_ADAPTER_DESCRIPTOR = *mut _STORAGE_ADAPTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub BytesPerCacheLine: DWORD,
    pub BytesOffsetForCacheAlignment: DWORD,
    pub BytesPerLogicalSector: DWORD,
    pub BytesPerPhysicalSector: DWORD,
    pub BytesOffsetForSectorAlignment: DWORD,
}
pub type STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
pub type PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = *mut _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub MediumProductType: DWORD,
}
pub type STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
pub type PSTORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = *mut _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_PORT_CODE_SET {
    StoragePortCodeSetReserved = 0,
    StoragePortCodeSetStorport = 1,
    StoragePortCodeSetSCSIport = 2,
    StoragePortCodeSetSpaceport = 3,
    StoragePortCodeSetATAport = 4,
    StoragePortCodeSetUSBport = 5,
    StoragePortCodeSetSBP2port = 6,
    StoragePortCodeSetSDport = 7,
}
pub use self::_STORAGE_PORT_CODE_SET as STORAGE_PORT_CODE_SET;
pub type PSTORAGE_PORT_CODE_SET = *mut _STORAGE_PORT_CODE_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_MINIPORT_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Portdriver: STORAGE_PORT_CODE_SET,
    pub LUNResetSupported: BOOLEAN,
    pub TargetResetSupported: BOOLEAN,
    pub IoTimeoutValue: WORD,
    pub ExtraIoInfoSupported: BOOLEAN,
    pub Flags: _STORAGE_MINIPORT_DESCRIPTOR__bindgen_ty_1,
    pub Reserved0: [BYTE; 2usize],
    pub Reserved1: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_MINIPORT_DESCRIPTOR__bindgen_ty_1 {
    pub __bindgen_anon_1: _STORAGE_MINIPORT_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub AsBYTE: BYTE,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_MINIPORT_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _STORAGE_MINIPORT_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LogicalPoFxForDisk(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LogicalPoFxForDisk(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LogicalPoFxForDisk: BYTE,
        Reserved: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LogicalPoFxForDisk: u8 = unsafe { ::std::mem::transmute(LogicalPoFxForDisk) };
            LogicalPoFxForDisk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_MINIPORT_DESCRIPTOR = _STORAGE_MINIPORT_DESCRIPTOR;
pub type PSTORAGE_MINIPORT_DESCRIPTOR = *mut _STORAGE_MINIPORT_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_IDENTIFIER_CODE_SET {
    StorageIdCodeSetReserved = 0,
    StorageIdCodeSetBinary = 1,
    StorageIdCodeSetAscii = 2,
    StorageIdCodeSetUtf8 = 3,
}
pub use self::_STORAGE_IDENTIFIER_CODE_SET as STORAGE_IDENTIFIER_CODE_SET;
pub type PSTORAGE_IDENTIFIER_CODE_SET = *mut _STORAGE_IDENTIFIER_CODE_SET;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_IDENTIFIER_TYPE {
    StorageIdTypeVendorSpecific = 0,
    StorageIdTypeVendorId = 1,
    StorageIdTypeEUI64 = 2,
    StorageIdTypeFCPHName = 3,
    StorageIdTypePortRelative = 4,
    StorageIdTypeTargetPortGroup = 5,
    StorageIdTypeLogicalUnitGroup = 6,
    StorageIdTypeMD5LogicalUnitIdentifier = 7,
    StorageIdTypeScsiNameString = 8,
}
pub use self::_STORAGE_IDENTIFIER_TYPE as STORAGE_IDENTIFIER_TYPE;
pub type PSTORAGE_IDENTIFIER_TYPE = *mut _STORAGE_IDENTIFIER_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ID_NAA_FORMAT {
    StorageIdNAAFormatIEEEExtended = 2,
    StorageIdNAAFormatIEEERegistered = 3,
    StorageIdNAAFormatIEEEERegisteredExtended = 5,
}
pub use self::_STORAGE_ID_NAA_FORMAT as STORAGE_ID_NAA_FORMAT;
pub type PSTORAGE_ID_NAA_FORMAT = *mut _STORAGE_ID_NAA_FORMAT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ASSOCIATION_TYPE {
    StorageIdAssocDevice = 0,
    StorageIdAssocPort = 1,
    StorageIdAssocTarget = 2,
}
pub use self::_STORAGE_ASSOCIATION_TYPE as STORAGE_ASSOCIATION_TYPE;
pub type PSTORAGE_ASSOCIATION_TYPE = *mut _STORAGE_ASSOCIATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDENTIFIER {
    pub CodeSet: STORAGE_IDENTIFIER_CODE_SET,
    pub Type: STORAGE_IDENTIFIER_TYPE,
    pub IdentifierSize: WORD,
    pub NextOffset: WORD,
    pub Association: STORAGE_ASSOCIATION_TYPE,
    pub Identifier: [BYTE; 1usize],
}
pub type STORAGE_IDENTIFIER = _STORAGE_IDENTIFIER;
pub type PSTORAGE_IDENTIFIER = *mut _STORAGE_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_ID_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumberOfIdentifiers: DWORD,
    pub Identifiers: [BYTE; 1usize],
}
pub type STORAGE_DEVICE_ID_DESCRIPTOR = _STORAGE_DEVICE_ID_DESCRIPTOR;
pub type PSTORAGE_DEVICE_ID_DESCRIPTOR = *mut _STORAGE_DEVICE_ID_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_SEEK_PENALTY_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub IncursSeekPenalty: BOOLEAN,
}
pub type DEVICE_SEEK_PENALTY_DESCRIPTOR = _DEVICE_SEEK_PENALTY_DESCRIPTOR;
pub type PDEVICE_SEEK_PENALTY_DESCRIPTOR = *mut _DEVICE_SEEK_PENALTY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_WRITE_AGGREGATION_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub BenefitsFromWriteAggregation: BOOLEAN,
}
pub type DEVICE_WRITE_AGGREGATION_DESCRIPTOR = _DEVICE_WRITE_AGGREGATION_DESCRIPTOR;
pub type PDEVICE_WRITE_AGGREGATION_DESCRIPTOR = *mut _DEVICE_WRITE_AGGREGATION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_TRIM_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub TrimEnabled: BOOLEAN,
}
pub type DEVICE_TRIM_DESCRIPTOR = _DEVICE_TRIM_DESCRIPTOR;
pub type PDEVICE_TRIM_DESCRIPTOR = *mut _DEVICE_TRIM_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LB_PROVISIONING_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Reserved1: [BYTE; 7usize],
    pub OptimalUnmapGranularity: DWORDLONG,
    pub UnmapGranularityAlignment: DWORDLONG,
    pub MaxUnmapLbaCount: DWORD,
    pub MaxUnmapBlockDescriptorCount: DWORD,
}
impl _DEVICE_LB_PROVISIONING_DESCRIPTOR {
    #[inline]
    pub fn ThinProvisioningEnabled(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThinProvisioningEnabled(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThinProvisioningReadZeros(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThinProvisioningReadZeros(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AnchorSupported(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_AnchorSupported(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn UnmapGranularityAlignmentValid(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UnmapGranularityAlignmentValid(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GetFreeSpaceSupported(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GetFreeSpaceSupported(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MapSupported(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MapSupported(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ThinProvisioningEnabled: BYTE,
        ThinProvisioningReadZeros: BYTE,
        AnchorSupported: BYTE,
        UnmapGranularityAlignmentValid: BYTE,
        GetFreeSpaceSupported: BYTE,
        MapSupported: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ThinProvisioningEnabled: u8 =
                unsafe { ::std::mem::transmute(ThinProvisioningEnabled) };
            ThinProvisioningEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ThinProvisioningReadZeros: u8 =
                unsafe { ::std::mem::transmute(ThinProvisioningReadZeros) };
            ThinProvisioningReadZeros as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let AnchorSupported: u8 = unsafe { ::std::mem::transmute(AnchorSupported) };
            AnchorSupported as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let UnmapGranularityAlignmentValid: u8 =
                unsafe { ::std::mem::transmute(UnmapGranularityAlignmentValid) };
            UnmapGranularityAlignmentValid as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let GetFreeSpaceSupported: u8 = unsafe { ::std::mem::transmute(GetFreeSpaceSupported) };
            GetFreeSpaceSupported as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MapSupported: u8 = unsafe { ::std::mem::transmute(MapSupported) };
            MapSupported as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_LB_PROVISIONING_DESCRIPTOR = _DEVICE_LB_PROVISIONING_DESCRIPTOR;
pub type PDEVICE_LB_PROVISIONING_DESCRIPTOR = *mut _DEVICE_LB_PROVISIONING_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    pub Size: DWORD,
    pub Version: DWORD,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Reserved1: [BYTE; 3usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Reserved3: [BYTE; 3usize],
    pub AvailableMappingResources: DWORDLONG,
    pub UsedMappingResources: DWORDLONG,
}
impl _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    #[inline]
    pub fn AvailableMappingResourcesValid(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AvailableMappingResourcesValid(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UsedMappingResourcesValid(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UsedMappingResourcesValid(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AvailableMappingResourcesValid: BYTE,
        UsedMappingResourcesValid: BYTE,
        Reserved0: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AvailableMappingResourcesValid: u8 =
                unsafe { ::std::mem::transmute(AvailableMappingResourcesValid) };
            AvailableMappingResourcesValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UsedMappingResourcesValid: u8 =
                unsafe { ::std::mem::transmute(UsedMappingResourcesValid) };
            UsedMappingResourcesValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn AvailableMappingResourcesScope(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_AvailableMappingResourcesScope(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn UsedMappingResourcesScope(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_UsedMappingResourcesScope(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        AvailableMappingResourcesScope: BYTE,
        UsedMappingResourcesScope: BYTE,
        Reserved2: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let AvailableMappingResourcesScope: u8 =
                unsafe { ::std::mem::transmute(AvailableMappingResourcesScope) };
            AvailableMappingResourcesScope as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let UsedMappingResourcesScope: u8 =
                unsafe { ::std::mem::transmute(UsedMappingResourcesScope) };
            UsedMappingResourcesScope as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved2: u8 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_LB_PROVISIONING_MAP_RESOURCES = _STORAGE_LB_PROVISIONING_MAP_RESOURCES;
pub type PSTORAGE_LB_PROVISIONING_MAP_RESOURCES = *mut _STORAGE_LB_PROVISIONING_MAP_RESOURCES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_POWER_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceAttentionSupported: BOOLEAN,
    pub AsynchronousNotificationSupported: BOOLEAN,
    pub IdlePowerManagementEnabled: BOOLEAN,
    pub D3ColdEnabled: BOOLEAN,
    pub D3ColdSupported: BOOLEAN,
    pub NoVerifyDuringIdlePower: BOOLEAN,
    pub Reserved: [BYTE; 2usize],
    pub IdleTimeoutInMS: DWORD,
}
pub type DEVICE_POWER_DESCRIPTOR = _DEVICE_POWER_DESCRIPTOR;
pub type PDEVICE_POWER_DESCRIPTOR = *mut _DEVICE_POWER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_COPY_OFFLOAD_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub MaximumTokenLifetime: DWORD,
    pub DefaultTokenLifetime: DWORD,
    pub MaximumTransferSize: DWORDLONG,
    pub OptimalTransferCount: DWORDLONG,
    pub MaximumDataDescriptors: DWORD,
    pub MaximumTransferLengthPerDescriptor: DWORD,
    pub OptimalTransferLengthPerDescriptor: DWORD,
    pub OptimalTransferLengthGranularity: WORD,
    pub Reserved: [BYTE; 2usize],
}
pub type DEVICE_COPY_OFFLOAD_DESCRIPTOR = _DEVICE_COPY_OFFLOAD_DESCRIPTOR;
pub type PDEVICE_COPY_OFFLOAD_DESCRIPTOR = *mut _DEVICE_COPY_OFFLOAD_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NameOffset: DWORD,
    pub NumberOfLogicalCopies: DWORD,
    pub NumberOfPhysicalCopies: DWORD,
    pub PhysicalDiskRedundancy: DWORD,
    pub NumberOfColumns: DWORD,
    pub Interleave: DWORD,
}
pub type STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
pub type PSTORAGE_DEVICE_RESILIENCY_DESCRIPTOR = *mut _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_RPMB_FRAME_TYPE {
    StorageRpmbFrameTypeUnknown = 0,
    StorageRpmbFrameTypeStandard = 1,
    StorageRpmbFrameTypeMax = 2,
}
pub use self::_STORAGE_RPMB_FRAME_TYPE as STORAGE_RPMB_FRAME_TYPE;
pub type PSTORAGE_RPMB_FRAME_TYPE = *mut _STORAGE_RPMB_FRAME_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_RPMB_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SizeInBytes: DWORD,
    pub MaxReliableWriteSizeInBytes: DWORD,
    pub FrameFormat: STORAGE_RPMB_FRAME_TYPE,
}
pub type STORAGE_RPMB_DESCRIPTOR = _STORAGE_RPMB_DESCRIPTOR;
pub type PSTORAGE_RPMB_DESCRIPTOR = *mut _STORAGE_RPMB_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_CRYPTO_ALGORITHM_ID {
    StorageCryptoAlgorithmUnknown = 0,
    StorageCryptoAlgorithmXTSAES = 1,
    StorageCryptoAlgorithmBitlockerAESCBC = 2,
    StorageCryptoAlgorithmAESECB = 3,
    StorageCryptoAlgorithmESSIVAESCBC = 4,
    StorageCryptoAlgorithmMax = 5,
}
pub use self::_STORAGE_CRYPTO_ALGORITHM_ID as STORAGE_CRYPTO_ALGORITHM_ID;
pub type PSTORAGE_CRYPTO_ALGORITHM_ID = *mut _STORAGE_CRYPTO_ALGORITHM_ID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_CRYPTO_KEY_SIZE {
    StorageCryptoKeySizeUnknown = 0,
    StorageCryptoKeySize128Bits = 1,
    StorageCryptoKeySize192Bits = 2,
    StorageCryptoKeySize256Bits = 3,
    StorageCryptoKeySize512Bits = 4,
}
pub use self::_STORAGE_CRYPTO_KEY_SIZE as STORAGE_CRYPTO_KEY_SIZE;
pub type PSTORAGE_CRYPTO_KEY_SIZE = *mut _STORAGE_CRYPTO_KEY_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_CRYPTO_CAPABILITY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub CryptoCapabilityIndex: DWORD,
    pub AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
    pub KeySize: STORAGE_CRYPTO_KEY_SIZE,
    pub DataUnitSizeBitmask: DWORD,
}
pub type STORAGE_CRYPTO_CAPABILITY = _STORAGE_CRYPTO_CAPABILITY;
pub type PSTORAGE_CRYPTO_CAPABILITY = *mut _STORAGE_CRYPTO_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_CRYPTO_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumKeysSupported: DWORD,
    pub NumCryptoCapabilities: DWORD,
    pub CryptoCapabilities: [STORAGE_CRYPTO_CAPABILITY; 1usize],
}
pub type STORAGE_CRYPTO_DESCRIPTOR = _STORAGE_CRYPTO_DESCRIPTOR;
pub type PSTORAGE_CRYPTO_DESCRIPTOR = *mut _STORAGE_CRYPTO_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_TIER_MEDIA_TYPE {
    StorageTierMediaTypeUnspecified = 0,
    StorageTierMediaTypeDisk = 1,
    StorageTierMediaTypeSsd = 2,
    StorageTierMediaTypeScm = 4,
    StorageTierMediaTypeMax = 5,
}
pub use self::_STORAGE_TIER_MEDIA_TYPE as STORAGE_TIER_MEDIA_TYPE;
pub type PSTORAGE_TIER_MEDIA_TYPE = *mut _STORAGE_TIER_MEDIA_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_TIER_CLASS {
    StorageTierClassUnspecified = 0,
    StorageTierClassCapacity = 1,
    StorageTierClassPerformance = 2,
    StorageTierClassMax = 3,
}
pub use self::_STORAGE_TIER_CLASS as STORAGE_TIER_CLASS;
pub type PSTORAGE_TIER_CLASS = *mut _STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TIER {
    pub Id: GUID,
    pub Name: [WCHAR; 256usize],
    pub Description: [WCHAR; 256usize],
    pub Flags: DWORDLONG,
    pub ProvisionedCapacity: DWORDLONG,
    pub MediaType: STORAGE_TIER_MEDIA_TYPE,
    pub Class: STORAGE_TIER_CLASS,
}
pub type STORAGE_TIER = _STORAGE_TIER;
pub type PSTORAGE_TIER = *mut _STORAGE_TIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_TIERING_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TotalNumberOfTiers: DWORD,
    pub NumberOfTiersReturned: DWORD,
    pub Tiers: [STORAGE_TIER; 1usize],
}
pub type STORAGE_DEVICE_TIERING_DESCRIPTOR = _STORAGE_DEVICE_TIERING_DESCRIPTOR;
pub type PSTORAGE_DEVICE_TIERING_DESCRIPTOR = *mut _STORAGE_DEVICE_TIERING_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumberOfFaultDomains: DWORD,
    pub FaultDomainIds: [GUID; 1usize],
}
pub type STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
pub type PSTORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = *mut _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_PROTOCOL_TYPE {
    ProtocolTypeUnknown = 0,
    ProtocolTypeScsi = 1,
    ProtocolTypeAta = 2,
    ProtocolTypeNvme = 3,
    ProtocolTypeSd = 4,
    ProtocolTypeUfs = 5,
    ProtocolTypeProprietary = 126,
    ProtocolTypeMaxReserved = 127,
}
pub use self::_STORAGE_PROTOCOL_TYPE as STORAGE_PROTOCOL_TYPE;
pub type PSTORAGE_PROTOCOL_TYPE = *mut _STORAGE_PROTOCOL_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_PROTOCOL_NVME_DATA_TYPE {
    NVMeDataTypeUnknown = 0,
    NVMeDataTypeIdentify = 1,
    NVMeDataTypeLogPage = 2,
    NVMeDataTypeFeature = 3,
}
pub use self::_STORAGE_PROTOCOL_NVME_DATA_TYPE as STORAGE_PROTOCOL_NVME_DATA_TYPE;
pub type PSTORAGE_PROTOCOL_NVME_DATA_TYPE = *mut _STORAGE_PROTOCOL_NVME_DATA_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_PROTOCOL_ATA_DATA_TYPE {
    AtaDataTypeUnknown = 0,
    AtaDataTypeIdentify = 1,
    AtaDataTypeLogPage = 2,
}
pub use self::_STORAGE_PROTOCOL_ATA_DATA_TYPE as STORAGE_PROTOCOL_ATA_DATA_TYPE;
pub type PSTORAGE_PROTOCOL_ATA_DATA_TYPE = *mut _STORAGE_PROTOCOL_ATA_DATA_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_PROTOCOL_UFS_DATA_TYPE {
    UfsDataTypeUnknown = 0,
    UfsDataTypeQueryDescriptor = 1,
    UfsDataTypeQueryAttribute = 2,
    UfsDataTypeQueryFlag = 3,
    UfsDataTypeQueryDmeAttribute = 4,
    UfsDataTypeQueryDmePeerAttribute = 5,
    UfsDataTypeMax = 6,
}
pub use self::_STORAGE_PROTOCOL_UFS_DATA_TYPE as STORAGE_PROTOCOL_UFS_DATA_TYPE;
pub type PSTORAGE_PROTOCOL_UFS_DATA_TYPE = *mut _STORAGE_PROTOCOL_UFS_DATA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE {
    pub __bindgen_anon_1: _STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE__bindgen_ty_1,
    pub AsUlong: DWORD,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE__bindgen_ty_1 {
    #[inline]
    pub fn RetainAsynEvent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RetainAsynEvent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LogSpecificField(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LogSpecificField(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RetainAsynEvent: DWORD,
        LogSpecificField: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RetainAsynEvent: u32 = unsafe { ::std::mem::transmute(RetainAsynEvent) };
            RetainAsynEvent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let LogSpecificField: u32 = unsafe { ::std::mem::transmute(LogSpecificField) };
            LogSpecificField as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE = _STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE;
pub type PSTORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE =
    *mut _STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_SPECIFIC_DATA {
    pub ProtocolType: STORAGE_PROTOCOL_TYPE,
    pub DataType: DWORD,
    pub ProtocolDataRequestValue: DWORD,
    pub ProtocolDataRequestSubValue: DWORD,
    pub ProtocolDataOffset: DWORD,
    pub ProtocolDataLength: DWORD,
    pub FixedProtocolReturnData: DWORD,
    pub ProtocolDataRequestSubValue2: DWORD,
    pub ProtocolDataRequestSubValue3: DWORD,
    pub ProtocolDataRequestSubValue4: DWORD,
}
pub type STORAGE_PROTOCOL_SPECIFIC_DATA = _STORAGE_PROTOCOL_SPECIFIC_DATA;
pub type PSTORAGE_PROTOCOL_SPECIFIC_DATA = *mut _STORAGE_PROTOCOL_SPECIFIC_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
    pub ProtocolType: STORAGE_PROTOCOL_TYPE,
    pub DataType: DWORD,
    pub ProtocolDataValue: DWORD,
    pub ProtocolDataSubValue: DWORD,
    pub ProtocolDataOffset: DWORD,
    pub ProtocolDataLength: DWORD,
    pub FixedProtocolReturnData: DWORD,
    pub ProtocolDataSubValue2: DWORD,
    pub ProtocolDataSubValue3: DWORD,
    pub ProtocolDataSubValue4: DWORD,
    pub ProtocolDataSubValue5: DWORD,
    pub Reserved: [DWORD; 5usize],
}
pub type STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
pub type PSTORAGE_PROTOCOL_SPECIFIC_DATA_EXT = *mut _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA,
}
pub type STORAGE_PROTOCOL_DATA_DESCRIPTOR = _STORAGE_PROTOCOL_DATA_DESCRIPTOR;
pub type PSTORAGE_PROTOCOL_DATA_DESCRIPTOR = *mut _STORAGE_PROTOCOL_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
}
pub type STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
pub type PSTORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = *mut _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_INFO {
    pub Index: WORD,
    pub Temperature: SHORT,
    pub OverThreshold: SHORT,
    pub UnderThreshold: SHORT,
    pub OverThresholdChangable: BOOLEAN,
    pub UnderThresholdChangable: BOOLEAN,
    pub EventGenerated: BOOLEAN,
    pub Reserved0: BYTE,
    pub Reserved1: DWORD,
}
pub type STORAGE_TEMPERATURE_INFO = _STORAGE_TEMPERATURE_INFO;
pub type PSTORAGE_TEMPERATURE_INFO = *mut _STORAGE_TEMPERATURE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_DATA_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub CriticalTemperature: SHORT,
    pub WarningTemperature: SHORT,
    pub InfoCount: WORD,
    pub Reserved0: [BYTE; 2usize],
    pub Reserved1: [DWORD; 2usize],
    pub TemperatureInfo: [STORAGE_TEMPERATURE_INFO; 1usize],
}
pub type STORAGE_TEMPERATURE_DATA_DESCRIPTOR = _STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
pub type PSTORAGE_TEMPERATURE_DATA_DESCRIPTOR = *mut _STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_THRESHOLD {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: WORD,
    pub Index: WORD,
    pub Threshold: SHORT,
    pub OverThreshold: BOOLEAN,
    pub Reserved: BYTE,
}
pub type STORAGE_TEMPERATURE_THRESHOLD = _STORAGE_TEMPERATURE_THRESHOLD;
pub type PSTORAGE_TEMPERATURE_THRESHOLD = *mut _STORAGE_TEMPERATURE_THRESHOLD;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_DEVICE_FORM_FACTOR {
    FormFactorUnknown = 0,
    FormFactor3_5 = 1,
    FormFactor2_5 = 2,
    FormFactor1_8 = 3,
    FormFactor1_8Less = 4,
    FormFactorEmbedded = 5,
    FormFactorMemoryCard = 6,
    FormFactormSata = 7,
    FormFactorM_2 = 8,
    FormFactorPCIeBoard = 9,
    FormFactorDimm = 10,
}
pub use self::_STORAGE_DEVICE_FORM_FACTOR as STORAGE_DEVICE_FORM_FACTOR;
pub type PSTORAGE_DEVICE_FORM_FACTOR = *mut _STORAGE_DEVICE_FORM_FACTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_COMPONENT_HEALTH_STATUS {
    HealthStatusUnknown = 0,
    HealthStatusNormal = 1,
    HealthStatusThrottled = 2,
    HealthStatusWarning = 3,
    HealthStatusDisabled = 4,
    HealthStatusFailed = 5,
}
pub use self::_STORAGE_COMPONENT_HEALTH_STATUS as STORAGE_COMPONENT_HEALTH_STATUS;
pub type PSTORAGE_COMPONENT_HEALTH_STATUS = *mut _STORAGE_COMPONENT_HEALTH_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_SPEC_VERSION {
    pub __bindgen_anon_1: _STORAGE_SPEC_VERSION__bindgen_ty_1,
    pub AsUlong: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_SPEC_VERSION__bindgen_ty_1 {
    pub MinorVersion: _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1,
    pub MajorVersion: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub AsUshort: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub SubMinor: BYTE,
    pub Minor: BYTE,
}
pub type STORAGE_SPEC_VERSION = _STORAGE_SPEC_VERSION;
pub type PSTORAGE_SPEC_VERSION = *mut _STORAGE_SPEC_VERSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PHYSICAL_DEVICE_DATA {
    pub DeviceId: DWORD,
    pub Role: DWORD,
    pub HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    pub CommandProtocol: STORAGE_PROTOCOL_TYPE,
    pub SpecVersion: STORAGE_SPEC_VERSION,
    pub FormFactor: STORAGE_DEVICE_FORM_FACTOR,
    pub Vendor: [BYTE; 8usize],
    pub Model: [BYTE; 40usize],
    pub FirmwareRevision: [BYTE; 16usize],
    pub Capacity: DWORDLONG,
    pub PhysicalLocation: [BYTE; 32usize],
    pub Reserved: [DWORD; 2usize],
}
pub type STORAGE_PHYSICAL_DEVICE_DATA = _STORAGE_PHYSICAL_DEVICE_DATA;
pub type PSTORAGE_PHYSICAL_DEVICE_DATA = *mut _STORAGE_PHYSICAL_DEVICE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PHYSICAL_ADAPTER_DATA {
    pub AdapterId: DWORD,
    pub HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    pub CommandProtocol: STORAGE_PROTOCOL_TYPE,
    pub SpecVersion: STORAGE_SPEC_VERSION,
    pub Vendor: [BYTE; 8usize],
    pub Model: [BYTE; 40usize],
    pub FirmwareRevision: [BYTE; 16usize],
    pub PhysicalLocation: [BYTE; 32usize],
    pub ExpanderConnected: BOOLEAN,
    pub Reserved0: [BYTE; 3usize],
    pub Reserved1: [DWORD; 3usize],
}
pub type STORAGE_PHYSICAL_ADAPTER_DATA = _STORAGE_PHYSICAL_ADAPTER_DATA;
pub type PSTORAGE_PHYSICAL_ADAPTER_DATA = *mut _STORAGE_PHYSICAL_ADAPTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PHYSICAL_NODE_DATA {
    pub NodeId: DWORD,
    pub AdapterCount: DWORD,
    pub AdapterDataLength: DWORD,
    pub AdapterDataOffset: DWORD,
    pub DeviceCount: DWORD,
    pub DeviceDataLength: DWORD,
    pub DeviceDataOffset: DWORD,
    pub Reserved: [DWORD; 3usize],
}
pub type STORAGE_PHYSICAL_NODE_DATA = _STORAGE_PHYSICAL_NODE_DATA;
pub type PSTORAGE_PHYSICAL_NODE_DATA = *mut _STORAGE_PHYSICAL_NODE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NodeCount: DWORD,
    pub Reserved: DWORD,
    pub Node: [STORAGE_PHYSICAL_NODE_DATA; 1usize],
}
pub type STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
pub type PSTORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = *mut _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub LunMaxIoCount: DWORD,
    pub AdapterMaxIoCount: DWORD,
}
pub type STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
pub type PSTORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = *mut _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Attributes: DWORD64,
}
pub type STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
pub type PSTORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = *mut _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_DISK_HEALTH_STATUS {
    DiskHealthUnknown = 0,
    DiskHealthUnhealthy = 1,
    DiskHealthWarning = 2,
    DiskHealthHealthy = 3,
    DiskHealthMax = 4,
}
pub use self::_STORAGE_DISK_HEALTH_STATUS as STORAGE_DISK_HEALTH_STATUS;
pub type PSTORAGE_DISK_HEALTH_STATUS = *mut _STORAGE_DISK_HEALTH_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_DISK_OPERATIONAL_STATUS {
    DiskOpStatusNone = 0,
    DiskOpStatusUnknown = 1,
    DiskOpStatusOk = 2,
    DiskOpStatusPredictingFailure = 3,
    DiskOpStatusInService = 4,
    DiskOpStatusHardwareError = 5,
    DiskOpStatusNotUsable = 6,
    DiskOpStatusTransientError = 7,
    DiskOpStatusMissing = 8,
}
pub use self::_STORAGE_DISK_OPERATIONAL_STATUS as STORAGE_DISK_OPERATIONAL_STATUS;
pub type PSTORAGE_DISK_OPERATIONAL_STATUS = *mut _STORAGE_DISK_OPERATIONAL_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_OPERATIONAL_STATUS_REASON {
    DiskOpReasonUnknown = 0,
    DiskOpReasonScsiSenseCode = 1,
    DiskOpReasonMedia = 2,
    DiskOpReasonIo = 3,
    DiskOpReasonThresholdExceeded = 4,
    DiskOpReasonLostData = 5,
    DiskOpReasonEnergySource = 6,
    DiskOpReasonConfiguration = 7,
    DiskOpReasonDeviceController = 8,
    DiskOpReasonMediaController = 9,
    DiskOpReasonComponent = 10,
    DiskOpReasonNVDIMM_N = 11,
    DiskOpReasonBackgroundOperation = 12,
    DiskOpReasonInvalidFirmware = 13,
    DiskOpReasonHealthCheck = 14,
    DiskOpReasonLostDataPersistence = 15,
    DiskOpReasonDisabledByPlatform = 16,
    DiskOpReasonLostWritePersistence = 17,
    DiskOpReasonDataPersistenceLossImminent = 18,
    DiskOpReasonWritePersistenceLossImminent = 19,
    DiskOpReasonMax = 20,
}
pub use self::_STORAGE_OPERATIONAL_STATUS_REASON as STORAGE_OPERATIONAL_STATUS_REASON;
pub type PSTORAGE_OPERATIONAL_STATUS_REASON = *mut _STORAGE_OPERATIONAL_STATUS_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Reason: STORAGE_OPERATIONAL_STATUS_REASON,
    pub RawBytes: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_OPERATIONAL_REASON__bindgen_ty_1 {
    pub ScsiSenseKey: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1,
    pub NVDIMM_N: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2,
    pub AsUlong: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1 {
    pub SenseKey: BYTE,
    pub ASC: BYTE,
    pub ASCQ: BYTE,
    pub Reserved: BYTE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2 {
    pub CriticalHealth: BYTE,
    pub ModuleHealth: [BYTE; 2usize],
    pub ErrorThresholdStatus: BYTE,
}
pub type STORAGE_OPERATIONAL_REASON = _STORAGE_OPERATIONAL_REASON;
pub type PSTORAGE_OPERATIONAL_REASON = *mut _STORAGE_OPERATIONAL_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_MANAGEMENT_STATUS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Health: STORAGE_DISK_HEALTH_STATUS,
    pub NumberOfOperationalStatus: DWORD,
    pub NumberOfAdditionalReasons: DWORD,
    pub OperationalStatus: [STORAGE_DISK_OPERATIONAL_STATUS; 16usize],
    pub AdditionalReasons: [STORAGE_OPERATIONAL_REASON; 1usize],
}
pub type STORAGE_DEVICE_MANAGEMENT_STATUS = _STORAGE_DEVICE_MANAGEMENT_STATUS;
pub type PSTORAGE_DEVICE_MANAGEMENT_STATUS = *mut _STORAGE_DEVICE_MANAGEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ADAPTER_SERIAL_NUMBER {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SerialNumber: [WCHAR; 128usize],
}
pub type STORAGE_ADAPTER_SERIAL_NUMBER = _STORAGE_ADAPTER_SERIAL_NUMBER;
pub type PSTORAGE_ADAPTER_SERIAL_NUMBER = *mut _STORAGE_ADAPTER_SERIAL_NUMBER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ZONED_DEVICE_TYPES {
    ZonedDeviceTypeUnknown = 0,
    ZonedDeviceTypeHostManaged = 1,
    ZonedDeviceTypeHostAware = 2,
    ZonedDeviceTypeDeviceManaged = 3,
}
pub use self::_STORAGE_ZONED_DEVICE_TYPES as STORAGE_ZONED_DEVICE_TYPES;
pub type PSTORAGE_ZONED_DEVICE_TYPES = *mut _STORAGE_ZONED_DEVICE_TYPES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ZONE_TYPES {
    ZoneTypeUnknown = 0,
    ZoneTypeConventional = 1,
    ZoneTypeSequentialWriteRequired = 2,
    ZoneTypeSequentialWritePreferred = 3,
    ZoneTypeMax = 4,
}
pub use self::_STORAGE_ZONE_TYPES as STORAGE_ZONE_TYPES;
pub type PSTORAGE_ZONE_TYPES = *mut _STORAGE_ZONE_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONE_GROUP {
    pub ZoneCount: DWORD,
    pub ZoneType: STORAGE_ZONE_TYPES,
    pub ZoneSize: DWORDLONG,
}
pub type STORAGE_ZONE_GROUP = _STORAGE_ZONE_GROUP;
pub type PSTORAGE_ZONE_GROUP = *mut _STORAGE_ZONE_GROUP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceType: STORAGE_ZONED_DEVICE_TYPES,
    pub ZoneCount: DWORD,
    pub ZoneAttributes: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1,
    pub ZoneGroupCount: DWORD,
    pub ZoneGroup: [STORAGE_ZONE_GROUP; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1 {
    pub SequentialRequiredZone: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub SequentialPreferredZone: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub MaxOpenZoneCount: DWORD,
    pub UnrestrictedRead: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub OptimalOpenZoneCount: DWORD,
    pub Reserved: DWORD,
}
pub type STORAGE_ZONED_DEVICE_DESCRIPTOR = _STORAGE_ZONED_DEVICE_DESCRIPTOR;
pub type PSTORAGE_ZONED_DEVICE_DESCRIPTOR = *mut _STORAGE_ZONED_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_LOCATION {
    pub Socket: DWORD,
    pub Slot: DWORD,
    pub Adapter: DWORD,
    pub Port: DWORD,
    pub __bindgen_anon_1: _DEVICE_LOCATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_LOCATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub Channel: DWORD,
    pub Device: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub Target: DWORD,
    pub Lun: DWORD,
}
pub type DEVICE_LOCATION = _DEVICE_LOCATION;
pub type PDEVICE_LOCATION = *mut _DEVICE_LOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_LOCATION_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Location: DEVICE_LOCATION,
    pub StringOffset: DWORD,
}
pub type STORAGE_DEVICE_LOCATION_DESCRIPTOR = _STORAGE_DEVICE_LOCATION_DESCRIPTOR;
pub type PSTORAGE_DEVICE_LOCATION_DESCRIPTOR = *mut _STORAGE_DEVICE_LOCATION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMA_PROPERTY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumaNode: DWORD,
}
pub type STORAGE_DEVICE_NUMA_PROPERTY = _STORAGE_DEVICE_NUMA_PROPERTY;
pub type PSTORAGE_DEVICE_NUMA_PROPERTY = *mut _STORAGE_DEVICE_NUMA_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub UnsafeShutdownCount: DWORD,
}
pub type STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
pub type PSTORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = *mut _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_INFO {
    pub ValidFields: DWORD,
    pub GroupId: DWORD,
    pub Flags: _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1,
    pub LifePercentage: DWORD,
    pub BytesReadCount: [BYTE; 16usize],
    pub ByteWriteCount: [BYTE; 16usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1 {
    #[inline]
    pub fn Shared(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Shared(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Shared: DWORD, Reserved: DWORD) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Shared: u32 = unsafe { ::std::mem::transmute(Shared) };
            Shared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_HW_ENDURANCE_INFO = _STORAGE_HW_ENDURANCE_INFO;
pub type PSTORAGE_HW_ENDURANCE_INFO = *mut _STORAGE_HW_ENDURANCE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
}
pub type STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
pub type PSTORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = *mut _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_LED_STATE_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub State: DWORDLONG,
}
pub type STORAGE_DEVICE_LED_STATE_DESCRIPTOR = _STORAGE_DEVICE_LED_STATE_DESCRIPTOR;
pub type PSTORAGE_DEVICE_LED_STATE_DESCRIPTOR = *mut _STORAGE_DEVICE_LED_STATE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SupportsSelfEncryption: BOOLEAN,
}
pub type STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY = _STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY;
pub type PSTORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY = *mut _STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ENCRYPTION_TYPE {
    StorageEncryptionTypeUnknown = 0,
    StorageEncryptionTypeEDrive = 1,
    StorageEncryptionTypeTcgOpal = 2,
}
pub use self::_STORAGE_ENCRYPTION_TYPE as STORAGE_ENCRYPTION_TYPE;
pub type PSTORAGE_ENCRYPTION_TYPE = *mut _STORAGE_ENCRYPTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY_V2 {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SupportsSelfEncryption: BOOLEAN,
    pub EncryptionType: STORAGE_ENCRYPTION_TYPE,
}
pub type STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY_V2 = _STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY_V2;
pub type PSTORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY_V2 =
    *mut _STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_FRU_ID_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub IdentifierSize: DWORD,
    pub Identifier: [BYTE; 1usize],
}
pub type STORAGE_FRU_ID_DESCRIPTOR = _STORAGE_FRU_ID_DESCRIPTOR;
pub type PSTORAGE_FRU_ID_DESCRIPTOR = *mut _STORAGE_FRU_ID_DESCRIPTOR;
pub type DEVICE_DATA_MANAGEMENT_SET_ACTION = DWORD;
pub type DEVICE_DSM_ACTION = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_RANGE {
    pub StartingOffset: LONGLONG,
    pub LengthInBytes: DWORDLONG,
}
pub type DEVICE_DATA_SET_RANGE = _DEVICE_DATA_SET_RANGE;
pub type PDEVICE_DATA_SET_RANGE = *mut _DEVICE_DATA_SET_RANGE;
pub type DEVICE_DSM_RANGE = _DEVICE_DATA_SET_RANGE;
pub type PDEVICE_DSM_RANGE = *mut _DEVICE_DATA_SET_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    pub Size: DWORD,
    pub Action: DEVICE_DSM_ACTION,
    pub Flags: DWORD,
    pub ParameterBlockOffset: DWORD,
    pub ParameterBlockLength: DWORD,
    pub DataSetRangesOffset: DWORD,
    pub DataSetRangesLength: DWORD,
}
pub type DEVICE_MANAGE_DATA_SET_ATTRIBUTES = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub type PDEVICE_MANAGE_DATA_SET_ATTRIBUTES = *mut _DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub type DEVICE_DSM_INPUT = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub type PDEVICE_DSM_INPUT = *mut _DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    pub Size: DWORD,
    pub Action: DEVICE_DSM_ACTION,
    pub Flags: DWORD,
    pub OperationStatus: DWORD,
    pub ExtendedError: DWORD,
    pub TargetDetailedError: DWORD,
    pub ReservedStatus: DWORD,
    pub OutputBlockOffset: DWORD,
    pub OutputBlockLength: DWORD,
}
pub type DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub type PDEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = *mut _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub type DEVICE_DSM_OUTPUT = _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub type PDEVICE_DSM_OUTPUT = *mut _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_DEFINITION {
    pub Action: DEVICE_DSM_ACTION,
    pub SingleRange: BOOLEAN,
    pub ParameterBlockAlignment: DWORD,
    pub ParameterBlockLength: DWORD,
    pub HasOutput: BOOLEAN,
    pub OutputBlockAlignment: DWORD,
    pub OutputBlockLength: DWORD,
}
pub type DEVICE_DSM_DEFINITION = _DEVICE_DSM_DEFINITION;
pub type PDEVICE_DSM_DEFINITION = *mut _DEVICE_DSM_DEFINITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_NOTIFICATION_PARAMETERS {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub NumFileTypeIDs: DWORD,
    pub FileTypeID: [GUID; 1usize],
}
pub type DEVICE_DSM_NOTIFICATION_PARAMETERS = _DEVICE_DSM_NOTIFICATION_PARAMETERS;
pub type PDEVICE_DSM_NOTIFICATION_PARAMETERS = *mut _DEVICE_DSM_NOTIFICATION_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_TOKEN {
    pub TokenType: [BYTE; 4usize],
    pub Reserved: [BYTE; 2usize],
    pub TokenIdLength: [BYTE; 2usize],
    pub __bindgen_anon_1: _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1 {
    pub StorageOffloadZeroDataToken: _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1,
    pub Token: [BYTE; 504usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved2: [BYTE; 504usize],
}
pub type STORAGE_OFFLOAD_TOKEN = _STORAGE_OFFLOAD_TOKEN;
pub type PSTORAGE_OFFLOAD_TOKEN = *mut _STORAGE_OFFLOAD_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    pub Flags: DWORD,
    pub TimeToLive: DWORD,
    pub Reserved: [DWORD; 2usize],
}
pub type DEVICE_DSM_OFFLOAD_READ_PARAMETERS = _DEVICE_DSM_OFFLOAD_READ_PARAMETERS;
pub type PDEVICE_DSM_OFFLOAD_READ_PARAMETERS = *mut _DEVICE_DSM_OFFLOAD_READ_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_READ_OUTPUT {
    pub OffloadReadFlags: DWORD,
    pub Reserved: DWORD,
    pub LengthProtected: DWORDLONG,
    pub TokenLength: DWORD,
    pub Token: STORAGE_OFFLOAD_TOKEN,
}
pub type STORAGE_OFFLOAD_READ_OUTPUT = _STORAGE_OFFLOAD_READ_OUTPUT;
pub type PSTORAGE_OFFLOAD_READ_OUTPUT = *mut _STORAGE_OFFLOAD_READ_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {
    pub Flags: DWORD,
    pub Reserved: DWORD,
    pub TokenOffset: DWORDLONG,
    pub Token: STORAGE_OFFLOAD_TOKEN,
}
pub type DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;
pub type PDEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = *mut _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OFFLOAD_WRITE_OUTPUT {
    pub OffloadWriteFlags: DWORD,
    pub Reserved: DWORD,
    pub LengthCopied: DWORDLONG,
}
pub type STORAGE_OFFLOAD_WRITE_OUTPUT = _STORAGE_OFFLOAD_WRITE_OUTPUT;
pub type PSTORAGE_OFFLOAD_WRITE_OUTPUT = *mut _STORAGE_OFFLOAD_WRITE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub OutputVersion: DWORD,
}
pub type DEVICE_DATA_SET_LBP_STATE_PARAMETERS = _DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub type PDEVICE_DATA_SET_LBP_STATE_PARAMETERS = *mut _DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub type DEVICE_DSM_ALLOCATION_PARAMETERS = _DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub type PDEVICE_DSM_ALLOCATION_PARAMETERS = *mut _DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    pub Size: DWORD,
    pub Version: DWORD,
    pub SlabSizeInBytes: DWORDLONG,
    pub SlabOffsetDeltaInBytes: DWORD,
    pub SlabAllocationBitMapBitCount: DWORD,
    pub SlabAllocationBitMapLength: DWORD,
    pub SlabAllocationBitMap: [DWORD; 1usize],
}
pub type DEVICE_DATA_SET_LB_PROVISIONING_STATE = _DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub type PDEVICE_DATA_SET_LB_PROVISIONING_STATE = *mut _DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub type DEVICE_DSM_ALLOCATION_OUTPUT = _DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub type PDEVICE_DSM_ALLOCATION_OUTPUT = *mut _DEVICE_DATA_SET_LB_PROVISIONING_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {
    pub Size: DWORD,
    pub Version: DWORD,
    pub SlabSizeInBytes: DWORDLONG,
    pub SlabOffsetDeltaInBytes: DWORDLONG,
    pub SlabAllocationBitMapBitCount: DWORD,
    pub SlabAllocationBitMapLength: DWORD,
    pub SlabAllocationBitMap: [DWORD; 1usize],
}
pub type DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub type PDEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = *mut _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub type DEVICE_DSM_ALLOCATION_OUTPUT2 = _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub type PDEVICE_DSM_ALLOCATION_OUTPUT2 = *mut _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_REPAIR_PARAMETERS {
    pub NumberOfRepairCopies: DWORD,
    pub SourceCopy: DWORD,
    pub RepairCopies: [DWORD; 1usize],
}
pub type DEVICE_DATA_SET_REPAIR_PARAMETERS = _DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub type PDEVICE_DATA_SET_REPAIR_PARAMETERS = *mut _DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub type DEVICE_DSM_REPAIR_PARAMETERS = _DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub type PDEVICE_DSM_REPAIR_PARAMETERS = *mut _DEVICE_DATA_SET_REPAIR_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_REPAIR_OUTPUT {
    pub ParityExtent: DEVICE_DSM_RANGE,
}
pub type DEVICE_DATA_SET_REPAIR_OUTPUT = _DEVICE_DATA_SET_REPAIR_OUTPUT;
pub type PDEVICE_DATA_SET_REPAIR_OUTPUT = *mut _DEVICE_DATA_SET_REPAIR_OUTPUT;
pub type DEVICE_DSM_REPAIR_OUTPUT = _DEVICE_DATA_SET_REPAIR_OUTPUT;
pub type PDEVICE_DSM_REPAIR_OUTPUT = *mut _DEVICE_DATA_SET_REPAIR_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_SCRUB_OUTPUT {
    pub BytesProcessed: DWORDLONG,
    pub BytesRepaired: DWORDLONG,
    pub BytesFailed: DWORDLONG,
}
pub type DEVICE_DATA_SET_SCRUB_OUTPUT = _DEVICE_DATA_SET_SCRUB_OUTPUT;
pub type PDEVICE_DATA_SET_SCRUB_OUTPUT = *mut _DEVICE_DATA_SET_SCRUB_OUTPUT;
pub type DEVICE_DSM_SCRUB_OUTPUT = _DEVICE_DATA_SET_SCRUB_OUTPUT;
pub type PDEVICE_DSM_SCRUB_OUTPUT = *mut _DEVICE_DATA_SET_SCRUB_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    pub BytesProcessed: DWORDLONG,
    pub BytesRepaired: DWORDLONG,
    pub BytesFailed: DWORDLONG,
    pub ParityExtent: DEVICE_DSM_RANGE,
    pub BytesScrubbed: DWORDLONG,
}
pub type DEVICE_DATA_SET_SCRUB_EX_OUTPUT = _DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub type PDEVICE_DATA_SET_SCRUB_EX_OUTPUT = *mut _DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub type DEVICE_DSM_SCRUB_OUTPUT2 = _DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub type PDEVICE_DSM_SCRUB_OUTPUT2 = *mut _DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_TIERING_QUERY_INPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub NumberOfTierIds: DWORD,
    pub TierIds: [GUID; 1usize],
}
pub type DEVICE_DSM_TIERING_QUERY_INPUT = _DEVICE_DSM_TIERING_QUERY_INPUT;
pub type PDEVICE_DSM_TIERING_QUERY_INPUT = *mut _DEVICE_DSM_TIERING_QUERY_INPUT;
pub type DEVICE_DSM_TIERING_QUERY_PARAMETERS = _DEVICE_DSM_TIERING_QUERY_INPUT;
pub type PDEVICE_DSM_TIERING_QUERY_PARAMETERS = *mut _DEVICE_DSM_TIERING_QUERY_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TIER_REGION {
    pub TierId: GUID,
    pub Offset: DWORDLONG,
    pub Length: DWORDLONG,
}
pub type STORAGE_TIER_REGION = _STORAGE_TIER_REGION;
pub type PSTORAGE_TIER_REGION = *mut _STORAGE_TIER_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_TIERING_QUERY_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Reserved: DWORD,
    pub Alignment: DWORDLONG,
    pub TotalNumberOfRegions: DWORD,
    pub NumberOfRegionsReturned: DWORD,
    pub Regions: [STORAGE_TIER_REGION; 1usize],
}
pub type DEVICE_DSM_TIERING_QUERY_OUTPUT = _DEVICE_DSM_TIERING_QUERY_OUTPUT;
pub type PDEVICE_DSM_TIERING_QUERY_OUTPUT = *mut _DEVICE_DSM_TIERING_QUERY_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    pub Size: DWORD,
    pub TargetPriority: BYTE,
    pub Reserved: [BYTE; 3usize],
}
pub type DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS =
    _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;
pub type PDEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS =
    *mut _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    pub TopologyRangeBytes: DWORDLONG,
    pub TopologyId: [BYTE; 16usize],
}
pub type DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub type PDEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = *mut _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub type DEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub type PDEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = *mut _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_STORAGE_ADDRESS_RANGE {
    pub StartAddress: LONGLONG,
    pub LengthInBytes: DWORDLONG,
}
pub type DEVICE_STORAGE_ADDRESS_RANGE = _DEVICE_STORAGE_ADDRESS_RANGE;
pub type PDEVICE_STORAGE_ADDRESS_RANGE = *mut _DEVICE_STORAGE_ADDRESS_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub TotalNumberOfRanges: DWORD,
    pub NumberOfRangesReturned: DWORD,
    pub Ranges: [DEVICE_STORAGE_ADDRESS_RANGE; 1usize],
}
pub type DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;
pub type PDEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = *mut _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_REPORT_ZONES_PARAMETERS {
    pub Size: DWORD,
    pub ReportOption: BYTE,
    pub Partial: BYTE,
    pub Reserved: [BYTE; 2usize],
}
pub type DEVICE_DSM_REPORT_ZONES_PARAMETERS = _DEVICE_DSM_REPORT_ZONES_PARAMETERS;
pub type PDEVICE_DSM_REPORT_ZONES_PARAMETERS = *mut _DEVICE_DSM_REPORT_ZONES_PARAMETERS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ZONES_ATTRIBUTES {
    ZonesAttributeTypeAndLengthMayDifferent = 0,
    ZonesAttributeTypeSameLengthSame = 1,
    ZonesAttributeTypeSameLastZoneLengthDifferent = 2,
    ZonesAttributeTypeMayDifferentLengthSame = 3,
}
pub use self::_STORAGE_ZONES_ATTRIBUTES as STORAGE_ZONES_ATTRIBUTES;
pub type PSTORAGE_ZONES_ATTRIBUTES = *mut _STORAGE_ZONES_ATTRIBUTES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ZONE_CONDITION {
    ZoneConditionConventional = 0,
    ZoneConditionEmpty = 1,
    ZoneConditionImplicitlyOpened = 2,
    ZoneConditionExplicitlyOpened = 3,
    ZoneConditionClosed = 4,
    ZoneConditionReadOnly = 13,
    ZoneConditionFull = 14,
    ZoneConditionOffline = 15,
}
pub use self::_STORAGE_ZONE_CONDITION as STORAGE_ZONE_CONDITION;
pub type PSTORAGE_ZONE_CONDITION = *mut _STORAGE_ZONE_CONDITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONE_DESCRIPTOR {
    pub Size: DWORD,
    pub ZoneType: STORAGE_ZONE_TYPES,
    pub ZoneCondition: STORAGE_ZONE_CONDITION,
    pub ResetWritePointerRecommend: BOOLEAN,
    pub Reserved0: [BYTE; 3usize],
    pub ZoneSize: DWORDLONG,
    pub WritePointerOffset: DWORDLONG,
}
pub type STORAGE_ZONE_DESCRIPTOR = _STORAGE_ZONE_DESCRIPTOR;
pub type PSTORAGE_ZONE_DESCRIPTOR = *mut _STORAGE_ZONE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_REPORT_ZONES_DATA {
    pub Size: DWORD,
    pub ZoneCount: DWORD,
    pub Attributes: STORAGE_ZONES_ATTRIBUTES,
    pub Reserved0: DWORD,
    pub ZoneDescriptors: [STORAGE_ZONE_DESCRIPTOR; 1usize],
}
pub type DEVICE_DSM_REPORT_ZONES_DATA = _DEVICE_DSM_REPORT_ZONES_DATA;
pub type PDEVICE_DSM_REPORT_ZONES_DATA = *mut _DEVICE_DSM_REPORT_ZONES_DATA;
pub type DEVICE_DSM_REPORT_ZONES_OUTPUT = _DEVICE_DSM_REPORT_ZONES_DATA;
pub type PDEVICE_DSM_REPORT_ZONES_OUTPUT = *mut _DEVICE_DSM_REPORT_ZONES_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_STORAGE_RANGE_ATTRIBUTES {
    pub LengthInBytes: DWORDLONG,
    pub __bindgen_anon_1: _DEVICE_STORAGE_RANGE_ATTRIBUTES__bindgen_ty_1,
    pub Reserved: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_STORAGE_RANGE_ATTRIBUTES__bindgen_ty_1 {
    pub AllFlags: DWORD,
    pub __bindgen_anon_1: _DEVICE_STORAGE_RANGE_ATTRIBUTES__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_STORAGE_RANGE_ATTRIBUTES__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _DEVICE_STORAGE_RANGE_ATTRIBUTES__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IsRangeBad(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsRangeBad(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(IsRangeBad: DWORD) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsRangeBad: u32 = unsafe { ::std::mem::transmute(IsRangeBad) };
            IsRangeBad as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type DEVICE_STORAGE_RANGE_ATTRIBUTES = _DEVICE_STORAGE_RANGE_ATTRIBUTES;
pub type PDEVICE_STORAGE_RANGE_ATTRIBUTES = *mut _DEVICE_STORAGE_RANGE_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_DSM_RANGE_ERROR_INFO {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub TotalNumberOfRanges: DWORD,
    pub NumberOfRangesReturned: DWORD,
    pub Ranges: [DEVICE_STORAGE_RANGE_ATTRIBUTES; 1usize],
}
pub type DEVICE_DSM_RANGE_ERROR_INFO = _DEVICE_DSM_RANGE_ERROR_INFO;
pub type PDEVICE_DSM_RANGE_ERROR_INFO = *mut _DEVICE_DSM_RANGE_ERROR_INFO;
pub type DEVICE_DSM_RANGE_ERROR_OUTPUT = _DEVICE_DSM_RANGE_ERROR_INFO;
pub type PDEVICE_DSM_RANGE_ERROR_OUTPUT = *mut _DEVICE_DSM_RANGE_ERROR_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_LOST_QUERY_PARAMETERS {
    pub Version: DWORD,
    pub Granularity: DWORDLONG,
}
pub type DEVICE_DSM_LOST_QUERY_PARAMETERS = _DEVICE_DSM_LOST_QUERY_PARAMETERS;
pub type PDEVICE_DSM_LOST_QUERY_PARAMETERS = *mut _DEVICE_DSM_LOST_QUERY_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_LOST_QUERY_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Alignment: DWORDLONG,
    pub NumberOfBits: DWORD,
    pub BitMap: [DWORD; 1usize],
}
pub type DEVICE_DSM_LOST_QUERY_OUTPUT = _DEVICE_DSM_LOST_QUERY_OUTPUT;
pub type PDEVICE_DSM_LOST_QUERY_OUTPUT = *mut _DEVICE_DSM_LOST_QUERY_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_FREE_SPACE_OUTPUT {
    pub Version: DWORD,
    pub FreeSpace: DWORDLONG,
}
pub type DEVICE_DSM_FREE_SPACE_OUTPUT = _DEVICE_DSM_FREE_SPACE_OUTPUT;
pub type PDEVICE_DSM_FREE_SPACE_OUTPUT = *mut _DEVICE_DSM_FREE_SPACE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_DSM_CONVERSION_OUTPUT {
    pub Version: DWORD,
    pub Source: GUID,
}
pub type DEVICE_DSM_CONVERSION_OUTPUT = _DEVICE_DSM_CONVERSION_OUTPUT;
pub type PDEVICE_DSM_CONVERSION_OUTPUT = *mut _DEVICE_DSM_CONVERSION_OUTPUT;
extern "C" {
    pub fn DeviceDsmParameterBlock(Input: PDEVICE_DSM_INPUT) -> PVOID;
}
extern "C" {
    pub fn DeviceDsmDataSetRanges(Input: PDEVICE_DSM_INPUT) -> PDEVICE_DSM_RANGE;
}
extern "C" {
    pub fn DeviceDsmNumberOfDataSetRanges(Input: PDEVICE_DSM_INPUT) -> DWORD;
}
extern "C" {
    pub fn DeviceDsmGetInputLength(
        Definition: PDEVICE_DSM_DEFINITION,
        ParameterBlockLength: DWORD,
        NumberOfDataSetRanges: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn DeviceDsmGetNumberOfDataSetRanges(
        Definition: PDEVICE_DSM_DEFINITION,
        InputLength: DWORD,
        ParameterBlockLength: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn DeviceDsmInitializeInput(
        Definition: PDEVICE_DSM_DEFINITION,
        Input: PDEVICE_DSM_INPUT,
        InputLength: DWORD,
        Flags: DWORD,
        Parameters: PVOID,
        ParameterBlockLength: DWORD,
    );
}
extern "C" {
    pub fn DeviceDsmAddDataSetRange(
        Input: PDEVICE_DSM_INPUT,
        InputLength: DWORD,
        Offset: LONGLONG,
        Length: DWORDLONG,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn DeviceDsmValidateInput(
        Definition: PDEVICE_DSM_DEFINITION,
        Input: PDEVICE_DSM_INPUT,
        InputLength: DWORD,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn DeviceDsmOutputBlock(Output: PDEVICE_DSM_OUTPUT) -> PVOID;
}
extern "C" {
    pub fn DeviceDsmGetOutputLength(
        Definition: PDEVICE_DSM_DEFINITION,
        OutputBlockLength: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn DeviceDsmValidateOutputLength(
        Definition: PDEVICE_DSM_DEFINITION,
        OutputLength: DWORD,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn DeviceDsmGetOutputBlockLength(
        Definition: PDEVICE_DSM_DEFINITION,
        OutputLength: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn DeviceDsmInitializeOutput(
        Definition: PDEVICE_DSM_DEFINITION,
        Output: PDEVICE_DSM_OUTPUT,
        OutputLength: DWORD,
        Flags: DWORD,
    );
}
extern "C" {
    pub fn DeviceDsmValidateOutput(
        Definition: PDEVICE_DSM_DEFINITION,
        Output: PDEVICE_DSM_OUTPUT,
        OutputLength: DWORD,
    ) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_GET_BC_PROPERTIES_OUTPUT {
    pub MaximumRequestsPerPeriod: DWORD,
    pub MinimumPeriod: DWORD,
    pub MaximumRequestSize: DWORDLONG,
    pub EstimatedTimePerRequest: DWORD,
    pub NumOutStandingRequests: DWORD,
    pub RequestSize: DWORDLONG,
}
pub type STORAGE_GET_BC_PROPERTIES_OUTPUT = _STORAGE_GET_BC_PROPERTIES_OUTPUT;
pub type PSTORAGE_GET_BC_PROPERTIES_OUTPUT = *mut _STORAGE_GET_BC_PROPERTIES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ALLOCATE_BC_STREAM_INPUT {
    pub Version: DWORD,
    pub RequestsPerPeriod: DWORD,
    pub Period: DWORD,
    pub RetryFailures: BOOLEAN,
    pub Discardable: BOOLEAN,
    pub Reserved1: [BOOLEAN; 2usize],
    pub AccessType: DWORD,
    pub AccessMode: DWORD,
}
pub type STORAGE_ALLOCATE_BC_STREAM_INPUT = _STORAGE_ALLOCATE_BC_STREAM_INPUT;
pub type PSTORAGE_ALLOCATE_BC_STREAM_INPUT = *mut _STORAGE_ALLOCATE_BC_STREAM_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    pub RequestSize: DWORDLONG,
    pub NumOutStandingRequests: DWORD,
}
pub type STORAGE_ALLOCATE_BC_STREAM_OUTPUT = _STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
pub type PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT = *mut _STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PRIORITY_HINT_SUPPORT {
    pub SupportFlags: DWORD,
}
pub type STORAGE_PRIORITY_HINT_SUPPORT = _STORAGE_PRIORITY_HINT_SUPPORT;
pub type PSTORAGE_PRIORITY_HINT_SUPPORT = *mut _STORAGE_PRIORITY_HINT_SUPPORT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_DIAGNOSTIC_LEVEL {
    StorageDiagnosticLevelDefault = 0,
    StorageDiagnosticLevelMax = 1,
}
pub use self::_STORAGE_DIAGNOSTIC_LEVEL as STORAGE_DIAGNOSTIC_LEVEL;
pub type PSTORAGE_DIAGNOSTIC_LEVEL = *mut _STORAGE_DIAGNOSTIC_LEVEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_DIAGNOSTIC_TARGET_TYPE {
    StorageDiagnosticTargetTypeUndefined = 0,
    StorageDiagnosticTargetTypePort = 1,
    StorageDiagnosticTargetTypeMiniport = 2,
    StorageDiagnosticTargetTypeHbaFirmware = 3,
    StorageDiagnosticTargetTypeMax = 4,
}
pub use self::_STORAGE_DIAGNOSTIC_TARGET_TYPE as STORAGE_DIAGNOSTIC_TARGET_TYPE;
pub type PSTORAGE_DIAGNOSTIC_TARGET_TYPE = *mut _STORAGE_DIAGNOSTIC_TARGET_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DIAGNOSTIC_REQUEST {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
    pub Level: STORAGE_DIAGNOSTIC_LEVEL,
}
pub type STORAGE_DIAGNOSTIC_REQUEST = _STORAGE_DIAGNOSTIC_REQUEST;
pub type PSTORAGE_DIAGNOSTIC_REQUEST = *mut _STORAGE_DIAGNOSTIC_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DIAGNOSTIC_DATA {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ProviderId: GUID,
    pub BufferSize: DWORD,
    pub Reserved: DWORD,
    pub DiagnosticDataBuffer: [BYTE; 1usize],
}
pub type STORAGE_DIAGNOSTIC_DATA = _STORAGE_DIAGNOSTIC_DATA;
pub type PSTORAGE_DIAGNOSTIC_DATA = *mut _STORAGE_DIAGNOSTIC_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_ELEMENT_STATUS_REQUEST {
    pub Version: DWORD,
    pub Size: DWORD,
    pub StartingElement: DWORD,
    pub Filter: BYTE,
    pub ReportType: BYTE,
    pub Reserved: [BYTE; 2usize],
}
pub type PHYSICAL_ELEMENT_STATUS_REQUEST = _PHYSICAL_ELEMENT_STATUS_REQUEST;
pub type PPHYSICAL_ELEMENT_STATUS_REQUEST = *mut _PHYSICAL_ELEMENT_STATUS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ElementIdentifier: DWORD,
    pub PhysicalElementType: BYTE,
    pub PhysicalElementHealth: BYTE,
    pub Reserved1: [BYTE; 2usize],
    pub AssociatedCapacity: DWORDLONG,
    pub Reserved2: [DWORD; 4usize],
}
pub type PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR;
pub type PPHYSICAL_ELEMENT_STATUS_DESCRIPTOR = *mut _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PHYSICAL_ELEMENT_STATUS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DescriptorCount: DWORD,
    pub ReturnedDescriptorCount: DWORD,
    pub ElementIdentifierBeingDepoped: DWORD,
    pub Reserved: DWORD,
    pub Descriptors: [PHYSICAL_ELEMENT_STATUS_DESCRIPTOR; 1usize],
}
pub type PHYSICAL_ELEMENT_STATUS = _PHYSICAL_ELEMENT_STATUS;
pub type PPHYSICAL_ELEMENT_STATUS = *mut _PHYSICAL_ELEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST {
    pub Version: DWORD,
    pub Size: DWORD,
    pub RequestCapacity: DWORDLONG,
    pub ElementIdentifier: DWORD,
    pub Reserved: DWORD,
}
pub type REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST;
pub type PREMOVE_ELEMENT_AND_TRUNCATE_REQUEST = *mut _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE {
    DeviceInternalStatusDataRequestTypeUndefined = 0,
    DeviceCurrentInternalStatusDataHeader = 1,
    DeviceCurrentInternalStatusData = 2,
    DeviceSavedInternalStatusDataHeader = 3,
    DeviceSavedInternalStatusData = 4,
}
pub use self::_DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE as DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE;
pub type PDEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = *mut _DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICE_INTERNAL_STATUS_DATA_SET {
    DeviceStatusDataSetUndefined = 0,
    DeviceStatusDataSet1 = 1,
    DeviceStatusDataSet2 = 2,
    DeviceStatusDataSet3 = 3,
    DeviceStatusDataSet4 = 4,
    DeviceStatusDataSetMax = 5,
}
pub use self::_DEVICE_INTERNAL_STATUS_DATA_SET as DEVICE_INTERNAL_STATUS_DATA_SET;
pub type PDEVICE_INTERNAL_STATUS_DATA_SET = *mut _DEVICE_INTERNAL_STATUS_DATA_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST {
    pub Version: DWORD,
    pub Size: DWORD,
    pub RequestDataType: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE,
    pub RequestDataSet: DEVICE_INTERNAL_STATUS_DATA_SET,
}
pub type GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST = _GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST;
pub type PGET_DEVICE_INTERNAL_STATUS_DATA_REQUEST = *mut _GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_INTERNAL_STATUS_DATA {
    pub Version: DWORD,
    pub Size: DWORD,
    pub T10VendorId: DWORDLONG,
    pub DataSet1Length: DWORD,
    pub DataSet2Length: DWORD,
    pub DataSet3Length: DWORD,
    pub DataSet4Length: DWORD,
    pub StatusDataVersion: BYTE,
    pub Reserved: [BYTE; 3usize],
    pub ReasonIdentifier: [BYTE; 128usize],
    pub StatusDataLength: DWORD,
    pub StatusData: [BYTE; 1usize],
}
pub type DEVICE_INTERNAL_STATUS_DATA = _DEVICE_INTERNAL_STATUS_DATA;
pub type PDEVICE_INTERNAL_STATUS_DATA = *mut _DEVICE_INTERNAL_STATUS_DATA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_SANITIZE_METHOD {
    StorageSanitizeMethodDefault = 0,
    StorageSanitizeMethodBlockErase = 1,
    StorageSanitizeMethodCryptoErase = 2,
}
pub use self::_STORAGE_SANITIZE_METHOD as STORAGE_SANITIZE_METHOD;
pub type PSTORAGE_SANITIZE_METHOD = *mut _STORAGE_SANITIZE_METHOD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_REINITIALIZE_MEDIA {
    pub Version: DWORD,
    pub Size: DWORD,
    pub TimeoutInSeconds: DWORD,
    pub SanitizeOption: _STORAGE_REINITIALIZE_MEDIA__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_REINITIALIZE_MEDIA__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _STORAGE_REINITIALIZE_MEDIA__bindgen_ty_1 {
    #[inline]
    pub fn SanitizeMethod(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SanitizeMethod(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowUnrestrictedSanitizeExit(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowUnrestrictedSanitizeExit(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SanitizeMethod: DWORD,
        DisallowUnrestrictedSanitizeExit: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SanitizeMethod: u32 = unsafe { ::std::mem::transmute(SanitizeMethod) };
            SanitizeMethod as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DisallowUnrestrictedSanitizeExit: u32 =
                unsafe { ::std::mem::transmute(DisallowUnrestrictedSanitizeExit) };
            DisallowUnrestrictedSanitizeExit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_REINITIALIZE_MEDIA = _STORAGE_REINITIALIZE_MEDIA;
pub type PSTORAGE_REINITIALIZE_MEDIA = *mut _STORAGE_REINITIALIZE_MEDIA;
#[repr(C)]
#[derive(Debug)]
pub struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    pub Reserved: WORD,
    pub SerialNumberLength: WORD,
    pub SerialNumber: __IncompleteArrayField<BYTE>,
}
pub type STORAGE_MEDIA_SERIAL_NUMBER_DATA = _STORAGE_MEDIA_SERIAL_NUMBER_DATA;
pub type PSTORAGE_MEDIA_SERIAL_NUMBER_DATA = *mut _STORAGE_MEDIA_SERIAL_NUMBER_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_READ_CAPACITY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub BlockLength: DWORD,
    pub NumberOfBlocks: LARGE_INTEGER,
    pub DiskLength: LARGE_INTEGER,
}
pub type STORAGE_READ_CAPACITY = _STORAGE_READ_CAPACITY;
pub type PSTORAGE_READ_CAPACITY = *mut _STORAGE_READ_CAPACITY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WRITE_CACHE_TYPE {
    WriteCacheTypeUnknown = 0,
    WriteCacheTypeNone = 1,
    WriteCacheTypeWriteBack = 2,
    WriteCacheTypeWriteThrough = 3,
}
pub use self::_WRITE_CACHE_TYPE as WRITE_CACHE_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WRITE_CACHE_ENABLE {
    WriteCacheEnableUnknown = 0,
    WriteCacheDisabled = 1,
    WriteCacheEnabled = 2,
}
pub use self::_WRITE_CACHE_ENABLE as WRITE_CACHE_ENABLE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WRITE_CACHE_CHANGE {
    WriteCacheChangeUnknown = 0,
    WriteCacheNotChangeable = 1,
    WriteCacheChangeable = 2,
}
pub use self::_WRITE_CACHE_CHANGE as WRITE_CACHE_CHANGE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _WRITE_THROUGH {
    WriteThroughUnknown = 0,
    WriteThroughNotSupported = 1,
    WriteThroughSupported = 2,
}
pub use self::_WRITE_THROUGH as WRITE_THROUGH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_WRITE_CACHE_PROPERTY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub WriteCacheType: WRITE_CACHE_TYPE,
    pub WriteCacheEnabled: WRITE_CACHE_ENABLE,
    pub WriteCacheChangeable: WRITE_CACHE_CHANGE,
    pub WriteThroughSupported: WRITE_THROUGH,
    pub FlushCacheSupported: BOOLEAN,
    pub UserDefinedPowerProtection: BOOLEAN,
    pub NVCacheEnabled: BOOLEAN,
}
pub type STORAGE_WRITE_CACHE_PROPERTY = _STORAGE_WRITE_CACHE_PROPERTY;
pub type PSTORAGE_WRITE_CACHE_PROPERTY = *mut _STORAGE_WRITE_CACHE_PROPERTY;
#[repr(C)]
pub struct _PERSISTENT_RESERVE_COMMAND {
    pub Version: DWORD,
    pub Size: DWORD,
    pub __bindgen_anon_1: _PERSISTENT_RESERVE_COMMAND__bindgen_ty_1,
}
#[repr(C)]
pub struct _PERSISTENT_RESERVE_COMMAND__bindgen_ty_1 {
    pub PR_IN: __BindgenUnionField<_PERSISTENT_RESERVE_COMMAND__bindgen_ty_1__bindgen_ty_1>,
    pub PR_OUT: __BindgenUnionField<_PERSISTENT_RESERVE_COMMAND__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u16; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERSISTENT_RESERVE_COMMAND__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub AllocationLength: WORD,
}
impl _PERSISTENT_RESERVE_COMMAND__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ServiceAction(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ServiceAction(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ServiceAction: BYTE,
        Reserved1: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ServiceAction: u8 = unsafe { ::std::mem::transmute(ServiceAction) };
            ServiceAction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved1: u8 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct _PERSISTENT_RESERVE_COMMAND__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub ParameterList: __IncompleteArrayField<BYTE>,
}
impl _PERSISTENT_RESERVE_COMMAND__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn ServiceAction(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_ServiceAction(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Scope(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Scope(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ServiceAction: BYTE,
        Reserved1: BYTE,
        Type: BYTE,
        Scope: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ServiceAction: u8 = unsafe { ::std::mem::transmute(ServiceAction) };
            ServiceAction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved1: u8 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let Type: u8 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let Scope: u8 = unsafe { ::std::mem::transmute(Scope) };
            Scope as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PERSISTENT_RESERVE_COMMAND = _PERSISTENT_RESERVE_COMMAND;
pub type PPERSISTENT_RESERVE_COMMAND = *mut _PERSISTENT_RESERVE_COMMAND;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DEVICEDUMP_COLLECTION_TYPE {
    TCCollectionBugCheck = 1,
    TCCollectionApplicationRequested = 2,
    TCCollectionDeviceRequested = 3,
}
pub use self::_DEVICEDUMP_COLLECTION_TYPE as DEVICEDUMP_COLLECTION_TYPEIDE_NOTIFICATION_TYPE;
pub type PDEVICEDUMP_COLLECTION_TYPE = *mut _DEVICEDUMP_COLLECTION_TYPE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_SUBSECTION_POINTER {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub dwOffset: DWORD,
}
pub type DEVICEDUMP_SUBSECTION_POINTER = _DEVICEDUMP_SUBSECTION_POINTER;
pub type PDEVICEDUMP_SUBSECTION_POINTER = *mut _DEVICEDUMP_SUBSECTION_POINTER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_STRUCTURE_VERSION {
    pub dwSignature: DWORD,
    pub dwVersion: DWORD,
    pub dwSize: DWORD,
}
pub type DEVICEDUMP_STRUCTURE_VERSION = _DEVICEDUMP_STRUCTURE_VERSION;
pub type PDEVICEDUMP_STRUCTURE_VERSION = *mut _DEVICEDUMP_STRUCTURE_VERSION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_SECTION_HEADER {
    pub guidDeviceDataId: GUID,
    pub sOrganizationID: [BYTE; 16usize],
    pub dwFirmwareRevision: DWORD,
    pub sModelNumber: [BYTE; 32usize],
    pub szDeviceManufacturingID: [BYTE; 32usize],
    pub dwFlags: DWORD,
    pub bRestrictedPrivateDataVersion: DWORD,
    pub dwFirmwareIssueId: DWORD,
    pub szIssueDescriptionString: [BYTE; 132usize],
}
pub type DEVICEDUMP_SECTION_HEADER = _DEVICEDUMP_SECTION_HEADER;
pub type PDEVICEDUMP_SECTION_HEADER = *mut _DEVICEDUMP_SECTION_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _GP_LOG_PAGE_DESCRIPTOR {
    pub LogAddress: WORD,
    pub LogSectors: WORD,
}
pub type GP_LOG_PAGE_DESCRIPTOR = _GP_LOG_PAGE_DESCRIPTOR;
pub type PGP_LOG_PAGE_DESCRIPTOR = *mut _GP_LOG_PAGE_DESCRIPTOR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_PUBLIC_SUBSECTION {
    pub dwFlags: DWORD,
    pub GPLogTable: [GP_LOG_PAGE_DESCRIPTOR; 16usize],
    pub szDescription: [CHAR; 16usize],
    pub bData: [BYTE; 1usize],
}
pub type DEVICEDUMP_PUBLIC_SUBSECTION = _DEVICEDUMP_PUBLIC_SUBSECTION;
pub type PDEVICEDUMP_PUBLIC_SUBSECTION = *mut _DEVICEDUMP_PUBLIC_SUBSECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_RESTRICTED_SUBSECTION {
    pub bData: [BYTE; 1usize],
}
pub type DEVICEDUMP_RESTRICTED_SUBSECTION = _DEVICEDUMP_RESTRICTED_SUBSECTION;
pub type PDEVICEDUMP_RESTRICTED_SUBSECTION = *mut _DEVICEDUMP_RESTRICTED_SUBSECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_PRIVATE_SUBSECTION {
    pub dwFlags: DWORD,
    pub GPLogId: GP_LOG_PAGE_DESCRIPTOR,
    pub bData: [BYTE; 1usize],
}
pub type DEVICEDUMP_PRIVATE_SUBSECTION = _DEVICEDUMP_PRIVATE_SUBSECTION;
pub type PDEVICEDUMP_PRIVATE_SUBSECTION = *mut _DEVICEDUMP_PRIVATE_SUBSECTION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_STORAGEDEVICE_DATA {
    pub Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    pub SectionHeader: DEVICEDUMP_SECTION_HEADER,
    pub dwBufferSize: DWORD,
    pub dwReasonForCollection: DWORD,
    pub PublicData: DEVICEDUMP_SUBSECTION_POINTER,
    pub RestrictedData: DEVICEDUMP_SUBSECTION_POINTER,
    pub PrivateData: DEVICEDUMP_SUBSECTION_POINTER,
}
pub type DEVICEDUMP_STORAGEDEVICE_DATA = _DEVICEDUMP_STORAGEDEVICE_DATA;
pub type PDEVICEDUMP_STORAGEDEVICE_DATA = *mut _DEVICEDUMP_STORAGEDEVICE_DATA;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {
    pub Cdb: [BYTE; 16usize],
    pub Command: [BYTE; 16usize],
    pub StartTime: DWORDLONG,
    pub EndTime: DWORDLONG,
    pub OperationStatus: DWORD,
    pub OperationError: DWORD,
    pub StackSpecific: _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1 {
    pub ExternalStack: _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1__bindgen_ty_1,
    pub AtaPort: _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1__bindgen_ty_2,
    pub StorPort: _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1__bindgen_ty_1 {
    pub dwReserved: DWORD,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1__bindgen_ty_2 {
    pub dwAtaPortSpecific: DWORD,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD__bindgen_ty_1__bindgen_ty_3 {
    pub SrbTag: DWORD,
}
pub type DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;
pub type PDEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD =
    *mut _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {
    pub Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    pub dwReasonForCollection: DWORD,
    pub cDriverName: [BYTE; 16usize],
    pub uiNumRecords: DWORD,
    pub RecordArray: [DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD; 1usize],
}
pub type DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;
pub type PDEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = *mut _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDLE_POWER {
    pub Version: DWORD,
    pub Size: DWORD,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub D3IdleTimeout: DWORD,
}
impl _STORAGE_IDLE_POWER {
    #[inline]
    pub fn WakeCapableHint(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeCapableHint(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn D3ColdSupported(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_D3ColdSupported(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WakeCapableHint: DWORD,
        D3ColdSupported: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WakeCapableHint: u32 = unsafe { ::std::mem::transmute(WakeCapableHint) };
            WakeCapableHint as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let D3ColdSupported: u32 = unsafe { ::std::mem::transmute(D3ColdSupported) };
            D3ColdSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_IDLE_POWER = _STORAGE_IDLE_POWER;
pub type PSTORAGE_IDLE_POWER = *mut _STORAGE_IDLE_POWER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_POWERUP_REASON_TYPE {
    StoragePowerupUnknown = 0,
    StoragePowerupIO = 1,
    StoragePowerupDeviceAttention = 2,
}
pub use self::_STORAGE_POWERUP_REASON_TYPE as STORAGE_POWERUP_REASON_TYPE;
pub type PSTORAGE_POWERUP_REASON_TYPE = *mut _STORAGE_POWERUP_REASON_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDLE_POWERUP_REASON {
    pub Version: DWORD,
    pub Size: DWORD,
    pub PowerupReason: STORAGE_POWERUP_REASON_TYPE,
}
pub type STORAGE_IDLE_POWERUP_REASON = _STORAGE_IDLE_POWERUP_REASON;
pub type PSTORAGE_IDLE_POWERUP_REASON = *mut _STORAGE_IDLE_POWERUP_REASON;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_DEVICE_POWER_CAP_UNITS {
    StorageDevicePowerCapUnitsPercent = 0,
    StorageDevicePowerCapUnitsMilliwatts = 1,
}
pub use self::_STORAGE_DEVICE_POWER_CAP_UNITS as STORAGE_DEVICE_POWER_CAP_UNITS;
pub type PSTORAGE_DEVICE_POWER_CAP_UNITS = *mut _STORAGE_DEVICE_POWER_CAP_UNITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_POWER_CAP {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Units: STORAGE_DEVICE_POWER_CAP_UNITS,
    pub MaxPower: DWORDLONG,
}
pub type STORAGE_DEVICE_POWER_CAP = _STORAGE_DEVICE_POWER_CAP;
pub type PSTORAGE_DEVICE_POWER_CAP = *mut _STORAGE_DEVICE_POWER_CAP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_RPMB_DATA_FRAME {
    pub Stuff: [BYTE; 196usize],
    pub KeyOrMAC: [BYTE; 32usize],
    pub Data: [BYTE; 256usize],
    pub Nonce: [BYTE; 16usize],
    pub WriteCounter: [BYTE; 4usize],
    pub Address: [BYTE; 2usize],
    pub BlockCount: [BYTE; 2usize],
    pub OperationResult: [BYTE; 2usize],
    pub RequestOrResponseType: [BYTE; 2usize],
}
pub type STORAGE_RPMB_DATA_FRAME = _STORAGE_RPMB_DATA_FRAME;
pub type PSTORAGE_RPMB_DATA_FRAME = *mut _STORAGE_RPMB_DATA_FRAME;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_RPMB_COMMAND_TYPE {
    StorRpmbProgramAuthKey = 1,
    StorRpmbQueryWriteCounter = 2,
    StorRpmbAuthenticatedWrite = 3,
    StorRpmbAuthenticatedRead = 4,
    StorRpmbReadResultRequest = 5,
    StorRpmbAuthenticatedDeviceConfigWrite = 6,
    StorRpmbAuthenticatedDeviceConfigRead = 7,
}
pub use self::_STORAGE_RPMB_COMMAND_TYPE as STORAGE_RPMB_COMMAND_TYPE;
pub type PSTORAGE_RPMB_COMMAND_TYPE = *mut _STORAGE_RPMB_COMMAND_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_EVENT_NOTIFICATION {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Events: DWORDLONG,
}
pub type STORAGE_EVENT_NOTIFICATION = _STORAGE_EVENT_NOTIFICATION;
pub type PSTORAGE_EVENT_NOTIFICATION = *mut _STORAGE_EVENT_NOTIFICATION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_COUNTER_TYPE {
    StorageCounterTypeUnknown = 0,
    StorageCounterTypeTemperatureCelsius = 1,
    StorageCounterTypeTemperatureCelsiusMax = 2,
    StorageCounterTypeReadErrorsTotal = 3,
    StorageCounterTypeReadErrorsCorrected = 4,
    StorageCounterTypeReadErrorsUncorrected = 5,
    StorageCounterTypeWriteErrorsTotal = 6,
    StorageCounterTypeWriteErrorsCorrected = 7,
    StorageCounterTypeWriteErrorsUncorrected = 8,
    StorageCounterTypeManufactureDate = 9,
    StorageCounterTypeStartStopCycleCount = 10,
    StorageCounterTypeStartStopCycleCountMax = 11,
    StorageCounterTypeLoadUnloadCycleCount = 12,
    StorageCounterTypeLoadUnloadCycleCountMax = 13,
    StorageCounterTypeWearPercentage = 14,
    StorageCounterTypeWearPercentageWarning = 15,
    StorageCounterTypeWearPercentageMax = 16,
    StorageCounterTypePowerOnHours = 17,
    StorageCounterTypeReadLatency100NSMax = 18,
    StorageCounterTypeWriteLatency100NSMax = 19,
    StorageCounterTypeFlushLatency100NSMax = 20,
    StorageCounterTypeMax = 21,
}
pub use self::_STORAGE_COUNTER_TYPE as STORAGE_COUNTER_TYPE;
pub type PSTORAGE_COUNTER_TYPE = *mut _STORAGE_COUNTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_COUNTER {
    pub Type: STORAGE_COUNTER_TYPE,
    pub Value: _STORAGE_COUNTER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_COUNTER__bindgen_ty_1 {
    pub ManufactureDate: _STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1,
    pub AsUlonglong: DWORDLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1 {
    pub Week: DWORD,
    pub Year: DWORD,
}
pub type STORAGE_COUNTER = _STORAGE_COUNTER;
pub type PSTORAGE_COUNTER = *mut _STORAGE_COUNTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_COUNTERS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumberOfCounters: DWORD,
    pub Counters: [STORAGE_COUNTER; 1usize],
}
pub type STORAGE_COUNTERS = _STORAGE_COUNTERS;
pub type PSTORAGE_COUNTERS = *mut _STORAGE_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_INFO_QUERY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Reserved: DWORD,
}
pub type STORAGE_HW_FIRMWARE_INFO_QUERY = _STORAGE_HW_FIRMWARE_INFO_QUERY;
pub type PSTORAGE_HW_FIRMWARE_INFO_QUERY = *mut _STORAGE_HW_FIRMWARE_INFO_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_SLOT_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SlotNumber: BYTE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Reserved1: [BYTE; 6usize],
    pub Revision: [BYTE; 16usize],
}
impl _STORAGE_HW_FIRMWARE_SLOT_INFO {
    #[inline]
    pub fn ReadOnly(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ReadOnly: BYTE, Reserved0: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_HW_FIRMWARE_SLOT_INFO = _STORAGE_HW_FIRMWARE_SLOT_INFO;
pub type PSTORAGE_HW_FIRMWARE_SLOT_INFO = *mut _STORAGE_HW_FIRMWARE_SLOT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub SlotCount: BYTE,
    pub ActiveSlot: BYTE,
    pub PendingActivateSlot: BYTE,
    pub FirmwareShared: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
    pub ImagePayloadAlignment: DWORD,
    pub ImagePayloadMaxSize: DWORD,
    pub Slot: [STORAGE_HW_FIRMWARE_SLOT_INFO; 1usize],
}
impl _STORAGE_HW_FIRMWARE_INFO {
    #[inline]
    pub fn SupportUpgrade(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SupportUpgrade(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SupportUpgrade: BYTE,
        Reserved0: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SupportUpgrade: u8 = unsafe { ::std::mem::transmute(SupportUpgrade) };
            SupportUpgrade as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type STORAGE_HW_FIRMWARE_INFO = _STORAGE_HW_FIRMWARE_INFO;
pub type PSTORAGE_HW_FIRMWARE_INFO = *mut _STORAGE_HW_FIRMWARE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_DOWNLOAD {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Slot: BYTE,
    pub Reserved: [BYTE; 3usize],
    pub Offset: DWORDLONG,
    pub BufferSize: DWORDLONG,
    pub ImageBuffer: [BYTE; 1usize],
}
pub type STORAGE_HW_FIRMWARE_DOWNLOAD = _STORAGE_HW_FIRMWARE_DOWNLOAD;
pub type PSTORAGE_HW_FIRMWARE_DOWNLOAD = *mut _STORAGE_HW_FIRMWARE_DOWNLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Slot: BYTE,
    pub Reserved: [BYTE; 3usize],
    pub Offset: DWORDLONG,
    pub BufferSize: DWORDLONG,
    pub ImageSize: DWORD,
    pub Reserved2: DWORD,
    pub ImageBuffer: [BYTE; 1usize],
}
pub type STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = _STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
pub type PSTORAGE_HW_FIRMWARE_DOWNLOAD_V2 = *mut _STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_ACTIVATE {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Slot: BYTE,
    pub Reserved0: [BYTE; 3usize],
}
pub type STORAGE_HW_FIRMWARE_ACTIVATE = _STORAGE_HW_FIRMWARE_ACTIVATE;
pub type PSTORAGE_HW_FIRMWARE_ACTIVATE = *mut _STORAGE_HW_FIRMWARE_ACTIVATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_COMMAND {
    pub Version: DWORD,
    pub Length: DWORD,
    pub ProtocolType: STORAGE_PROTOCOL_TYPE,
    pub Flags: DWORD,
    pub ReturnStatus: DWORD,
    pub ErrorCode: DWORD,
    pub CommandLength: DWORD,
    pub ErrorInfoLength: DWORD,
    pub DataToDeviceTransferLength: DWORD,
    pub DataFromDeviceTransferLength: DWORD,
    pub TimeOutValue: DWORD,
    pub ErrorInfoOffset: DWORD,
    pub DataToDeviceBufferOffset: DWORD,
    pub DataFromDeviceBufferOffset: DWORD,
    pub CommandSpecific: DWORD,
    pub Reserved0: DWORD,
    pub FixedProtocolReturnData: DWORD,
    pub Reserved1: [DWORD; 3usize],
    pub Command: [BYTE; 1usize],
}
pub type STORAGE_PROTOCOL_COMMAND = _STORAGE_PROTOCOL_COMMAND;
pub type PSTORAGE_PROTOCOL_COMMAND = *mut _STORAGE_PROTOCOL_COMMAND;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_ATTRIBUTE_MGMT_ACTION {
    StorAttributeMgmt_ClearAttribute = 0,
    StorAttributeMgmt_SetAttribute = 1,
    StorAttributeMgmt_ResetAttribute = 2,
}
pub use self::_STORAGE_ATTRIBUTE_MGMT_ACTION as STORAGE_ATTRIBUTE_MGMT_ACTION;
pub type PSTORAGE_ATTRIBUTE_MGMT_ACTION = *mut _STORAGE_ATTRIBUTE_MGMT_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ATTRIBUTE_MGMT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
    pub Attribute: DWORD,
}
pub type STORAGE_ATTRIBUTE_MGMT = _STORAGE_ATTRIBUTE_MGMT;
pub type PSTORAGE_ATTRIBUTE_MGMT = *mut _STORAGE_ATTRIBUTE_MGMT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_HEALTH_NOTIFICATION_DATA {
    pub DeviceGuid: GUID,
}
pub type SCM_PD_HEALTH_NOTIFICATION_DATA = _SCM_PD_HEALTH_NOTIFICATION_DATA;
pub type PSCM_PD_HEALTH_NOTIFICATION_DATA = *mut _SCM_PD_HEALTH_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_LOGICAL_DEVICE_INSTANCE {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceGuid: GUID,
    pub SymbolicLink: [WCHAR; 256usize],
}
pub type SCM_LOGICAL_DEVICE_INSTANCE = _SCM_LOGICAL_DEVICE_INSTANCE;
pub type PSCM_LOGICAL_DEVICE_INSTANCE = *mut _SCM_LOGICAL_DEVICE_INSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_LOGICAL_DEVICES {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceCount: DWORD,
    pub Devices: [SCM_LOGICAL_DEVICE_INSTANCE; 1usize],
}
pub type SCM_LOGICAL_DEVICES = _SCM_LOGICAL_DEVICES;
pub type PSCM_LOGICAL_DEVICES = *mut _SCM_LOGICAL_DEVICES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PHYSICAL_DEVICE_INSTANCE {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NfitHandle: DWORD,
    pub SymbolicLink: [WCHAR; 256usize],
}
pub type SCM_PHYSICAL_DEVICE_INSTANCE = _SCM_PHYSICAL_DEVICE_INSTANCE;
pub type PSCM_PHYSICAL_DEVICE_INSTANCE = *mut _SCM_PHYSICAL_DEVICE_INSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PHYSICAL_DEVICES {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceCount: DWORD,
    pub Devices: [SCM_PHYSICAL_DEVICE_INSTANCE; 1usize],
}
pub type SCM_PHYSICAL_DEVICES = _SCM_PHYSICAL_DEVICES;
pub type PSCM_PHYSICAL_DEVICES = *mut _SCM_PHYSICAL_DEVICES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_REGION_FLAG {
    ScmRegionFlagNone = 0,
    ScmRegionFlagLabel = 1,
}
pub use self::_SCM_REGION_FLAG as SCM_REGION_FLAG;
pub type PSCM_REGION_FLAG = *mut _SCM_REGION_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_REGION {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub NfitHandle: DWORD,
    pub LogicalDeviceGuid: GUID,
    pub AddressRangeType: GUID,
    pub AssociatedId: DWORD,
    pub Length: DWORD64,
    pub StartingDPA: DWORD64,
    pub BaseSPA: DWORD64,
    pub SPAOffset: DWORD64,
    pub RegionOffset: DWORD64,
}
pub type SCM_REGION = _SCM_REGION;
pub type PSCM_REGION = *mut _SCM_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_REGIONS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub RegionCount: DWORD,
    pub Regions: [SCM_REGION; 1usize],
}
pub type SCM_REGIONS = _SCM_REGIONS;
pub type PSCM_REGIONS = *mut _SCM_REGIONS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_BUS_QUERY_TYPE {
    ScmBusQuery_Descriptor = 0,
    ScmBusQuery_IsSupported = 1,
    ScmBusQuery_Max = 2,
}
pub use self::_SCM_BUS_QUERY_TYPE as SCM_BUS_QUERY_TYPE;
pub type PSCM_BUS_QUERY_TYPE = *mut _SCM_BUS_QUERY_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_BUS_SET_TYPE {
    ScmBusSet_Descriptor = 0,
    ScmBusSet_IsSupported = 1,
    ScmBusSet_Max = 2,
}
pub use self::_SCM_BUS_SET_TYPE as SCM_BUS_SET_TYPE;
pub type PSCM_BUS_SET_TYPE = *mut _SCM_BUS_SET_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_BUS_PROPERTY_ID {
    ScmBusProperty_RuntimeFwActivationInfo = 0,
    ScmBusProperty_DedicatedMemoryInfo = 1,
    ScmBusProperty_DedicatedMemoryState = 2,
    ScmBusProperty_Max = 3,
}
pub use self::_SCM_BUS_PROPERTY_ID as SCM_BUS_PROPERTY_ID;
pub type PSCM_BUS_PROPERTY_ID = *mut _SCM_BUS_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_PROPERTY_QUERY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub PropertyId: SCM_BUS_PROPERTY_ID,
    pub QueryType: SCM_BUS_QUERY_TYPE,
    pub AdditionalParameters: [BYTE; 1usize],
}
pub type SCM_BUS_PROPERTY_QUERY = _SCM_BUS_PROPERTY_QUERY;
pub type PSCM_BUS_PROPERTY_QUERY = *mut _SCM_BUS_PROPERTY_QUERY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_BUS_FIRMWARE_ACTIVATION_STATE {
    ScmBusFirmwareActivationState_Idle = 0,
    ScmBusFirmwareActivationState_Armed = 1,
    ScmBusFirmwareActivationState_Busy = 2,
}
pub use self::_SCM_BUS_FIRMWARE_ACTIVATION_STATE as SCM_BUS_FIRMWARE_ACTIVATION_STATE;
pub type PSCM_BUS_FIRMWARE_ACTIVATION_STATE = *mut _SCM_BUS_FIRMWARE_ACTIVATION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_RUNTIME_FW_ACTIVATION_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub RuntimeFwActivationSupported: BOOLEAN,
    pub FirmwareActivationState: SCM_BUS_FIRMWARE_ACTIVATION_STATE,
    pub FirmwareActivationCapability: _SCM_BUS_RUNTIME_FW_ACTIVATION_INFO__bindgen_ty_1,
    pub EstimatedFirmwareActivationTimeInUSecs: DWORDLONG,
    pub EstimatedProcessorAccessQuiesceTimeInUSecs: DWORDLONG,
    pub EstimatedIOAccessQuiesceTimeInUSecs: DWORDLONG,
    pub PlatformSupportedMaxIOAccessQuiesceTimeInUSecs: DWORDLONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_RUNTIME_FW_ACTIVATION_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SCM_BUS_RUNTIME_FW_ACTIVATION_INFO__bindgen_ty_1 {
    #[inline]
    pub fn FwManagedIoQuiesceFwActivationSupported(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FwManagedIoQuiesceFwActivationSupported(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OsManagedIoQuiesceFwActivationSupported(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OsManagedIoQuiesceFwActivationSupported(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WarmResetBasedFwActivationSupported(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmResetBasedFwActivationSupported(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FwManagedIoQuiesceFwActivationSupported: DWORD,
        OsManagedIoQuiesceFwActivationSupported: DWORD,
        WarmResetBasedFwActivationSupported: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FwManagedIoQuiesceFwActivationSupported: u32 =
                unsafe { ::std::mem::transmute(FwManagedIoQuiesceFwActivationSupported) };
            FwManagedIoQuiesceFwActivationSupported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OsManagedIoQuiesceFwActivationSupported: u32 =
                unsafe { ::std::mem::transmute(OsManagedIoQuiesceFwActivationSupported) };
            OsManagedIoQuiesceFwActivationSupported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WarmResetBasedFwActivationSupported: u32 =
                unsafe { ::std::mem::transmute(WarmResetBasedFwActivationSupported) };
            WarmResetBasedFwActivationSupported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SCM_BUS_RUNTIME_FW_ACTIVATION_INFO = _SCM_BUS_RUNTIME_FW_ACTIVATION_INFO;
pub type PSCM_BUS_RUNTIME_FW_ACTIVATION_INFO = *mut _SCM_BUS_RUNTIME_FW_ACTIVATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO {
    pub DeviceGuid: GUID,
    pub DeviceNumber: DWORD,
    pub Flags: _SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO__bindgen_ty_1,
    pub DeviceSize: DWORDLONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO__bindgen_ty_1 {
    #[inline]
    pub fn ForcedByRegistry(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ForcedByRegistry(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Initialized(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Initialized(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ForcedByRegistry: DWORD,
        Initialized: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ForcedByRegistry: u32 = unsafe { ::std::mem::transmute(ForcedByRegistry) };
            ForcedByRegistry as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Initialized: u32 = unsafe { ::std::mem::transmute(Initialized) };
            Initialized as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO = _SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO;
pub type PSCM_BUS_DEDICATED_MEMORY_DEVICE_INFO = *mut _SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceCount: DWORD,
    pub Devices: [SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO; 1usize],
}
pub type SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO = _SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO;
pub type PSCM_BUS_DEDICATED_MEMORY_DEVICES_INFO = *mut _SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_PROPERTY_SET {
    pub Version: DWORD,
    pub Size: DWORD,
    pub PropertyId: SCM_BUS_PROPERTY_ID,
    pub SetType: SCM_BUS_SET_TYPE,
    pub AdditionalParameters: [BYTE; 1usize],
}
pub type SCM_BUS_PROPERTY_SET = _SCM_BUS_PROPERTY_SET;
pub type PSCM_BUS_PROPERTY_SET = *mut _SCM_BUS_PROPERTY_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_BUS_DEDICATED_MEMORY_STATE {
    pub ActivateState: BOOLEAN,
}
pub type SCM_BUS_DEDICATED_MEMORY_STATE = _SCM_BUS_DEDICATED_MEMORY_STATE;
pub type PSCM_BUS_DEDICATED_MEMORY_STATE = *mut _SCM_BUS_DEDICATED_MEMORY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_INTERLEAVED_PD_INFO {
    pub DeviceHandle: DWORD,
    pub DeviceGuid: GUID,
}
pub type SCM_INTERLEAVED_PD_INFO = _SCM_INTERLEAVED_PD_INFO;
pub type PSCM_INTERLEAVED_PD_INFO = *mut _SCM_INTERLEAVED_PD_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_LD_INTERLEAVE_SET_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub InterleaveSetSize: DWORD,
    pub InterleaveSet: [SCM_INTERLEAVED_PD_INFO; 1usize],
}
pub type SCM_LD_INTERLEAVE_SET_INFO = _SCM_LD_INTERLEAVE_SET_INFO;
pub type PSCM_LD_INTERLEAVE_SET_INFO = *mut _SCM_LD_INTERLEAVE_SET_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_QUERY_TYPE {
    ScmPhysicalDeviceQuery_Descriptor = 0,
    ScmPhysicalDeviceQuery_IsSupported = 1,
    ScmPhysicalDeviceQuery_Max = 2,
}
pub use self::_SCM_PD_QUERY_TYPE as SCM_PD_QUERY_TYPE;
pub type PSCM_PD_QUERY_TYPE = *mut _SCM_PD_QUERY_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_SET_TYPE {
    ScmPhysicalDeviceSet_Descriptor = 0,
    ScmPhysicalDeviceSet_IsSupported = 1,
    ScmPhysicalDeviceSet_Max = 2,
}
pub use self::_SCM_PD_SET_TYPE as SCM_PD_SET_TYPE;
pub type PSCM_PD_SET_TYPE = *mut _SCM_PD_SET_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_PROPERTY_ID {
    ScmPhysicalDeviceProperty_DeviceInfo = 0,
    ScmPhysicalDeviceProperty_ManagementStatus = 1,
    ScmPhysicalDeviceProperty_FirmwareInfo = 2,
    ScmPhysicalDeviceProperty_LocationString = 3,
    ScmPhysicalDeviceProperty_DeviceSpecificInfo = 4,
    ScmPhysicalDeviceProperty_DeviceHandle = 5,
    ScmPhysicalDeviceProperty_FruIdString = 6,
    ScmPhysicalDeviceProperty_RuntimeFwActivationInfo = 7,
    ScmPhysicalDeviceProperty_RuntimeFwActivationArmState = 8,
    ScmPhysicalDeviceProperty_Max = 9,
}
pub use self::_SCM_PD_PROPERTY_ID as SCM_PD_PROPERTY_ID;
pub type PSCM_PD_PROPERTY_ID = *mut _SCM_PD_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PROPERTY_QUERY {
    pub Version: DWORD,
    pub Size: DWORD,
    pub PropertyId: SCM_PD_PROPERTY_ID,
    pub QueryType: SCM_PD_QUERY_TYPE,
    pub AdditionalParameters: [BYTE; 1usize],
}
pub type SCM_PD_PROPERTY_QUERY = _SCM_PD_PROPERTY_QUERY;
pub type PSCM_PD_PROPERTY_QUERY = *mut _SCM_PD_PROPERTY_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PROPERTY_SET {
    pub Version: DWORD,
    pub Size: DWORD,
    pub PropertyId: SCM_PD_PROPERTY_ID,
    pub SetType: SCM_PD_SET_TYPE,
    pub AdditionalParameters: [BYTE; 1usize],
}
pub type SCM_PD_PROPERTY_SET = _SCM_PD_PROPERTY_SET;
pub type PSCM_PD_PROPERTY_SET = *mut _SCM_PD_PROPERTY_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE {
    pub ArmState: BOOLEAN,
}
pub type SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE = _SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE;
pub type PSCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE = *mut _SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DESCRIPTOR_HEADER {
    pub Version: DWORD,
    pub Size: DWORD,
}
pub type SCM_PD_DESCRIPTOR_HEADER = _SCM_PD_DESCRIPTOR_HEADER;
pub type PSCM_PD_DESCRIPTOR_HEADER = *mut _SCM_PD_DESCRIPTOR_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_HANDLE {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceGuid: GUID,
    pub DeviceHandle: DWORD,
}
pub type SCM_PD_DEVICE_HANDLE = _SCM_PD_DEVICE_HANDLE;
pub type PSCM_PD_DEVICE_HANDLE = *mut _SCM_PD_DEVICE_HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub DeviceGuid: GUID,
    pub UnsafeShutdownCount: DWORD,
    pub PersistentMemorySizeInBytes: DWORD64,
    pub VolatileMemorySizeInBytes: DWORD64,
    pub TotalMemorySizeInBytes: DWORD64,
    pub SlotNumber: DWORD,
    pub DeviceHandle: DWORD,
    pub PhysicalId: WORD,
    pub NumberOfFormatInterfaceCodes: BYTE,
    pub FormatInterfaceCodes: [WORD; 8usize],
    pub VendorId: DWORD,
    pub ProductId: DWORD,
    pub SubsystemDeviceId: DWORD,
    pub SubsystemVendorId: DWORD,
    pub ManufacturingLocation: BYTE,
    pub ManufacturingWeek: BYTE,
    pub ManufacturingYear: BYTE,
    pub SerialNumber4Byte: DWORD,
    pub SerialNumberLengthInChars: DWORD,
    pub SerialNumber: [CHAR; 1usize],
}
pub type SCM_PD_DEVICE_INFO = _SCM_PD_DEVICE_INFO;
pub type PSCM_PD_DEVICE_INFO = *mut _SCM_PD_DEVICE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_SPECIFIC_PROPERTY {
    pub Name: [WCHAR; 128usize],
    pub Value: LONGLONG,
}
pub type SCM_PD_DEVICE_SPECIFIC_PROPERTY = _SCM_PD_DEVICE_SPECIFIC_PROPERTY;
pub type PSCM_PD_DEVICE_SPECIFIC_PROPERTY = *mut _SCM_PD_DEVICE_SPECIFIC_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_SPECIFIC_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub NumberOfProperties: DWORD,
    pub DeviceSpecificProperties: [SCM_PD_DEVICE_SPECIFIC_PROPERTY; 1usize],
}
pub type SCM_PD_DEVICE_SPECIFIC_INFO = _SCM_PD_DEVICE_SPECIFIC_INFO;
pub type PSCM_PD_DEVICE_SPECIFIC_INFO = *mut _SCM_PD_DEVICE_SPECIFIC_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_SLOT_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SlotNumber: BYTE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Reserved1: [BYTE; 6usize],
    pub Revision: [BYTE; 32usize],
}
impl _SCM_PD_FIRMWARE_SLOT_INFO {
    #[inline]
    pub fn ReadOnly(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ReadOnly: BYTE, Reserved0: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SCM_PD_FIRMWARE_SLOT_INFO = _SCM_PD_FIRMWARE_SLOT_INFO;
pub type PSCM_PD_FIRMWARE_SLOT_INFO = *mut _SCM_PD_FIRMWARE_SLOT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ActiveSlot: BYTE,
    pub NextActiveSlot: BYTE,
    pub SlotCount: BYTE,
    pub Slots: [SCM_PD_FIRMWARE_SLOT_INFO; 1usize],
}
pub type SCM_PD_FIRMWARE_INFO = _SCM_PD_FIRMWARE_INFO;
pub type PSCM_PD_FIRMWARE_INFO = *mut _SCM_PD_FIRMWARE_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_HEALTH_STATUS {
    ScmPhysicalDeviceHealth_Unknown = 0,
    ScmPhysicalDeviceHealth_Unhealthy = 1,
    ScmPhysicalDeviceHealth_Warning = 2,
    ScmPhysicalDeviceHealth_Healthy = 3,
    ScmPhysicalDeviceHealth_Max = 4,
}
pub use self::_SCM_PD_HEALTH_STATUS as SCM_PD_HEALTH_STATUS;
pub type PSCM_PD_HEALTH_STATUS = *mut _SCM_PD_HEALTH_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_OPERATIONAL_STATUS {
    ScmPhysicalDeviceOpStatus_Unknown = 0,
    ScmPhysicalDeviceOpStatus_Ok = 1,
    ScmPhysicalDeviceOpStatus_PredictingFailure = 2,
    ScmPhysicalDeviceOpStatus_InService = 3,
    ScmPhysicalDeviceOpStatus_HardwareError = 4,
    ScmPhysicalDeviceOpStatus_NotUsable = 5,
    ScmPhysicalDeviceOpStatus_TransientError = 6,
    ScmPhysicalDeviceOpStatus_Missing = 7,
    ScmPhysicalDeviceOpStatus_Max = 8,
}
pub use self::_SCM_PD_OPERATIONAL_STATUS as SCM_PD_OPERATIONAL_STATUS;
pub type PSCM_PD_OPERATIONAL_STATUS = *mut _SCM_PD_OPERATIONAL_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_OPERATIONAL_STATUS_REASON {
    ScmPhysicalDeviceOpReason_Unknown = 0,
    ScmPhysicalDeviceOpReason_Media = 1,
    ScmPhysicalDeviceOpReason_ThresholdExceeded = 2,
    ScmPhysicalDeviceOpReason_LostData = 3,
    ScmPhysicalDeviceOpReason_EnergySource = 4,
    ScmPhysicalDeviceOpReason_Configuration = 5,
    ScmPhysicalDeviceOpReason_DeviceController = 6,
    ScmPhysicalDeviceOpReason_MediaController = 7,
    ScmPhysicalDeviceOpReason_Component = 8,
    ScmPhysicalDeviceOpReason_BackgroundOperation = 9,
    ScmPhysicalDeviceOpReason_InvalidFirmware = 10,
    ScmPhysicalDeviceOpReason_HealthCheck = 11,
    ScmPhysicalDeviceOpReason_LostDataPersistence = 12,
    ScmPhysicalDeviceOpReason_DisabledByPlatform = 13,
    ScmPhysicalDeviceOpReason_PermanentError = 14,
    ScmPhysicalDeviceOpReason_LostWritePersistence = 15,
    ScmPhysicalDeviceOpReason_FatalError = 16,
    ScmPhysicalDeviceOpReason_DataPersistenceLossImminent = 17,
    ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = 18,
    ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock = 19,
    ScmPhysicalDeviceOpReason_PerformanceDegradation = 20,
    ScmPhysicalDeviceOpReason_ExcessiveTemperature = 21,
    ScmPhysicalDeviceOpReason_InternalFailure = 22,
    ScmPhysicalDeviceOpReason_Max = 23,
}
pub use self::_SCM_PD_OPERATIONAL_STATUS_REASON as SCM_PD_OPERATIONAL_STATUS_REASON;
pub type PSCM_PD_OPERATIONAL_STATUS_REASON = *mut _SCM_PD_OPERATIONAL_STATUS_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_MANAGEMENT_STATUS {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Health: SCM_PD_HEALTH_STATUS,
    pub NumberOfOperationalStatus: DWORD,
    pub NumberOfAdditionalReasons: DWORD,
    pub OperationalStatus: [SCM_PD_OPERATIONAL_STATUS; 16usize],
    pub AdditionalReasons: [SCM_PD_OPERATIONAL_STATUS_REASON; 1usize],
}
pub type SCM_PD_MANAGEMENT_STATUS = _SCM_PD_MANAGEMENT_STATUS;
pub type PSCM_PD_MANAGEMENT_STATUS = *mut _SCM_PD_MANAGEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_LOCATION_STRING {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Location: [WCHAR; 1usize],
}
pub type SCM_PD_LOCATION_STRING = _SCM_PD_LOCATION_STRING;
pub type PSCM_PD_LOCATION_STRING = *mut _SCM_PD_LOCATION_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FRU_ID_STRING {
    pub Version: DWORD,
    pub Size: DWORD,
    pub IdentifierSize: DWORD,
    pub Identifier: [BYTE; 1usize],
}
pub type SCM_PD_FRU_ID_STRING = _SCM_PD_FRU_ID_STRING;
pub type PSCM_PD_FRU_ID_STRING = *mut _SCM_PD_FRU_ID_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_DOWNLOAD {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Slot: BYTE,
    pub Reserved: [BYTE; 3usize],
    pub Offset: DWORD64,
    pub FirmwareImageSizeInBytes: DWORD,
    pub FirmwareImage: [BYTE; 1usize],
}
pub type SCM_PD_FIRMWARE_DOWNLOAD = _SCM_PD_FIRMWARE_DOWNLOAD;
pub type PSCM_PD_FIRMWARE_DOWNLOAD = *mut _SCM_PD_FIRMWARE_DOWNLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_ACTIVATE {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Slot: BYTE,
}
pub type SCM_PD_FIRMWARE_ACTIVATE = _SCM_PD_FIRMWARE_ACTIVATE;
pub type PSCM_PD_FIRMWARE_ACTIVATE = *mut _SCM_PD_FIRMWARE_ACTIVATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_LAST_FW_ACTIVATION_STATUS {
    ScmPdLastFwActivationStatus_None = 0,
    ScmPdLastFwActivationStatus_Success = 1,
    ScmPdLastFwActivationStatus_FwNotFound = 2,
    ScmPdLastFwActivationStatus_ColdRebootRequired = 3,
    ScmPdLastFwActivaitonStatus_ActivationInProgress = 4,
    ScmPdLastFwActivaitonStatus_Retry = 5,
    ScmPdLastFwActivaitonStatus_FwUnsupported = 6,
    ScmPdLastFwActivaitonStatus_UnknownError = 7,
}
pub use self::_SCM_PD_LAST_FW_ACTIVATION_STATUS as SCM_PD_LAST_FW_ACTIVATION_STATUS;
pub type PSCM_PD_LAST_FW_ACTIVATION_STATUS = *mut _SCM_PD_LAST_FW_ACTIVATION_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_FIRMWARE_ACTIVATION_STATE {
    ScmPdFirmwareActivationState_Idle = 0,
    ScmPdFirmwareActivationState_Armed = 1,
    ScmPdFirmwareActivationState_Busy = 2,
}
pub use self::_SCM_PD_FIRMWARE_ACTIVATION_STATE as SCM_PD_FIRMWARE_ACTIVATION_STATE;
pub type PSCM_PD_FIRMWARE_ACTIVATION_STATE = *mut _SCM_PD_FIRMWARE_ACTIVATION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_RUNTIME_FW_ACTIVATION_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub LastFirmwareActivationStatus: SCM_PD_LAST_FW_ACTIVATION_STATUS,
    pub FirmwareActivationState: SCM_PD_FIRMWARE_ACTIVATION_STATE,
}
pub type SCM_PD_RUNTIME_FW_ACTIVATION_INFO = _SCM_PD_RUNTIME_FW_ACTIVATION_INFO;
pub type PSCM_PD_RUNTIME_FW_ACTIVATION_INFO = *mut _SCM_PD_RUNTIME_FW_ACTIVATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ProtocolGuid: GUID,
    pub DataSize: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type SCM_PD_PASSTHROUGH_INPUT = _SCM_PD_PASSTHROUGH_INPUT;
pub type PSCM_PD_PASSTHROUGH_INPUT = *mut _SCM_PD_PASSTHROUGH_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub ProtocolGuid: GUID,
    pub DataSize: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type SCM_PD_PASSTHROUGH_OUTPUT = _SCM_PD_PASSTHROUGH_OUTPUT;
pub type PSCM_PD_PASSTHROUGH_OUTPUT = *mut _SCM_PD_PASSTHROUGH_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
    pub Opcode: DWORD,
    pub OpcodeParametersLength: DWORD,
    pub OpcodeParameters: [BYTE; 1usize],
}
pub type SCM_PD_PASSTHROUGH_INVDIMM_INPUT = _SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
pub type PSCM_PD_PASSTHROUGH_INVDIMM_INPUT = *mut _SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
    pub GeneralStatus: WORD,
    pub ExtendedStatus: WORD,
    pub OutputDataLength: DWORD,
    pub OutputData: [BYTE; 1usize],
}
pub type SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
pub type PSCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = *mut _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_INPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Options: _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1 {
    #[inline]
    pub fn Overwrite(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Overwrite(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Overwrite: DWORD) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Overwrite: u32 = unsafe { ::std::mem::transmute(Overwrite) };
            Overwrite as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SCM_PD_REINITIALIZE_MEDIA_INPUT = _SCM_PD_REINITIALIZE_MEDIA_INPUT;
pub type PSCM_PD_REINITIALIZE_MEDIA_INPUT = *mut _SCM_PD_REINITIALIZE_MEDIA_INPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SCM_PD_MEDIA_REINITIALIZATION_STATUS {
    ScmPhysicalDeviceReinit_Success = 0,
    ScmPhysicalDeviceReinit_RebootNeeded = 1,
    ScmPhysicalDeviceReinit_ColdBootNeeded = 2,
    ScmPhysicalDeviceReinit_Max = 3,
}
pub use self::_SCM_PD_MEDIA_REINITIALIZATION_STATUS as SCM_PD_MEDIA_REINITIALIZATION_STATUS;
pub type PSCM_PD_MEDIA_REINITIALIZATION_STATUS = *mut _SCM_PD_MEDIA_REINITIALIZATION_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
}
pub type SCM_PD_REINITIALIZE_MEDIA_OUTPUT = _SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
pub type PSCM_PD_REINITIALIZE_MEDIA_OUTPUT = *mut _SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _MEDIA_TYPE {
    Unknown = 0,
    F5_1Pt2_512 = 1,
    F3_1Pt44_512 = 2,
    F3_2Pt88_512 = 3,
    F3_20Pt8_512 = 4,
    F3_720_512 = 5,
    F5_360_512 = 6,
    F5_320_512 = 7,
    F5_320_1024 = 8,
    F5_180_512 = 9,
    F5_160_512 = 10,
    RemovableMedia = 11,
    FixedMedia = 12,
    F3_120M_512 = 13,
    F3_640_512 = 14,
    F5_640_512 = 15,
    F5_720_512 = 16,
    F3_1Pt2_512 = 17,
    F3_1Pt23_1024 = 18,
    F5_1Pt23_1024 = 19,
    F3_128Mb_512 = 20,
    F3_230Mb_512 = 21,
    F8_256_128 = 22,
    F3_200Mb_512 = 23,
    F3_240M_512 = 24,
    F3_32M_512 = 25,
}
pub use self::_MEDIA_TYPE as MEDIA_TYPE;
pub type PMEDIA_TYPE = *mut _MEDIA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORMAT_PARAMETERS {
    pub MediaType: MEDIA_TYPE,
    pub StartCylinderNumber: DWORD,
    pub EndCylinderNumber: DWORD,
    pub StartHeadNumber: DWORD,
    pub EndHeadNumber: DWORD,
}
pub type FORMAT_PARAMETERS = _FORMAT_PARAMETERS;
pub type PFORMAT_PARAMETERS = *mut _FORMAT_PARAMETERS;
pub type BAD_TRACK_NUMBER = WORD;
pub type PBAD_TRACK_NUMBER = *mut WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORMAT_EX_PARAMETERS {
    pub MediaType: MEDIA_TYPE,
    pub StartCylinderNumber: DWORD,
    pub EndCylinderNumber: DWORD,
    pub StartHeadNumber: DWORD,
    pub EndHeadNumber: DWORD,
    pub FormatGapLength: WORD,
    pub SectorsPerTrack: WORD,
    pub SectorNumber: [WORD; 1usize],
}
pub type FORMAT_EX_PARAMETERS = _FORMAT_EX_PARAMETERS;
pub type PFORMAT_EX_PARAMETERS = *mut _FORMAT_EX_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_GEOMETRY {
    pub Cylinders: LARGE_INTEGER,
    pub MediaType: MEDIA_TYPE,
    pub TracksPerCylinder: DWORD,
    pub SectorsPerTrack: DWORD,
    pub BytesPerSector: DWORD,
}
pub type DISK_GEOMETRY = _DISK_GEOMETRY;
pub type PDISK_GEOMETRY = *mut _DISK_GEOMETRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION {
    pub StartingOffset: LARGE_INTEGER,
    pub PartitionLength: LARGE_INTEGER,
    pub HiddenSectors: DWORD,
    pub PartitionNumber: DWORD,
    pub PartitionType: BYTE,
    pub BootIndicator: BOOLEAN,
    pub RecognizedPartition: BOOLEAN,
    pub RewritePartition: BOOLEAN,
}
pub type PARTITION_INFORMATION = _PARTITION_INFORMATION;
pub type PPARTITION_INFORMATION = *mut _PARTITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PARTITION_INFORMATION {
    pub PartitionType: BYTE,
}
pub type SET_PARTITION_INFORMATION = _SET_PARTITION_INFORMATION;
pub type PSET_PARTITION_INFORMATION = *mut _SET_PARTITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DRIVE_LAYOUT_INFORMATION {
    pub PartitionCount: DWORD,
    pub Signature: DWORD,
    pub PartitionEntry: [PARTITION_INFORMATION; 1usize],
}
pub type DRIVE_LAYOUT_INFORMATION = _DRIVE_LAYOUT_INFORMATION;
pub type PDRIVE_LAYOUT_INFORMATION = *mut _DRIVE_LAYOUT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VERIFY_INFORMATION {
    pub StartingOffset: LARGE_INTEGER,
    pub Length: DWORD,
}
pub type VERIFY_INFORMATION = _VERIFY_INFORMATION;
pub type PVERIFY_INFORMATION = *mut _VERIFY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REASSIGN_BLOCKS {
    pub Reserved: WORD,
    pub Count: WORD,
    pub BlockNumber: [DWORD; 1usize],
}
pub type REASSIGN_BLOCKS = _REASSIGN_BLOCKS;
pub type PREASSIGN_BLOCKS = *mut _REASSIGN_BLOCKS;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _REASSIGN_BLOCKS_EX {
    pub Reserved: WORD,
    pub Count: WORD,
    pub BlockNumber: [LARGE_INTEGER; 1usize],
}
pub type REASSIGN_BLOCKS_EX = _REASSIGN_BLOCKS_EX;
pub type PREASSIGN_BLOCKS_EX = *mut _REASSIGN_BLOCKS_EX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PARTITION_STYLE {
    PARTITION_STYLE_MBR = 0,
    PARTITION_STYLE_GPT = 1,
    PARTITION_STYLE_RAW = 2,
}
pub use self::_PARTITION_STYLE as PARTITION_STYLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PARTITION_INFORMATION_GPT {
    pub PartitionType: GUID,
    pub PartitionId: GUID,
    pub Attributes: DWORD64,
    pub Name: [WCHAR; 36usize],
}
pub type PARTITION_INFORMATION_GPT = _PARTITION_INFORMATION_GPT;
pub type PPARTITION_INFORMATION_GPT = *mut _PARTITION_INFORMATION_GPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PARTITION_INFORMATION_MBR {
    pub PartitionType: BYTE,
    pub BootIndicator: BOOLEAN,
    pub RecognizedPartition: BOOLEAN,
    pub HiddenSectors: DWORD,
    pub PartitionId: GUID,
}
pub type PARTITION_INFORMATION_MBR = _PARTITION_INFORMATION_MBR;
pub type PPARTITION_INFORMATION_MBR = *mut _PARTITION_INFORMATION_MBR;
pub type SET_PARTITION_INFORMATION_MBR = SET_PARTITION_INFORMATION;
pub type SET_PARTITION_INFORMATION_GPT = PARTITION_INFORMATION_GPT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SET_PARTITION_INFORMATION_EX {
    pub PartitionStyle: PARTITION_STYLE,
    pub __bindgen_anon_1: _SET_PARTITION_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SET_PARTITION_INFORMATION_EX__bindgen_ty_1 {
    pub Mbr: SET_PARTITION_INFORMATION_MBR,
    pub Gpt: SET_PARTITION_INFORMATION_GPT,
}
pub type SET_PARTITION_INFORMATION_EX = _SET_PARTITION_INFORMATION_EX;
pub type PSET_PARTITION_INFORMATION_EX = *mut _SET_PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_DISK_GPT {
    pub DiskId: GUID,
    pub MaxPartitionCount: DWORD,
}
pub type CREATE_DISK_GPT = _CREATE_DISK_GPT;
pub type PCREATE_DISK_GPT = *mut _CREATE_DISK_GPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CREATE_DISK_MBR {
    pub Signature: DWORD,
}
pub type CREATE_DISK_MBR = _CREATE_DISK_MBR;
pub type PCREATE_DISK_MBR = *mut _CREATE_DISK_MBR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CREATE_DISK {
    pub PartitionStyle: PARTITION_STYLE,
    pub __bindgen_anon_1: _CREATE_DISK__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CREATE_DISK__bindgen_ty_1 {
    pub Mbr: CREATE_DISK_MBR,
    pub Gpt: CREATE_DISK_GPT,
}
pub type CREATE_DISK = _CREATE_DISK;
pub type PCREATE_DISK = *mut _CREATE_DISK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GET_LENGTH_INFORMATION {
    pub Length: LARGE_INTEGER,
}
pub type GET_LENGTH_INFORMATION = _GET_LENGTH_INFORMATION;
pub type PGET_LENGTH_INFORMATION = *mut _GET_LENGTH_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION_EX {
    pub PartitionStyle: PARTITION_STYLE,
    pub StartingOffset: LARGE_INTEGER,
    pub PartitionLength: LARGE_INTEGER,
    pub PartitionNumber: DWORD,
    pub RewritePartition: BOOLEAN,
    pub IsServicePartition: BOOLEAN,
    pub __bindgen_anon_1: _PARTITION_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PARTITION_INFORMATION_EX__bindgen_ty_1 {
    pub Mbr: PARTITION_INFORMATION_MBR,
    pub Gpt: PARTITION_INFORMATION_GPT,
}
pub type PARTITION_INFORMATION_EX = _PARTITION_INFORMATION_EX;
pub type PPARTITION_INFORMATION_EX = *mut _PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DRIVE_LAYOUT_INFORMATION_GPT {
    pub DiskId: GUID,
    pub StartingUsableOffset: LARGE_INTEGER,
    pub UsableLength: LARGE_INTEGER,
    pub MaxPartitionCount: DWORD,
}
pub type DRIVE_LAYOUT_INFORMATION_GPT = _DRIVE_LAYOUT_INFORMATION_GPT;
pub type PDRIVE_LAYOUT_INFORMATION_GPT = *mut _DRIVE_LAYOUT_INFORMATION_GPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVE_LAYOUT_INFORMATION_MBR {
    pub Signature: DWORD,
    pub CheckSum: DWORD,
}
pub type DRIVE_LAYOUT_INFORMATION_MBR = _DRIVE_LAYOUT_INFORMATION_MBR;
pub type PDRIVE_LAYOUT_INFORMATION_MBR = *mut _DRIVE_LAYOUT_INFORMATION_MBR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DRIVE_LAYOUT_INFORMATION_EX {
    pub PartitionStyle: DWORD,
    pub PartitionCount: DWORD,
    pub __bindgen_anon_1: _DRIVE_LAYOUT_INFORMATION_EX__bindgen_ty_1,
    pub PartitionEntry: [PARTITION_INFORMATION_EX; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DRIVE_LAYOUT_INFORMATION_EX__bindgen_ty_1 {
    pub Mbr: DRIVE_LAYOUT_INFORMATION_MBR,
    pub Gpt: DRIVE_LAYOUT_INFORMATION_GPT,
}
pub type DRIVE_LAYOUT_INFORMATION_EX = _DRIVE_LAYOUT_INFORMATION_EX;
pub type PDRIVE_LAYOUT_INFORMATION_EX = *mut _DRIVE_LAYOUT_INFORMATION_EX;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DETECTION_TYPE {
    DetectNone = 0,
    DetectInt13 = 1,
    DetectExInt13 = 2,
}
pub use self::_DETECTION_TYPE as DETECTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_INT13_INFO {
    pub DriveSelect: WORD,
    pub MaxCylinders: DWORD,
    pub SectorsPerTrack: WORD,
    pub MaxHeads: WORD,
    pub NumberDrives: WORD,
}
pub type DISK_INT13_INFO = _DISK_INT13_INFO;
pub type PDISK_INT13_INFO = *mut _DISK_INT13_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_EX_INT13_INFO {
    pub ExBufferSize: WORD,
    pub ExFlags: WORD,
    pub ExCylinders: DWORD,
    pub ExHeads: DWORD,
    pub ExSectorsPerTrack: DWORD,
    pub ExSectorsPerDrive: DWORD64,
    pub ExSectorSize: WORD,
    pub ExReserved: WORD,
}
pub type DISK_EX_INT13_INFO = _DISK_EX_INT13_INFO;
pub type PDISK_EX_INT13_INFO = *mut _DISK_EX_INT13_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_DETECTION_INFO {
    pub SizeOfDetectInfo: DWORD,
    pub DetectionType: DETECTION_TYPE,
    pub __bindgen_anon_1: _DISK_DETECTION_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISK_DETECTION_INFO__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISK_DETECTION_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_DETECTION_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub Int13: DISK_INT13_INFO,
    pub ExInt13: DISK_EX_INT13_INFO,
}
pub type DISK_DETECTION_INFO = _DISK_DETECTION_INFO;
pub type PDISK_DETECTION_INFO = *mut _DISK_DETECTION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_PARTITION_INFO {
    pub SizeOfPartitionInfo: DWORD,
    pub PartitionStyle: PARTITION_STYLE,
    pub __bindgen_anon_1: _DISK_PARTITION_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISK_PARTITION_INFO__bindgen_ty_1 {
    pub Mbr: _DISK_PARTITION_INFO__bindgen_ty_1__bindgen_ty_1,
    pub Gpt: _DISK_PARTITION_INFO__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_PARTITION_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub Signature: DWORD,
    pub CheckSum: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_PARTITION_INFO__bindgen_ty_1__bindgen_ty_2 {
    pub DiskId: GUID,
}
pub type DISK_PARTITION_INFO = _DISK_PARTITION_INFO;
pub type PDISK_PARTITION_INFO = *mut _DISK_PARTITION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_GEOMETRY_EX {
    pub Geometry: DISK_GEOMETRY,
    pub DiskSize: LARGE_INTEGER,
    pub Data: [BYTE; 1usize],
}
pub type DISK_GEOMETRY_EX = _DISK_GEOMETRY_EX;
pub type PDISK_GEOMETRY_EX = *mut _DISK_GEOMETRY_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_CONTROLLER_NUMBER {
    pub ControllerNumber: DWORD,
    pub DiskNumber: DWORD,
}
pub type DISK_CONTROLLER_NUMBER = _DISK_CONTROLLER_NUMBER;
pub type PDISK_CONTROLLER_NUMBER = *mut _DISK_CONTROLLER_NUMBER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DISK_CACHE_RETENTION_PRIORITY {
    EqualPriority = 0,
    KeepPrefetchedData = 1,
    KeepReadData = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_CACHE_INFORMATION {
    pub ParametersSavable: BOOLEAN,
    pub ReadCacheEnabled: BOOLEAN,
    pub WriteCacheEnabled: BOOLEAN,
    pub ReadRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    pub WriteRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    pub DisablePrefetchTransferLength: WORD,
    pub PrefetchScalar: BOOLEAN,
    pub __bindgen_anon_1: _DISK_CACHE_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISK_CACHE_INFORMATION__bindgen_ty_1 {
    pub ScalarPrefetch: _DISK_CACHE_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub BlockPrefetch: _DISK_CACHE_INFORMATION__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_CACHE_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Minimum: WORD,
    pub Maximum: WORD,
    pub MaximumBlocks: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_CACHE_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub Minimum: WORD,
    pub Maximum: WORD,
}
pub type DISK_CACHE_INFORMATION = _DISK_CACHE_INFORMATION;
pub type PDISK_CACHE_INFORMATION = *mut _DISK_CACHE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_GROW_PARTITION {
    pub PartitionNumber: DWORD,
    pub BytesToGrow: LARGE_INTEGER,
}
pub type DISK_GROW_PARTITION = _DISK_GROW_PARTITION;
pub type PDISK_GROW_PARTITION = *mut _DISK_GROW_PARTITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HISTOGRAM_BUCKET {
    pub Reads: DWORD,
    pub Writes: DWORD,
}
pub type HISTOGRAM_BUCKET = _HISTOGRAM_BUCKET;
pub type PHISTOGRAM_BUCKET = *mut _HISTOGRAM_BUCKET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_HISTOGRAM {
    pub DiskSize: LARGE_INTEGER,
    pub Start: LARGE_INTEGER,
    pub End: LARGE_INTEGER,
    pub Average: LARGE_INTEGER,
    pub AverageRead: LARGE_INTEGER,
    pub AverageWrite: LARGE_INTEGER,
    pub Granularity: DWORD,
    pub Size: DWORD,
    pub ReadCount: DWORD,
    pub WriteCount: DWORD,
    pub Histogram: PHISTOGRAM_BUCKET,
}
pub type DISK_HISTOGRAM = _DISK_HISTOGRAM;
pub type PDISK_HISTOGRAM = *mut _DISK_HISTOGRAM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_PERFORMANCE {
    pub BytesRead: LARGE_INTEGER,
    pub BytesWritten: LARGE_INTEGER,
    pub ReadTime: LARGE_INTEGER,
    pub WriteTime: LARGE_INTEGER,
    pub IdleTime: LARGE_INTEGER,
    pub ReadCount: DWORD,
    pub WriteCount: DWORD,
    pub QueueDepth: DWORD,
    pub SplitCount: DWORD,
    pub QueryTime: LARGE_INTEGER,
    pub StorageDeviceNumber: DWORD,
    pub StorageManagerName: [WCHAR; 8usize],
}
pub type DISK_PERFORMANCE = _DISK_PERFORMANCE;
pub type PDISK_PERFORMANCE = *mut _DISK_PERFORMANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_RECORD {
    pub ByteOffset: LARGE_INTEGER,
    pub StartTime: LARGE_INTEGER,
    pub EndTime: LARGE_INTEGER,
    pub VirtualAddress: PVOID,
    pub NumberOfBytes: DWORD,
    pub DeviceNumber: BYTE,
    pub ReadRequest: BOOLEAN,
}
pub type DISK_RECORD = _DISK_RECORD;
pub type PDISK_RECORD = *mut _DISK_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISK_LOGGING {
    pub Function: BYTE,
    pub BufferAddress: PVOID,
    pub BufferSize: DWORD,
}
pub type DISK_LOGGING = _DISK_LOGGING;
pub type PDISK_LOGGING = *mut _DISK_LOGGING;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _BIN_TYPES {
    RequestSize = 0,
    RequestLocation = 1,
}
pub use self::_BIN_TYPES as BIN_TYPES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIN_RANGE {
    pub StartValue: LARGE_INTEGER,
    pub Length: LARGE_INTEGER,
}
pub type BIN_RANGE = _BIN_RANGE;
pub type PBIN_RANGE = *mut _BIN_RANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PERF_BIN {
    pub NumberOfBins: DWORD,
    pub TypeOfBin: DWORD,
    pub BinsRanges: [BIN_RANGE; 1usize],
}
pub type PERF_BIN = _PERF_BIN;
pub type PPERF_BIN = *mut _PERF_BIN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIN_COUNT {
    pub BinRange: BIN_RANGE,
    pub BinCount: DWORD,
}
pub type BIN_COUNT = _BIN_COUNT;
pub type PBIN_COUNT = *mut _BIN_COUNT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIN_RESULTS {
    pub NumberOfBins: DWORD,
    pub BinCounts: [BIN_COUNT; 1usize],
}
pub type BIN_RESULTS = _BIN_RESULTS;
pub type PBIN_RESULTS = *mut _BIN_RESULTS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _GETVERSIONINPARAMS {
    pub bVersion: BYTE,
    pub bRevision: BYTE,
    pub bReserved: BYTE,
    pub bIDEDeviceMap: BYTE,
    pub fCapabilities: DWORD,
    pub dwReserved: [DWORD; 4usize],
}
pub type GETVERSIONINPARAMS = _GETVERSIONINPARAMS;
pub type PGETVERSIONINPARAMS = *mut _GETVERSIONINPARAMS;
pub type LPGETVERSIONINPARAMS = *mut _GETVERSIONINPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IDEREGS {
    pub bFeaturesReg: BYTE,
    pub bSectorCountReg: BYTE,
    pub bSectorNumberReg: BYTE,
    pub bCylLowReg: BYTE,
    pub bCylHighReg: BYTE,
    pub bDriveHeadReg: BYTE,
    pub bCommandReg: BYTE,
    pub bReserved: BYTE,
}
pub type IDEREGS = _IDEREGS;
pub type PIDEREGS = *mut _IDEREGS;
pub type LPIDEREGS = *mut _IDEREGS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SENDCMDINPARAMS {
    pub cBufferSize: DWORD,
    pub irDriveRegs: IDEREGS,
    pub bDriveNumber: BYTE,
    pub bReserved: [BYTE; 3usize],
    pub dwReserved: [DWORD; 4usize],
    pub bBuffer: [BYTE; 1usize],
}
pub type SENDCMDINPARAMS = _SENDCMDINPARAMS;
pub type PSENDCMDINPARAMS = *mut _SENDCMDINPARAMS;
pub type LPSENDCMDINPARAMS = *mut _SENDCMDINPARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVERSTATUS {
    pub bDriverError: BYTE,
    pub bIDEError: BYTE,
    pub bReserved: [BYTE; 2usize],
    pub dwReserved: [DWORD; 2usize],
}
pub type DRIVERSTATUS = _DRIVERSTATUS;
pub type PDRIVERSTATUS = *mut _DRIVERSTATUS;
pub type LPDRIVERSTATUS = *mut _DRIVERSTATUS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SENDCMDOUTPARAMS {
    pub cBufferSize: DWORD,
    pub DriverStatus: DRIVERSTATUS,
    pub bBuffer: [BYTE; 1usize],
}
pub type SENDCMDOUTPARAMS = _SENDCMDOUTPARAMS;
pub type PSENDCMDOUTPARAMS = *mut _SENDCMDOUTPARAMS;
pub type LPSENDCMDOUTPARAMS = *mut _SENDCMDOUTPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_DISK_ATTRIBUTES {
    pub Version: DWORD,
    pub Reserved1: DWORD,
    pub Attributes: DWORDLONG,
}
pub type GET_DISK_ATTRIBUTES = _GET_DISK_ATTRIBUTES;
pub type PGET_DISK_ATTRIBUTES = *mut _GET_DISK_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DISK_ATTRIBUTES {
    pub Version: DWORD,
    pub Persist: BOOLEAN,
    pub Reserved1: [BYTE; 3usize],
    pub Attributes: DWORDLONG,
    pub AttributesMask: DWORDLONG,
    pub Reserved2: [DWORD; 4usize],
}
pub type SET_DISK_ATTRIBUTES = _SET_DISK_ATTRIBUTES;
pub type PSET_DISK_ATTRIBUTES = *mut _SET_DISK_ATTRIBUTES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ELEMENT_TYPE {
    AllElements = 0,
    ChangerTransport = 1,
    ChangerSlot = 2,
    ChangerIEPort = 3,
    ChangerDrive = 4,
    ChangerDoor = 5,
    ChangerKeypad = 6,
    ChangerMaxElement = 7,
}
pub use self::_ELEMENT_TYPE as ELEMENT_TYPE;
pub type PELEMENT_TYPE = *mut _ELEMENT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_ELEMENT {
    pub ElementType: ELEMENT_TYPE,
    pub ElementAddress: DWORD,
}
pub type CHANGER_ELEMENT = _CHANGER_ELEMENT;
pub type PCHANGER_ELEMENT = *mut _CHANGER_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_ELEMENT_LIST {
    pub Element: CHANGER_ELEMENT,
    pub NumberOfElements: DWORD,
}
pub type CHANGER_ELEMENT_LIST = _CHANGER_ELEMENT_LIST;
pub type PCHANGER_ELEMENT_LIST = *mut _CHANGER_ELEMENT_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_CHANGER_PARAMETERS {
    pub Size: DWORD,
    pub NumberTransportElements: WORD,
    pub NumberStorageElements: WORD,
    pub NumberCleanerSlots: WORD,
    pub NumberIEElements: WORD,
    pub NumberDataTransferElements: WORD,
    pub NumberOfDoors: WORD,
    pub FirstSlotNumber: WORD,
    pub FirstDriveNumber: WORD,
    pub FirstTransportNumber: WORD,
    pub FirstIEPortNumber: WORD,
    pub FirstCleanerSlotAddress: WORD,
    pub MagazineSize: WORD,
    pub DriveCleanTimeout: DWORD,
    pub Features0: DWORD,
    pub Features1: DWORD,
    pub MoveFromTransport: BYTE,
    pub MoveFromSlot: BYTE,
    pub MoveFromIePort: BYTE,
    pub MoveFromDrive: BYTE,
    pub ExchangeFromTransport: BYTE,
    pub ExchangeFromSlot: BYTE,
    pub ExchangeFromIePort: BYTE,
    pub ExchangeFromDrive: BYTE,
    pub LockUnlockCapabilities: BYTE,
    pub PositionCapabilities: BYTE,
    pub Reserved1: [BYTE; 2usize],
    pub Reserved2: [DWORD; 2usize],
}
pub type GET_CHANGER_PARAMETERS = _GET_CHANGER_PARAMETERS;
pub type PGET_CHANGER_PARAMETERS = *mut _GET_CHANGER_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_PRODUCT_DATA {
    pub VendorId: [BYTE; 8usize],
    pub ProductId: [BYTE; 16usize],
    pub Revision: [BYTE; 4usize],
    pub SerialNumber: [BYTE; 32usize],
    pub DeviceType: BYTE,
}
pub type CHANGER_PRODUCT_DATA = _CHANGER_PRODUCT_DATA;
pub type PCHANGER_PRODUCT_DATA = *mut _CHANGER_PRODUCT_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_SET_ACCESS {
    pub Element: CHANGER_ELEMENT,
    pub Control: DWORD,
}
pub type CHANGER_SET_ACCESS = _CHANGER_SET_ACCESS;
pub type PCHANGER_SET_ACCESS = *mut _CHANGER_SET_ACCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_READ_ELEMENT_STATUS {
    pub ElementList: CHANGER_ELEMENT_LIST,
    pub VolumeTagInfo: BOOLEAN,
}
pub type CHANGER_READ_ELEMENT_STATUS = _CHANGER_READ_ELEMENT_STATUS;
pub type PCHANGER_READ_ELEMENT_STATUS = *mut _CHANGER_READ_ELEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_ELEMENT_STATUS {
    pub Element: CHANGER_ELEMENT,
    pub SrcElementAddress: CHANGER_ELEMENT,
    pub Flags: DWORD,
    pub ExceptionCode: DWORD,
    pub TargetId: BYTE,
    pub Lun: BYTE,
    pub Reserved: WORD,
    pub PrimaryVolumeID: [BYTE; 36usize],
    pub AlternateVolumeID: [BYTE; 36usize],
}
pub type CHANGER_ELEMENT_STATUS = _CHANGER_ELEMENT_STATUS;
pub type PCHANGER_ELEMENT_STATUS = *mut _CHANGER_ELEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_ELEMENT_STATUS_EX {
    pub Element: CHANGER_ELEMENT,
    pub SrcElementAddress: CHANGER_ELEMENT,
    pub Flags: DWORD,
    pub ExceptionCode: DWORD,
    pub TargetId: BYTE,
    pub Lun: BYTE,
    pub Reserved: WORD,
    pub PrimaryVolumeID: [BYTE; 36usize],
    pub AlternateVolumeID: [BYTE; 36usize],
    pub VendorIdentification: [BYTE; 8usize],
    pub ProductIdentification: [BYTE; 16usize],
    pub SerialNumber: [BYTE; 32usize],
}
pub type CHANGER_ELEMENT_STATUS_EX = _CHANGER_ELEMENT_STATUS_EX;
pub type PCHANGER_ELEMENT_STATUS_EX = *mut _CHANGER_ELEMENT_STATUS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_INITIALIZE_ELEMENT_STATUS {
    pub ElementList: CHANGER_ELEMENT_LIST,
    pub BarCodeScan: BOOLEAN,
}
pub type CHANGER_INITIALIZE_ELEMENT_STATUS = _CHANGER_INITIALIZE_ELEMENT_STATUS;
pub type PCHANGER_INITIALIZE_ELEMENT_STATUS = *mut _CHANGER_INITIALIZE_ELEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_SET_POSITION {
    pub Transport: CHANGER_ELEMENT,
    pub Destination: CHANGER_ELEMENT,
    pub Flip: BOOLEAN,
}
pub type CHANGER_SET_POSITION = _CHANGER_SET_POSITION;
pub type PCHANGER_SET_POSITION = *mut _CHANGER_SET_POSITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_EXCHANGE_MEDIUM {
    pub Transport: CHANGER_ELEMENT,
    pub Source: CHANGER_ELEMENT,
    pub Destination1: CHANGER_ELEMENT,
    pub Destination2: CHANGER_ELEMENT,
    pub Flip1: BOOLEAN,
    pub Flip2: BOOLEAN,
}
pub type CHANGER_EXCHANGE_MEDIUM = _CHANGER_EXCHANGE_MEDIUM;
pub type PCHANGER_EXCHANGE_MEDIUM = *mut _CHANGER_EXCHANGE_MEDIUM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_MOVE_MEDIUM {
    pub Transport: CHANGER_ELEMENT,
    pub Source: CHANGER_ELEMENT,
    pub Destination: CHANGER_ELEMENT,
    pub Flip: BOOLEAN,
}
pub type CHANGER_MOVE_MEDIUM = _CHANGER_MOVE_MEDIUM;
pub type PCHANGER_MOVE_MEDIUM = *mut _CHANGER_MOVE_MEDIUM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CHANGER_SEND_VOLUME_TAG_INFORMATION {
    pub StartingElement: CHANGER_ELEMENT,
    pub ActionCode: DWORD,
    pub VolumeIDTemplate: [BYTE; 40usize],
}
pub type CHANGER_SEND_VOLUME_TAG_INFORMATION = _CHANGER_SEND_VOLUME_TAG_INFORMATION;
pub type PCHANGER_SEND_VOLUME_TAG_INFORMATION = *mut _CHANGER_SEND_VOLUME_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _READ_ELEMENT_ADDRESS_INFO {
    pub NumberOfElements: DWORD,
    pub ElementStatus: [CHANGER_ELEMENT_STATUS; 1usize],
}
pub type READ_ELEMENT_ADDRESS_INFO = _READ_ELEMENT_ADDRESS_INFO;
pub type PREAD_ELEMENT_ADDRESS_INFO = *mut _READ_ELEMENT_ADDRESS_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CHANGER_DEVICE_PROBLEM_TYPE {
    DeviceProblemNone = 0,
    DeviceProblemHardware = 1,
    DeviceProblemCHMError = 2,
    DeviceProblemDoorOpen = 3,
    DeviceProblemCalibrationError = 4,
    DeviceProblemTargetFailure = 5,
    DeviceProblemCHMMoveError = 6,
    DeviceProblemCHMZeroError = 7,
    DeviceProblemCartridgeInsertError = 8,
    DeviceProblemPositionError = 9,
    DeviceProblemSensorError = 10,
    DeviceProblemCartridgeEjectError = 11,
    DeviceProblemGripperError = 12,
    DeviceProblemDriveError = 13,
}
pub use self::_CHANGER_DEVICE_PROBLEM_TYPE as CHANGER_DEVICE_PROBLEM_TYPE;
pub type PCHANGER_DEVICE_PROBLEM_TYPE = *mut _CHANGER_DEVICE_PROBLEM_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PATHNAME_BUFFER {
    pub PathNameLength: DWORD,
    pub Name: [WCHAR; 1usize],
}
pub type PATHNAME_BUFFER = _PATHNAME_BUFFER;
pub type PPATHNAME_BUFFER = *mut _PATHNAME_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_FAT_BPB_BUFFER {
    pub First0x24BytesOfBootSector: [BYTE; 36usize],
}
pub type FSCTL_QUERY_FAT_BPB_BUFFER = _FSCTL_QUERY_FAT_BPB_BUFFER;
pub type PFSCTL_QUERY_FAT_BPB_BUFFER = *mut _FSCTL_QUERY_FAT_BPB_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NTFS_VOLUME_DATA_BUFFER {
    pub VolumeSerialNumber: LARGE_INTEGER,
    pub NumberSectors: LARGE_INTEGER,
    pub TotalClusters: LARGE_INTEGER,
    pub FreeClusters: LARGE_INTEGER,
    pub TotalReserved: LARGE_INTEGER,
    pub BytesPerSector: DWORD,
    pub BytesPerCluster: DWORD,
    pub BytesPerFileRecordSegment: DWORD,
    pub ClustersPerFileRecordSegment: DWORD,
    pub MftValidDataLength: LARGE_INTEGER,
    pub MftStartLcn: LARGE_INTEGER,
    pub Mft2StartLcn: LARGE_INTEGER,
    pub MftZoneStart: LARGE_INTEGER,
    pub MftZoneEnd: LARGE_INTEGER,
}
pub type PNTFS_VOLUME_DATA_BUFFER = *mut NTFS_VOLUME_DATA_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTFS_EXTENDED_VOLUME_DATA {
    pub ByteCount: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub BytesPerPhysicalSector: DWORD,
    pub LfsMajorVersion: WORD,
    pub LfsMinorVersion: WORD,
    pub MaxDeviceTrimExtentCount: DWORD,
    pub MaxDeviceTrimByteCount: DWORD,
    pub MaxVolumeTrimExtentCount: DWORD,
    pub MaxVolumeTrimByteCount: DWORD,
}
pub type PNTFS_EXTENDED_VOLUME_DATA = *mut NTFS_EXTENDED_VOLUME_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct REFS_VOLUME_DATA_BUFFER {
    pub ByteCount: DWORD,
    pub MajorVersion: DWORD,
    pub MinorVersion: DWORD,
    pub BytesPerPhysicalSector: DWORD,
    pub VolumeSerialNumber: LARGE_INTEGER,
    pub NumberSectors: LARGE_INTEGER,
    pub TotalClusters: LARGE_INTEGER,
    pub FreeClusters: LARGE_INTEGER,
    pub TotalReserved: LARGE_INTEGER,
    pub BytesPerSector: DWORD,
    pub BytesPerCluster: DWORD,
    pub MaximumSizeOfResidentFile: LARGE_INTEGER,
    pub FastTierDataFillRatio: WORD,
    pub SlowTierDataFillRatio: WORD,
    pub DestagesFastTierToSlowTierRate: DWORD,
    pub Reserved: [LARGE_INTEGER; 9usize],
}
pub type PREFS_VOLUME_DATA_BUFFER = *mut REFS_VOLUME_DATA_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER {
    pub StartingLcn: LARGE_INTEGER,
}
pub type PSTARTING_LCN_INPUT_BUFFER = *mut STARTING_LCN_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER_EX {
    pub StartingLcn: LARGE_INTEGER,
    pub Flags: DWORD,
}
pub type PSTARTING_LCN_INPUT_BUFFER_EX = *mut STARTING_LCN_INPUT_BUFFER_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VOLUME_BITMAP_BUFFER {
    pub StartingLcn: LARGE_INTEGER,
    pub BitmapSize: LARGE_INTEGER,
    pub Buffer: [BYTE; 1usize],
}
pub type PVOLUME_BITMAP_BUFFER = *mut VOLUME_BITMAP_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_VCN_INPUT_BUFFER {
    pub StartingVcn: LARGE_INTEGER,
}
pub type PSTARTING_VCN_INPUT_BUFFER = *mut STARTING_VCN_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER {
    pub ExtentCount: DWORD,
    pub StartingVcn: LARGE_INTEGER,
    pub Extents: [RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1 {
    pub NextVcn: LARGE_INTEGER,
    pub Lcn: LARGE_INTEGER,
}
pub type PRETRIEVAL_POINTERS_BUFFER = *mut RETRIEVAL_POINTERS_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    pub ExtentCount: DWORD,
    pub StartingVcn: LARGE_INTEGER,
    pub Extents: [RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER__bindgen_ty_1 {
    pub NextVcn: LARGE_INTEGER,
    pub Lcn: LARGE_INTEGER,
    pub ReferenceCount: DWORD,
}
pub type PRETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = *mut RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RETRIEVAL_POINTER_COUNT {
    pub ExtentCount: DWORD,
}
pub type PRETRIEVAL_POINTER_COUNT = *mut RETRIEVAL_POINTER_COUNT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NTFS_FILE_RECORD_INPUT_BUFFER {
    pub FileReferenceNumber: LARGE_INTEGER,
}
pub type PNTFS_FILE_RECORD_INPUT_BUFFER = *mut NTFS_FILE_RECORD_INPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NTFS_FILE_RECORD_OUTPUT_BUFFER {
    pub FileReferenceNumber: LARGE_INTEGER,
    pub FileRecordLength: DWORD,
    pub FileRecordBuffer: [BYTE; 1usize],
}
pub type PNTFS_FILE_RECORD_OUTPUT_BUFFER = *mut NTFS_FILE_RECORD_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MOVE_FILE_DATA {
    pub FileHandle: HANDLE,
    pub StartingVcn: LARGE_INTEGER,
    pub StartingLcn: LARGE_INTEGER,
    pub ClusterCount: DWORD,
}
pub type PMOVE_FILE_DATA = *mut MOVE_FILE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MOVE_FILE_RECORD_DATA {
    pub FileHandle: HANDLE,
    pub SourceFileRecord: LARGE_INTEGER,
    pub TargetFileRecord: LARGE_INTEGER,
}
pub type PMOVE_FILE_RECORD_DATA = *mut MOVE_FILE_RECORD_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MOVE_FILE_DATA32 {
    pub FileHandle: UINT32,
    pub StartingVcn: LARGE_INTEGER,
    pub StartingLcn: LARGE_INTEGER,
    pub ClusterCount: DWORD,
}
pub type MOVE_FILE_DATA32 = _MOVE_FILE_DATA32;
pub type PMOVE_FILE_DATA32 = *mut _MOVE_FILE_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIND_BY_SID_DATA {
    pub Restart: DWORD,
    pub Sid: SID,
}
pub type PFIND_BY_SID_DATA = *mut FIND_BY_SID_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIND_BY_SID_OUTPUT {
    pub NextEntryOffset: DWORD,
    pub FileIndex: DWORD,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PFIND_BY_SID_OUTPUT = *mut FIND_BY_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MFT_ENUM_DATA_V0 {
    pub StartFileReferenceNumber: DWORDLONG,
    pub LowUsn: USN,
    pub HighUsn: USN,
}
pub type PMFT_ENUM_DATA_V0 = *mut MFT_ENUM_DATA_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MFT_ENUM_DATA_V1 {
    pub StartFileReferenceNumber: DWORDLONG,
    pub LowUsn: USN,
    pub HighUsn: USN,
    pub MinMajorVersion: WORD,
    pub MaxMajorVersion: WORD,
}
pub type PMFT_ENUM_DATA_V1 = *mut MFT_ENUM_DATA_V1;
pub type MFT_ENUM_DATA = MFT_ENUM_DATA_V1;
pub type PMFT_ENUM_DATA = *mut MFT_ENUM_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CREATE_USN_JOURNAL_DATA {
    pub MaximumSize: DWORDLONG,
    pub AllocationDelta: DWORDLONG,
}
pub type PCREATE_USN_JOURNAL_DATA = *mut CREATE_USN_JOURNAL_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READ_FILE_USN_DATA {
    pub MinMajorVersion: WORD,
    pub MaxMajorVersion: WORD,
}
pub type PREAD_FILE_USN_DATA = *mut READ_FILE_USN_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READ_USN_JOURNAL_DATA_V0 {
    pub StartUsn: USN,
    pub ReasonMask: DWORD,
    pub ReturnOnlyOnClose: DWORD,
    pub Timeout: DWORDLONG,
    pub BytesToWaitFor: DWORDLONG,
    pub UsnJournalID: DWORDLONG,
}
pub type PREAD_USN_JOURNAL_DATA_V0 = *mut READ_USN_JOURNAL_DATA_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READ_USN_JOURNAL_DATA_V1 {
    pub StartUsn: USN,
    pub ReasonMask: DWORD,
    pub ReturnOnlyOnClose: DWORD,
    pub Timeout: DWORDLONG,
    pub BytesToWaitFor: DWORDLONG,
    pub UsnJournalID: DWORDLONG,
    pub MinMajorVersion: WORD,
    pub MaxMajorVersion: WORD,
}
pub type PREAD_USN_JOURNAL_DATA_V1 = *mut READ_USN_JOURNAL_DATA_V1;
pub type READ_USN_JOURNAL_DATA = READ_USN_JOURNAL_DATA_V1;
pub type PREAD_USN_JOURNAL_DATA = *mut READ_USN_JOURNAL_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_TRACK_MODIFIED_RANGES {
    pub Flags: DWORD,
    pub Unused: DWORD,
    pub ChunkSize: DWORDLONG,
    pub FileSizeThreshold: LONGLONG,
}
pub type PUSN_TRACK_MODIFIED_RANGES = *mut USN_TRACK_MODIFIED_RANGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RANGE_TRACK_OUTPUT {
    pub Usn: USN,
}
pub type PUSN_RANGE_TRACK_OUTPUT = *mut USN_RANGE_TRACK_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct USN_RECORD_V2 {
    pub RecordLength: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub FileReferenceNumber: DWORDLONG,
    pub ParentFileReferenceNumber: DWORDLONG,
    pub Usn: USN,
    pub TimeStamp: LARGE_INTEGER,
    pub Reason: DWORD,
    pub SourceInfo: DWORD,
    pub SecurityId: DWORD,
    pub FileAttributes: DWORD,
    pub FileNameLength: WORD,
    pub FileNameOffset: WORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PUSN_RECORD_V2 = *mut USN_RECORD_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct USN_RECORD_V3 {
    pub RecordLength: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub FileReferenceNumber: FILE_ID_128,
    pub ParentFileReferenceNumber: FILE_ID_128,
    pub Usn: USN,
    pub TimeStamp: LARGE_INTEGER,
    pub Reason: DWORD,
    pub SourceInfo: DWORD,
    pub SecurityId: DWORD,
    pub FileAttributes: DWORD,
    pub FileNameLength: WORD,
    pub FileNameOffset: WORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PUSN_RECORD_V3 = *mut USN_RECORD_V3;
pub type USN_RECORD = USN_RECORD_V2;
pub type PUSN_RECORD = *mut USN_RECORD_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RECORD_COMMON_HEADER {
    pub RecordLength: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
}
pub type PUSN_RECORD_COMMON_HEADER = *mut USN_RECORD_COMMON_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RECORD_EXTENT {
    pub Offset: LONGLONG,
    pub Length: LONGLONG,
}
pub type PUSN_RECORD_EXTENT = *mut USN_RECORD_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_RECORD_V4 {
    pub Header: USN_RECORD_COMMON_HEADER,
    pub FileReferenceNumber: FILE_ID_128,
    pub ParentFileReferenceNumber: FILE_ID_128,
    pub Usn: USN,
    pub Reason: DWORD,
    pub SourceInfo: DWORD,
    pub RemainingExtents: DWORD,
    pub NumberOfExtents: WORD,
    pub ExtentSize: WORD,
    pub Extents: [USN_RECORD_EXTENT; 1usize],
}
pub type PUSN_RECORD_V4 = *mut USN_RECORD_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub union USN_RECORD_UNION {
    pub Header: USN_RECORD_COMMON_HEADER,
    pub V2: USN_RECORD_V2,
    pub V3: USN_RECORD_V3,
    pub V4: USN_RECORD_V4,
}
pub type PUSN_RECORD_UNION = *mut USN_RECORD_UNION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_JOURNAL_DATA_V0 {
    pub UsnJournalID: DWORDLONG,
    pub FirstUsn: USN,
    pub NextUsn: USN,
    pub LowestValidUsn: USN,
    pub MaxUsn: USN,
    pub MaximumSize: DWORDLONG,
    pub AllocationDelta: DWORDLONG,
}
pub type PUSN_JOURNAL_DATA_V0 = *mut USN_JOURNAL_DATA_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_JOURNAL_DATA_V1 {
    pub UsnJournalID: DWORDLONG,
    pub FirstUsn: USN,
    pub NextUsn: USN,
    pub LowestValidUsn: USN,
    pub MaxUsn: USN,
    pub MaximumSize: DWORDLONG,
    pub AllocationDelta: DWORDLONG,
    pub MinSupportedMajorVersion: WORD,
    pub MaxSupportedMajorVersion: WORD,
}
pub type PUSN_JOURNAL_DATA_V1 = *mut USN_JOURNAL_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USN_JOURNAL_DATA_V2 {
    pub UsnJournalID: DWORDLONG,
    pub FirstUsn: USN,
    pub NextUsn: USN,
    pub LowestValidUsn: USN,
    pub MaxUsn: USN,
    pub MaximumSize: DWORDLONG,
    pub AllocationDelta: DWORDLONG,
    pub MinSupportedMajorVersion: WORD,
    pub MaxSupportedMajorVersion: WORD,
    pub Flags: DWORD,
    pub RangeTrackChunkSize: DWORDLONG,
    pub RangeTrackFileSizeThreshold: LONGLONG,
}
pub type PUSN_JOURNAL_DATA_V2 = *mut USN_JOURNAL_DATA_V2;
pub type USN_JOURNAL_DATA = USN_JOURNAL_DATA_V1;
pub type PUSN_JOURNAL_DATA = *mut USN_JOURNAL_DATA_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DELETE_USN_JOURNAL_DATA {
    pub UsnJournalID: DWORDLONG,
    pub DeleteFlags: DWORD,
}
pub type PDELETE_USN_JOURNAL_DATA = *mut DELETE_USN_JOURNAL_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MARK_HANDLE_INFO {
    pub __bindgen_anon_1: _MARK_HANDLE_INFO__bindgen_ty_1,
    pub VolumeHandle: HANDLE,
    pub HandleInfo: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MARK_HANDLE_INFO__bindgen_ty_1 {
    pub UsnSourceInfo: DWORD,
    pub CopyNumber: DWORD,
}
pub type MARK_HANDLE_INFO = _MARK_HANDLE_INFO;
pub type PMARK_HANDLE_INFO = *mut _MARK_HANDLE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MARK_HANDLE_INFO32 {
    pub __bindgen_anon_1: _MARK_HANDLE_INFO32__bindgen_ty_1,
    pub VolumeHandle: UINT32,
    pub HandleInfo: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MARK_HANDLE_INFO32__bindgen_ty_1 {
    pub UsnSourceInfo: DWORD,
    pub CopyNumber: DWORD,
}
pub type MARK_HANDLE_INFO32 = _MARK_HANDLE_INFO32;
pub type PMARK_HANDLE_INFO32 = *mut _MARK_HANDLE_INFO32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BULK_SECURITY_TEST_DATA {
    pub DesiredAccess: ACCESS_MASK,
    pub SecurityIds: [DWORD; 1usize],
}
pub type PBULK_SECURITY_TEST_DATA = *mut BULK_SECURITY_TEST_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PREFETCH {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Prefetch: [DWORDLONG; 1usize],
}
pub type FILE_PREFETCH = _FILE_PREFETCH;
pub type PFILE_PREFETCH = *mut _FILE_PREFETCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PREFETCH_EX {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Context: PVOID,
    pub Prefetch: [DWORDLONG; 1usize],
}
pub type FILE_PREFETCH_EX = _FILE_PREFETCH_EX;
pub type PFILE_PREFETCH_EX = *mut _FILE_PREFETCH_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILESYSTEM_STATISTICS {
    pub FileSystemType: WORD,
    pub Version: WORD,
    pub SizeOfCompleteStructure: DWORD,
    pub UserFileReads: DWORD,
    pub UserFileReadBytes: DWORD,
    pub UserDiskReads: DWORD,
    pub UserFileWrites: DWORD,
    pub UserFileWriteBytes: DWORD,
    pub UserDiskWrites: DWORD,
    pub MetaDataReads: DWORD,
    pub MetaDataReadBytes: DWORD,
    pub MetaDataDiskReads: DWORD,
    pub MetaDataWrites: DWORD,
    pub MetaDataWriteBytes: DWORD,
    pub MetaDataDiskWrites: DWORD,
}
pub type FILESYSTEM_STATISTICS = _FILESYSTEM_STATISTICS;
pub type PFILESYSTEM_STATISTICS = *mut _FILESYSTEM_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAT_STATISTICS {
    pub CreateHits: DWORD,
    pub SuccessfulCreates: DWORD,
    pub FailedCreates: DWORD,
    pub NonCachedReads: DWORD,
    pub NonCachedReadBytes: DWORD,
    pub NonCachedWrites: DWORD,
    pub NonCachedWriteBytes: DWORD,
    pub NonCachedDiskReads: DWORD,
    pub NonCachedDiskWrites: DWORD,
}
pub type FAT_STATISTICS = _FAT_STATISTICS;
pub type PFAT_STATISTICS = *mut _FAT_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXFAT_STATISTICS {
    pub CreateHits: DWORD,
    pub SuccessfulCreates: DWORD,
    pub FailedCreates: DWORD,
    pub NonCachedReads: DWORD,
    pub NonCachedReadBytes: DWORD,
    pub NonCachedWrites: DWORD,
    pub NonCachedWriteBytes: DWORD,
    pub NonCachedDiskReads: DWORD,
    pub NonCachedDiskWrites: DWORD,
}
pub type EXFAT_STATISTICS = _EXFAT_STATISTICS;
pub type PEXFAT_STATISTICS = *mut _EXFAT_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS {
    pub LogFileFullExceptions: DWORD,
    pub OtherExceptions: DWORD,
    pub MftReads: DWORD,
    pub MftReadBytes: DWORD,
    pub MftWrites: DWORD,
    pub MftWriteBytes: DWORD,
    pub MftWritesUserLevel: _NTFS_STATISTICS__bindgen_ty_1,
    pub MftWritesFlushForLogFileFull: WORD,
    pub MftWritesLazyWriter: WORD,
    pub MftWritesUserRequest: WORD,
    pub Mft2Writes: DWORD,
    pub Mft2WriteBytes: DWORD,
    pub Mft2WritesUserLevel: _NTFS_STATISTICS__bindgen_ty_2,
    pub Mft2WritesFlushForLogFileFull: WORD,
    pub Mft2WritesLazyWriter: WORD,
    pub Mft2WritesUserRequest: WORD,
    pub RootIndexReads: DWORD,
    pub RootIndexReadBytes: DWORD,
    pub RootIndexWrites: DWORD,
    pub RootIndexWriteBytes: DWORD,
    pub BitmapReads: DWORD,
    pub BitmapReadBytes: DWORD,
    pub BitmapWrites: DWORD,
    pub BitmapWriteBytes: DWORD,
    pub BitmapWritesFlushForLogFileFull: WORD,
    pub BitmapWritesLazyWriter: WORD,
    pub BitmapWritesUserRequest: WORD,
    pub BitmapWritesUserLevel: _NTFS_STATISTICS__bindgen_ty_3,
    pub MftBitmapReads: DWORD,
    pub MftBitmapReadBytes: DWORD,
    pub MftBitmapWrites: DWORD,
    pub MftBitmapWriteBytes: DWORD,
    pub MftBitmapWritesFlushForLogFileFull: WORD,
    pub MftBitmapWritesLazyWriter: WORD,
    pub MftBitmapWritesUserRequest: WORD,
    pub MftBitmapWritesUserLevel: _NTFS_STATISTICS__bindgen_ty_4,
    pub UserIndexReads: DWORD,
    pub UserIndexReadBytes: DWORD,
    pub UserIndexWrites: DWORD,
    pub UserIndexWriteBytes: DWORD,
    pub LogFileReads: DWORD,
    pub LogFileReadBytes: DWORD,
    pub LogFileWrites: DWORD,
    pub LogFileWriteBytes: DWORD,
    pub Allocate: _NTFS_STATISTICS__bindgen_ty_5,
    pub DiskResourcesExhausted: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_1 {
    pub Write: WORD,
    pub Create: WORD,
    pub SetInfo: WORD,
    pub Flush: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_2 {
    pub Write: WORD,
    pub Create: WORD,
    pub SetInfo: WORD,
    pub Flush: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_3 {
    pub Write: WORD,
    pub Create: WORD,
    pub SetInfo: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_4 {
    pub Write: WORD,
    pub Create: WORD,
    pub SetInfo: WORD,
    pub Flush: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS__bindgen_ty_5 {
    pub Calls: DWORD,
    pub Clusters: DWORD,
    pub Hints: DWORD,
    pub RunsReturned: DWORD,
    pub HintsHonored: DWORD,
    pub HintsClusters: DWORD,
    pub Cache: DWORD,
    pub CacheClusters: DWORD,
    pub CacheMiss: DWORD,
    pub CacheMissClusters: DWORD,
}
pub type NTFS_STATISTICS = _NTFS_STATISTICS;
pub type PNTFS_STATISTICS = *mut _NTFS_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILESYSTEM_STATISTICS_EX {
    pub FileSystemType: WORD,
    pub Version: WORD,
    pub SizeOfCompleteStructure: DWORD,
    pub UserFileReads: DWORDLONG,
    pub UserFileReadBytes: DWORDLONG,
    pub UserDiskReads: DWORDLONG,
    pub UserFileWrites: DWORDLONG,
    pub UserFileWriteBytes: DWORDLONG,
    pub UserDiskWrites: DWORDLONG,
    pub MetaDataReads: DWORDLONG,
    pub MetaDataReadBytes: DWORDLONG,
    pub MetaDataDiskReads: DWORDLONG,
    pub MetaDataWrites: DWORDLONG,
    pub MetaDataWriteBytes: DWORDLONG,
    pub MetaDataDiskWrites: DWORDLONG,
}
pub type FILESYSTEM_STATISTICS_EX = _FILESYSTEM_STATISTICS_EX;
pub type PFILESYSTEM_STATISTICS_EX = *mut _FILESYSTEM_STATISTICS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX {
    pub LogFileFullExceptions: DWORD,
    pub OtherExceptions: DWORD,
    pub MftReads: DWORDLONG,
    pub MftReadBytes: DWORDLONG,
    pub MftWrites: DWORDLONG,
    pub MftWriteBytes: DWORDLONG,
    pub MftWritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_1,
    pub MftWritesFlushForLogFileFull: DWORD,
    pub MftWritesLazyWriter: DWORD,
    pub MftWritesUserRequest: DWORD,
    pub Mft2Writes: DWORDLONG,
    pub Mft2WriteBytes: DWORDLONG,
    pub Mft2WritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_2,
    pub Mft2WritesFlushForLogFileFull: DWORD,
    pub Mft2WritesLazyWriter: DWORD,
    pub Mft2WritesUserRequest: DWORD,
    pub RootIndexReads: DWORDLONG,
    pub RootIndexReadBytes: DWORDLONG,
    pub RootIndexWrites: DWORDLONG,
    pub RootIndexWriteBytes: DWORDLONG,
    pub BitmapReads: DWORDLONG,
    pub BitmapReadBytes: DWORDLONG,
    pub BitmapWrites: DWORDLONG,
    pub BitmapWriteBytes: DWORDLONG,
    pub BitmapWritesFlushForLogFileFull: DWORD,
    pub BitmapWritesLazyWriter: DWORD,
    pub BitmapWritesUserRequest: DWORD,
    pub BitmapWritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_3,
    pub MftBitmapReads: DWORDLONG,
    pub MftBitmapReadBytes: DWORDLONG,
    pub MftBitmapWrites: DWORDLONG,
    pub MftBitmapWriteBytes: DWORDLONG,
    pub MftBitmapWritesFlushForLogFileFull: DWORD,
    pub MftBitmapWritesLazyWriter: DWORD,
    pub MftBitmapWritesUserRequest: DWORD,
    pub MftBitmapWritesUserLevel: _NTFS_STATISTICS_EX__bindgen_ty_4,
    pub UserIndexReads: DWORDLONG,
    pub UserIndexReadBytes: DWORDLONG,
    pub UserIndexWrites: DWORDLONG,
    pub UserIndexWriteBytes: DWORDLONG,
    pub LogFileReads: DWORDLONG,
    pub LogFileReadBytes: DWORDLONG,
    pub LogFileWrites: DWORDLONG,
    pub LogFileWriteBytes: DWORDLONG,
    pub Allocate: _NTFS_STATISTICS_EX__bindgen_ty_5,
    pub DiskResourcesExhausted: DWORD,
    pub VolumeTrimCount: DWORDLONG,
    pub VolumeTrimTime: DWORDLONG,
    pub VolumeTrimByteCount: DWORDLONG,
    pub FileLevelTrimCount: DWORDLONG,
    pub FileLevelTrimTime: DWORDLONG,
    pub FileLevelTrimByteCount: DWORDLONG,
    pub VolumeTrimSkippedCount: DWORDLONG,
    pub VolumeTrimSkippedByteCount: DWORDLONG,
    pub NtfsFillStatInfoFromMftRecordCalledCount: DWORDLONG,
    pub NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount: DWORDLONG,
    pub NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount: DWORDLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_1 {
    pub Write: DWORD,
    pub Create: DWORD,
    pub SetInfo: DWORD,
    pub Flush: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_2 {
    pub Write: DWORD,
    pub Create: DWORD,
    pub SetInfo: DWORD,
    pub Flush: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_3 {
    pub Write: DWORD,
    pub Create: DWORD,
    pub SetInfo: DWORD,
    pub Flush: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_4 {
    pub Write: DWORD,
    pub Create: DWORD,
    pub SetInfo: DWORD,
    pub Flush: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NTFS_STATISTICS_EX__bindgen_ty_5 {
    pub Calls: DWORD,
    pub RunsReturned: DWORD,
    pub Hints: DWORD,
    pub HintsHonored: DWORD,
    pub Cache: DWORD,
    pub CacheMiss: DWORD,
    pub Clusters: DWORDLONG,
    pub HintsClusters: DWORDLONG,
    pub CacheClusters: DWORDLONG,
    pub CacheMissClusters: DWORDLONG,
}
pub type NTFS_STATISTICS_EX = _NTFS_STATISTICS_EX;
pub type PNTFS_STATISTICS_EX = *mut _NTFS_STATISTICS_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_BUFFER {
    pub ObjectId: [BYTE; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_BUFFER__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_BUFFER__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [BYTE; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_BUFFER__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [BYTE; 16usize],
    pub BirthObjectId: [BYTE; 16usize],
    pub DomainId: [BYTE; 16usize],
}
pub type FILE_OBJECTID_BUFFER = _FILE_OBJECTID_BUFFER;
pub type PFILE_OBJECTID_BUFFER = *mut _FILE_OBJECTID_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SET_SPARSE_BUFFER {
    pub SetSparse: BOOLEAN,
}
pub type FILE_SET_SPARSE_BUFFER = _FILE_SET_SPARSE_BUFFER;
pub type PFILE_SET_SPARSE_BUFFER = *mut _FILE_SET_SPARSE_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ZERO_DATA_INFORMATION {
    pub FileOffset: LARGE_INTEGER,
    pub BeyondFinalZero: LARGE_INTEGER,
}
pub type FILE_ZERO_DATA_INFORMATION = _FILE_ZERO_DATA_INFORMATION;
pub type PFILE_ZERO_DATA_INFORMATION = *mut _FILE_ZERO_DATA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ZERO_DATA_INFORMATION_EX {
    pub FileOffset: LARGE_INTEGER,
    pub BeyondFinalZero: LARGE_INTEGER,
    pub Flags: DWORD,
}
pub type FILE_ZERO_DATA_INFORMATION_EX = _FILE_ZERO_DATA_INFORMATION_EX;
pub type PFILE_ZERO_DATA_INFORMATION_EX = *mut _FILE_ZERO_DATA_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATED_RANGE_BUFFER {
    pub FileOffset: LARGE_INTEGER,
    pub Length: LARGE_INTEGER,
}
pub type FILE_ALLOCATED_RANGE_BUFFER = _FILE_ALLOCATED_RANGE_BUFFER;
pub type PFILE_ALLOCATED_RANGE_BUFFER = *mut _FILE_ALLOCATED_RANGE_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_BUFFER {
    pub EncryptionOperation: DWORD,
    pub Private: [BYTE; 1usize],
}
pub type ENCRYPTION_BUFFER = _ENCRYPTION_BUFFER;
pub type PENCRYPTION_BUFFER = *mut _ENCRYPTION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DECRYPTION_STATUS_BUFFER {
    pub NoEncryptedStreams: BOOLEAN,
}
pub type DECRYPTION_STATUS_BUFFER = _DECRYPTION_STATUS_BUFFER;
pub type PDECRYPTION_STATUS_BUFFER = *mut _DECRYPTION_STATUS_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_RAW_ENCRYPTED_DATA {
    pub FileOffset: LONGLONG,
    pub Length: DWORD,
}
pub type REQUEST_RAW_ENCRYPTED_DATA = _REQUEST_RAW_ENCRYPTED_DATA;
pub type PREQUEST_RAW_ENCRYPTED_DATA = *mut _REQUEST_RAW_ENCRYPTED_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTED_DATA_INFO {
    pub StartingFileOffset: DWORDLONG,
    pub OutputBufferOffset: DWORD,
    pub BytesWithinFileSize: DWORD,
    pub BytesWithinValidDataLength: DWORD,
    pub CompressionFormat: WORD,
    pub DataUnitShift: BYTE,
    pub ChunkShift: BYTE,
    pub ClusterShift: BYTE,
    pub EncryptionFormat: BYTE,
    pub NumberOfDataBlocks: WORD,
    pub DataBlockSize: [DWORD; 1usize],
}
pub type ENCRYPTED_DATA_INFO = _ENCRYPTED_DATA_INFO;
pub type PENCRYPTED_DATA_INFO = *mut _ENCRYPTED_DATA_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXTENDED_ENCRYPTED_DATA_INFO {
    pub ExtendedCode: DWORD,
    pub Length: DWORD,
    pub Flags: DWORD,
    pub Reserved: DWORD,
}
pub type EXTENDED_ENCRYPTED_DATA_INFO = _EXTENDED_ENCRYPTED_DATA_INFO;
pub type PEXTENDED_ENCRYPTED_DATA_INFO = *mut _EXTENDED_ENCRYPTED_DATA_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PLEX_READ_DATA_REQUEST {
    pub ByteOffset: LARGE_INTEGER,
    pub ByteLength: DWORD,
    pub PlexNumber: DWORD,
}
pub type PLEX_READ_DATA_REQUEST = _PLEX_READ_DATA_REQUEST;
pub type PPLEX_READ_DATA_REQUEST = *mut _PLEX_READ_DATA_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SI_COPYFILE {
    pub SourceFileNameLength: DWORD,
    pub DestinationFileNameLength: DWORD,
    pub Flags: DWORD,
    pub FileNameBuffer: [WCHAR; 1usize],
}
pub type SI_COPYFILE = _SI_COPYFILE;
pub type PSI_COPYFILE = *mut _SI_COPYFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAKE_COMPATIBLE_BUFFER {
    pub CloseDisc: BOOLEAN,
}
pub type FILE_MAKE_COMPATIBLE_BUFFER = _FILE_MAKE_COMPATIBLE_BUFFER;
pub type PFILE_MAKE_COMPATIBLE_BUFFER = *mut _FILE_MAKE_COMPATIBLE_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SET_DEFECT_MGMT_BUFFER {
    pub Disable: BOOLEAN,
}
pub type FILE_SET_DEFECT_MGMT_BUFFER = _FILE_SET_DEFECT_MGMT_BUFFER;
pub type PFILE_SET_DEFECT_MGMT_BUFFER = *mut _FILE_SET_DEFECT_MGMT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_QUERY_SPARING_BUFFER {
    pub SparingUnitBytes: DWORD,
    pub SoftwareSparing: BOOLEAN,
    pub TotalSpareBlocks: DWORD,
    pub FreeSpareBlocks: DWORD,
}
pub type FILE_QUERY_SPARING_BUFFER = _FILE_QUERY_SPARING_BUFFER;
pub type PFILE_QUERY_SPARING_BUFFER = *mut _FILE_QUERY_SPARING_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    pub DirectoryCount: LARGE_INTEGER,
    pub FileCount: LARGE_INTEGER,
    pub FsFormatMajVersion: WORD,
    pub FsFormatMinVersion: WORD,
    pub FsFormatName: [WCHAR; 12usize],
    pub FormatTime: LARGE_INTEGER,
    pub LastUpdateTime: LARGE_INTEGER,
    pub CopyrightInfo: [WCHAR; 34usize],
    pub AbstractInfo: [WCHAR; 34usize],
    pub FormattingImplementationInfo: [WCHAR; 34usize],
    pub LastModifyingImplementationInfo: [WCHAR; 34usize],
}
pub type FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub type PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER = *mut _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub type CLSN = DWORDLONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    pub Hint1: DWORDLONG,
    pub Hint2: DWORDLONG,
    pub Clsn: CLSN,
    pub Status: DWORD,
}
pub type FILE_INITIATE_REPAIR_OUTPUT_BUFFER = _FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
pub type PFILE_INITIATE_REPAIR_OUTPUT_BUFFER = *mut _FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SHRINK_VOLUME_REQUEST_TYPES {
    ShrinkPrepare = 1,
    ShrinkCommit = 2,
    ShrinkAbort = 3,
}
pub use self::_SHRINK_VOLUME_REQUEST_TYPES as SHRINK_VOLUME_REQUEST_TYPES;
pub type PSHRINK_VOLUME_REQUEST_TYPES = *mut _SHRINK_VOLUME_REQUEST_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHRINK_VOLUME_INFORMATION {
    pub ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
    pub Flags: DWORDLONG,
    pub NewNumberOfSectors: LONGLONG,
}
pub type SHRINK_VOLUME_INFORMATION = _SHRINK_VOLUME_INFORMATION;
pub type PSHRINK_VOLUME_INFORMATION = *mut _SHRINK_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_MODIFY_RM {
    pub Flags: DWORD,
    pub LogContainerCountMax: DWORD,
    pub LogContainerCountMin: DWORD,
    pub LogContainerCount: DWORD,
    pub LogGrowthIncrement: DWORD,
    pub LogAutoShrinkPercentage: DWORD,
    pub Reserved: DWORDLONG,
    pub LoggingMode: WORD,
}
pub type TXFS_MODIFY_RM = _TXFS_MODIFY_RM;
pub type PTXFS_MODIFY_RM = *mut _TXFS_MODIFY_RM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TXFS_QUERY_RM_INFORMATION {
    pub BytesRequired: DWORD,
    pub TailLsn: DWORDLONG,
    pub CurrentLsn: DWORDLONG,
    pub ArchiveTailLsn: DWORDLONG,
    pub LogContainerSize: DWORDLONG,
    pub HighestVirtualClock: LARGE_INTEGER,
    pub LogContainerCount: DWORD,
    pub LogContainerCountMax: DWORD,
    pub LogContainerCountMin: DWORD,
    pub LogGrowthIncrement: DWORD,
    pub LogAutoShrinkPercentage: DWORD,
    pub Flags: DWORD,
    pub LoggingMode: WORD,
    pub Reserved: WORD,
    pub RmState: DWORD,
    pub LogCapacity: DWORDLONG,
    pub LogFree: DWORDLONG,
    pub TopsSize: DWORDLONG,
    pub TopsUsed: DWORDLONG,
    pub TransactionCount: DWORDLONG,
    pub OnePCCount: DWORDLONG,
    pub TwoPCCount: DWORDLONG,
    pub NumberLogFileFull: DWORDLONG,
    pub OldestTransactionAge: DWORDLONG,
    pub RMName: GUID,
    pub TmLogPathOffset: DWORD,
}
pub type TXFS_QUERY_RM_INFORMATION = _TXFS_QUERY_RM_INFORMATION;
pub type PTXFS_QUERY_RM_INFORMATION = *mut _TXFS_QUERY_RM_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
    pub LastVirtualClock: LARGE_INTEGER,
    pub LastRedoLsn: DWORDLONG,
    pub HighestRecoveryLsn: DWORDLONG,
    pub Flags: DWORD,
}
pub type TXFS_ROLLFORWARD_REDO_INFORMATION = _TXFS_ROLLFORWARD_REDO_INFORMATION;
pub type PTXFS_ROLLFORWARD_REDO_INFORMATION = *mut _TXFS_ROLLFORWARD_REDO_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_START_RM_INFORMATION {
    pub Flags: DWORD,
    pub LogContainerSize: DWORDLONG,
    pub LogContainerCountMin: DWORD,
    pub LogContainerCountMax: DWORD,
    pub LogGrowthIncrement: DWORD,
    pub LogAutoShrinkPercentage: DWORD,
    pub TmLogPathOffset: DWORD,
    pub TmLogPathLength: WORD,
    pub LoggingMode: WORD,
    pub LogPathLength: WORD,
    pub Reserved: WORD,
    pub LogPath: [WCHAR; 1usize],
}
pub type TXFS_START_RM_INFORMATION = _TXFS_START_RM_INFORMATION;
pub type PTXFS_START_RM_INFORMATION = *mut _TXFS_START_RM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_GET_METADATA_INFO_OUT {
    pub TxfFileId: _TXFS_GET_METADATA_INFO_OUT__bindgen_ty_1,
    pub LockingTransaction: GUID,
    pub LastLsn: DWORDLONG,
    pub TransactionState: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_GET_METADATA_INFO_OUT__bindgen_ty_1 {
    pub LowPart: LONGLONG,
    pub HighPart: LONGLONG,
}
pub type TXFS_GET_METADATA_INFO_OUT = _TXFS_GET_METADATA_INFO_OUT;
pub type PTXFS_GET_METADATA_INFO_OUT = *mut _TXFS_GET_METADATA_INFO_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    pub Offset: DWORDLONG,
    pub NameFlags: DWORD,
    pub FileId: LONGLONG,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD,
    pub Reserved3: LONGLONG,
    pub FileName: [WCHAR; 1usize],
}
pub type TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
pub type PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = *mut _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {
    pub KtmTransaction: GUID,
    pub NumberOfFiles: DWORDLONG,
    pub BufferSizeRequired: DWORDLONG,
    pub Offset: DWORDLONG,
}
pub type TXFS_LIST_TRANSACTION_LOCKED_FILES = _TXFS_LIST_TRANSACTION_LOCKED_FILES;
pub type PTXFS_LIST_TRANSACTION_LOCKED_FILES = *mut _TXFS_LIST_TRANSACTION_LOCKED_FILES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTIONS_ENTRY {
    pub TransactionId: GUID,
    pub TransactionState: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD,
    pub Reserved3: LONGLONG,
}
pub type TXFS_LIST_TRANSACTIONS_ENTRY = _TXFS_LIST_TRANSACTIONS_ENTRY;
pub type PTXFS_LIST_TRANSACTIONS_ENTRY = *mut _TXFS_LIST_TRANSACTIONS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_LIST_TRANSACTIONS {
    pub NumberOfTransactions: DWORDLONG,
    pub BufferSizeRequired: DWORDLONG,
}
pub type TXFS_LIST_TRANSACTIONS = _TXFS_LIST_TRANSACTIONS;
pub type PTXFS_LIST_TRANSACTIONS = *mut _TXFS_LIST_TRANSACTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TXFS_READ_BACKUP_INFORMATION_OUT {
    pub __bindgen_anon_1: _TXFS_READ_BACKUP_INFORMATION_OUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TXFS_READ_BACKUP_INFORMATION_OUT__bindgen_ty_1 {
    pub BufferLength: DWORD,
    pub Buffer: [BYTE; 1usize],
}
pub type TXFS_READ_BACKUP_INFORMATION_OUT = _TXFS_READ_BACKUP_INFORMATION_OUT;
pub type PTXFS_READ_BACKUP_INFORMATION_OUT = *mut _TXFS_READ_BACKUP_INFORMATION_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_WRITE_BACKUP_INFORMATION {
    pub Buffer: [BYTE; 1usize],
}
pub type TXFS_WRITE_BACKUP_INFORMATION = _TXFS_WRITE_BACKUP_INFORMATION;
pub type PTXFS_WRITE_BACKUP_INFORMATION = *mut _TXFS_WRITE_BACKUP_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_GET_TRANSACTED_VERSION {
    pub ThisBaseVersion: DWORD,
    pub LatestVersion: DWORD,
    pub ThisMiniVersion: WORD,
    pub FirstMiniVersion: WORD,
    pub LatestMiniVersion: WORD,
}
pub type TXFS_GET_TRANSACTED_VERSION = _TXFS_GET_TRANSACTED_VERSION;
pub type PTXFS_GET_TRANSACTED_VERSION = *mut _TXFS_GET_TRANSACTED_VERSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_SAVEPOINT_INFORMATION {
    pub KtmTransaction: HANDLE,
    pub ActionCode: DWORD,
    pub SavepointId: DWORD,
}
pub type TXFS_SAVEPOINT_INFORMATION = _TXFS_SAVEPOINT_INFORMATION;
pub type PTXFS_SAVEPOINT_INFORMATION = *mut _TXFS_SAVEPOINT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_CREATE_MINIVERSION_INFO {
    pub StructureVersion: WORD,
    pub StructureLength: WORD,
    pub BaseVersion: DWORD,
    pub MiniVersion: WORD,
}
pub type TXFS_CREATE_MINIVERSION_INFO = _TXFS_CREATE_MINIVERSION_INFO;
pub type PTXFS_CREATE_MINIVERSION_INFO = *mut _TXFS_CREATE_MINIVERSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXFS_TRANSACTION_ACTIVE_INFO {
    pub TransactionsActiveAtSnapshot: BOOLEAN,
}
pub type TXFS_TRANSACTION_ACTIVE_INFO = _TXFS_TRANSACTION_ACTIVE_INFO;
pub type PTXFS_TRANSACTION_ACTIVE_INFO = *mut _TXFS_TRANSACTION_ACTIVE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BOOT_AREA_INFO {
    pub BootSectorCount: DWORD,
    pub BootSectors: [_BOOT_AREA_INFO__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BOOT_AREA_INFO__bindgen_ty_1 {
    pub Offset: LARGE_INTEGER,
}
pub type BOOT_AREA_INFO = _BOOT_AREA_INFO;
pub type PBOOT_AREA_INFO = *mut _BOOT_AREA_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RETRIEVAL_POINTER_BASE {
    pub FileAreaOffset: LARGE_INTEGER,
}
pub type RETRIEVAL_POINTER_BASE = _RETRIEVAL_POINTER_BASE;
pub type PRETRIEVAL_POINTER_BASE = *mut _RETRIEVAL_POINTER_BASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    pub VolumeFlags: DWORD,
    pub FlagMask: DWORD,
    pub Version: DWORD,
    pub Reserved: DWORD,
}
pub type FILE_FS_PERSISTENT_VOLUME_INFORMATION = _FILE_FS_PERSISTENT_VOLUME_INFORMATION;
pub type PFILE_FS_PERSISTENT_VOLUME_INFORMATION = *mut _FILE_FS_PERSISTENT_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SYSTEM_RECOGNITION_INFORMATION {
    pub FileSystem: [CHAR; 9usize],
}
pub type FILE_SYSTEM_RECOGNITION_INFORMATION = _FILE_SYSTEM_RECOGNITION_INFORMATION;
pub type PFILE_SYSTEM_RECOGNITION_INFORMATION = *mut _FILE_SYSTEM_RECOGNITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_OPLOCK_INPUT_BUFFER {
    pub StructureVersion: WORD,
    pub StructureLength: WORD,
    pub RequestedOplockLevel: DWORD,
    pub Flags: DWORD,
}
pub type REQUEST_OPLOCK_INPUT_BUFFER = _REQUEST_OPLOCK_INPUT_BUFFER;
pub type PREQUEST_OPLOCK_INPUT_BUFFER = *mut _REQUEST_OPLOCK_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REQUEST_OPLOCK_OUTPUT_BUFFER {
    pub StructureVersion: WORD,
    pub StructureLength: WORD,
    pub OriginalOplockLevel: DWORD,
    pub NewOplockLevel: DWORD,
    pub Flags: DWORD,
    pub AccessMode: ACCESS_MASK,
    pub ShareMode: WORD,
}
pub type REQUEST_OPLOCK_OUTPUT_BUFFER = _REQUEST_OPLOCK_OUTPUT_BUFFER;
pub type PREQUEST_OPLOCK_OUTPUT_BUFFER = *mut _REQUEST_OPLOCK_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_STORAGE_TYPE {
    pub DeviceId: DWORD,
    pub VendorId: GUID,
}
pub type VIRTUAL_STORAGE_TYPE = _VIRTUAL_STORAGE_TYPE;
pub type PVIRTUAL_STORAGE_TYPE = *mut _VIRTUAL_STORAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    pub RequestLevel: DWORD,
    pub RequestFlags: DWORD,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = *mut _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    pub EntryLength: DWORD,
    pub DependencyTypeFlags: DWORD,
    pub ProviderSpecificFlags: DWORD,
    pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY =
    *mut _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    pub EntryLength: DWORD,
    pub DependencyTypeFlags: DWORD,
    pub ProviderSpecificFlags: DWORD,
    pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    pub AncestorLevel: DWORD,
    pub HostVolumeNameOffset: DWORD,
    pub HostVolumeNameSize: DWORD,
    pub DependentVolumeNameOffset: DWORD,
    pub DependentVolumeNameSize: DWORD,
    pub RelativePathOffset: DWORD,
    pub RelativePathSize: DWORD,
    pub DependentDeviceNameOffset: DWORD,
    pub DependentDeviceNameSize: DWORD,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY =
    *mut _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    pub ResponseLevel: DWORD,
    pub NumberEntries: DWORD,
    pub __bindgen_anon_1: _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1 {
    pub Lev1Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY; 0usize]>,
    pub Lev2Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY; 0usize]>,
    pub bindgen_union_field: u32,
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
pub type PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = *mut _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_INPUT {
    pub CurrentMachineSIDOffset: WORD,
    pub CurrentMachineSIDLength: WORD,
    pub NewMachineSIDOffset: WORD,
    pub NewMachineSIDLength: WORD,
}
pub type SD_CHANGE_MACHINE_SID_INPUT = _SD_CHANGE_MACHINE_SID_INPUT;
pub type PSD_CHANGE_MACHINE_SID_INPUT = *mut _SD_CHANGE_MACHINE_SID_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_OUTPUT {
    pub NumSDChangedSuccess: DWORDLONG,
    pub NumSDChangedFail: DWORDLONG,
    pub NumSDUnused: DWORDLONG,
    pub NumSDTotal: DWORDLONG,
    pub NumMftSDChangedSuccess: DWORDLONG,
    pub NumMftSDChangedFail: DWORDLONG,
    pub NumMftSDTotal: DWORDLONG,
}
pub type SD_CHANGE_MACHINE_SID_OUTPUT = _SD_CHANGE_MACHINE_SID_OUTPUT;
pub type PSD_CHANGE_MACHINE_SID_OUTPUT = *mut _SD_CHANGE_MACHINE_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_INPUT {
    pub Reserved: DWORD,
}
pub type SD_QUERY_STATS_INPUT = _SD_QUERY_STATS_INPUT;
pub type PSD_QUERY_STATS_INPUT = *mut _SD_QUERY_STATS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_OUTPUT {
    pub SdsStreamSize: DWORDLONG,
    pub SdsAllocationSize: DWORDLONG,
    pub SiiStreamSize: DWORDLONG,
    pub SiiAllocationSize: DWORDLONG,
    pub SdhStreamSize: DWORDLONG,
    pub SdhAllocationSize: DWORDLONG,
    pub NumSDTotal: DWORDLONG,
    pub NumSDUnused: DWORDLONG,
}
pub type SD_QUERY_STATS_OUTPUT = _SD_QUERY_STATS_OUTPUT;
pub type PSD_QUERY_STATS_OUTPUT = *mut _SD_QUERY_STATS_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_INPUT {
    pub StartingOffset: DWORDLONG,
    pub MaxSDEntriesToReturn: DWORDLONG,
}
pub type SD_ENUM_SDS_INPUT = _SD_ENUM_SDS_INPUT;
pub type PSD_ENUM_SDS_INPUT = *mut _SD_ENUM_SDS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_ENTRY {
    pub Hash: DWORD,
    pub SecurityId: DWORD,
    pub Offset: DWORDLONG,
    pub Length: DWORD,
    pub Descriptor: [BYTE; 1usize],
}
pub type SD_ENUM_SDS_ENTRY = _SD_ENUM_SDS_ENTRY;
pub type PSD_ENUM_SDS_ENTRY = *mut _SD_ENUM_SDS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_OUTPUT {
    pub NextOffset: DWORDLONG,
    pub NumSDEntriesReturned: DWORDLONG,
    pub NumSDBytesReturned: DWORDLONG,
    pub SDEntry: [SD_ENUM_SDS_ENTRY; 1usize],
}
pub type SD_ENUM_SDS_OUTPUT = _SD_ENUM_SDS_OUTPUT;
pub type PSD_ENUM_SDS_OUTPUT = *mut _SD_ENUM_SDS_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_INPUT {
    pub Flags: DWORD,
    pub ChangeType: DWORD,
    pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1 {
    pub SdChange: SD_CHANGE_MACHINE_SID_INPUT,
    pub SdQueryStats: SD_QUERY_STATS_INPUT,
    pub SdEnumSds: SD_ENUM_SDS_INPUT,
}
pub type SD_GLOBAL_CHANGE_INPUT = _SD_GLOBAL_CHANGE_INPUT;
pub type PSD_GLOBAL_CHANGE_INPUT = *mut _SD_GLOBAL_CHANGE_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_OUTPUT {
    pub Flags: DWORD,
    pub ChangeType: DWORD,
    pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1 {
    pub SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
    pub SdQueryStats: SD_QUERY_STATS_OUTPUT,
    pub SdEnumSds: SD_ENUM_SDS_OUTPUT,
}
pub type SD_GLOBAL_CHANGE_OUTPUT = _SD_GLOBAL_CHANGE_OUTPUT;
pub type PSD_GLOBAL_CHANGE_OUTPUT = *mut _SD_GLOBAL_CHANGE_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    pub Flags: DWORD,
    pub NumberOfClusters: DWORD,
    pub Cluster: [LARGE_INTEGER; 1usize],
}
pub type LOOKUP_STREAM_FROM_CLUSTER_INPUT = _LOOKUP_STREAM_FROM_CLUSTER_INPUT;
pub type PLOOKUP_STREAM_FROM_CLUSTER_INPUT = *mut _LOOKUP_STREAM_FROM_CLUSTER_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    pub Offset: DWORD,
    pub NumberOfMatches: DWORD,
    pub BufferSizeRequired: DWORD,
}
pub type LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
pub type PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT = *mut _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    pub OffsetToNext: DWORD,
    pub Flags: DWORD,
    pub Reserved: LARGE_INTEGER,
    pub Cluster: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type LOOKUP_STREAM_FROM_CLUSTER_ENTRY = _LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
pub type PLOOKUP_STREAM_FROM_CLUSTER_ENTRY = *mut _LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TYPE_NOTIFICATION_INPUT {
    pub Flags: DWORD,
    pub NumFileTypeIDs: DWORD,
    pub FileTypeID: [GUID; 1usize],
}
pub type FILE_TYPE_NOTIFICATION_INPUT = _FILE_TYPE_NOTIFICATION_INPUT;
pub type PFILE_TYPE_NOTIFICATION_INPUT = *mut _FILE_TYPE_NOTIFICATION_INPUT;
extern "C" {
    pub static FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE: GUID;
}
extern "C" {
    pub static FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE: GUID;
}
extern "C" {
    pub static FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_MGMT_LOCK {
    pub Flags: DWORD,
}
pub type CSV_MGMT_LOCK = _CSV_MGMT_LOCK;
pub type PCSV_MGMT_LOCK = *mut _CSV_MGMT_LOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CSV_NAMESPACE_INFO {
    pub Version: DWORD,
    pub DeviceNumber: DWORD,
    pub StartingOffset: LARGE_INTEGER,
    pub SectorSize: DWORD,
}
pub type CSV_NAMESPACE_INFO = _CSV_NAMESPACE_INFO;
pub type PCSV_NAMESPACE_INFO = *mut _CSV_NAMESPACE_INFO;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CSV_CONTROL_OP {
    CsvControlStartRedirectFile = 2,
    CsvControlStopRedirectFile = 3,
    CsvControlQueryRedirectState = 4,
    CsvControlQueryFileRevision = 6,
    CsvControlQueryMdsPath = 8,
    CsvControlQueryFileRevisionFileId128 = 9,
    CsvControlQueryVolumeRedirectState = 10,
    CsvControlEnableUSNRangeModificationTracking = 13,
    CsvControlMarkHandleLocalVolumeMount = 14,
    CsvControlUnmarkHandleLocalVolumeMount = 15,
    CsvControlGetCsvFsMdsPathV2 = 18,
    CsvControlDisableCaching = 19,
    CsvControlEnableCaching = 20,
    CsvControlStartForceDFO = 21,
    CsvControlStopForceDFO = 22,
    CsvControlQueryMdsPathNoPause = 23,
    CsvControlSetVolumeId = 24,
    CsvControlQueryVolumeId = 25,
}
pub use self::_CSV_CONTROL_OP as CSV_CONTROL_OP;
pub type PCSV_CONTROL_OP = *mut _CSV_CONTROL_OP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_CONTROL_PARAM {
    pub Operation: CSV_CONTROL_OP,
    pub Unused: LONGLONG,
}
pub type CSV_CONTROL_PARAM = _CSV_CONTROL_PARAM;
pub type PCSV_CONTROL_PARAM = *mut _CSV_CONTROL_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_REDIRECT_STATE {
    pub MdsNodeId: DWORD,
    pub DsNodeId: DWORD,
    pub FileRedirected: BOOLEAN,
}
pub type CSV_QUERY_REDIRECT_STATE = _CSV_QUERY_REDIRECT_STATE;
pub type PCSV_QUERY_REDIRECT_STATE = *mut _CSV_QUERY_REDIRECT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_FILE_REVISION {
    pub FileId: LONGLONG,
    pub FileRevision: [LONGLONG; 3usize],
}
pub type CSV_QUERY_FILE_REVISION = _CSV_QUERY_FILE_REVISION;
pub type PCSV_QUERY_FILE_REVISION = *mut _CSV_QUERY_FILE_REVISION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    pub FileId: FILE_ID_128,
    pub FileRevision: [LONGLONG; 3usize],
}
pub type CSV_QUERY_FILE_REVISION_FILE_ID_128 = _CSV_QUERY_FILE_REVISION_FILE_ID_128;
pub type PCSV_QUERY_FILE_REVISION_FILE_ID_128 = *mut _CSV_QUERY_FILE_REVISION_FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_MDS_PATH {
    pub MdsNodeId: DWORD,
    pub DsNodeId: DWORD,
    pub PathLength: DWORD,
    pub Path: [WCHAR; 1usize],
}
pub type CSV_QUERY_MDS_PATH = _CSV_QUERY_MDS_PATH;
pub type PCSV_QUERY_MDS_PATH = *mut _CSV_QUERY_MDS_PATH;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _CSVFS_DISK_CONNECTIVITY {
    CsvFsDiskConnectivityNone = 0,
    CsvFsDiskConnectivityMdsNodeOnly = 1,
    CsvFsDiskConnectivitySubsetOfNodes = 2,
    CsvFsDiskConnectivityAllNodes = 3,
}
pub use self::_CSVFS_DISK_CONNECTIVITY as CSVFS_DISK_CONNECTIVITY;
pub type PCSVFS_DISK_CONNECTIVITY = *mut _CSVFS_DISK_CONNECTIVITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_VOLUME_REDIRECT_STATE {
    pub MdsNodeId: DWORD,
    pub DsNodeId: DWORD,
    pub IsDiskConnected: BOOLEAN,
    pub ClusterEnableDirectIo: BOOLEAN,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
}
pub type CSV_QUERY_VOLUME_REDIRECT_STATE = _CSV_QUERY_VOLUME_REDIRECT_STATE;
pub type PCSV_QUERY_VOLUME_REDIRECT_STATE = *mut _CSV_QUERY_VOLUME_REDIRECT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_MDS_PATH_V2 {
    pub Version: LONGLONG,
    pub RequiredSize: DWORD,
    pub MdsNodeId: DWORD,
    pub DsNodeId: DWORD,
    pub Flags: DWORD,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    pub VolumeId: GUID,
    pub IpAddressOffset: DWORD,
    pub IpAddressLength: DWORD,
    pub PathOffset: DWORD,
    pub PathLength: DWORD,
}
pub type CSV_QUERY_MDS_PATH_V2 = _CSV_QUERY_MDS_PATH_V2;
pub type PCSV_QUERY_MDS_PATH_V2 = *mut _CSV_QUERY_MDS_PATH_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_SET_VOLUME_ID {
    pub VolumeId: GUID,
}
pub type CSV_SET_VOLUME_ID = _CSV_SET_VOLUME_ID;
pub type PCSV_SET_VOLUME_ID = *mut _CSV_SET_VOLUME_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_VOLUME_ID {
    pub VolumeId: GUID,
}
pub type CSV_QUERY_VOLUME_ID = _CSV_QUERY_VOLUME_ID;
pub type PCSV_QUERY_VOLUME_ID = *mut _CSV_QUERY_VOLUME_ID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _LMR_QUERY_INFO_CLASS {
    LMRQuerySessionInfo = 1,
}
pub use self::_LMR_QUERY_INFO_CLASS as LMR_QUERY_INFO_CLASS;
pub type PLMR_QUERY_INFO_CLASS = *mut _LMR_QUERY_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LMR_QUERY_INFO_PARAM {
    pub Operation: LMR_QUERY_INFO_CLASS,
}
pub type LMR_QUERY_INFO_PARAM = _LMR_QUERY_INFO_PARAM;
pub type PLMR_QUERY_INFO_PARAM = *mut _LMR_QUERY_INFO_PARAM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LMR_QUERY_SESSION_INFO {
    pub SessionId: UINT64,
}
pub type LMR_QUERY_SESSION_INFO = _LMR_QUERY_SESSION_INFO;
pub type PLMR_QUERY_SESSION_INFO = *mut _LMR_QUERY_SESSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    pub VetoedFromAltitudeIntegral: DWORDLONG,
    pub VetoedFromAltitudeDecimal: DWORDLONG,
    pub Reason: [WCHAR; 256usize],
}
pub type CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
pub type PCSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = *mut _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _STORAGE_RESERVE_ID {
    StorageReserveIdNone = 0,
    StorageReserveIdHard = 1,
    StorageReserveIdSoft = 2,
    StorageReserveIdUpdateScratch = 3,
    StorageReserveIdMax = 4,
}
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
pub type PSTORAGE_RESERVE_ID = *mut _STORAGE_RESERVE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CSV_IS_OWNED_BY_CSVFS {
    pub OwnedByCSVFS: BOOLEAN,
}
pub type CSV_IS_OWNED_BY_CSVFS = _CSV_IS_OWNED_BY_CSVFS;
pub type PCSV_IS_OWNED_BY_CSVFS = *mut _CSV_IS_OWNED_BY_CSVFS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM_RANGE {
    pub Offset: DWORDLONG,
    pub Length: DWORDLONG,
}
pub type FILE_LEVEL_TRIM_RANGE = _FILE_LEVEL_TRIM_RANGE;
pub type PFILE_LEVEL_TRIM_RANGE = *mut _FILE_LEVEL_TRIM_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM {
    pub Key: DWORD,
    pub NumRanges: DWORD,
    pub Ranges: [FILE_LEVEL_TRIM_RANGE; 1usize],
}
pub type FILE_LEVEL_TRIM = _FILE_LEVEL_TRIM;
pub type PFILE_LEVEL_TRIM = *mut _FILE_LEVEL_TRIM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM_OUTPUT {
    pub NumRangesProcessed: DWORD,
}
pub type FILE_LEVEL_TRIM_OUTPUT = _FILE_LEVEL_TRIM_OUTPUT;
pub type PFILE_LEVEL_TRIM_OUTPUT = *mut _FILE_LEVEL_TRIM_OUTPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _QUERY_FILE_LAYOUT_FILTER_TYPE {
    QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = 0,
    QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = 1,
    QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = 2,
    QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = 3,
    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = 4,
}
pub use self::_QUERY_FILE_LAYOUT_FILTER_TYPE as QUERY_FILE_LAYOUT_FILTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLUSTER_RANGE {
    pub StartingCluster: LARGE_INTEGER,
    pub ClusterCount: LARGE_INTEGER,
}
pub type CLUSTER_RANGE = _CLUSTER_RANGE;
pub type PCLUSTER_RANGE = *mut _CLUSTER_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REFERENCE_RANGE {
    pub StartingFileReferenceNumber: DWORDLONG,
    pub EndingFileReferenceNumber: DWORDLONG,
}
pub type FILE_REFERENCE_RANGE = _FILE_REFERENCE_RANGE;
pub type PFILE_REFERENCE_RANGE = *mut _FILE_REFERENCE_RANGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUERY_FILE_LAYOUT_INPUT {
    pub __bindgen_anon_1: _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_1,
    pub Flags: DWORD,
    pub FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    pub Reserved: DWORD,
    pub Filter: _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_1 {
    pub FilterEntryCount: DWORD,
    pub NumberOfPairs: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _QUERY_FILE_LAYOUT_INPUT__bindgen_ty_2 {
    pub ClusterRanges: [CLUSTER_RANGE; 1usize],
    pub FileReferenceRanges: [FILE_REFERENCE_RANGE; 1usize],
    pub StorageReserveIds: [STORAGE_RESERVE_ID; 1usize],
}
pub type QUERY_FILE_LAYOUT_INPUT = _QUERY_FILE_LAYOUT_INPUT;
pub type PQUERY_FILE_LAYOUT_INPUT = *mut _QUERY_FILE_LAYOUT_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_FILE_LAYOUT_OUTPUT {
    pub FileEntryCount: DWORD,
    pub FirstFileOffset: DWORD,
    pub Flags: DWORD,
    pub Reserved: DWORD,
}
pub type QUERY_FILE_LAYOUT_OUTPUT = _QUERY_FILE_LAYOUT_OUTPUT;
pub type PQUERY_FILE_LAYOUT_OUTPUT = *mut _QUERY_FILE_LAYOUT_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LAYOUT_ENTRY {
    pub Version: DWORD,
    pub NextFileOffset: DWORD,
    pub Flags: DWORD,
    pub FileAttributes: DWORD,
    pub FileReferenceNumber: DWORDLONG,
    pub FirstNameOffset: DWORD,
    pub FirstStreamOffset: DWORD,
    pub ExtraInfoOffset: DWORD,
    pub ExtraInfoLength: DWORD,
}
pub type FILE_LAYOUT_ENTRY = _FILE_LAYOUT_ENTRY;
pub type PFILE_LAYOUT_ENTRY = *mut _FILE_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LAYOUT_NAME_ENTRY {
    pub NextNameOffset: DWORD,
    pub Flags: DWORD,
    pub ParentFileReferenceNumber: DWORDLONG,
    pub FileNameLength: DWORD,
    pub Reserved: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type FILE_LAYOUT_NAME_ENTRY = _FILE_LAYOUT_NAME_ENTRY;
pub type PFILE_LAYOUT_NAME_ENTRY = *mut _FILE_LAYOUT_NAME_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LAYOUT_INFO_ENTRY {
    pub BasicInformation: _FILE_LAYOUT_INFO_ENTRY__bindgen_ty_1,
    pub OwnerId: DWORD,
    pub SecurityId: DWORD,
    pub Usn: USN,
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LAYOUT_INFO_ENTRY__bindgen_ty_1 {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: DWORD,
}
pub type FILE_LAYOUT_INFO_ENTRY = _FILE_LAYOUT_INFO_ENTRY;
pub type PFILE_LAYOUT_INFO_ENTRY = *mut _FILE_LAYOUT_INFO_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_LAYOUT_ENTRY {
    pub Version: DWORD,
    pub NextStreamOffset: DWORD,
    pub Flags: DWORD,
    pub ExtentInformationOffset: DWORD,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub StreamInformationOffset: DWORD,
    pub AttributeTypeCode: DWORD,
    pub AttributeFlags: DWORD,
    pub StreamIdentifierLength: DWORD,
    pub StreamIdentifier: [WCHAR; 1usize],
}
pub type STREAM_LAYOUT_ENTRY = _STREAM_LAYOUT_ENTRY;
pub type PSTREAM_LAYOUT_ENTRY = *mut _STREAM_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_EXTENT_ENTRY {
    pub Flags: DWORD,
    pub ExtentInformation: _STREAM_EXTENT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_EXTENT_ENTRY__bindgen_ty_1 {
    pub RetrievalPointers: RETRIEVAL_POINTERS_BUFFER,
}
pub type STREAM_EXTENT_ENTRY = _STREAM_EXTENT_ENTRY;
pub type PSTREAM_EXTENT_ENTRY = *mut _STREAM_EXTENT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ChecksumChunkSizeInBytes: DWORD,
    pub ClusterSizeInBytes: DWORD,
}
pub type FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
pub type PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER = *mut _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
}
pub type FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
pub type PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER = *mut _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    pub EnableIntegrity: BYTE,
    pub KeepIntegrityStateUnchanged: BYTE,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub Version: BYTE,
    pub Reserved2: [BYTE; 7usize],
}
pub type FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
pub type PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX =
    *mut _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_READ_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TokenTimeToLive: DWORD,
    pub Reserved: DWORD,
    pub FileOffset: DWORDLONG,
    pub CopyLength: DWORDLONG,
}
pub type FSCTL_OFFLOAD_READ_INPUT = _FSCTL_OFFLOAD_READ_INPUT;
pub type PFSCTL_OFFLOAD_READ_INPUT = *mut _FSCTL_OFFLOAD_READ_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_READ_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TransferLength: DWORDLONG,
    pub Token: [BYTE; 512usize],
}
pub type FSCTL_OFFLOAD_READ_OUTPUT = _FSCTL_OFFLOAD_READ_OUTPUT;
pub type PFSCTL_OFFLOAD_READ_OUTPUT = *mut _FSCTL_OFFLOAD_READ_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_WRITE_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub FileOffset: DWORDLONG,
    pub CopyLength: DWORDLONG,
    pub TransferOffset: DWORDLONG,
    pub Token: [BYTE; 512usize],
}
pub type FSCTL_OFFLOAD_WRITE_INPUT = _FSCTL_OFFLOAD_WRITE_INPUT;
pub type PFSCTL_OFFLOAD_WRITE_INPUT = *mut _FSCTL_OFFLOAD_WRITE_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_WRITE_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub LengthWritten: DWORDLONG,
}
pub type FSCTL_OFFLOAD_WRITE_OUTPUT = _FSCTL_OFFLOAD_WRITE_OUTPUT;
pub type PFSCTL_OFFLOAD_WRITE_OUTPUT = *mut _FSCTL_OFFLOAD_WRITE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PURGE_FAILURE_MODE_INPUT {
    pub Flags: DWORD,
}
pub type SET_PURGE_FAILURE_MODE_INPUT = _SET_PURGE_FAILURE_MODE_INPUT;
pub type PSET_PURGE_FAILURE_MODE_INPUT = *mut _SET_PURGE_FAILURE_MODE_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPAIR_COPIES_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub FileOffset: LARGE_INTEGER,
    pub Length: DWORD,
    pub SourceCopy: DWORD,
    pub NumberOfRepairCopies: DWORD,
    pub RepairCopies: [DWORD; 1usize],
}
pub type REPAIR_COPIES_INPUT = _REPAIR_COPIES_INPUT;
pub type PREPAIR_COPIES_INPUT = *mut _REPAIR_COPIES_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REPAIR_COPIES_OUTPUT {
    pub Size: DWORD,
    pub Status: DWORD,
    pub ResumeFileOffset: LARGE_INTEGER,
}
pub type REPAIR_COPIES_OUTPUT = _REPAIR_COPIES_OUTPUT;
pub type PREPAIR_COPIES_OUTPUT = *mut _REPAIR_COPIES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_INFO {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Usage: DWORD,
    pub Reserved: DWORD,
}
pub type FILE_REGION_INFO = _FILE_REGION_INFO;
pub type PFILE_REGION_INFO = *mut _FILE_REGION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_OUTPUT {
    pub Flags: DWORD,
    pub TotalRegionEntryCount: DWORD,
    pub RegionEntryCount: DWORD,
    pub Reserved: DWORD,
    pub Region: [FILE_REGION_INFO; 1usize],
}
pub type FILE_REGION_OUTPUT = _FILE_REGION_OUTPUT;
pub type PFILE_REGION_OUTPUT = *mut _FILE_REGION_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_INPUT {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub DesiredUsage: DWORD,
}
pub type FILE_REGION_INPUT = _FILE_REGION_INPUT;
pub type PFILE_REGION_INPUT = *mut _FILE_REGION_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WRITE_USN_REASON_INPUT {
    pub Flags: DWORD,
    pub UsnReasonToWrite: DWORD,
}
pub type WRITE_USN_REASON_INPUT = _WRITE_USN_REASON_INPUT;
pub type PWRITE_USN_REASON_INPUT = *mut _WRITE_USN_REASON_INPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_STORAGE_TIER_MEDIA_TYPE {
    FileStorageTierMediaTypeUnspecified = 0,
    FileStorageTierMediaTypeDisk = 1,
    FileStorageTierMediaTypeSsd = 2,
    FileStorageTierMediaTypeScm = 4,
    FileStorageTierMediaTypeMax = 5,
}
pub use self::_FILE_STORAGE_TIER_MEDIA_TYPE as FILE_STORAGE_TIER_MEDIA_TYPE;
pub type PFILE_STORAGE_TIER_MEDIA_TYPE = *mut _FILE_STORAGE_TIER_MEDIA_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FILE_STORAGE_TIER_CLASS {
    FileStorageTierClassUnspecified = 0,
    FileStorageTierClassCapacity = 1,
    FileStorageTierClassPerformance = 2,
    FileStorageTierClassMax = 3,
}
pub use self::_FILE_STORAGE_TIER_CLASS as FILE_STORAGE_TIER_CLASS;
pub type PFILE_STORAGE_TIER_CLASS = *mut _FILE_STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_TIER {
    pub Id: GUID,
    pub Name: [WCHAR; 256usize],
    pub Description: [WCHAR; 256usize],
    pub Flags: DWORDLONG,
    pub ProvisionedCapacity: DWORDLONG,
    pub MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    pub Class: FILE_STORAGE_TIER_CLASS,
}
pub type FILE_STORAGE_TIER = _FILE_STORAGE_TIER;
pub type PFILE_STORAGE_TIER = *mut _FILE_STORAGE_TIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TotalNumberOfTiers: DWORD,
    pub NumberOfTiersReturned: DWORD,
    pub Tiers: [FILE_STORAGE_TIER; 1usize],
}
pub type FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
pub type PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT = *mut _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub StreamInformation: _STREAM_INFORMATION_ENTRY__StreamInformation,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_INFORMATION_ENTRY__StreamInformation {
    pub DesiredStorageClass: _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass,
    pub DataStream: _STREAM_INFORMATION_ENTRY__StreamInformation__DataStream,
    pub Reparse: _STREAM_INFORMATION_ENTRY__StreamInformation__Reparse,
    pub Ea: _STREAM_INFORMATION_ENTRY__StreamInformation__Ea,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__DataStream {
    pub Length: WORD,
    pub Flags: WORD,
    pub Reserved: DWORD,
    pub Vdl: DWORDLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__Reparse {
    pub Length: WORD,
    pub Flags: WORD,
    pub ReparseDataSize: DWORD,
    pub ReparseDataOffset: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__Ea {
    pub Length: WORD,
    pub Flags: WORD,
    pub EaSize: DWORD,
    pub EaInformationOffset: DWORD,
}
pub type STREAM_INFORMATION_ENTRY = _STREAM_INFORMATION_ENTRY;
pub type PSTREAM_INFORMATION_ENTRY = *mut _STREAM_INFORMATION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_REGION_INFO_INPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub NumberOfTierIds: DWORD,
    pub TierIds: [GUID; 1usize],
}
pub type FSCTL_QUERY_REGION_INFO_INPUT = _FSCTL_QUERY_REGION_INFO_INPUT;
pub type PFSCTL_QUERY_REGION_INFO_INPUT = *mut _FSCTL_QUERY_REGION_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_TIER_REGION {
    pub TierId: GUID,
    pub Offset: DWORDLONG,
    pub Length: DWORDLONG,
}
pub type FILE_STORAGE_TIER_REGION = _FILE_STORAGE_TIER_REGION;
pub type PFILE_STORAGE_TIER_REGION = *mut _FILE_STORAGE_TIER_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_REGION_INFO_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Reserved: DWORD,
    pub Alignment: DWORDLONG,
    pub TotalNumberOfRegions: DWORD,
    pub NumberOfRegionsReturned: DWORD,
    pub Regions: [FILE_STORAGE_TIER_REGION; 1usize],
}
pub type FSCTL_QUERY_REGION_INFO_OUTPUT = _FSCTL_QUERY_REGION_INFO_OUTPUT;
pub type PFSCTL_QUERY_REGION_INFO_OUTPUT = *mut _FSCTL_QUERY_REGION_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: DWORD,
}
pub type FILE_DESIRED_STORAGE_CLASS_INFORMATION = _FILE_DESIRED_STORAGE_CLASS_INFORMATION;
pub type PFILE_DESIRED_STORAGE_CLASS_INFORMATION = *mut _FILE_DESIRED_STORAGE_CLASS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA {
    pub FileHandle: HANDLE,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
}
pub type DUPLICATE_EXTENTS_DATA = _DUPLICATE_EXTENTS_DATA;
pub type PDUPLICATE_EXTENTS_DATA = *mut _DUPLICATE_EXTENTS_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA32 {
    pub FileHandle: UINT32,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
}
pub type DUPLICATE_EXTENTS_DATA32 = _DUPLICATE_EXTENTS_DATA32;
pub type PDUPLICATE_EXTENTS_DATA32 = *mut _DUPLICATE_EXTENTS_DATA32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA_EX {
    pub Size: SIZE_T,
    pub FileHandle: HANDLE,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
    pub Flags: DWORD,
}
pub type DUPLICATE_EXTENTS_DATA_EX = _DUPLICATE_EXTENTS_DATA_EX;
pub type PDUPLICATE_EXTENTS_DATA_EX = *mut _DUPLICATE_EXTENTS_DATA_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DUPLICATE_EXTENTS_DATA_EX32 {
    pub Size: DWORD32,
    pub FileHandle: DWORD32,
    pub SourceFileOffset: LARGE_INTEGER,
    pub TargetFileOffset: LARGE_INTEGER,
    pub ByteCount: LARGE_INTEGER,
    pub Flags: DWORD,
}
pub type DUPLICATE_EXTENTS_DATA_EX32 = _DUPLICATE_EXTENTS_DATA_EX32;
pub type PDUPLICATE_EXTENTS_DATA_EX32 = *mut _DUPLICATE_EXTENTS_DATA_EX32;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _DUPLICATE_EXTENTS_STATE {
    FileSnapStateInactive = 0,
    FileSnapStateSource = 1,
    FileSnapStateTarget = 2,
}
pub use self::_DUPLICATE_EXTENTS_STATE as DUPLICATE_EXTENTS_STATE;
pub type PDUPLICATE_EXTENTS_STATE = *mut _DUPLICATE_EXTENTS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASYNC_DUPLICATE_EXTENTS_STATUS {
    pub Version: DWORD,
    pub State: DUPLICATE_EXTENTS_STATE,
    pub SourceFileOffset: DWORDLONG,
    pub TargetFileOffset: DWORDLONG,
    pub ByteCount: DWORDLONG,
    pub BytesDuplicated: DWORDLONG,
}
pub type ASYNC_DUPLICATE_EXTENTS_STATUS = _ASYNC_DUPLICATE_EXTENTS_STATUS;
pub type PASYNC_DUPLICATE_EXTENTS_STATUS = *mut _ASYNC_DUPLICATE_EXTENTS_STATUS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REFS_SMR_VOLUME_GC_STATE {
    SmrGcStateInactive = 0,
    SmrGcStatePaused = 1,
    SmrGcStateActive = 2,
    SmrGcStateActiveFullSpeed = 3,
}
pub use self::_REFS_SMR_VOLUME_GC_STATE as REFS_SMR_VOLUME_GC_STATE;
pub type PREFS_SMR_VOLUME_GC_STATE = *mut _REFS_SMR_VOLUME_GC_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _REFS_SMR_VOLUME_INFO_OUTPUT {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub SizeOfRandomlyWritableTier: LARGE_INTEGER,
    pub FreeSpaceInRandomlyWritableTier: LARGE_INTEGER,
    pub SizeofSMRTier: LARGE_INTEGER,
    pub FreeSpaceInSMRTier: LARGE_INTEGER,
    pub UsableFreeSpaceInSMRTier: LARGE_INTEGER,
    pub VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    pub VolumeGcLastStatus: DWORD,
    pub CurrentGcBandFillPercentage: DWORD,
    pub Unused: [DWORDLONG; 6usize],
}
pub type REFS_SMR_VOLUME_INFO_OUTPUT = _REFS_SMR_VOLUME_INFO_OUTPUT;
pub type PREFS_SMR_VOLUME_INFO_OUTPUT = *mut _REFS_SMR_VOLUME_INFO_OUTPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REFS_SMR_VOLUME_GC_ACTION {
    SmrGcActionStart = 1,
    SmrGcActionStartFullSpeed = 2,
    SmrGcActionPause = 3,
    SmrGcActionStop = 4,
}
pub use self::_REFS_SMR_VOLUME_GC_ACTION as REFS_SMR_VOLUME_GC_ACTION;
pub type PREFS_SMR_VOLUME_GC_ACTION = *mut _REFS_SMR_VOLUME_GC_ACTION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _REFS_SMR_VOLUME_GC_METHOD {
    SmrGcMethodCompaction = 1,
    SmrGcMethodCompression = 2,
    SmrGcMethodRotation = 3,
}
pub use self::_REFS_SMR_VOLUME_GC_METHOD as REFS_SMR_VOLUME_GC_METHOD;
pub type PREFS_SMR_VOLUME_GC_METHOD = *mut _REFS_SMR_VOLUME_GC_METHOD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REFS_SMR_VOLUME_GC_PARAMETERS {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub Action: REFS_SMR_VOLUME_GC_ACTION,
    pub Method: REFS_SMR_VOLUME_GC_METHOD,
    pub IoGranularity: DWORD,
    pub CompressionFormat: DWORD,
    pub Unused: [DWORDLONG; 8usize],
}
pub type REFS_SMR_VOLUME_GC_PARAMETERS = _REFS_SMR_VOLUME_GC_PARAMETERS;
pub type PREFS_SMR_VOLUME_GC_PARAMETERS = *mut _REFS_SMR_VOLUME_GC_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    pub OptimalWriteSize: DWORD,
    pub StreamGranularitySize: DWORD,
    pub StreamIdMin: DWORD,
    pub StreamIdMax: DWORD,
}
pub type STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
pub type PSTREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = *mut _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    pub Flags: DWORD,
    pub StreamId: DWORD,
}
pub type STREAMS_ASSOCIATE_ID_INPUT_BUFFER = _STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
pub type PSTREAMS_ASSOCIATE_ID_INPUT_BUFFER = *mut _STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_ID_OUTPUT_BUFFER {
    pub StreamId: DWORD,
}
pub type STREAMS_QUERY_ID_OUTPUT_BUFFER = _STREAMS_QUERY_ID_OUTPUT_BUFFER;
pub type PSTREAMS_QUERY_ID_OUTPUT_BUFFER = *mut _STREAMS_QUERY_ID_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_INPUT_RANGE {
    pub StartOffset: DWORDLONG,
    pub LengthInBytes: DWORDLONG,
}
pub type QUERY_BAD_RANGES_INPUT_RANGE = _QUERY_BAD_RANGES_INPUT_RANGE;
pub type PQUERY_BAD_RANGES_INPUT_RANGE = *mut _QUERY_BAD_RANGES_INPUT_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_INPUT {
    pub Flags: DWORD,
    pub NumRanges: DWORD,
    pub Ranges: [QUERY_BAD_RANGES_INPUT_RANGE; 1usize],
}
pub type QUERY_BAD_RANGES_INPUT = _QUERY_BAD_RANGES_INPUT;
pub type PQUERY_BAD_RANGES_INPUT = *mut _QUERY_BAD_RANGES_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_OUTPUT_RANGE {
    pub Flags: DWORD,
    pub Reserved: DWORD,
    pub StartOffset: DWORDLONG,
    pub LengthInBytes: DWORDLONG,
}
pub type QUERY_BAD_RANGES_OUTPUT_RANGE = _QUERY_BAD_RANGES_OUTPUT_RANGE;
pub type PQUERY_BAD_RANGES_OUTPUT_RANGE = *mut _QUERY_BAD_RANGES_OUTPUT_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_BAD_RANGES_OUTPUT {
    pub Flags: DWORD,
    pub NumBadRanges: DWORD,
    pub NextOffsetToLookUp: DWORDLONG,
    pub BadRanges: [QUERY_BAD_RANGES_OUTPUT_RANGE; 1usize],
}
pub type QUERY_BAD_RANGES_OUTPUT = _QUERY_BAD_RANGES_OUTPUT;
pub type PQUERY_BAD_RANGES_OUTPUT = *mut _QUERY_BAD_RANGES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    pub Flags: DWORD,
    pub AlignmentShift: DWORD,
    pub FileOffsetToAlign: DWORDLONG,
    pub FallbackAlignmentShift: DWORD,
}
pub type SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
pub type PSET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = *mut _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _VIRTUAL_STORAGE_BEHAVIOR_CODE {
    VirtualStorageBehaviorUndefined = 0,
    VirtualStorageBehaviorCacheWriteThrough = 1,
    VirtualStorageBehaviorCacheWriteBack = 2,
    VirtualStorageBehaviorStopIoProcessing = 3,
    VirtualStorageBehaviorRestartIoProcessing = 4,
}
pub use self::_VIRTUAL_STORAGE_BEHAVIOR_CODE as VIRTUAL_STORAGE_BEHAVIOR_CODE;
pub type PVIRTUAL_STORAGE_BEHAVIOR_CODE = *mut _VIRTUAL_STORAGE_BEHAVIOR_CODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    pub Size: DWORD,
    pub BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
}
pub type VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
pub type PVIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = *mut _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCRYPTION_KEY_CTRL_INPUT {
    pub HeaderSize: DWORD,
    pub StructureSize: DWORD,
    pub KeyOffset: WORD,
    pub KeySize: WORD,
    pub DplLock: DWORD,
    pub DplUserId: DWORDLONG,
    pub DplCredentialId: DWORDLONG,
}
pub type ENCRYPTION_KEY_CTRL_INPUT = _ENCRYPTION_KEY_CTRL_INPUT;
pub type PENCRYPTION_KEY_CTRL_INPUT = *mut _ENCRYPTION_KEY_CTRL_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOF_EXTERNAL_INFO {
    pub Version: DWORD,
    pub Provider: DWORD,
}
pub type WOF_EXTERNAL_INFO = _WOF_EXTERNAL_INFO;
pub type PWOF_EXTERNAL_INFO = *mut _WOF_EXTERNAL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOF_EXTERNAL_FILE_ID {
    pub FileId: FILE_ID_128,
}
pub type WOF_EXTERNAL_FILE_ID = _WOF_EXTERNAL_FILE_ID;
pub type PWOF_EXTERNAL_FILE_ID = *mut _WOF_EXTERNAL_FILE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOF_VERSION_INFO {
    pub WofVersion: DWORD,
}
pub type WOF_VERSION_INFO = _WOF_VERSION_INFO;
pub type PWOF_VERSION_INFO = *mut _WOF_VERSION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_EXTERNAL_INFO {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub DataSourceId: LARGE_INTEGER,
    pub ResourceHash: [BYTE; 20usize],
}
pub type WIM_PROVIDER_EXTERNAL_INFO = _WIM_PROVIDER_EXTERNAL_INFO;
pub type PWIM_PROVIDER_EXTERNAL_INFO = *mut _WIM_PROVIDER_EXTERNAL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIM_PROVIDER_ADD_OVERLAY_INPUT {
    pub WimType: DWORD,
    pub WimIndex: DWORD,
    pub WimFileNameOffset: DWORD,
    pub WimFileNameLength: DWORD,
}
pub type WIM_PROVIDER_ADD_OVERLAY_INPUT = _WIM_PROVIDER_ADD_OVERLAY_INPUT;
pub type PWIM_PROVIDER_ADD_OVERLAY_INPUT = *mut _WIM_PROVIDER_ADD_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    pub DataSourceId: LARGE_INTEGER,
    pub WimFileNameOffset: DWORD,
    pub WimFileNameLength: DWORD,
}
pub type WIM_PROVIDER_UPDATE_OVERLAY_INPUT = _WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
pub type PWIM_PROVIDER_UPDATE_OVERLAY_INPUT = *mut _WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    pub DataSourceId: LARGE_INTEGER,
}
pub type WIM_PROVIDER_REMOVE_OVERLAY_INPUT = _WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
pub type PWIM_PROVIDER_REMOVE_OVERLAY_INPUT = *mut _WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    pub DataSourceId: LARGE_INTEGER,
}
pub type WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
pub type PWIM_PROVIDER_SUSPEND_OVERLAY_INPUT = *mut _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WIM_PROVIDER_OVERLAY_ENTRY {
    pub NextEntryOffset: DWORD,
    pub DataSourceId: LARGE_INTEGER,
    pub WimGuid: GUID,
    pub WimFileNameOffset: DWORD,
    pub WimType: DWORD,
    pub WimIndex: DWORD,
    pub Flags: DWORD,
}
pub type WIM_PROVIDER_OVERLAY_ENTRY = _WIM_PROVIDER_OVERLAY_ENTRY;
pub type PWIM_PROVIDER_OVERLAY_ENTRY = *mut _WIM_PROVIDER_OVERLAY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROVIDER_EXTERNAL_INFO_V0 {
    pub Version: DWORD,
    pub Algorithm: DWORD,
}
pub type FILE_PROVIDER_EXTERNAL_INFO_V0 = _FILE_PROVIDER_EXTERNAL_INFO_V0;
pub type PFILE_PROVIDER_EXTERNAL_INFO_V0 = *mut _FILE_PROVIDER_EXTERNAL_INFO_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROVIDER_EXTERNAL_INFO_V1 {
    pub Version: DWORD,
    pub Algorithm: DWORD,
    pub Flags: DWORD,
}
pub type FILE_PROVIDER_EXTERNAL_INFO_V1 = _FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type PFILE_PROVIDER_EXTERNAL_INFO_V1 = *mut _FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type FILE_PROVIDER_EXTERNAL_INFO = FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type PFILE_PROVIDER_EXTERNAL_INFO = PFILE_PROVIDER_EXTERNAL_INFO_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTAINER_VOLUME_STATE {
    pub Flags: DWORD,
}
pub type CONTAINER_VOLUME_STATE = _CONTAINER_VOLUME_STATE;
pub type PCONTAINER_VOLUME_STATE = *mut _CONTAINER_VOLUME_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTAINER_ROOT_INFO_INPUT {
    pub Flags: DWORD,
}
pub type CONTAINER_ROOT_INFO_INPUT = _CONTAINER_ROOT_INFO_INPUT;
pub type PCONTAINER_ROOT_INFO_INPUT = *mut _CONTAINER_ROOT_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTAINER_ROOT_INFO_OUTPUT {
    pub ContainerRootIdLength: WORD,
    pub ContainerRootId: [BYTE; 1usize],
}
pub type CONTAINER_ROOT_INFO_OUTPUT = _CONTAINER_ROOT_INFO_OUTPUT;
pub type PCONTAINER_ROOT_INFO_OUTPUT = *mut _CONTAINER_ROOT_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUALIZATION_INSTANCE_INFO_INPUT {
    pub NumberOfWorkerThreads: DWORD,
    pub Flags: DWORD,
}
pub type VIRTUALIZATION_INSTANCE_INFO_INPUT = _VIRTUALIZATION_INSTANCE_INFO_INPUT;
pub type PVIRTUALIZATION_INSTANCE_INFO_INPUT = *mut _VIRTUALIZATION_INSTANCE_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    pub HeaderSize: WORD,
    pub Flags: DWORD,
    pub NotificationInfoSize: DWORD,
    pub NotificationInfoOffset: WORD,
    pub ProviderMajorVersion: WORD,
}
pub type VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
pub type PVIRTUALIZATION_INSTANCE_INFO_INPUT_EX = *mut _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    pub VirtualizationInstanceID: GUID,
}
pub type VIRTUALIZATION_INSTANCE_INFO_OUTPUT = _VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
pub type PVIRTUALIZATION_INSTANCE_INFO_OUTPUT = *mut _VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_FILTER_FILE_IDENTIFIER_INPUT {
    pub AltitudeLength: WORD,
    pub Altitude: [WCHAR; 1usize],
}
pub type GET_FILTER_FILE_IDENTIFIER_INPUT = _GET_FILTER_FILE_IDENTIFIER_INPUT;
pub type PGET_FILTER_FILE_IDENTIFIER_INPUT = *mut _GET_FILTER_FILE_IDENTIFIER_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    pub FilterFileIdentifierLength: WORD,
    pub FilterFileIdentifier: [BYTE; 1usize],
}
pub type GET_FILTER_FILE_IDENTIFIER_OUTPUT = _GET_FILTER_FILE_IDENTIFIER_OUTPUT;
pub type PGET_FILTER_FILE_IDENTIFIER_OUTPUT = *mut _GET_FILTER_FILE_IDENTIFIER_OUTPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_BPIO_OPERATIONS {
    FS_BPIO_OP_ENABLE = 1,
    FS_BPIO_OP_DISABLE = 2,
    FS_BPIO_OP_QUERY = 3,
    FS_BPIO_OP_VOLUME_STACK_PAUSE = 4,
    FS_BPIO_OP_VOLUME_STACK_RESUME = 5,
    FS_BPIO_OP_STREAM_PAUSE = 6,
    FS_BPIO_OP_STREAM_RESUME = 7,
    FS_BPIO_OP_GET_INFO = 8,
    FS_BPIO_OP_MAX_OPERATION = 9,
}
pub use self::_FS_BPIO_OPERATIONS as FS_BPIO_OPERATIONS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_BPIO_INFLAGS {
    FSBPIO_INFL_None = 0,
    FSBPIO_INFL_SKIP_STORAGE_STACK_QUERY = 1,
}
pub use self::_FS_BPIO_INFLAGS as FS_BPIO_INFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_INPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub InFlags: FS_BPIO_INFLAGS,
    pub Reserved1: DWORDLONG,
    pub Reserved2: DWORDLONG,
}
pub type FS_BPIO_INPUT = _FS_BPIO_INPUT;
pub type PFS_BPIO_INPUT = *mut _FS_BPIO_INPUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _FS_BPIO_OUTFLAGS {
    FSBPIO_OUTFL_None = 0,
    FSBPIO_OUTFL_VOLUME_STACK_BYPASS_PAUSED = 1,
    FSBPIO_OUTFL_STREAM_BYPASS_PAUSED = 2,
    FSBPIO_OUTFL_FILTER_ATTACH_BLOCKED = 4,
    FSBPIO_OUTFL_COMPATIBLE_STORAGE_DRIVER = 8,
}
pub use self::_FS_BPIO_OUTFLAGS as FS_BPIO_OUTFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_RESULTS {
    pub OpStatus: DWORD,
    pub FailingDriverNameLen: WORD,
    pub FailingDriverName: [WCHAR; 32usize],
    pub FailureReasonLen: WORD,
    pub FailureReason: [WCHAR; 128usize],
}
pub type FS_BPIO_RESULTS = _FS_BPIO_RESULTS;
pub type PFS_BPIO_RESULTS = *mut _FS_BPIO_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_INFO {
    pub ActiveBypassIoCount: DWORD,
    pub StorageDriverNameLen: WORD,
    pub StorageDriverName: [WCHAR; 32usize],
}
pub type FS_BPIO_INFO = _FS_BPIO_INFO;
pub type PFS_BPIO_INFO = *mut _FS_BPIO_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FS_BPIO_OUTPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub OutFlags: FS_BPIO_OUTFLAGS,
    pub Reserved1: DWORDLONG,
    pub Reserved2: DWORDLONG,
    pub __bindgen_anon_1: _FS_BPIO_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FS_BPIO_OUTPUT__bindgen_ty_1 {
    pub Enable: FS_BPIO_RESULTS,
    pub Query: FS_BPIO_RESULTS,
    pub VolumeStackResume: FS_BPIO_RESULTS,
    pub StreamResume: FS_BPIO_RESULTS,
    pub GetInfo: FS_BPIO_INFO,
}
pub type FS_BPIO_OUTPUT = _FS_BPIO_OUTPUT;
pub type PFS_BPIO_OUTPUT = *mut _FS_BPIO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    pub Version: WORD,
}
pub type SMB_SHARE_FLUSH_AND_PURGE_INPUT = _SMB_SHARE_FLUSH_AND_PURGE_INPUT;
pub type PSMB_SHARE_FLUSH_AND_PURGE_INPUT = *mut _SMB_SHARE_FLUSH_AND_PURGE_INPUT;
pub type PCSMB_SHARE_FLUSH_AND_PURGE_INPUT = *const _SMB_SHARE_FLUSH_AND_PURGE_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    pub cEntriesPurged: DWORD,
}
pub type SMB_SHARE_FLUSH_AND_PURGE_OUTPUT = _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT;
pub type PSMB_SHARE_FLUSH_AND_PURGE_OUTPUT = *mut _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT;
pub type PCSMB_SHARE_FLUSH_AND_PURGE_OUTPUT = *const _SMB_SHARE_FLUSH_AND_PURGE_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_EXTENT {
    pub DiskNumber: DWORD,
    pub StartingOffset: LARGE_INTEGER,
    pub ExtentLength: LARGE_INTEGER,
}
pub type DISK_EXTENT = _DISK_EXTENT;
pub type PDISK_EXTENT = *mut _DISK_EXTENT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VOLUME_DISK_EXTENTS {
    pub NumberOfDiskExtents: DWORD,
    pub Extents: [DISK_EXTENT; 1usize],
}
pub type VOLUME_DISK_EXTENTS = _VOLUME_DISK_EXTENTS;
pub type PVOLUME_DISK_EXTENTS = *mut _VOLUME_DISK_EXTENTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION {
    pub GptAttributes: DWORDLONG,
}
pub type VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION;
pub type PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION = *mut _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION;
pub type PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        SourceContext: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
        TargetContext: *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER,
        RelativeOffset: LONGLONG,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {
    pub Validation: WORD,
    pub Flags: WORD,
    pub TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
}
pub type IO_IRP_EXT_TRACK_OFFSET_HEADER = _IO_IRP_EXT_TRACK_OFFSET_HEADER;
pub type PIO_IRP_EXT_TRACK_OFFSET_HEADER = *mut _IO_IRP_EXT_TRACK_OFFSET_HEADER;
pub type UWORD = WORD;
extern "C" {
    pub static GUID_DEVINTERFACE_SMARTCARD_READER: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_IO_REQUEST {
    pub dwProtocol: DWORD,
    pub cbPciLength: DWORD,
}
pub type SCARD_IO_REQUEST = _SCARD_IO_REQUEST;
pub type PSCARD_IO_REQUEST = *mut _SCARD_IO_REQUEST;
pub type LPSCARD_IO_REQUEST = *mut _SCARD_IO_REQUEST;
pub type LPCSCARD_IO_REQUEST = *const SCARD_IO_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_T0_COMMAND {
    pub bCla: BYTE,
    pub bIns: BYTE,
    pub bP1: BYTE,
    pub bP2: BYTE,
    pub bP3: BYTE,
}
pub type SCARD_T0_COMMAND = _SCARD_T0_COMMAND;
pub type LPSCARD_T0_COMMAND = *mut _SCARD_T0_COMMAND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCARD_T0_REQUEST {
    pub ioRequest: SCARD_IO_REQUEST,
    pub bSw1: BYTE,
    pub bSw2: BYTE,
    pub __bindgen_anon_1: _SCARD_T0_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SCARD_T0_REQUEST__bindgen_ty_1 {
    pub CmdBytes: SCARD_T0_COMMAND,
    pub rgbHeader: [BYTE; 5usize],
}
pub type SCARD_T0_REQUEST = _SCARD_T0_REQUEST;
pub type PSCARD_T0_REQUEST = *mut SCARD_T0_REQUEST;
pub type LPSCARD_T0_REQUEST = *mut SCARD_T0_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_T1_REQUEST {
    pub ioRequest: SCARD_IO_REQUEST,
}
pub type SCARD_T1_REQUEST = _SCARD_T1_REQUEST;
pub type PSCARD_T1_REQUEST = *mut SCARD_T1_REQUEST;
pub type LPSCARD_T1_REQUEST = *mut SCARD_T1_REQUEST;
pub type LPCBYTE = *const BYTE;
extern "C" {
    pub static g_rgSCardT0Pci: SCARD_IO_REQUEST;
}
extern "C" {
    pub static g_rgSCardT1Pci: SCARD_IO_REQUEST;
}
extern "C" {
    pub static g_rgSCardRawPci: SCARD_IO_REQUEST;
}
pub type SCARDCONTEXT = ULONG_PTR;
pub type PSCARDCONTEXT = *mut SCARDCONTEXT;
pub type LPSCARDCONTEXT = *mut SCARDCONTEXT;
pub type SCARDHANDLE = ULONG_PTR;
pub type PSCARDHANDLE = *mut SCARDHANDLE;
pub type LPSCARDHANDLE = *mut SCARDHANDLE;
extern "C" {
    pub fn SCardEstablishContext(
        dwScope: DWORD,
        pvReserved1: LPCVOID,
        pvReserved2: LPCVOID,
        phContext: LPSCARDCONTEXT,
    ) -> LONG;
}
extern "C" {
    pub fn SCardReleaseContext(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
    pub fn SCardIsValidContext(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
    pub fn SCardListReaderGroupsA(
        hContext: SCARDCONTEXT,
        mszGroups: LPSTR,
        pcchGroups: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListReaderGroupsW(
        hContext: SCARDCONTEXT,
        mszGroups: LPWSTR,
        pcchGroups: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListReadersA(
        hContext: SCARDCONTEXT,
        mszGroups: LPCSTR,
        mszReaders: LPSTR,
        pcchReaders: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListReadersW(
        hContext: SCARDCONTEXT,
        mszGroups: LPCWSTR,
        mszReaders: LPWSTR,
        pcchReaders: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListCardsA(
        hContext: SCARDCONTEXT,
        pbAtr: LPCBYTE,
        rgquidInterfaces: LPCGUID,
        cguidInterfaceCount: DWORD,
        mszCards: *mut CHAR,
        pcchCards: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListCardsW(
        hContext: SCARDCONTEXT,
        pbAtr: LPCBYTE,
        rgquidInterfaces: LPCGUID,
        cguidInterfaceCount: DWORD,
        mszCards: *mut WCHAR,
        pcchCards: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListInterfacesA(
        hContext: SCARDCONTEXT,
        szCard: LPCSTR,
        pguidInterfaces: LPGUID,
        pcguidInterfaces: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListInterfacesW(
        hContext: SCARDCONTEXT,
        szCard: LPCWSTR,
        pguidInterfaces: LPGUID,
        pcguidInterfaces: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetProviderIdA(
        hContext: SCARDCONTEXT,
        szCard: LPCSTR,
        pguidProviderId: LPGUID,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetProviderIdW(
        hContext: SCARDCONTEXT,
        szCard: LPCWSTR,
        pguidProviderId: LPGUID,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetCardTypeProviderNameA(
        hContext: SCARDCONTEXT,
        szCardName: LPCSTR,
        dwProviderId: DWORD,
        szProvider: *mut CHAR,
        pcchProvider: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetCardTypeProviderNameW(
        hContext: SCARDCONTEXT,
        szCardName: LPCWSTR,
        dwProviderId: DWORD,
        szProvider: *mut WCHAR,
        pcchProvider: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardIntroduceReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) -> LONG;
}
extern "C" {
    pub fn SCardIntroduceReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) -> LONG;
}
extern "C" {
    pub fn SCardForgetReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) -> LONG;
}
extern "C" {
    pub fn SCardForgetReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) -> LONG;
}
extern "C" {
    pub fn SCardIntroduceReaderA(
        hContext: SCARDCONTEXT,
        szReaderName: LPCSTR,
        szDeviceName: LPCSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardIntroduceReaderW(
        hContext: SCARDCONTEXT,
        szReaderName: LPCWSTR,
        szDeviceName: LPCWSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardForgetReaderA(hContext: SCARDCONTEXT, szReaderName: LPCSTR) -> LONG;
}
extern "C" {
    pub fn SCardForgetReaderW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR) -> LONG;
}
extern "C" {
    pub fn SCardAddReaderToGroupA(
        hContext: SCARDCONTEXT,
        szReaderName: LPCSTR,
        szGroupName: LPCSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardAddReaderToGroupW(
        hContext: SCARDCONTEXT,
        szReaderName: LPCWSTR,
        szGroupName: LPCWSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardRemoveReaderFromGroupA(
        hContext: SCARDCONTEXT,
        szReaderName: LPCSTR,
        szGroupName: LPCSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardRemoveReaderFromGroupW(
        hContext: SCARDCONTEXT,
        szReaderName: LPCWSTR,
        szGroupName: LPCWSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardIntroduceCardTypeA(
        hContext: SCARDCONTEXT,
        szCardName: LPCSTR,
        pguidPrimaryProvider: LPCGUID,
        rgguidInterfaces: LPCGUID,
        dwInterfaceCount: DWORD,
        pbAtr: LPCBYTE,
        pbAtrMask: LPCBYTE,
        cbAtrLen: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardIntroduceCardTypeW(
        hContext: SCARDCONTEXT,
        szCardName: LPCWSTR,
        pguidPrimaryProvider: LPCGUID,
        rgguidInterfaces: LPCGUID,
        dwInterfaceCount: DWORD,
        pbAtr: LPCBYTE,
        pbAtrMask: LPCBYTE,
        cbAtrLen: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardSetCardTypeProviderNameA(
        hContext: SCARDCONTEXT,
        szCardName: LPCSTR,
        dwProviderId: DWORD,
        szProvider: LPCSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardSetCardTypeProviderNameW(
        hContext: SCARDCONTEXT,
        szCardName: LPCWSTR,
        dwProviderId: DWORD,
        szProvider: LPCWSTR,
    ) -> LONG;
}
extern "C" {
    pub fn SCardForgetCardTypeA(hContext: SCARDCONTEXT, szCardName: LPCSTR) -> LONG;
}
extern "C" {
    pub fn SCardForgetCardTypeW(hContext: SCARDCONTEXT, szCardName: LPCWSTR) -> LONG;
}
extern "C" {
    pub fn SCardFreeMemory(hContext: SCARDCONTEXT, pvMem: LPCVOID) -> LONG;
}
extern "C" {
    pub fn SCardAccessStartedEvent() -> HANDLE;
}
extern "C" {
    pub fn SCardReleaseStartedEvent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCARD_READERSTATEA {
    pub szReader: LPCSTR,
    pub pvUserData: LPVOID,
    pub dwCurrentState: DWORD,
    pub dwEventState: DWORD,
    pub cbAtr: DWORD,
    pub rgbAtr: [BYTE; 36usize],
}
pub type PSCARD_READERSTATEA = *mut SCARD_READERSTATEA;
pub type LPSCARD_READERSTATEA = *mut SCARD_READERSTATEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCARD_READERSTATEW {
    pub szReader: LPCWSTR,
    pub pvUserData: LPVOID,
    pub dwCurrentState: DWORD,
    pub dwEventState: DWORD,
    pub cbAtr: DWORD,
    pub rgbAtr: [BYTE; 36usize],
}
pub type PSCARD_READERSTATEW = *mut SCARD_READERSTATEW;
pub type LPSCARD_READERSTATEW = *mut SCARD_READERSTATEW;
pub type SCARD_READERSTATE = SCARD_READERSTATEA;
pub type PSCARD_READERSTATE = PSCARD_READERSTATEA;
pub type LPSCARD_READERSTATE = LPSCARD_READERSTATEA;
extern "C" {
    pub fn SCardLocateCardsA(
        hContext: SCARDCONTEXT,
        mszCards: LPCSTR,
        rgReaderStates: LPSCARD_READERSTATEA,
        cReaders: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardLocateCardsW(
        hContext: SCARDCONTEXT,
        mszCards: LPCWSTR,
        rgReaderStates: LPSCARD_READERSTATEW,
        cReaders: DWORD,
    ) -> LONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_ATRMASK {
    pub cbAtr: DWORD,
    pub rgbAtr: [BYTE; 36usize],
    pub rgbMask: [BYTE; 36usize],
}
pub type SCARD_ATRMASK = _SCARD_ATRMASK;
pub type PSCARD_ATRMASK = *mut _SCARD_ATRMASK;
pub type LPSCARD_ATRMASK = *mut _SCARD_ATRMASK;
extern "C" {
    pub fn SCardLocateCardsByATRA(
        hContext: SCARDCONTEXT,
        rgAtrMasks: LPSCARD_ATRMASK,
        cAtrs: DWORD,
        rgReaderStates: LPSCARD_READERSTATEA,
        cReaders: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardLocateCardsByATRW(
        hContext: SCARDCONTEXT,
        rgAtrMasks: LPSCARD_ATRMASK,
        cAtrs: DWORD,
        rgReaderStates: LPSCARD_READERSTATEW,
        cReaders: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetStatusChangeA(
        hContext: SCARDCONTEXT,
        dwTimeout: DWORD,
        rgReaderStates: LPSCARD_READERSTATEA,
        cReaders: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetStatusChangeW(
        hContext: SCARDCONTEXT,
        dwTimeout: DWORD,
        rgReaderStates: LPSCARD_READERSTATEW,
        cReaders: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardCancel(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
    pub fn SCardConnectA(
        hContext: SCARDCONTEXT,
        szReader: LPCSTR,
        dwShareMode: DWORD,
        dwPreferredProtocols: DWORD,
        phCard: LPSCARDHANDLE,
        pdwActiveProtocol: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardConnectW(
        hContext: SCARDCONTEXT,
        szReader: LPCWSTR,
        dwShareMode: DWORD,
        dwPreferredProtocols: DWORD,
        phCard: LPSCARDHANDLE,
        pdwActiveProtocol: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardReconnect(
        hCard: SCARDHANDLE,
        dwShareMode: DWORD,
        dwPreferredProtocols: DWORD,
        dwInitialization: DWORD,
        pdwActiveProtocol: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardDisconnect(hCard: SCARDHANDLE, dwDisposition: DWORD) -> LONG;
}
extern "C" {
    pub fn SCardBeginTransaction(hCard: SCARDHANDLE) -> LONG;
}
extern "C" {
    pub fn SCardEndTransaction(hCard: SCARDHANDLE, dwDisposition: DWORD) -> LONG;
}
extern "C" {
    pub fn SCardCancelTransaction(hCard: SCARDHANDLE) -> LONG;
}
extern "C" {
    pub fn SCardState(
        hCard: SCARDHANDLE,
        pdwState: LPDWORD,
        pdwProtocol: LPDWORD,
        pbAtr: LPBYTE,
        pcbAtrLen: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardStatusA(
        hCard: SCARDHANDLE,
        mszReaderNames: LPSTR,
        pcchReaderLen: LPDWORD,
        pdwState: LPDWORD,
        pdwProtocol: LPDWORD,
        pbAtr: LPBYTE,
        pcbAtrLen: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardStatusW(
        hCard: SCARDHANDLE,
        mszReaderNames: LPWSTR,
        pcchReaderLen: LPDWORD,
        pdwState: LPDWORD,
        pdwProtocol: LPDWORD,
        pbAtr: LPBYTE,
        pcbAtrLen: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardTransmit(
        hCard: SCARDHANDLE,
        pioSendPci: LPCSCARD_IO_REQUEST,
        pbSendBuffer: LPCBYTE,
        cbSendLength: DWORD,
        pioRecvPci: LPSCARD_IO_REQUEST,
        pbRecvBuffer: LPBYTE,
        pcbRecvLength: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetTransmitCount(hCard: SCARDHANDLE, pcTransmitCount: LPDWORD) -> LONG;
}
extern "C" {
    pub fn SCardControl(
        hCard: SCARDHANDLE,
        dwControlCode: DWORD,
        lpInBuffer: LPCVOID,
        cbInBufferSize: DWORD,
        lpOutBuffer: LPVOID,
        cbOutBufferSize: DWORD,
        lpBytesReturned: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetAttrib(
        hCard: SCARDHANDLE,
        dwAttrId: DWORD,
        pbAttr: LPBYTE,
        pcbAttrLen: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardSetAttrib(
        hCard: SCARDHANDLE,
        dwAttrId: DWORD,
        pbAttr: LPCBYTE,
        cbAttrLen: DWORD,
    ) -> LONG;
}
pub type LPOCNCONNPROCA = ::std::option::Option<
    unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: LPSTR, arg3: LPSTR, arg4: PVOID) -> SCARDHANDLE,
>;
pub type LPOCNCONNPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: SCARDCONTEXT,
        arg2: LPWSTR,
        arg3: LPWSTR,
        arg4: PVOID,
    ) -> SCARDHANDLE,
>;
pub type LPOCNCHKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: SCARDHANDLE, arg3: PVOID) -> BOOL,
>;
pub type LPOCNDSCPROC =
    ::std::option::Option<unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: SCARDHANDLE, arg3: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARD_SEARCH_CRITERIAA {
    pub dwStructSize: DWORD,
    pub lpstrGroupNames: LPSTR,
    pub nMaxGroupNames: DWORD,
    pub rgguidInterfaces: LPCGUID,
    pub cguidInterfaces: DWORD,
    pub lpstrCardNames: LPSTR,
    pub nMaxCardNames: DWORD,
    pub lpfnCheck: LPOCNCHKPROC,
    pub lpfnConnect: LPOCNCONNPROCA,
    pub lpfnDisconnect: LPOCNDSCPROC,
    pub pvUserData: LPVOID,
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
}
pub type POPENCARD_SEARCH_CRITERIAA = *mut OPENCARD_SEARCH_CRITERIAA;
pub type LPOPENCARD_SEARCH_CRITERIAA = *mut OPENCARD_SEARCH_CRITERIAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARD_SEARCH_CRITERIAW {
    pub dwStructSize: DWORD,
    pub lpstrGroupNames: LPWSTR,
    pub nMaxGroupNames: DWORD,
    pub rgguidInterfaces: LPCGUID,
    pub cguidInterfaces: DWORD,
    pub lpstrCardNames: LPWSTR,
    pub nMaxCardNames: DWORD,
    pub lpfnCheck: LPOCNCHKPROC,
    pub lpfnConnect: LPOCNCONNPROCW,
    pub lpfnDisconnect: LPOCNDSCPROC,
    pub pvUserData: LPVOID,
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
}
pub type POPENCARD_SEARCH_CRITERIAW = *mut OPENCARD_SEARCH_CRITERIAW;
pub type LPOPENCARD_SEARCH_CRITERIAW = *mut OPENCARD_SEARCH_CRITERIAW;
pub type OPENCARD_SEARCH_CRITERIA = OPENCARD_SEARCH_CRITERIAA;
pub type POPENCARD_SEARCH_CRITERIA = POPENCARD_SEARCH_CRITERIAA;
pub type LPOPENCARD_SEARCH_CRITERIA = LPOPENCARD_SEARCH_CRITERIAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAME_EXA {
    pub dwStructSize: DWORD,
    pub hSCardContext: SCARDCONTEXT,
    pub hwndOwner: HWND,
    pub dwFlags: DWORD,
    pub lpstrTitle: LPCSTR,
    pub lpstrSearchDesc: LPCSTR,
    pub hIcon: HICON,
    pub pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAA,
    pub lpfnConnect: LPOCNCONNPROCA,
    pub pvUserData: LPVOID,
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
    pub lpstrRdr: LPSTR,
    pub nMaxRdr: DWORD,
    pub lpstrCard: LPSTR,
    pub nMaxCard: DWORD,
    pub dwActiveProtocol: DWORD,
    pub hCardHandle: SCARDHANDLE,
}
pub type POPENCARDNAME_EXA = *mut OPENCARDNAME_EXA;
pub type LPOPENCARDNAME_EXA = *mut OPENCARDNAME_EXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAME_EXW {
    pub dwStructSize: DWORD,
    pub hSCardContext: SCARDCONTEXT,
    pub hwndOwner: HWND,
    pub dwFlags: DWORD,
    pub lpstrTitle: LPCWSTR,
    pub lpstrSearchDesc: LPCWSTR,
    pub hIcon: HICON,
    pub pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAW,
    pub lpfnConnect: LPOCNCONNPROCW,
    pub pvUserData: LPVOID,
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
    pub lpstrRdr: LPWSTR,
    pub nMaxRdr: DWORD,
    pub lpstrCard: LPWSTR,
    pub nMaxCard: DWORD,
    pub dwActiveProtocol: DWORD,
    pub hCardHandle: SCARDHANDLE,
}
pub type POPENCARDNAME_EXW = *mut OPENCARDNAME_EXW;
pub type LPOPENCARDNAME_EXW = *mut OPENCARDNAME_EXW;
pub type OPENCARDNAME_EX = OPENCARDNAME_EXA;
pub type POPENCARDNAME_EX = POPENCARDNAME_EXA;
pub type LPOPENCARDNAME_EX = LPOPENCARDNAME_EXA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum READER_SEL_REQUEST_MATCH_TYPE {
    RSR_MATCH_TYPE_READER_AND_CONTAINER = 1,
    RSR_MATCH_TYPE_SERIAL_NUMBER = 2,
    RSR_MATCH_TYPE_ALL_CARDS = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct READER_SEL_REQUEST {
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
    pub MatchType: READER_SEL_REQUEST_MATCH_TYPE,
    pub __bindgen_anon_1: READER_SEL_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union READER_SEL_REQUEST__bindgen_ty_1 {
    pub ReaderAndContainerParameter: READER_SEL_REQUEST__bindgen_ty_1__bindgen_ty_1,
    pub SerialNumberParameter: READER_SEL_REQUEST__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READER_SEL_REQUEST__bindgen_ty_1__bindgen_ty_1 {
    pub cbReaderNameOffset: DWORD,
    pub cchReaderNameLength: DWORD,
    pub cbContainerNameOffset: DWORD,
    pub cchContainerNameLength: DWORD,
    pub dwDesiredCardModuleVersion: DWORD,
    pub dwCspFlags: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READER_SEL_REQUEST__bindgen_ty_1__bindgen_ty_2 {
    pub cbSerialNumberOffset: DWORD,
    pub cbSerialNumberLength: DWORD,
    pub dwDesiredCardModuleVersion: DWORD,
}
pub type PREADER_SEL_REQUEST = *mut READER_SEL_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct READER_SEL_RESPONSE {
    pub cbReaderNameOffset: DWORD,
    pub cchReaderNameLength: DWORD,
    pub cbCardNameOffset: DWORD,
    pub cchCardNameLength: DWORD,
}
pub type PREADER_SEL_RESPONSE = *mut READER_SEL_RESPONSE;
extern "C" {
    pub fn SCardUIDlgSelectCardA(arg1: LPOPENCARDNAME_EXA) -> LONG;
}
extern "C" {
    pub fn SCardUIDlgSelectCardW(arg1: LPOPENCARDNAME_EXW) -> LONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAMEA {
    pub dwStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hSCardContext: SCARDCONTEXT,
    pub lpstrGroupNames: LPSTR,
    pub nMaxGroupNames: DWORD,
    pub lpstrCardNames: LPSTR,
    pub nMaxCardNames: DWORD,
    pub rgguidInterfaces: LPCGUID,
    pub cguidInterfaces: DWORD,
    pub lpstrRdr: LPSTR,
    pub nMaxRdr: DWORD,
    pub lpstrCard: LPSTR,
    pub nMaxCard: DWORD,
    pub lpstrTitle: LPCSTR,
    pub dwFlags: DWORD,
    pub pvUserData: LPVOID,
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
    pub dwActiveProtocol: DWORD,
    pub lpfnConnect: LPOCNCONNPROCA,
    pub lpfnCheck: LPOCNCHKPROC,
    pub lpfnDisconnect: LPOCNDSCPROC,
    pub hCardHandle: SCARDHANDLE,
}
pub type POPENCARDNAMEA = *mut OPENCARDNAMEA;
pub type LPOPENCARDNAMEA = *mut OPENCARDNAMEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAMEW {
    pub dwStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hSCardContext: SCARDCONTEXT,
    pub lpstrGroupNames: LPWSTR,
    pub nMaxGroupNames: DWORD,
    pub lpstrCardNames: LPWSTR,
    pub nMaxCardNames: DWORD,
    pub rgguidInterfaces: LPCGUID,
    pub cguidInterfaces: DWORD,
    pub lpstrRdr: LPWSTR,
    pub nMaxRdr: DWORD,
    pub lpstrCard: LPWSTR,
    pub nMaxCard: DWORD,
    pub lpstrTitle: LPCWSTR,
    pub dwFlags: DWORD,
    pub pvUserData: LPVOID,
    pub dwShareMode: DWORD,
    pub dwPreferredProtocols: DWORD,
    pub dwActiveProtocol: DWORD,
    pub lpfnConnect: LPOCNCONNPROCW,
    pub lpfnCheck: LPOCNCHKPROC,
    pub lpfnDisconnect: LPOCNDSCPROC,
    pub hCardHandle: SCARDHANDLE,
}
pub type POPENCARDNAMEW = *mut OPENCARDNAMEW;
pub type LPOPENCARDNAMEW = *mut OPENCARDNAMEW;
pub type OPENCARDNAME = OPENCARDNAMEA;
pub type POPENCARDNAME = POPENCARDNAMEA;
pub type LPOPENCARDNAME = LPOPENCARDNAMEA;
extern "C" {
    pub fn GetOpenCardNameA(arg1: LPOPENCARDNAMEA) -> LONG;
}
extern "C" {
    pub fn GetOpenCardNameW(arg1: LPOPENCARDNAMEW) -> LONG;
}
extern "C" {
    pub fn SCardDlgExtendedError() -> LONG;
}
extern "C" {
    pub fn SCardReadCacheA(
        hContext: SCARDCONTEXT,
        CardIdentifier: *mut UUID,
        FreshnessCounter: DWORD,
        LookupName: LPSTR,
        Data: PBYTE,
        DataLen: *mut DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardReadCacheW(
        hContext: SCARDCONTEXT,
        CardIdentifier: *mut UUID,
        FreshnessCounter: DWORD,
        LookupName: LPWSTR,
        Data: PBYTE,
        DataLen: *mut DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardWriteCacheA(
        hContext: SCARDCONTEXT,
        CardIdentifier: *mut UUID,
        FreshnessCounter: DWORD,
        LookupName: LPSTR,
        Data: PBYTE,
        DataLen: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardWriteCacheW(
        hContext: SCARDCONTEXT,
        CardIdentifier: *mut UUID,
        FreshnessCounter: DWORD,
        LookupName: LPWSTR,
        Data: PBYTE,
        DataLen: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetReaderIconA(
        hContext: SCARDCONTEXT,
        szReaderName: LPCSTR,
        pbIcon: LPBYTE,
        pcbIcon: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetReaderIconW(
        hContext: SCARDCONTEXT,
        szReaderName: LPCWSTR,
        pbIcon: LPBYTE,
        pcbIcon: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetDeviceTypeIdA(
        hContext: SCARDCONTEXT,
        szReaderName: LPCSTR,
        pdwDeviceTypeId: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetDeviceTypeIdW(
        hContext: SCARDCONTEXT,
        szReaderName: LPCWSTR,
        pdwDeviceTypeId: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetReaderDeviceInstanceIdA(
        hContext: SCARDCONTEXT,
        szReaderName: LPCSTR,
        szDeviceInstanceId: LPSTR,
        pcchDeviceInstanceId: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardGetReaderDeviceInstanceIdW(
        hContext: SCARDCONTEXT,
        szReaderName: LPCWSTR,
        szDeviceInstanceId: LPWSTR,
        pcchDeviceInstanceId: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListReadersWithDeviceInstanceIdA(
        hContext: SCARDCONTEXT,
        szDeviceInstanceId: LPCSTR,
        mszReaders: LPSTR,
        pcchReaders: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardListReadersWithDeviceInstanceIdW(
        hContext: SCARDCONTEXT,
        szDeviceInstanceId: LPCWSTR,
        mszReaders: LPWSTR,
        pcchReaders: LPDWORD,
    ) -> LONG;
}
extern "C" {
    pub fn SCardAudit(hContext: SCARDCONTEXT, dwEvent: DWORD) -> LONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSP {
    _unused: [u8; 0],
}
pub type HPROPSHEETPAGE = *mut _PSP;
pub type LPFNPSPCALLBACKA = ::std::option::Option<
    unsafe extern "C" fn(hwnd: HWND, uMsg: UINT, ppsp: *mut _PROPSHEETPAGEA) -> UINT,
>;
pub type LPFNPSPCALLBACKW = ::std::option::Option<
    unsafe extern "C" fn(hwnd: HWND, uMsg: UINT, ppsp: *mut _PROPSHEETPAGEW) -> UINT,
>;
pub type PROPSHEETPAGE_RESOURCE = LPCDLGTEMPLATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEA_V1 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEA_V1__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEA_V1__bindgen_ty_2,
    pub pszTitle: LPCSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKA,
    pub pcRefParent: *mut UINT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA_V1__bindgen_ty_1 {
    pub pszTemplate: LPCSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA_V1__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
pub type PROPSHEETPAGEA_V1 = _PROPSHEETPAGEA_V1;
pub type LPPROPSHEETPAGEA_V1 = *mut _PROPSHEETPAGEA_V1;
pub type LPCPROPSHEETPAGEA_V1 = *const PROPSHEETPAGEA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEA_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEA_V2__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEA_V2__bindgen_ty_2,
    pub pszTitle: LPCSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKA,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCSTR,
    pub pszHeaderSubTitle: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA_V2__bindgen_ty_1 {
    pub pszTemplate: LPCSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA_V2__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
pub type PROPSHEETPAGEA_V2 = _PROPSHEETPAGEA_V2;
pub type LPPROPSHEETPAGEA_V2 = *mut _PROPSHEETPAGEA_V2;
pub type LPCPROPSHEETPAGEA_V2 = *const PROPSHEETPAGEA_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEA_V3 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEA_V3__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEA_V3__bindgen_ty_2,
    pub pszTitle: LPCSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKA,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCSTR,
    pub pszHeaderSubTitle: LPCSTR,
    pub hActCtx: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA_V3__bindgen_ty_1 {
    pub pszTemplate: LPCSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA_V3__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
pub type PROPSHEETPAGEA_V3 = _PROPSHEETPAGEA_V3;
pub type LPPROPSHEETPAGEA_V3 = *mut _PROPSHEETPAGEA_V3;
pub type LPCPROPSHEETPAGEA_V3 = *const PROPSHEETPAGEA_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEA {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEA__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEA__bindgen_ty_2,
    pub pszTitle: LPCSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKA,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCSTR,
    pub pszHeaderSubTitle: LPCSTR,
    pub hActCtx: HANDLE,
    pub __bindgen_anon_3: _PROPSHEETPAGEA__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_1 {
    pub pszTemplate: LPCSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_3 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCSTR,
}
pub type PROPSHEETPAGEA_V4 = _PROPSHEETPAGEA;
pub type LPPROPSHEETPAGEA_V4 = *mut _PROPSHEETPAGEA;
pub type LPCPROPSHEETPAGEA_V4 = *const PROPSHEETPAGEA_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEW_V1 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEW_V1__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEW_V1__bindgen_ty_2,
    pub pszTitle: LPCWSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKW,
    pub pcRefParent: *mut UINT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW_V1__bindgen_ty_1 {
    pub pszTemplate: LPCWSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW_V1__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
pub type PROPSHEETPAGEW_V1 = _PROPSHEETPAGEW_V1;
pub type LPPROPSHEETPAGEW_V1 = *mut _PROPSHEETPAGEW_V1;
pub type LPCPROPSHEETPAGEW_V1 = *const PROPSHEETPAGEW_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEW_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEW_V2__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEW_V2__bindgen_ty_2,
    pub pszTitle: LPCWSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKW,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCWSTR,
    pub pszHeaderSubTitle: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW_V2__bindgen_ty_1 {
    pub pszTemplate: LPCWSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW_V2__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
pub type PROPSHEETPAGEW_V2 = _PROPSHEETPAGEW_V2;
pub type LPPROPSHEETPAGEW_V2 = *mut _PROPSHEETPAGEW_V2;
pub type LPCPROPSHEETPAGEW_V2 = *const PROPSHEETPAGEW_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEW_V3 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEW_V3__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEW_V3__bindgen_ty_2,
    pub pszTitle: LPCWSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKW,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCWSTR,
    pub pszHeaderSubTitle: LPCWSTR,
    pub hActCtx: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW_V3__bindgen_ty_1 {
    pub pszTemplate: LPCWSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW_V3__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
pub type PROPSHEETPAGEW_V3 = _PROPSHEETPAGEW_V3;
pub type LPPROPSHEETPAGEW_V3 = *mut _PROPSHEETPAGEW_V3;
pub type LPCPROPSHEETPAGEW_V3 = *const PROPSHEETPAGEW_V3;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEW {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEW__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEW__bindgen_ty_2,
    pub pszTitle: LPCWSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKW,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCWSTR,
    pub pszHeaderSubTitle: LPCWSTR,
    pub hActCtx: HANDLE,
    pub __bindgen_anon_3: _PROPSHEETPAGEW__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_1 {
    pub pszTemplate: LPCWSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_3 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCWSTR,
}
pub type PROPSHEETPAGEW_V4 = _PROPSHEETPAGEW;
pub type LPPROPSHEETPAGEW_V4 = *mut _PROPSHEETPAGEW;
pub type LPCPROPSHEETPAGEW_V4 = *const PROPSHEETPAGEW_V4;
pub type PROPSHEETPAGEA_LATEST = PROPSHEETPAGEA_V4;
pub type PROPSHEETPAGEW_LATEST = PROPSHEETPAGEW_V4;
pub type LPPROPSHEETPAGEA_LATEST = LPPROPSHEETPAGEA_V4;
pub type LPPROPSHEETPAGEW_LATEST = LPPROPSHEETPAGEW_V4;
pub type LPCPROPSHEETPAGEA_LATEST = LPCPROPSHEETPAGEA_V4;
pub type LPCPROPSHEETPAGEW_LATEST = LPCPROPSHEETPAGEW_V4;
pub type PROPSHEETPAGEA = PROPSHEETPAGEA_V4;
pub type PROPSHEETPAGEW = PROPSHEETPAGEW_V4;
pub type LPPROPSHEETPAGEA = LPPROPSHEETPAGEA_V4;
pub type LPPROPSHEETPAGEW = LPPROPSHEETPAGEW_V4;
pub type LPCPROPSHEETPAGEA = LPCPROPSHEETPAGEA_V4;
pub type LPCPROPSHEETPAGEW = LPCPROPSHEETPAGEW_V4;
pub type PFNPROPSHEETCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: LPARAM) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERA_V1 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERA_V1__bindgen_ty_1,
    pub pszCaption: LPCSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERA_V1__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERA_V1__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V1__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V1__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V1__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEA,
    pub phpage: *mut HPROPSHEETPAGE,
}
pub type PROPSHEETHEADERA_V1 = _PROPSHEETHEADERA_V1;
pub type LPPROPSHEETHEADERA_V1 = *mut _PROPSHEETHEADERA_V1;
pub type LPCPROPSHEETHEADERA_V1 = *const PROPSHEETHEADERA_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERA_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERA_V2__bindgen_ty_1,
    pub pszCaption: LPCSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERA_V2__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERA_V2__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
    pub __bindgen_anon_4: _PROPSHEETHEADERA_V2__bindgen_ty_4,
    pub hplWatermark: HPALETTE,
    pub __bindgen_anon_5: _PROPSHEETHEADERA_V2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEA,
    pub phpage: *mut HPROPSHEETPAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_4 {
    pub hbmWatermark: HBITMAP,
    pub pszbmWatermark: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_5 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCSTR,
}
pub type PROPSHEETHEADERA_V2 = _PROPSHEETHEADERA_V2;
pub type LPPROPSHEETHEADERA_V2 = *mut _PROPSHEETHEADERA_V2;
pub type LPCPROPSHEETHEADERA_V2 = *const PROPSHEETHEADERA_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERW_V1 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERW_V1__bindgen_ty_1,
    pub pszCaption: LPCWSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERW_V1__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERW_V1__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V1__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V1__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V1__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEW,
    pub phpage: *mut HPROPSHEETPAGE,
}
pub type PROPSHEETHEADERW_V1 = _PROPSHEETHEADERW_V1;
pub type LPPROPSHEETHEADERW_V1 = *mut _PROPSHEETHEADERW_V1;
pub type LPCPROPSHEETHEADERW_V1 = *const PROPSHEETHEADERW_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERW_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERW_V2__bindgen_ty_1,
    pub pszCaption: LPCWSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERW_V2__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERW_V2__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
    pub __bindgen_anon_4: _PROPSHEETHEADERW_V2__bindgen_ty_4,
    pub hplWatermark: HPALETTE,
    pub __bindgen_anon_5: _PROPSHEETHEADERW_V2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEW,
    pub phpage: *mut HPROPSHEETPAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_4 {
    pub hbmWatermark: HBITMAP,
    pub pszbmWatermark: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_5 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCWSTR,
}
pub type PROPSHEETHEADERW_V2 = _PROPSHEETHEADERW_V2;
pub type LPPROPSHEETHEADERW_V2 = *mut _PROPSHEETHEADERW_V2;
pub type LPCPROPSHEETHEADERW_V2 = *const PROPSHEETHEADERW_V2;
pub type PROPSHEETHEADERA = PROPSHEETHEADERA_V2;
pub type PROPSHEETHEADERW = PROPSHEETHEADERW_V2;
pub type LPPROPSHEETHEADERA = LPPROPSHEETHEADERA_V2;
pub type LPPROPSHEETHEADERW = LPPROPSHEETHEADERW_V2;
pub type LPCPROPSHEETHEADERA = LPCPROPSHEETHEADERA_V2;
pub type LPCPROPSHEETHEADERW = LPCPROPSHEETHEADERW_V2;
extern "C" {
    pub fn CreatePropertySheetPageA(constPropSheetPagePointer: LPCPROPSHEETPAGEA)
        -> HPROPSHEETPAGE;
}
extern "C" {
    pub fn CreatePropertySheetPageW(constPropSheetPagePointer: LPCPROPSHEETPAGEW)
        -> HPROPSHEETPAGE;
}
extern "C" {
    pub fn DestroyPropertySheetPage(arg1: HPROPSHEETPAGE) -> BOOL;
}
extern "C" {
    pub fn PropertySheetA(arg1: LPCPROPSHEETHEADERA) -> INT_PTR;
}
extern "C" {
    pub fn PropertySheetW(arg1: LPCPROPSHEETHEADERW) -> INT_PTR;
}
pub type LPFNADDPROPSHEETPAGE =
    ::std::option::Option<unsafe extern "C" fn(arg1: HPROPSHEETPAGE, arg2: LPARAM) -> BOOL>;
pub type LPFNADDPROPSHEETPAGES = ::std::option::Option<
    unsafe extern "C" fn(arg1: LPVOID, arg2: LPFNADDPROPSHEETPAGE, arg3: LPARAM) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSHNOTIFY {
    pub hdr: NMHDR,
    pub lParam: LPARAM,
}
pub type PSHNOTIFY = _PSHNOTIFY;
pub type LPPSHNOTIFY = *mut _PSHNOTIFY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_1A {
    pub Flags: DWORD,
    pub pDescription: LPSTR,
    pub pName: LPSTR,
    pub pComment: LPSTR,
}
pub type PRINTER_INFO_1A = _PRINTER_INFO_1A;
pub type PPRINTER_INFO_1A = *mut _PRINTER_INFO_1A;
pub type LPPRINTER_INFO_1A = *mut _PRINTER_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_1W {
    pub Flags: DWORD,
    pub pDescription: LPWSTR,
    pub pName: LPWSTR,
    pub pComment: LPWSTR,
}
pub type PRINTER_INFO_1W = _PRINTER_INFO_1W;
pub type PPRINTER_INFO_1W = *mut _PRINTER_INFO_1W;
pub type LPPRINTER_INFO_1W = *mut _PRINTER_INFO_1W;
pub type PRINTER_INFO_1 = PRINTER_INFO_1A;
pub type PPRINTER_INFO_1 = PPRINTER_INFO_1A;
pub type LPPRINTER_INFO_1 = LPPRINTER_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_2A {
    pub pServerName: LPSTR,
    pub pPrinterName: LPSTR,
    pub pShareName: LPSTR,
    pub pPortName: LPSTR,
    pub pDriverName: LPSTR,
    pub pComment: LPSTR,
    pub pLocation: LPSTR,
    pub pDevMode: LPDEVMODEA,
    pub pSepFile: LPSTR,
    pub pPrintProcessor: LPSTR,
    pub pDatatype: LPSTR,
    pub pParameters: LPSTR,
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Attributes: DWORD,
    pub Priority: DWORD,
    pub DefaultPriority: DWORD,
    pub StartTime: DWORD,
    pub UntilTime: DWORD,
    pub Status: DWORD,
    pub cJobs: DWORD,
    pub AveragePPM: DWORD,
}
pub type PRINTER_INFO_2A = _PRINTER_INFO_2A;
pub type PPRINTER_INFO_2A = *mut _PRINTER_INFO_2A;
pub type LPPRINTER_INFO_2A = *mut _PRINTER_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_2W {
    pub pServerName: LPWSTR,
    pub pPrinterName: LPWSTR,
    pub pShareName: LPWSTR,
    pub pPortName: LPWSTR,
    pub pDriverName: LPWSTR,
    pub pComment: LPWSTR,
    pub pLocation: LPWSTR,
    pub pDevMode: LPDEVMODEW,
    pub pSepFile: LPWSTR,
    pub pPrintProcessor: LPWSTR,
    pub pDatatype: LPWSTR,
    pub pParameters: LPWSTR,
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Attributes: DWORD,
    pub Priority: DWORD,
    pub DefaultPriority: DWORD,
    pub StartTime: DWORD,
    pub UntilTime: DWORD,
    pub Status: DWORD,
    pub cJobs: DWORD,
    pub AveragePPM: DWORD,
}
pub type PRINTER_INFO_2W = _PRINTER_INFO_2W;
pub type PPRINTER_INFO_2W = *mut _PRINTER_INFO_2W;
pub type LPPRINTER_INFO_2W = *mut _PRINTER_INFO_2W;
pub type PRINTER_INFO_2 = PRINTER_INFO_2A;
pub type PPRINTER_INFO_2 = PPRINTER_INFO_2A;
pub type LPPRINTER_INFO_2 = LPPRINTER_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_3 {
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
}
pub type PRINTER_INFO_3 = _PRINTER_INFO_3;
pub type PPRINTER_INFO_3 = *mut _PRINTER_INFO_3;
pub type LPPRINTER_INFO_3 = *mut _PRINTER_INFO_3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_4A {
    pub pPrinterName: LPSTR,
    pub pServerName: LPSTR,
    pub Attributes: DWORD,
}
pub type PRINTER_INFO_4A = _PRINTER_INFO_4A;
pub type PPRINTER_INFO_4A = *mut _PRINTER_INFO_4A;
pub type LPPRINTER_INFO_4A = *mut _PRINTER_INFO_4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_4W {
    pub pPrinterName: LPWSTR,
    pub pServerName: LPWSTR,
    pub Attributes: DWORD,
}
pub type PRINTER_INFO_4W = _PRINTER_INFO_4W;
pub type PPRINTER_INFO_4W = *mut _PRINTER_INFO_4W;
pub type LPPRINTER_INFO_4W = *mut _PRINTER_INFO_4W;
pub type PRINTER_INFO_4 = PRINTER_INFO_4A;
pub type PPRINTER_INFO_4 = PPRINTER_INFO_4A;
pub type LPPRINTER_INFO_4 = LPPRINTER_INFO_4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_5A {
    pub pPrinterName: LPSTR,
    pub pPortName: LPSTR,
    pub Attributes: DWORD,
    pub DeviceNotSelectedTimeout: DWORD,
    pub TransmissionRetryTimeout: DWORD,
}
pub type PRINTER_INFO_5A = _PRINTER_INFO_5A;
pub type PPRINTER_INFO_5A = *mut _PRINTER_INFO_5A;
pub type LPPRINTER_INFO_5A = *mut _PRINTER_INFO_5A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_5W {
    pub pPrinterName: LPWSTR,
    pub pPortName: LPWSTR,
    pub Attributes: DWORD,
    pub DeviceNotSelectedTimeout: DWORD,
    pub TransmissionRetryTimeout: DWORD,
}
pub type PRINTER_INFO_5W = _PRINTER_INFO_5W;
pub type PPRINTER_INFO_5W = *mut _PRINTER_INFO_5W;
pub type LPPRINTER_INFO_5W = *mut _PRINTER_INFO_5W;
pub type PRINTER_INFO_5 = PRINTER_INFO_5A;
pub type PPRINTER_INFO_5 = PPRINTER_INFO_5A;
pub type LPPRINTER_INFO_5 = LPPRINTER_INFO_5A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_6 {
    pub dwStatus: DWORD,
}
pub type PRINTER_INFO_6 = _PRINTER_INFO_6;
pub type PPRINTER_INFO_6 = *mut _PRINTER_INFO_6;
pub type LPPRINTER_INFO_6 = *mut _PRINTER_INFO_6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_7A {
    pub pszObjectGUID: LPSTR,
    pub dwAction: DWORD,
}
pub type PRINTER_INFO_7A = _PRINTER_INFO_7A;
pub type PPRINTER_INFO_7A = *mut _PRINTER_INFO_7A;
pub type LPPRINTER_INFO_7A = *mut _PRINTER_INFO_7A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_7W {
    pub pszObjectGUID: LPWSTR,
    pub dwAction: DWORD,
}
pub type PRINTER_INFO_7W = _PRINTER_INFO_7W;
pub type PPRINTER_INFO_7W = *mut _PRINTER_INFO_7W;
pub type LPPRINTER_INFO_7W = *mut _PRINTER_INFO_7W;
pub type PRINTER_INFO_7 = PRINTER_INFO_7A;
pub type PPRINTER_INFO_7 = PPRINTER_INFO_7A;
pub type LPPRINTER_INFO_7 = LPPRINTER_INFO_7A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_8A {
    pub pDevMode: LPDEVMODEA,
}
pub type PRINTER_INFO_8A = _PRINTER_INFO_8A;
pub type PPRINTER_INFO_8A = *mut _PRINTER_INFO_8A;
pub type LPPRINTER_INFO_8A = *mut _PRINTER_INFO_8A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_8W {
    pub pDevMode: LPDEVMODEW,
}
pub type PRINTER_INFO_8W = _PRINTER_INFO_8W;
pub type PPRINTER_INFO_8W = *mut _PRINTER_INFO_8W;
pub type LPPRINTER_INFO_8W = *mut _PRINTER_INFO_8W;
pub type PRINTER_INFO_8 = PRINTER_INFO_8A;
pub type PPRINTER_INFO_8 = PPRINTER_INFO_8A;
pub type LPPRINTER_INFO_8 = LPPRINTER_INFO_8A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_9A {
    pub pDevMode: LPDEVMODEA,
}
pub type PRINTER_INFO_9A = _PRINTER_INFO_9A;
pub type PPRINTER_INFO_9A = *mut _PRINTER_INFO_9A;
pub type LPPRINTER_INFO_9A = *mut _PRINTER_INFO_9A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_INFO_9W {
    pub pDevMode: LPDEVMODEW,
}
pub type PRINTER_INFO_9W = _PRINTER_INFO_9W;
pub type PPRINTER_INFO_9W = *mut _PRINTER_INFO_9W;
pub type LPPRINTER_INFO_9W = *mut _PRINTER_INFO_9W;
pub type PRINTER_INFO_9 = PRINTER_INFO_9A;
pub type PPRINTER_INFO_9 = PPRINTER_INFO_9A;
pub type LPPRINTER_INFO_9 = LPPRINTER_INFO_9A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_1A {
    pub JobId: DWORD,
    pub pPrinterName: LPSTR,
    pub pMachineName: LPSTR,
    pub pUserName: LPSTR,
    pub pDocument: LPSTR,
    pub pDatatype: LPSTR,
    pub pStatus: LPSTR,
    pub Status: DWORD,
    pub Priority: DWORD,
    pub Position: DWORD,
    pub TotalPages: DWORD,
    pub PagesPrinted: DWORD,
    pub Submitted: SYSTEMTIME,
}
pub type JOB_INFO_1A = _JOB_INFO_1A;
pub type PJOB_INFO_1A = *mut _JOB_INFO_1A;
pub type LPJOB_INFO_1A = *mut _JOB_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_1W {
    pub JobId: DWORD,
    pub pPrinterName: LPWSTR,
    pub pMachineName: LPWSTR,
    pub pUserName: LPWSTR,
    pub pDocument: LPWSTR,
    pub pDatatype: LPWSTR,
    pub pStatus: LPWSTR,
    pub Status: DWORD,
    pub Priority: DWORD,
    pub Position: DWORD,
    pub TotalPages: DWORD,
    pub PagesPrinted: DWORD,
    pub Submitted: SYSTEMTIME,
}
pub type JOB_INFO_1W = _JOB_INFO_1W;
pub type PJOB_INFO_1W = *mut _JOB_INFO_1W;
pub type LPJOB_INFO_1W = *mut _JOB_INFO_1W;
pub type JOB_INFO_1 = JOB_INFO_1A;
pub type PJOB_INFO_1 = PJOB_INFO_1A;
pub type LPJOB_INFO_1 = LPJOB_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_2A {
    pub JobId: DWORD,
    pub pPrinterName: LPSTR,
    pub pMachineName: LPSTR,
    pub pUserName: LPSTR,
    pub pDocument: LPSTR,
    pub pNotifyName: LPSTR,
    pub pDatatype: LPSTR,
    pub pPrintProcessor: LPSTR,
    pub pParameters: LPSTR,
    pub pDriverName: LPSTR,
    pub pDevMode: LPDEVMODEA,
    pub pStatus: LPSTR,
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Status: DWORD,
    pub Priority: DWORD,
    pub Position: DWORD,
    pub StartTime: DWORD,
    pub UntilTime: DWORD,
    pub TotalPages: DWORD,
    pub Size: DWORD,
    pub Submitted: SYSTEMTIME,
    pub Time: DWORD,
    pub PagesPrinted: DWORD,
}
pub type JOB_INFO_2A = _JOB_INFO_2A;
pub type PJOB_INFO_2A = *mut _JOB_INFO_2A;
pub type LPJOB_INFO_2A = *mut _JOB_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_2W {
    pub JobId: DWORD,
    pub pPrinterName: LPWSTR,
    pub pMachineName: LPWSTR,
    pub pUserName: LPWSTR,
    pub pDocument: LPWSTR,
    pub pNotifyName: LPWSTR,
    pub pDatatype: LPWSTR,
    pub pPrintProcessor: LPWSTR,
    pub pParameters: LPWSTR,
    pub pDriverName: LPWSTR,
    pub pDevMode: LPDEVMODEW,
    pub pStatus: LPWSTR,
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Status: DWORD,
    pub Priority: DWORD,
    pub Position: DWORD,
    pub StartTime: DWORD,
    pub UntilTime: DWORD,
    pub TotalPages: DWORD,
    pub Size: DWORD,
    pub Submitted: SYSTEMTIME,
    pub Time: DWORD,
    pub PagesPrinted: DWORD,
}
pub type JOB_INFO_2W = _JOB_INFO_2W;
pub type PJOB_INFO_2W = *mut _JOB_INFO_2W;
pub type LPJOB_INFO_2W = *mut _JOB_INFO_2W;
pub type JOB_INFO_2 = JOB_INFO_2A;
pub type PJOB_INFO_2 = PJOB_INFO_2A;
pub type LPJOB_INFO_2 = LPJOB_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_3 {
    pub JobId: DWORD,
    pub NextJobId: DWORD,
    pub Reserved: DWORD,
}
pub type JOB_INFO_3 = _JOB_INFO_3;
pub type PJOB_INFO_3 = *mut _JOB_INFO_3;
pub type LPJOB_INFO_3 = *mut _JOB_INFO_3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_4A {
    pub JobId: DWORD,
    pub pPrinterName: LPSTR,
    pub pMachineName: LPSTR,
    pub pUserName: LPSTR,
    pub pDocument: LPSTR,
    pub pNotifyName: LPSTR,
    pub pDatatype: LPSTR,
    pub pPrintProcessor: LPSTR,
    pub pParameters: LPSTR,
    pub pDriverName: LPSTR,
    pub pDevMode: LPDEVMODEA,
    pub pStatus: LPSTR,
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Status: DWORD,
    pub Priority: DWORD,
    pub Position: DWORD,
    pub StartTime: DWORD,
    pub UntilTime: DWORD,
    pub TotalPages: DWORD,
    pub Size: DWORD,
    pub Submitted: SYSTEMTIME,
    pub Time: DWORD,
    pub PagesPrinted: DWORD,
    pub SizeHigh: LONG,
}
pub type JOB_INFO_4A = _JOB_INFO_4A;
pub type PJOB_INFO_4A = *mut _JOB_INFO_4A;
pub type LPJOB_INFO_4A = *mut _JOB_INFO_4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_INFO_4W {
    pub JobId: DWORD,
    pub pPrinterName: LPWSTR,
    pub pMachineName: LPWSTR,
    pub pUserName: LPWSTR,
    pub pDocument: LPWSTR,
    pub pNotifyName: LPWSTR,
    pub pDatatype: LPWSTR,
    pub pPrintProcessor: LPWSTR,
    pub pParameters: LPWSTR,
    pub pDriverName: LPWSTR,
    pub pDevMode: LPDEVMODEW,
    pub pStatus: LPWSTR,
    pub pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub Status: DWORD,
    pub Priority: DWORD,
    pub Position: DWORD,
    pub StartTime: DWORD,
    pub UntilTime: DWORD,
    pub TotalPages: DWORD,
    pub Size: DWORD,
    pub Submitted: SYSTEMTIME,
    pub Time: DWORD,
    pub PagesPrinted: DWORD,
    pub SizeHigh: LONG,
}
pub type JOB_INFO_4W = _JOB_INFO_4W;
pub type PJOB_INFO_4W = *mut _JOB_INFO_4W;
pub type LPJOB_INFO_4W = *mut _JOB_INFO_4W;
pub type JOB_INFO_4 = JOB_INFO_4A;
pub type PJOB_INFO_4 = PJOB_INFO_4A;
pub type LPJOB_INFO_4 = LPJOB_INFO_4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADDJOB_INFO_1A {
    pub Path: LPSTR,
    pub JobId: DWORD,
}
pub type ADDJOB_INFO_1A = _ADDJOB_INFO_1A;
pub type PADDJOB_INFO_1A = *mut _ADDJOB_INFO_1A;
pub type LPADDJOB_INFO_1A = *mut _ADDJOB_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADDJOB_INFO_1W {
    pub Path: LPWSTR,
    pub JobId: DWORD,
}
pub type ADDJOB_INFO_1W = _ADDJOB_INFO_1W;
pub type PADDJOB_INFO_1W = *mut _ADDJOB_INFO_1W;
pub type LPADDJOB_INFO_1W = *mut _ADDJOB_INFO_1W;
pub type ADDJOB_INFO_1 = ADDJOB_INFO_1A;
pub type PADDJOB_INFO_1 = PADDJOB_INFO_1A;
pub type LPADDJOB_INFO_1 = LPADDJOB_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_1A {
    pub pName: LPSTR,
}
pub type DRIVER_INFO_1A = _DRIVER_INFO_1A;
pub type PDRIVER_INFO_1A = *mut _DRIVER_INFO_1A;
pub type LPDRIVER_INFO_1A = *mut _DRIVER_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_1W {
    pub pName: LPWSTR,
}
pub type DRIVER_INFO_1W = _DRIVER_INFO_1W;
pub type PDRIVER_INFO_1W = *mut _DRIVER_INFO_1W;
pub type LPDRIVER_INFO_1W = *mut _DRIVER_INFO_1W;
pub type DRIVER_INFO_1 = DRIVER_INFO_1A;
pub type PDRIVER_INFO_1 = PDRIVER_INFO_1A;
pub type LPDRIVER_INFO_1 = LPDRIVER_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_2A {
    pub cVersion: DWORD,
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDriverPath: LPSTR,
    pub pDataFile: LPSTR,
    pub pConfigFile: LPSTR,
}
pub type DRIVER_INFO_2A = _DRIVER_INFO_2A;
pub type PDRIVER_INFO_2A = *mut _DRIVER_INFO_2A;
pub type LPDRIVER_INFO_2A = *mut _DRIVER_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_2W {
    pub cVersion: DWORD,
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDriverPath: LPWSTR,
    pub pDataFile: LPWSTR,
    pub pConfigFile: LPWSTR,
}
pub type DRIVER_INFO_2W = _DRIVER_INFO_2W;
pub type PDRIVER_INFO_2W = *mut _DRIVER_INFO_2W;
pub type LPDRIVER_INFO_2W = *mut _DRIVER_INFO_2W;
pub type DRIVER_INFO_2 = DRIVER_INFO_2A;
pub type PDRIVER_INFO_2 = PDRIVER_INFO_2A;
pub type LPDRIVER_INFO_2 = LPDRIVER_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_3A {
    pub cVersion: DWORD,
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDriverPath: LPSTR,
    pub pDataFile: LPSTR,
    pub pConfigFile: LPSTR,
    pub pHelpFile: LPSTR,
    pub pDependentFiles: LPSTR,
    pub pMonitorName: LPSTR,
    pub pDefaultDataType: LPSTR,
}
pub type DRIVER_INFO_3A = _DRIVER_INFO_3A;
pub type PDRIVER_INFO_3A = *mut _DRIVER_INFO_3A;
pub type LPDRIVER_INFO_3A = *mut _DRIVER_INFO_3A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_3W {
    pub cVersion: DWORD,
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDriverPath: LPWSTR,
    pub pDataFile: LPWSTR,
    pub pConfigFile: LPWSTR,
    pub pHelpFile: LPWSTR,
    pub pDependentFiles: LPWSTR,
    pub pMonitorName: LPWSTR,
    pub pDefaultDataType: LPWSTR,
}
pub type DRIVER_INFO_3W = _DRIVER_INFO_3W;
pub type PDRIVER_INFO_3W = *mut _DRIVER_INFO_3W;
pub type LPDRIVER_INFO_3W = *mut _DRIVER_INFO_3W;
pub type DRIVER_INFO_3 = DRIVER_INFO_3A;
pub type PDRIVER_INFO_3 = PDRIVER_INFO_3A;
pub type LPDRIVER_INFO_3 = LPDRIVER_INFO_3A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_4A {
    pub cVersion: DWORD,
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDriverPath: LPSTR,
    pub pDataFile: LPSTR,
    pub pConfigFile: LPSTR,
    pub pHelpFile: LPSTR,
    pub pDependentFiles: LPSTR,
    pub pMonitorName: LPSTR,
    pub pDefaultDataType: LPSTR,
    pub pszzPreviousNames: LPSTR,
}
pub type DRIVER_INFO_4A = _DRIVER_INFO_4A;
pub type PDRIVER_INFO_4A = *mut _DRIVER_INFO_4A;
pub type LPDRIVER_INFO_4A = *mut _DRIVER_INFO_4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_4W {
    pub cVersion: DWORD,
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDriverPath: LPWSTR,
    pub pDataFile: LPWSTR,
    pub pConfigFile: LPWSTR,
    pub pHelpFile: LPWSTR,
    pub pDependentFiles: LPWSTR,
    pub pMonitorName: LPWSTR,
    pub pDefaultDataType: LPWSTR,
    pub pszzPreviousNames: LPWSTR,
}
pub type DRIVER_INFO_4W = _DRIVER_INFO_4W;
pub type PDRIVER_INFO_4W = *mut _DRIVER_INFO_4W;
pub type LPDRIVER_INFO_4W = *mut _DRIVER_INFO_4W;
pub type DRIVER_INFO_4 = DRIVER_INFO_4A;
pub type PDRIVER_INFO_4 = PDRIVER_INFO_4A;
pub type LPDRIVER_INFO_4 = LPDRIVER_INFO_4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_5A {
    pub cVersion: DWORD,
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDriverPath: LPSTR,
    pub pDataFile: LPSTR,
    pub pConfigFile: LPSTR,
    pub dwDriverAttributes: DWORD,
    pub dwConfigVersion: DWORD,
    pub dwDriverVersion: DWORD,
}
pub type DRIVER_INFO_5A = _DRIVER_INFO_5A;
pub type PDRIVER_INFO_5A = *mut _DRIVER_INFO_5A;
pub type LPDRIVER_INFO_5A = *mut _DRIVER_INFO_5A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_5W {
    pub cVersion: DWORD,
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDriverPath: LPWSTR,
    pub pDataFile: LPWSTR,
    pub pConfigFile: LPWSTR,
    pub dwDriverAttributes: DWORD,
    pub dwConfigVersion: DWORD,
    pub dwDriverVersion: DWORD,
}
pub type DRIVER_INFO_5W = _DRIVER_INFO_5W;
pub type PDRIVER_INFO_5W = *mut _DRIVER_INFO_5W;
pub type LPDRIVER_INFO_5W = *mut _DRIVER_INFO_5W;
pub type DRIVER_INFO_5 = DRIVER_INFO_5A;
pub type PDRIVER_INFO_5 = PDRIVER_INFO_5A;
pub type LPDRIVER_INFO_5 = LPDRIVER_INFO_5A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_6A {
    pub cVersion: DWORD,
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDriverPath: LPSTR,
    pub pDataFile: LPSTR,
    pub pConfigFile: LPSTR,
    pub pHelpFile: LPSTR,
    pub pDependentFiles: LPSTR,
    pub pMonitorName: LPSTR,
    pub pDefaultDataType: LPSTR,
    pub pszzPreviousNames: LPSTR,
    pub ftDriverDate: FILETIME,
    pub dwlDriverVersion: DWORDLONG,
    pub pszMfgName: LPSTR,
    pub pszOEMUrl: LPSTR,
    pub pszHardwareID: LPSTR,
    pub pszProvider: LPSTR,
}
pub type DRIVER_INFO_6A = _DRIVER_INFO_6A;
pub type PDRIVER_INFO_6A = *mut _DRIVER_INFO_6A;
pub type LPDRIVER_INFO_6A = *mut _DRIVER_INFO_6A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_6W {
    pub cVersion: DWORD,
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDriverPath: LPWSTR,
    pub pDataFile: LPWSTR,
    pub pConfigFile: LPWSTR,
    pub pHelpFile: LPWSTR,
    pub pDependentFiles: LPWSTR,
    pub pMonitorName: LPWSTR,
    pub pDefaultDataType: LPWSTR,
    pub pszzPreviousNames: LPWSTR,
    pub ftDriverDate: FILETIME,
    pub dwlDriverVersion: DWORDLONG,
    pub pszMfgName: LPWSTR,
    pub pszOEMUrl: LPWSTR,
    pub pszHardwareID: LPWSTR,
    pub pszProvider: LPWSTR,
}
pub type DRIVER_INFO_6W = _DRIVER_INFO_6W;
pub type PDRIVER_INFO_6W = *mut _DRIVER_INFO_6W;
pub type LPDRIVER_INFO_6W = *mut _DRIVER_INFO_6W;
pub type DRIVER_INFO_6 = DRIVER_INFO_6A;
pub type PDRIVER_INFO_6 = PDRIVER_INFO_6A;
pub type LPDRIVER_INFO_6 = LPDRIVER_INFO_6A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_8A {
    pub cVersion: DWORD,
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDriverPath: LPSTR,
    pub pDataFile: LPSTR,
    pub pConfigFile: LPSTR,
    pub pHelpFile: LPSTR,
    pub pDependentFiles: LPSTR,
    pub pMonitorName: LPSTR,
    pub pDefaultDataType: LPSTR,
    pub pszzPreviousNames: LPSTR,
    pub ftDriverDate: FILETIME,
    pub dwlDriverVersion: DWORDLONG,
    pub pszMfgName: LPSTR,
    pub pszOEMUrl: LPSTR,
    pub pszHardwareID: LPSTR,
    pub pszProvider: LPSTR,
    pub pszPrintProcessor: LPSTR,
    pub pszVendorSetup: LPSTR,
    pub pszzColorProfiles: LPSTR,
    pub pszInfPath: LPSTR,
    pub dwPrinterDriverAttributes: DWORD,
    pub pszzCoreDriverDependencies: LPSTR,
    pub ftMinInboxDriverVerDate: FILETIME,
    pub dwlMinInboxDriverVerVersion: DWORDLONG,
}
pub type DRIVER_INFO_8A = _DRIVER_INFO_8A;
pub type PDRIVER_INFO_8A = *mut _DRIVER_INFO_8A;
pub type LPDRIVER_INFO_8A = *mut _DRIVER_INFO_8A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_INFO_8W {
    pub cVersion: DWORD,
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDriverPath: LPWSTR,
    pub pDataFile: LPWSTR,
    pub pConfigFile: LPWSTR,
    pub pHelpFile: LPWSTR,
    pub pDependentFiles: LPWSTR,
    pub pMonitorName: LPWSTR,
    pub pDefaultDataType: LPWSTR,
    pub pszzPreviousNames: LPWSTR,
    pub ftDriverDate: FILETIME,
    pub dwlDriverVersion: DWORDLONG,
    pub pszMfgName: LPWSTR,
    pub pszOEMUrl: LPWSTR,
    pub pszHardwareID: LPWSTR,
    pub pszProvider: LPWSTR,
    pub pszPrintProcessor: LPWSTR,
    pub pszVendorSetup: LPWSTR,
    pub pszzColorProfiles: LPWSTR,
    pub pszInfPath: LPWSTR,
    pub dwPrinterDriverAttributes: DWORD,
    pub pszzCoreDriverDependencies: LPWSTR,
    pub ftMinInboxDriverVerDate: FILETIME,
    pub dwlMinInboxDriverVerVersion: DWORDLONG,
}
pub type DRIVER_INFO_8W = _DRIVER_INFO_8W;
pub type PDRIVER_INFO_8W = *mut _DRIVER_INFO_8W;
pub type LPDRIVER_INFO_8W = *mut _DRIVER_INFO_8W;
pub type DRIVER_INFO_8 = DRIVER_INFO_8A;
pub type PDRIVER_INFO_8 = PDRIVER_INFO_8A;
pub type LPDRIVER_INFO_8 = LPDRIVER_INFO_8A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOC_INFO_1A {
    pub pDocName: LPSTR,
    pub pOutputFile: LPSTR,
    pub pDatatype: LPSTR,
}
pub type DOC_INFO_1A = _DOC_INFO_1A;
pub type PDOC_INFO_1A = *mut _DOC_INFO_1A;
pub type LPDOC_INFO_1A = *mut _DOC_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOC_INFO_1W {
    pub pDocName: LPWSTR,
    pub pOutputFile: LPWSTR,
    pub pDatatype: LPWSTR,
}
pub type DOC_INFO_1W = _DOC_INFO_1W;
pub type PDOC_INFO_1W = *mut _DOC_INFO_1W;
pub type LPDOC_INFO_1W = *mut _DOC_INFO_1W;
pub type DOC_INFO_1 = DOC_INFO_1A;
pub type PDOC_INFO_1 = PDOC_INFO_1A;
pub type LPDOC_INFO_1 = LPDOC_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_1A {
    pub Flags: DWORD,
    pub pName: LPSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
}
pub type FORM_INFO_1A = _FORM_INFO_1A;
pub type PFORM_INFO_1A = *mut _FORM_INFO_1A;
pub type LPFORM_INFO_1A = *mut _FORM_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_1W {
    pub Flags: DWORD,
    pub pName: LPWSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
}
pub type FORM_INFO_1W = _FORM_INFO_1W;
pub type PFORM_INFO_1W = *mut _FORM_INFO_1W;
pub type LPFORM_INFO_1W = *mut _FORM_INFO_1W;
pub type FORM_INFO_1 = FORM_INFO_1A;
pub type PFORM_INFO_1 = PFORM_INFO_1A;
pub type LPFORM_INFO_1 = LPFORM_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_2A {
    pub Flags: DWORD,
    pub pName: LPCSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
    pub pKeyword: LPCSTR,
    pub StringType: DWORD,
    pub pMuiDll: LPCSTR,
    pub dwResourceId: DWORD,
    pub pDisplayName: LPCSTR,
    pub wLangId: LANGID,
}
pub type FORM_INFO_2A = _FORM_INFO_2A;
pub type PFORM_INFO_2A = *mut _FORM_INFO_2A;
pub type LPFORM_INFO_2A = *mut _FORM_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_2W {
    pub Flags: DWORD,
    pub pName: LPCWSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
    pub pKeyword: LPCSTR,
    pub StringType: DWORD,
    pub pMuiDll: LPCWSTR,
    pub dwResourceId: DWORD,
    pub pDisplayName: LPCWSTR,
    pub wLangId: LANGID,
}
pub type FORM_INFO_2W = _FORM_INFO_2W;
pub type PFORM_INFO_2W = *mut _FORM_INFO_2W;
pub type LPFORM_INFO_2W = *mut _FORM_INFO_2W;
pub type FORM_INFO_2 = FORM_INFO_2A;
pub type PFORM_INFO_2 = PFORM_INFO_2A;
pub type LPFORM_INFO_2 = LPFORM_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOC_INFO_2A {
    pub pDocName: LPSTR,
    pub pOutputFile: LPSTR,
    pub pDatatype: LPSTR,
    pub dwMode: DWORD,
    pub JobId: DWORD,
}
pub type DOC_INFO_2A = _DOC_INFO_2A;
pub type PDOC_INFO_2A = *mut _DOC_INFO_2A;
pub type LPDOC_INFO_2A = *mut _DOC_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOC_INFO_2W {
    pub pDocName: LPWSTR,
    pub pOutputFile: LPWSTR,
    pub pDatatype: LPWSTR,
    pub dwMode: DWORD,
    pub JobId: DWORD,
}
pub type DOC_INFO_2W = _DOC_INFO_2W;
pub type PDOC_INFO_2W = *mut _DOC_INFO_2W;
pub type LPDOC_INFO_2W = *mut _DOC_INFO_2W;
pub type DOC_INFO_2 = DOC_INFO_2A;
pub type PDOC_INFO_2 = PDOC_INFO_2A;
pub type LPDOC_INFO_2 = LPDOC_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOC_INFO_3A {
    pub pDocName: LPSTR,
    pub pOutputFile: LPSTR,
    pub pDatatype: LPSTR,
    pub dwFlags: DWORD,
}
pub type DOC_INFO_3A = _DOC_INFO_3A;
pub type PDOC_INFO_3A = *mut _DOC_INFO_3A;
pub type LPDOC_INFO_3A = *mut _DOC_INFO_3A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DOC_INFO_3W {
    pub pDocName: LPWSTR,
    pub pOutputFile: LPWSTR,
    pub pDatatype: LPWSTR,
    pub dwFlags: DWORD,
}
pub type DOC_INFO_3W = _DOC_INFO_3W;
pub type PDOC_INFO_3W = *mut _DOC_INFO_3W;
pub type LPDOC_INFO_3W = *mut _DOC_INFO_3W;
pub type DOC_INFO_3 = DOC_INFO_3A;
pub type PDOC_INFO_3 = PDOC_INFO_3A;
pub type LPDOC_INFO_3 = LPDOC_INFO_3A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTPROCESSOR_INFO_1A {
    pub pName: LPSTR,
}
pub type PRINTPROCESSOR_INFO_1A = _PRINTPROCESSOR_INFO_1A;
pub type PPRINTPROCESSOR_INFO_1A = *mut _PRINTPROCESSOR_INFO_1A;
pub type LPPRINTPROCESSOR_INFO_1A = *mut _PRINTPROCESSOR_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTPROCESSOR_INFO_1W {
    pub pName: LPWSTR,
}
pub type PRINTPROCESSOR_INFO_1W = _PRINTPROCESSOR_INFO_1W;
pub type PPRINTPROCESSOR_INFO_1W = *mut _PRINTPROCESSOR_INFO_1W;
pub type LPPRINTPROCESSOR_INFO_1W = *mut _PRINTPROCESSOR_INFO_1W;
pub type PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1A;
pub type PPRINTPROCESSOR_INFO_1 = PPRINTPROCESSOR_INFO_1A;
pub type LPPRINTPROCESSOR_INFO_1 = LPPRINTPROCESSOR_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTPROCESSOR_CAPS_1 {
    pub dwLevel: DWORD,
    pub dwNupOptions: DWORD,
    pub dwPageOrderFlags: DWORD,
    pub dwNumberOfCopies: DWORD,
}
pub type PRINTPROCESSOR_CAPS_1 = _PRINTPROCESSOR_CAPS_1;
pub type PPRINTPROCESSOR_CAPS_1 = *mut _PRINTPROCESSOR_CAPS_1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTPROCESSOR_CAPS_2 {
    pub dwLevel: DWORD,
    pub dwNupOptions: DWORD,
    pub dwPageOrderFlags: DWORD,
    pub dwNumberOfCopies: DWORD,
    pub dwDuplexHandlingCaps: DWORD,
    pub dwNupDirectionCaps: DWORD,
    pub dwNupBorderCaps: DWORD,
    pub dwBookletHandlingCaps: DWORD,
    pub dwScalingCaps: DWORD,
}
pub type PRINTPROCESSOR_CAPS_2 = _PRINTPROCESSOR_CAPS_2;
pub type PPRINTPROCESSOR_CAPS_2 = *mut _PRINTPROCESSOR_CAPS_2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_INFO_1A {
    pub pName: LPSTR,
}
pub type PORT_INFO_1A = _PORT_INFO_1A;
pub type PPORT_INFO_1A = *mut _PORT_INFO_1A;
pub type LPPORT_INFO_1A = *mut _PORT_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_INFO_1W {
    pub pName: LPWSTR,
}
pub type PORT_INFO_1W = _PORT_INFO_1W;
pub type PPORT_INFO_1W = *mut _PORT_INFO_1W;
pub type LPPORT_INFO_1W = *mut _PORT_INFO_1W;
pub type PORT_INFO_1 = PORT_INFO_1A;
pub type PPORT_INFO_1 = PPORT_INFO_1A;
pub type LPPORT_INFO_1 = LPPORT_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_INFO_2A {
    pub pPortName: LPSTR,
    pub pMonitorName: LPSTR,
    pub pDescription: LPSTR,
    pub fPortType: DWORD,
    pub Reserved: DWORD,
}
pub type PORT_INFO_2A = _PORT_INFO_2A;
pub type PPORT_INFO_2A = *mut _PORT_INFO_2A;
pub type LPPORT_INFO_2A = *mut _PORT_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_INFO_2W {
    pub pPortName: LPWSTR,
    pub pMonitorName: LPWSTR,
    pub pDescription: LPWSTR,
    pub fPortType: DWORD,
    pub Reserved: DWORD,
}
pub type PORT_INFO_2W = _PORT_INFO_2W;
pub type PPORT_INFO_2W = *mut _PORT_INFO_2W;
pub type LPPORT_INFO_2W = *mut _PORT_INFO_2W;
pub type PORT_INFO_2 = PORT_INFO_2A;
pub type PPORT_INFO_2 = PPORT_INFO_2A;
pub type LPPORT_INFO_2 = LPPORT_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_INFO_3A {
    pub dwStatus: DWORD,
    pub pszStatus: LPSTR,
    pub dwSeverity: DWORD,
}
pub type PORT_INFO_3A = _PORT_INFO_3A;
pub type PPORT_INFO_3A = *mut _PORT_INFO_3A;
pub type LPPORT_INFO_3A = *mut _PORT_INFO_3A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PORT_INFO_3W {
    pub dwStatus: DWORD,
    pub pszStatus: LPWSTR,
    pub dwSeverity: DWORD,
}
pub type PORT_INFO_3W = _PORT_INFO_3W;
pub type PPORT_INFO_3W = *mut _PORT_INFO_3W;
pub type LPPORT_INFO_3W = *mut _PORT_INFO_3W;
pub type PORT_INFO_3 = PORT_INFO_3A;
pub type PPORT_INFO_3 = PPORT_INFO_3A;
pub type LPPORT_INFO_3 = LPPORT_INFO_3A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MONITOR_INFO_1A {
    pub pName: LPSTR,
}
pub type MONITOR_INFO_1A = _MONITOR_INFO_1A;
pub type PMONITOR_INFO_1A = *mut _MONITOR_INFO_1A;
pub type LPMONITOR_INFO_1A = *mut _MONITOR_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MONITOR_INFO_1W {
    pub pName: LPWSTR,
}
pub type MONITOR_INFO_1W = _MONITOR_INFO_1W;
pub type PMONITOR_INFO_1W = *mut _MONITOR_INFO_1W;
pub type LPMONITOR_INFO_1W = *mut _MONITOR_INFO_1W;
pub type MONITOR_INFO_1 = MONITOR_INFO_1A;
pub type PMONITOR_INFO_1 = PMONITOR_INFO_1A;
pub type LPMONITOR_INFO_1 = LPMONITOR_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MONITOR_INFO_2A {
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDLLName: LPSTR,
}
pub type MONITOR_INFO_2A = _MONITOR_INFO_2A;
pub type PMONITOR_INFO_2A = *mut _MONITOR_INFO_2A;
pub type LPMONITOR_INFO_2A = *mut _MONITOR_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MONITOR_INFO_2W {
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDLLName: LPWSTR,
}
pub type MONITOR_INFO_2W = _MONITOR_INFO_2W;
pub type PMONITOR_INFO_2W = *mut _MONITOR_INFO_2W;
pub type LPMONITOR_INFO_2W = *mut _MONITOR_INFO_2W;
pub type MONITOR_INFO_2 = MONITOR_INFO_2A;
pub type PMONITOR_INFO_2 = PMONITOR_INFO_2A;
pub type LPMONITOR_INFO_2 = LPMONITOR_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DATATYPES_INFO_1A {
    pub pName: LPSTR,
}
pub type DATATYPES_INFO_1A = _DATATYPES_INFO_1A;
pub type PDATATYPES_INFO_1A = *mut _DATATYPES_INFO_1A;
pub type LPDATATYPES_INFO_1A = *mut _DATATYPES_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DATATYPES_INFO_1W {
    pub pName: LPWSTR,
}
pub type DATATYPES_INFO_1W = _DATATYPES_INFO_1W;
pub type PDATATYPES_INFO_1W = *mut _DATATYPES_INFO_1W;
pub type LPDATATYPES_INFO_1W = *mut _DATATYPES_INFO_1W;
pub type DATATYPES_INFO_1 = DATATYPES_INFO_1A;
pub type PDATATYPES_INFO_1 = PDATATYPES_INFO_1A;
pub type LPDATATYPES_INFO_1 = LPDATATYPES_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_DEFAULTSA {
    pub pDatatype: LPSTR,
    pub pDevMode: LPDEVMODEA,
    pub DesiredAccess: ACCESS_MASK,
}
pub type PRINTER_DEFAULTSA = _PRINTER_DEFAULTSA;
pub type PPRINTER_DEFAULTSA = *mut _PRINTER_DEFAULTSA;
pub type LPPRINTER_DEFAULTSA = *mut _PRINTER_DEFAULTSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_DEFAULTSW {
    pub pDatatype: LPWSTR,
    pub pDevMode: LPDEVMODEW,
    pub DesiredAccess: ACCESS_MASK,
}
pub type PRINTER_DEFAULTSW = _PRINTER_DEFAULTSW;
pub type PPRINTER_DEFAULTSW = *mut _PRINTER_DEFAULTSW;
pub type LPPRINTER_DEFAULTSW = *mut _PRINTER_DEFAULTSW;
pub type PRINTER_DEFAULTS = PRINTER_DEFAULTSA;
pub type PPRINTER_DEFAULTS = PPRINTER_DEFAULTSA;
pub type LPPRINTER_DEFAULTS = LPPRINTER_DEFAULTSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_ENUM_VALUESA {
    pub pValueName: LPSTR,
    pub cbValueName: DWORD,
    pub dwType: DWORD,
    pub pData: LPBYTE,
    pub cbData: DWORD,
}
pub type PRINTER_ENUM_VALUESA = _PRINTER_ENUM_VALUESA;
pub type PPRINTER_ENUM_VALUESA = *mut _PRINTER_ENUM_VALUESA;
pub type LPPRINTER_ENUM_VALUESA = *mut _PRINTER_ENUM_VALUESA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_ENUM_VALUESW {
    pub pValueName: LPWSTR,
    pub cbValueName: DWORD,
    pub dwType: DWORD,
    pub pData: LPBYTE,
    pub cbData: DWORD,
}
pub type PRINTER_ENUM_VALUESW = _PRINTER_ENUM_VALUESW;
pub type PPRINTER_ENUM_VALUESW = *mut _PRINTER_ENUM_VALUESW;
pub type LPPRINTER_ENUM_VALUESW = *mut _PRINTER_ENUM_VALUESW;
pub type PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESA;
pub type PPRINTER_ENUM_VALUES = PPRINTER_ENUM_VALUESA;
pub type LPPRINTER_ENUM_VALUES = LPPRINTER_ENUM_VALUESA;
extern "C" {
    pub fn EnumPrintersA(
        Flags: DWORD,
        Name: LPSTR,
        Level: DWORD,
        pPrinterEnum: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrintersW(
        Flags: DWORD,
        Name: LPWSTR,
        Level: DWORD,
        pPrinterEnum: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetSpoolFileHandle(hPrinter: HANDLE) -> HANDLE;
}
extern "C" {
    pub fn CommitSpoolData(hPrinter: HANDLE, hSpoolFile: HANDLE, cbCommit: DWORD) -> HANDLE;
}
extern "C" {
    pub fn CloseSpoolFileHandle(hPrinter: HANDLE, hSpoolFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn OpenPrinterA(
        pPrinterName: LPSTR,
        phPrinter: LPHANDLE,
        pDefault: LPPRINTER_DEFAULTSA,
    ) -> BOOL;
}
extern "C" {
    pub fn OpenPrinterW(
        pPrinterName: LPWSTR,
        phPrinter: LPHANDLE,
        pDefault: LPPRINTER_DEFAULTSW,
    ) -> BOOL;
}
extern "C" {
    pub fn ResetPrinterA(hPrinter: HANDLE, pDefault: LPPRINTER_DEFAULTSA) -> BOOL;
}
extern "C" {
    pub fn ResetPrinterW(hPrinter: HANDLE, pDefault: LPPRINTER_DEFAULTSW) -> BOOL;
}
extern "C" {
    pub fn SetJobA(
        hPrinter: HANDLE,
        JobId: DWORD,
        Level: DWORD,
        pJob: LPBYTE,
        Command: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetJobW(
        hPrinter: HANDLE,
        JobId: DWORD,
        Level: DWORD,
        pJob: LPBYTE,
        Command: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetJobA(
        hPrinter: HANDLE,
        JobId: DWORD,
        Level: DWORD,
        pJob: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetJobW(
        hPrinter: HANDLE,
        JobId: DWORD,
        Level: DWORD,
        pJob: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumJobsA(
        hPrinter: HANDLE,
        FirstJob: DWORD,
        NoJobs: DWORD,
        Level: DWORD,
        pJob: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumJobsW(
        hPrinter: HANDLE,
        FirstJob: DWORD,
        NoJobs: DWORD,
        Level: DWORD,
        pJob: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPrinterA(pName: LPSTR, Level: DWORD, pPrinter: LPBYTE) -> HANDLE;
}
extern "C" {
    pub fn AddPrinterW(pName: LPWSTR, Level: DWORD, pPrinter: LPBYTE) -> HANDLE;
}
extern "C" {
    pub fn DeletePrinter(hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetPrinterA(hPrinter: HANDLE, Level: DWORD, pPrinter: LPBYTE, Command: DWORD) -> BOOL;
}
extern "C" {
    pub fn SetPrinterW(hPrinter: HANDLE, Level: DWORD, pPrinter: LPBYTE, Command: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetPrinterA(
        hPrinter: HANDLE,
        Level: DWORD,
        pPrinter: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrinterW(
        hPrinter: HANDLE,
        Level: DWORD,
        pPrinter: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPrinterDriverA(pName: LPSTR, Level: DWORD, pDriverInfo: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn AddPrinterDriverW(pName: LPWSTR, Level: DWORD, pDriverInfo: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn AddPrinterDriverExA(
        pName: LPSTR,
        Level: DWORD,
        lpbDriverInfo: PBYTE,
        dwFileCopyFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPrinterDriverExW(
        pName: LPWSTR,
        Level: DWORD,
        lpbDriverInfo: PBYTE,
        dwFileCopyFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrinterDriversA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        Level: DWORD,
        pDriverInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrinterDriversW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        Level: DWORD,
        pDriverInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrinterDriverA(
        hPrinter: HANDLE,
        pEnvironment: LPSTR,
        Level: DWORD,
        pDriverInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrinterDriverW(
        hPrinter: HANDLE,
        pEnvironment: LPWSTR,
        Level: DWORD,
        pDriverInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrinterDriverDirectoryA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        Level: DWORD,
        pDriverDirectory: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrinterDriverDirectoryW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        Level: DWORD,
        pDriverDirectory: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn DeletePrinterDriverA(pName: LPSTR, pEnvironment: LPSTR, pDriverName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn DeletePrinterDriverW(pName: LPWSTR, pEnvironment: LPWSTR, pDriverName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn DeletePrinterDriverExA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        pDriverName: LPSTR,
        dwDeleteFlag: DWORD,
        dwVersionFlag: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn DeletePrinterDriverExW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        pDriverName: LPWSTR,
        dwDeleteFlag: DWORD,
        dwVersionFlag: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPrintProcessorA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        pPathName: LPSTR,
        pPrintProcessorName: LPSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPrintProcessorW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        pPathName: LPWSTR,
        pPrintProcessorName: LPWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrintProcessorsA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        Level: DWORD,
        pPrintProcessorInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrintProcessorsW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        Level: DWORD,
        pPrintProcessorInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrintProcessorDirectoryA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        Level: DWORD,
        pPrintProcessorInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrintProcessorDirectoryW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        Level: DWORD,
        pPrintProcessorInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrintProcessorDatatypesA(
        pName: LPSTR,
        pPrintProcessorName: LPSTR,
        Level: DWORD,
        pDatatypes: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPrintProcessorDatatypesW(
        pName: LPWSTR,
        pPrintProcessorName: LPWSTR,
        Level: DWORD,
        pDatatypes: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn DeletePrintProcessorA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        pPrintProcessorName: LPSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn DeletePrintProcessorW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        pPrintProcessorName: LPWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn StartDocPrinterA(hPrinter: HANDLE, Level: DWORD, pDocInfo: LPBYTE) -> DWORD;
}
extern "C" {
    pub fn StartDocPrinterW(hPrinter: HANDLE, Level: DWORD, pDocInfo: LPBYTE) -> DWORD;
}
extern "C" {
    pub fn StartPagePrinter(hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn WritePrinter(hPrinter: HANDLE, pBuf: LPVOID, cbBuf: DWORD, pcWritten: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn FlushPrinter(
        hPrinter: HANDLE,
        pBuf: LPVOID,
        cbBuf: DWORD,
        pcWritten: LPDWORD,
        cSleep: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EndPagePrinter(hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn AbortPrinter(hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ReadPrinter(hPrinter: HANDLE, pBuf: LPVOID, cbBuf: DWORD, pNoBytesRead: LPDWORD)
        -> BOOL;
}
extern "C" {
    pub fn EndDocPrinter(hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn AddJobA(
        hPrinter: HANDLE,
        Level: DWORD,
        pData: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddJobW(
        hPrinter: HANDLE,
        Level: DWORD,
        pData: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ScheduleJob(hPrinter: HANDLE, JobId: DWORD) -> BOOL;
}
extern "C" {
    pub fn PrinterProperties(hWnd: HWND, hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn DocumentPropertiesA(
        hWnd: HWND,
        hPrinter: HANDLE,
        pDeviceName: LPSTR,
        pDevModeOutput: PDEVMODEA,
        pDevModeInput: PDEVMODEA,
        fMode: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn DocumentPropertiesW(
        hWnd: HWND,
        hPrinter: HANDLE,
        pDeviceName: LPWSTR,
        pDevModeOutput: PDEVMODEW,
        pDevModeInput: PDEVMODEW,
        fMode: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn AdvancedDocumentPropertiesA(
        hWnd: HWND,
        hPrinter: HANDLE,
        pDeviceName: LPSTR,
        pDevModeOutput: PDEVMODEA,
        pDevModeInput: PDEVMODEA,
    ) -> LONG;
}
extern "C" {
    pub fn AdvancedDocumentPropertiesW(
        hWnd: HWND,
        hPrinter: HANDLE,
        pDeviceName: LPWSTR,
        pDevModeOutput: PDEVMODEW,
        pDevModeInput: PDEVMODEW,
    ) -> LONG;
}
extern "C" {
    pub fn ExtDeviceMode(
        hWnd: HWND,
        hInst: HANDLE,
        pDevModeOutput: LPDEVMODEA,
        pDeviceName: LPSTR,
        pPort: LPSTR,
        pDevModeInput: LPDEVMODEA,
        pProfile: LPSTR,
        fMode: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn GetPrinterDataA(
        hPrinter: HANDLE,
        pValueName: LPSTR,
        pType: LPDWORD,
        pData: LPBYTE,
        nSize: DWORD,
        pcbNeeded: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrinterDataW(
        hPrinter: HANDLE,
        pValueName: LPWSTR,
        pType: LPDWORD,
        pData: LPBYTE,
        nSize: DWORD,
        pcbNeeded: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrinterDataExA(
        hPrinter: HANDLE,
        pKeyName: LPCSTR,
        pValueName: LPCSTR,
        pType: LPDWORD,
        pData: LPBYTE,
        nSize: DWORD,
        pcbNeeded: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrinterDataExW(
        hPrinter: HANDLE,
        pKeyName: LPCWSTR,
        pValueName: LPCWSTR,
        pType: LPDWORD,
        pData: LPBYTE,
        nSize: DWORD,
        pcbNeeded: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn EnumPrinterDataA(
        hPrinter: HANDLE,
        dwIndex: DWORD,
        pValueName: LPSTR,
        cbValueName: DWORD,
        pcbValueName: LPDWORD,
        pType: LPDWORD,
        pData: LPBYTE,
        cbData: DWORD,
        pcbData: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn EnumPrinterDataW(
        hPrinter: HANDLE,
        dwIndex: DWORD,
        pValueName: LPWSTR,
        cbValueName: DWORD,
        pcbValueName: LPDWORD,
        pType: LPDWORD,
        pData: LPBYTE,
        cbData: DWORD,
        pcbData: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn EnumPrinterDataExA(
        hPrinter: HANDLE,
        pKeyName: LPCSTR,
        pEnumValues: LPBYTE,
        cbEnumValues: DWORD,
        pcbEnumValues: LPDWORD,
        pnEnumValues: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn EnumPrinterDataExW(
        hPrinter: HANDLE,
        pKeyName: LPCWSTR,
        pEnumValues: LPBYTE,
        cbEnumValues: DWORD,
        pcbEnumValues: LPDWORD,
        pnEnumValues: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn EnumPrinterKeyA(
        hPrinter: HANDLE,
        pKeyName: LPCSTR,
        pSubkey: LPSTR,
        cbSubkey: DWORD,
        pcbSubkey: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn EnumPrinterKeyW(
        hPrinter: HANDLE,
        pKeyName: LPCWSTR,
        pSubkey: LPWSTR,
        cbSubkey: DWORD,
        pcbSubkey: LPDWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetPrinterDataA(
        hPrinter: HANDLE,
        pValueName: LPSTR,
        Type: DWORD,
        pData: LPBYTE,
        cbData: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetPrinterDataW(
        hPrinter: HANDLE,
        pValueName: LPWSTR,
        Type: DWORD,
        pData: LPBYTE,
        cbData: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetPrinterDataExA(
        hPrinter: HANDLE,
        pKeyName: LPCSTR,
        pValueName: LPCSTR,
        Type: DWORD,
        pData: LPBYTE,
        cbData: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetPrinterDataExW(
        hPrinter: HANDLE,
        pKeyName: LPCWSTR,
        pValueName: LPCWSTR,
        Type: DWORD,
        pData: LPBYTE,
        cbData: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn DeletePrinterDataA(hPrinter: HANDLE, pValueName: LPSTR) -> DWORD;
}
extern "C" {
    pub fn DeletePrinterDataW(hPrinter: HANDLE, pValueName: LPWSTR) -> DWORD;
}
extern "C" {
    pub fn DeletePrinterDataExA(hPrinter: HANDLE, pKeyName: LPCSTR, pValueName: LPCSTR) -> DWORD;
}
extern "C" {
    pub fn DeletePrinterDataExW(hPrinter: HANDLE, pKeyName: LPCWSTR, pValueName: LPCWSTR) -> DWORD;
}
extern "C" {
    pub fn DeletePrinterKeyA(hPrinter: HANDLE, pKeyName: LPCSTR) -> DWORD;
}
extern "C" {
    pub fn DeletePrinterKeyW(hPrinter: HANDLE, pKeyName: LPCWSTR) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_NOTIFY_OPTIONS_TYPE {
    pub Type: WORD,
    pub Reserved0: WORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD,
    pub Count: DWORD,
    pub pFields: PWORD,
}
pub type PRINTER_NOTIFY_OPTIONS_TYPE = _PRINTER_NOTIFY_OPTIONS_TYPE;
pub type PPRINTER_NOTIFY_OPTIONS_TYPE = *mut _PRINTER_NOTIFY_OPTIONS_TYPE;
pub type LPPRINTER_NOTIFY_OPTIONS_TYPE = *mut _PRINTER_NOTIFY_OPTIONS_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_NOTIFY_OPTIONS {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub Count: DWORD,
    pub pTypes: PPRINTER_NOTIFY_OPTIONS_TYPE,
}
pub type PRINTER_NOTIFY_OPTIONS = _PRINTER_NOTIFY_OPTIONS;
pub type PPRINTER_NOTIFY_OPTIONS = *mut _PRINTER_NOTIFY_OPTIONS;
pub type LPPRINTER_NOTIFY_OPTIONS = *mut _PRINTER_NOTIFY_OPTIONS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PRINTER_NOTIFY_INFO_DATA {
    pub Type: WORD,
    pub Field: WORD,
    pub Reserved: DWORD,
    pub Id: DWORD,
    pub NotifyData: _PRINTER_NOTIFY_INFO_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PRINTER_NOTIFY_INFO_DATA__bindgen_ty_1 {
    pub adwData: [DWORD; 2usize],
    pub Data: _PRINTER_NOTIFY_INFO_DATA__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_NOTIFY_INFO_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub cbBuf: DWORD,
    pub pBuf: LPVOID,
}
pub type PRINTER_NOTIFY_INFO_DATA = _PRINTER_NOTIFY_INFO_DATA;
pub type PPRINTER_NOTIFY_INFO_DATA = *mut _PRINTER_NOTIFY_INFO_DATA;
pub type LPPRINTER_NOTIFY_INFO_DATA = *mut _PRINTER_NOTIFY_INFO_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PRINTER_NOTIFY_INFO {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub Count: DWORD,
    pub aData: [PRINTER_NOTIFY_INFO_DATA; 1usize],
}
pub type PRINTER_NOTIFY_INFO = _PRINTER_NOTIFY_INFO;
pub type PPRINTER_NOTIFY_INFO = *mut _PRINTER_NOTIFY_INFO;
pub type LPPRINTER_NOTIFY_INFO = *mut _PRINTER_NOTIFY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BINARY_CONTAINER {
    pub cbBuf: DWORD,
    pub pData: LPBYTE,
}
pub type BINARY_CONTAINER = _BINARY_CONTAINER;
pub type PBINARY_CONTAINER = *mut _BINARY_CONTAINER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIDI_DATA {
    pub dwBidiType: DWORD,
    pub u: _BIDI_DATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _BIDI_DATA__bindgen_ty_1 {
    pub bData: BOOL,
    pub iData: LONG,
    pub sData: LPWSTR,
    pub fData: FLOAT,
    pub biData: BINARY_CONTAINER,
}
pub type BIDI_DATA = _BIDI_DATA;
pub type PBIDI_DATA = *mut _BIDI_DATA;
pub type LPBIDI_DATA = *mut _BIDI_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIDI_REQUEST_DATA {
    pub dwReqNumber: DWORD,
    pub pSchema: LPWSTR,
    pub data: BIDI_DATA,
}
pub type BIDI_REQUEST_DATA = _BIDI_REQUEST_DATA;
pub type PBIDI_REQUEST_DATA = *mut _BIDI_REQUEST_DATA;
pub type LPBIDI_REQUEST_DATA = *mut _BIDI_REQUEST_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIDI_REQUEST_CONTAINER {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub Count: DWORD,
    pub aData: [BIDI_REQUEST_DATA; 1usize],
}
pub type BIDI_REQUEST_CONTAINER = _BIDI_REQUEST_CONTAINER;
pub type PBIDI_REQUEST_CONTAINER = *mut _BIDI_REQUEST_CONTAINER;
pub type LPBIDI_REQUEST_CONTAINER = *mut _BIDI_REQUEST_CONTAINER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIDI_RESPONSE_DATA {
    pub dwResult: DWORD,
    pub dwReqNumber: DWORD,
    pub pSchema: LPWSTR,
    pub data: BIDI_DATA,
}
pub type BIDI_RESPONSE_DATA = _BIDI_RESPONSE_DATA;
pub type PBIDI_RESPONSE_DATA = *mut _BIDI_RESPONSE_DATA;
pub type LPBIDI_RESPONSE_DATA = *mut _BIDI_RESPONSE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _BIDI_RESPONSE_CONTAINER {
    pub Version: DWORD,
    pub Flags: DWORD,
    pub Count: DWORD,
    pub aData: [BIDI_RESPONSE_DATA; 1usize],
}
pub type BIDI_RESPONSE_CONTAINER = _BIDI_RESPONSE_CONTAINER;
pub type PBIDI_RESPONSE_CONTAINER = *mut _BIDI_RESPONSE_CONTAINER;
pub type LPBIDI_RESPONSE_CONTAINER = *mut _BIDI_RESPONSE_CONTAINER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BIDI_TYPE {
    BIDI_NULL = 0,
    BIDI_INT = 1,
    BIDI_FLOAT = 2,
    BIDI_BOOL = 3,
    BIDI_STRING = 4,
    BIDI_TEXT = 5,
    BIDI_ENUM = 6,
    BIDI_BLOB = 7,
}
extern "C" {
    pub fn WaitForPrinterChange(hPrinter: HANDLE, Flags: DWORD) -> DWORD;
}
extern "C" {
    pub fn FindFirstPrinterChangeNotification(
        hPrinter: HANDLE,
        fdwFilter: DWORD,
        fdwOptions: DWORD,
        pPrinterNotifyOptions: PVOID,
    ) -> HANDLE;
}
extern "C" {
    pub fn FindNextPrinterChangeNotification(
        hChange: HANDLE,
        pdwChange: PDWORD,
        pvReserved: LPVOID,
        ppPrinterNotifyInfo: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn FreePrinterNotifyInfo(pPrinterNotifyInfo: PPRINTER_NOTIFY_INFO) -> BOOL;
}
extern "C" {
    pub fn FindClosePrinterChangeNotification(hChange: HANDLE) -> BOOL;
}
extern "C" {
    pub fn PrinterMessageBoxA(
        hPrinter: HANDLE,
        Error: DWORD,
        hWnd: HWND,
        pText: LPSTR,
        pCaption: LPSTR,
        dwType: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn PrinterMessageBoxW(
        hPrinter: HANDLE,
        Error: DWORD,
        hWnd: HWND,
        pText: LPWSTR,
        pCaption: LPWSTR,
        dwType: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn ClosePrinter(hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn AddFormA(hPrinter: HANDLE, Level: DWORD, pForm: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn AddFormW(hPrinter: HANDLE, Level: DWORD, pForm: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn DeleteFormA(hPrinter: HANDLE, pFormName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn DeleteFormW(hPrinter: HANDLE, pFormName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn GetFormA(
        hPrinter: HANDLE,
        pFormName: LPSTR,
        Level: DWORD,
        pForm: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFormW(
        hPrinter: HANDLE,
        pFormName: LPWSTR,
        Level: DWORD,
        pForm: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFormA(hPrinter: HANDLE, pFormName: LPSTR, Level: DWORD, pForm: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn SetFormW(hPrinter: HANDLE, pFormName: LPWSTR, Level: DWORD, pForm: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn EnumFormsA(
        hPrinter: HANDLE,
        Level: DWORD,
        pForm: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumFormsW(
        hPrinter: HANDLE,
        Level: DWORD,
        pForm: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumMonitorsA(
        pName: LPSTR,
        Level: DWORD,
        pMonitor: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumMonitorsW(
        pName: LPWSTR,
        Level: DWORD,
        pMonitor: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddMonitorA(pName: LPSTR, Level: DWORD, pMonitors: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn AddMonitorW(pName: LPWSTR, Level: DWORD, pMonitors: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn DeleteMonitorA(pName: LPSTR, pEnvironment: LPSTR, pMonitorName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn DeleteMonitorW(pName: LPWSTR, pEnvironment: LPWSTR, pMonitorName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn EnumPortsA(
        pName: LPSTR,
        Level: DWORD,
        pPort: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumPortsW(
        pName: LPWSTR,
        Level: DWORD,
        pPort: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
        pcReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPortA(pName: LPSTR, hWnd: HWND, pMonitorName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn AddPortW(pName: LPWSTR, hWnd: HWND, pMonitorName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn ConfigurePortA(pName: LPSTR, hWnd: HWND, pPortName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn ConfigurePortW(pName: LPWSTR, hWnd: HWND, pPortName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn DeletePortA(pName: LPSTR, hWnd: HWND, pPortName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn DeletePortW(pName: LPWSTR, hWnd: HWND, pPortName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn XcvDataW(
        hXcv: HANDLE,
        pszDataName: PCWSTR,
        pInputData: PBYTE,
        cbInputData: DWORD,
        pOutputData: PBYTE,
        cbOutputData: DWORD,
        pcbOutputNeeded: PDWORD,
        pdwStatus: PDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDefaultPrinterA(pszBuffer: LPSTR, pcchBuffer: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetDefaultPrinterW(pszBuffer: LPWSTR, pcchBuffer: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn SetDefaultPrinterA(pszPrinter: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn SetDefaultPrinterW(pszPrinter: LPCWSTR) -> BOOL;
}
extern "C" {
    pub fn SetPortA(pName: LPSTR, pPortName: LPSTR, dwLevel: DWORD, pPortInfo: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn SetPortW(pName: LPWSTR, pPortName: LPWSTR, dwLevel: DWORD, pPortInfo: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn AddPrinterConnectionA(pName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn AddPrinterConnectionW(pName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn DeletePrinterConnectionA(pName: LPSTR) -> BOOL;
}
extern "C" {
    pub fn DeletePrinterConnectionW(pName: LPWSTR) -> BOOL;
}
extern "C" {
    pub fn ConnectToPrinterDlg(hwnd: HWND, Flags: DWORD) -> HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROVIDOR_INFO_1A {
    pub pName: LPSTR,
    pub pEnvironment: LPSTR,
    pub pDLLName: LPSTR,
}
pub type PROVIDOR_INFO_1A = _PROVIDOR_INFO_1A;
pub type PPROVIDOR_INFO_1A = *mut _PROVIDOR_INFO_1A;
pub type LPPROVIDOR_INFO_1A = *mut _PROVIDOR_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROVIDOR_INFO_1W {
    pub pName: LPWSTR,
    pub pEnvironment: LPWSTR,
    pub pDLLName: LPWSTR,
}
pub type PROVIDOR_INFO_1W = _PROVIDOR_INFO_1W;
pub type PPROVIDOR_INFO_1W = *mut _PROVIDOR_INFO_1W;
pub type LPPROVIDOR_INFO_1W = *mut _PROVIDOR_INFO_1W;
pub type PROVIDOR_INFO_1 = PROVIDOR_INFO_1A;
pub type PPROVIDOR_INFO_1 = PPROVIDOR_INFO_1A;
pub type LPPROVIDOR_INFO_1 = LPPROVIDOR_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROVIDOR_INFO_2A {
    pub pOrder: LPSTR,
}
pub type PROVIDOR_INFO_2A = _PROVIDOR_INFO_2A;
pub type PPROVIDOR_INFO_2A = *mut _PROVIDOR_INFO_2A;
pub type LPPROVIDOR_INFO_2A = *mut _PROVIDOR_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROVIDOR_INFO_2W {
    pub pOrder: LPWSTR,
}
pub type PROVIDOR_INFO_2W = _PROVIDOR_INFO_2W;
pub type PPROVIDOR_INFO_2W = *mut _PROVIDOR_INFO_2W;
pub type LPPROVIDOR_INFO_2W = *mut _PROVIDOR_INFO_2W;
pub type PROVIDOR_INFO_2 = PROVIDOR_INFO_2A;
pub type PPROVIDOR_INFO_2 = PPROVIDOR_INFO_2A;
pub type LPPROVIDOR_INFO_2 = LPPROVIDOR_INFO_2A;
extern "C" {
    pub fn AddPrintProvidorA(pName: LPSTR, Level: DWORD, pProvidorInfo: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn AddPrintProvidorW(pName: LPWSTR, Level: DWORD, pProvidorInfo: LPBYTE) -> BOOL;
}
extern "C" {
    pub fn DeletePrintProvidorA(
        pName: LPSTR,
        pEnvironment: LPSTR,
        pPrintProvidorName: LPSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn DeletePrintProvidorW(
        pName: LPWSTR,
        pEnvironment: LPWSTR,
        pPrintProvidorName: LPWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn IsValidDevmodeA(pDevmode: PDEVMODEA, DevmodeSize: usize) -> BOOL;
}
extern "C" {
    pub fn IsValidDevmodeW(pDevmode: PDEVMODEW, DevmodeSize: usize) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _PRINTER_OPTION_FLAGS {
    PRINTER_OPTION_NO_CACHE = 1,
    PRINTER_OPTION_CACHE = 2,
    PRINTER_OPTION_CLIENT_CHANGE = 4,
    PRINTER_OPTION_NO_CLIENT_DATA = 8,
}
pub use self::_PRINTER_OPTION_FLAGS as PRINTER_OPTION_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_OPTIONSA {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
}
pub type PRINTER_OPTIONSA = _PRINTER_OPTIONSA;
pub type PPRINTER_OPTIONSA = *mut _PRINTER_OPTIONSA;
pub type LPPRINTER_OPTIONSA = *mut _PRINTER_OPTIONSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_OPTIONSW {
    pub cbSize: UINT,
    pub dwFlags: DWORD,
}
pub type PRINTER_OPTIONSW = _PRINTER_OPTIONSW;
pub type PPRINTER_OPTIONSW = *mut _PRINTER_OPTIONSW;
pub type LPPRINTER_OPTIONSW = *mut _PRINTER_OPTIONSW;
pub type PRINTER_OPTIONS = PRINTER_OPTIONSA;
pub type PPRINTER_OPTIONS = PPRINTER_OPTIONSA;
pub type LPPRINTER_OPTIONS = LPPRINTER_OPTIONSA;
extern "C" {
    pub fn OpenPrinter2A(
        pPrinterName: LPCSTR,
        phPrinter: LPHANDLE,
        pDefault: PPRINTER_DEFAULTSA,
        pOptions: PPRINTER_OPTIONSA,
    ) -> BOOL;
}
extern "C" {
    pub fn OpenPrinter2W(
        pPrinterName: LPCWSTR,
        phPrinter: LPHANDLE,
        pDefault: PPRINTER_DEFAULTSW,
        pOptions: PPRINTER_OPTIONSW,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_CONNECTION_INFO_1A {
    pub dwFlags: DWORD,
    pub pszDriverName: LPSTR,
}
pub type PRINTER_CONNECTION_INFO_1A = _PRINTER_CONNECTION_INFO_1A;
pub type PPRINTER_CONNECTION_INFO_1A = *mut _PRINTER_CONNECTION_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRINTER_CONNECTION_INFO_1W {
    pub dwFlags: DWORD,
    pub pszDriverName: LPWSTR,
}
pub type PRINTER_CONNECTION_INFO_1W = _PRINTER_CONNECTION_INFO_1W;
pub type PPRINTER_CONNECTION_INFO_1W = *mut _PRINTER_CONNECTION_INFO_1W;
pub type PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1A;
pub type PPRINTER_CONNECTION_INFO_1 = PPRINTER_CONNECTION_INFO_1A;
extern "C" {
    pub fn AddPrinterConnection2A(
        hWnd: HWND,
        pszName: LPCSTR,
        dwLevel: DWORD,
        pConnectionInfo: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn AddPrinterConnection2W(
        hWnd: HWND,
        pszName: LPCWSTR,
        dwLevel: DWORD,
        pConnectionInfo: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn InstallPrinterDriverFromPackageA(
        pszServer: LPCSTR,
        pszInfPath: LPCSTR,
        pszDriverName: LPCSTR,
        pszEnvironment: LPCSTR,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn InstallPrinterDriverFromPackageW(
        pszServer: LPCWSTR,
        pszInfPath: LPCWSTR,
        pszDriverName: LPCWSTR,
        pszEnvironment: LPCWSTR,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn UploadPrinterDriverPackageA(
        pszServer: LPCSTR,
        pszInfPath: LPCSTR,
        pszEnvironment: LPCSTR,
        dwFlags: DWORD,
        hwnd: HWND,
        pszDestInfPath: LPSTR,
        pcchDestInfPath: PULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn UploadPrinterDriverPackageW(
        pszServer: LPCWSTR,
        pszInfPath: LPCWSTR,
        pszEnvironment: LPCWSTR,
        dwFlags: DWORD,
        hwnd: HWND,
        pszDestInfPath: LPWSTR,
        pcchDestInfPath: PULONG,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CORE_PRINTER_DRIVERA {
    pub CoreDriverGUID: GUID,
    pub ftDriverDate: FILETIME,
    pub dwlDriverVersion: DWORDLONG,
    pub szPackageID: [CHAR; 260usize],
}
pub type CORE_PRINTER_DRIVERA = _CORE_PRINTER_DRIVERA;
pub type PCORE_PRINTER_DRIVERA = *mut _CORE_PRINTER_DRIVERA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CORE_PRINTER_DRIVERW {
    pub CoreDriverGUID: GUID,
    pub ftDriverDate: FILETIME,
    pub dwlDriverVersion: DWORDLONG,
    pub szPackageID: [WCHAR; 260usize],
}
pub type CORE_PRINTER_DRIVERW = _CORE_PRINTER_DRIVERW;
pub type PCORE_PRINTER_DRIVERW = *mut _CORE_PRINTER_DRIVERW;
pub type CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERA;
pub type PCORE_PRINTER_DRIVER = PCORE_PRINTER_DRIVERA;
extern "C" {
    pub fn GetCorePrinterDriversA(
        pszServer: LPCSTR,
        pszEnvironment: LPCSTR,
        pszzCoreDriverDependencies: LPCSTR,
        cCorePrinterDrivers: DWORD,
        pCorePrinterDrivers: PCORE_PRINTER_DRIVERA,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetCorePrinterDriversW(
        pszServer: LPCWSTR,
        pszEnvironment: LPCWSTR,
        pszzCoreDriverDependencies: LPCWSTR,
        cCorePrinterDrivers: DWORD,
        pCorePrinterDrivers: PCORE_PRINTER_DRIVERW,
    ) -> HRESULT;
}
extern "C" {
    pub fn CorePrinterDriverInstalledA(
        pszServer: LPCSTR,
        pszEnvironment: LPCSTR,
        CoreDriverGUID: GUID,
        ftDriverDate: FILETIME,
        dwlDriverVersion: DWORDLONG,
        pbDriverInstalled: *mut BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn CorePrinterDriverInstalledW(
        pszServer: LPCWSTR,
        pszEnvironment: LPCWSTR,
        CoreDriverGUID: GUID,
        ftDriverDate: FILETIME,
        dwlDriverVersion: DWORDLONG,
        pbDriverInstalled: *mut BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetPrinterDriverPackagePathA(
        pszServer: LPCSTR,
        pszEnvironment: LPCSTR,
        pszLanguage: LPCSTR,
        pszPackageID: LPCSTR,
        pszDriverPackageCab: LPSTR,
        cchDriverPackageCab: DWORD,
        pcchRequiredSize: LPDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetPrinterDriverPackagePathW(
        pszServer: LPCWSTR,
        pszEnvironment: LPCWSTR,
        pszLanguage: LPCWSTR,
        pszPackageID: LPCWSTR,
        pszDriverPackageCab: LPWSTR,
        cchDriverPackageCab: DWORD,
        pcchRequiredSize: LPDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn DeletePrinterDriverPackageA(
        pszServer: LPCSTR,
        pszInfPath: LPCSTR,
        pszEnvironment: LPCSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn DeletePrinterDriverPackageW(
        pszServer: LPCWSTR,
        pszInfPath: LPCWSTR,
        pszEnvironment: LPCWSTR,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPrintPropertyType {
    kPropertyTypeString = 1,
    kPropertyTypeInt32 = 2,
    kPropertyTypeInt64 = 3,
    kPropertyTypeByte = 4,
    kPropertyTypeTime = 5,
    kPropertyTypeDevMode = 6,
    kPropertyTypeSD = 7,
    kPropertyTypeNotificationReply = 8,
    kPropertyTypeNotificationOptions = 9,
    kPropertyTypeBuffer = 10,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPrintXPSJobProgress {
    kAddingDocumentSequence = 0,
    kDocumentSequenceAdded = 1,
    kAddingFixedDocument = 2,
    kFixedDocumentAdded = 3,
    kAddingFixedPage = 4,
    kFixedPageAdded = 5,
    kResourceAdded = 6,
    kFontAdded = 7,
    kImageAdded = 8,
    kXpsDocumentCommitted = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EPrintXPSJobOperation {
    kJobProduction = 1,
    kJobConsumption = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrintPropertyValue {
    pub ePropertyType: EPrintPropertyType,
    pub value: PrintPropertyValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PrintPropertyValue__bindgen_ty_1 {
    pub propertyByte: BYTE,
    pub propertyString: PWSTR,
    pub propertyInt32: LONG,
    pub propertyInt64: LONGLONG,
    pub propertyBlob: PrintPropertyValue__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintPropertyValue__bindgen_ty_1__bindgen_ty_1 {
    pub cbBuf: DWORD,
    pub pBuf: LPVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrintNamedProperty {
    pub propertyName: *mut WCHAR,
    pub propertyValue: PrintPropertyValue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintPropertiesCollection {
    pub numberOfProperties: ULONG,
    pub propertiesCollection: *mut PrintNamedProperty,
}
extern "C" {
    pub fn ReportJobProcessingProgress(
        printerHandle: HANDLE,
        jobId: ULONG,
        jobOperation: EPrintXPSJobOperation,
        jobProgress: EPrintXPSJobProgress,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetPrinterDriver2A(
        hWnd: HWND,
        hPrinter: HANDLE,
        pEnvironment: LPSTR,
        Level: DWORD,
        pDriverInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetPrinterDriver2W(
        hWnd: HWND,
        hPrinter: HANDLE,
        pEnvironment: LPWSTR,
        Level: DWORD,
        pDriverInfo: LPBYTE,
        cbBuf: DWORD,
        pcbNeeded: LPDWORD,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PRINT_EXECUTION_CONTEXT {
    PRINT_EXECUTION_CONTEXT_APPLICATION = 0,
    PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = 1,
    PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = 2,
    PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = 3,
    PRINT_EXECUTION_CONTEXT_WOW64 = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PRINT_EXECUTION_DATA {
    pub context: PRINT_EXECUTION_CONTEXT,
    pub clientAppPID: DWORD,
}
extern "C" {
    pub fn GetPrintExecutionData(pData: *mut PRINT_EXECUTION_DATA) -> BOOL;
}
extern "C" {
    pub fn GetJobNamedPropertyValue(
        hPrinter: HANDLE,
        JobId: DWORD,
        pszName: PCWSTR,
        pValue: *mut PrintPropertyValue,
    ) -> DWORD;
}
extern "C" {
    pub fn FreePrintPropertyValue(pValue: *mut PrintPropertyValue);
}
extern "C" {
    pub fn FreePrintNamedPropertyArray(
        cProperties: DWORD,
        ppProperties: *mut *mut PrintNamedProperty,
    );
}
extern "C" {
    pub fn SetJobNamedProperty(
        hPrinter: HANDLE,
        JobId: DWORD,
        pProperty: *const PrintNamedProperty,
    ) -> DWORD;
}
extern "C" {
    pub fn DeleteJobNamedProperty(hPrinter: HANDLE, JobId: DWORD, pszName: PCWSTR) -> DWORD;
}
extern "C" {
    pub fn EnumJobNamedProperties(
        hPrinter: HANDLE,
        JobId: DWORD,
        pcProperties: *mut DWORD,
        ppProperties: *mut *mut PrintNamedProperty,
    ) -> DWORD;
}
extern "C" {
    pub fn GetPrintOutputInfo(
        hWnd: HWND,
        pszPrinter: PCWSTR,
        phFile: *mut HANDLE,
        ppszOutputFile: *mut PWSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type max_align_t = f64;
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn wcstod(_String: *const u16, _EndPtr: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn _wcstod_l(_String: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const u16, _EndPtr: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn _wcstold_l(_String: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const u16, _EndPtr: *mut *mut u16) -> f32;
}
extern "C" {
    pub fn _wcstof_l(_String: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const u16) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const u16) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const u16) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wtoi64(_String: *const u16) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(_Buffer: *mut u16, _Path: *const u16, _BufferCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Drive: *const u16,
        _Dir: *const u16,
        _Filename: *const u16,
        _Ext: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut u16,
        _Drive: *const u16,
        _Dir: *const u16,
        _Filename: *const u16,
        _Ext: *const u16,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const u16);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const u16,
        _Drive: *mut u16,
        _Dir: *mut u16,
        _Filename: *mut u16,
        _Ext: *mut u16,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const u16,
        _Drive: *mut u16,
        _DriveCount: usize,
        _Dir: *mut u16,
        _DirCount: usize,
        _Filename: *mut u16,
        _FilenameCount: usize,
        _Ext: *mut u16,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut u16,
        _BufferCount: *mut usize,
        _VarName: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _VarName: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const u16, _Value: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const u16,
        _VarName: *const u16,
        _Buffer: *mut u16,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(_Filename: *const u16, _VarName: *const u16, _ResultPath: *mut u16);
}
extern "C" {
    pub fn _wsystem(_Command: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const u16,
        arg2: *const u16,
        arg3: *const u16,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut u16;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut u16) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?abs@@YAJJ@Z"]
    pub fn abs1(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}?abs@@YA_J_J@Z"]
    pub fn abs2(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}?div@@YA?AU_ldiv_t@@JJ@Z"]
    pub fn div1(_A1: ::std::os::raw::c_long, _A2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    #[link_name = "\u{1}?div@@YA?AU_lldiv_t@@_J0@Z"]
    pub fn div2(_A1: ::std::os::raw::c_longlong, _A2: ::std::os::raw::c_longlong) -> lldiv_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut u16,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut u16,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: u16,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const u16,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const u16,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const u16,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut u16;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut u16;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagREGCLS {
    REGCLS_SINGLEUSE = 0,
    REGCLS_MULTIPLEUSE = 1,
    REGCLS_MULTI_SEPARATE = 2,
    REGCLS_SUSPENDED = 4,
    REGCLS_SURROGATE = 8,
    REGCLS_AGILE = 16,
}
pub use self::tagREGCLS as REGCLS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCOINITBASE {
    COINITBASE_MULTITHREADED = 0,
}
pub use self::tagCOINITBASE as COINITBASE;
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPUNKNOWN = *mut IUnknown;
extern "C" {
    pub static IID_IUnknown: IID;
}
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
    pub vtable_: *const IUnknown__bindgen_vtable,
}
extern "C" {
    pub fn IUnknown_QueryInterface_Proxy(
        This: *mut IUnknown,
        riid: *const IID,
        ppvObject: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IUnknown_QueryInterface_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IUnknown_AddRef_Proxy(This: *mut IUnknown) -> ULONG;
}
extern "C" {
    pub fn IUnknown_AddRef_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IUnknown_Release_Proxy(This: *mut IUnknown) -> ULONG;
}
extern "C" {
    pub fn IUnknown_Release_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_AsyncIUnknown: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIUnknown {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0002_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0002_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPCLASSFACTORY = *mut IClassFactory;
extern "C" {
    pub static IID_IClassFactory: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IClassFactory {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IClassFactory_RemoteCreateInstance_Proxy(
        This: *mut IClassFactory,
        riid: *const IID,
        ppvObject: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IClassFactory_RemoteCreateInstance_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IClassFactory_RemoteLockServer_Proxy(This: *mut IClassFactory, fLock: BOOL) -> HRESULT;
}
extern "C" {
    pub fn IClassFactory_RemoteLockServer_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwnbase_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn IClassFactory_CreateInstance_Proxy(
        This: *mut IClassFactory,
        pUnkOuter: *mut IUnknown,
        riid: *const IID,
        ppvObject: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IClassFactory_CreateInstance_Stub(
        This: *mut IClassFactory,
        riid: *const IID,
        ppvObject: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IClassFactory_LockServer_Proxy(This: *mut IClassFactory, fLock: BOOL) -> HRESULT;
}
extern "C" {
    pub fn IClassFactory_LockServer_Stub(This: *mut IClassFactory, fLock: BOOL) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumContextProps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IObjContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COSERVERINFO {
    pub dwReserved1: DWORD,
    pub pwszName: LPWSTR,
    pub pAuthInfo: *mut COAUTHINFO,
    pub dwReserved2: DWORD,
}
pub type COSERVERINFO = _COSERVERINFO;
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPMARSHAL = *mut IMarshal;
extern "C" {
    pub static IID_IMarshal: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMarshal {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_INoMarshal: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct INoMarshal {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IAgileObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAgileObject {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagACTIVATIONTYPE {
    ACTIVATIONTYPE_UNCATEGORIZED = 0,
    ACTIVATIONTYPE_FROM_MONIKER = 1,
    ACTIVATIONTYPE_FROM_DATA = 2,
    ACTIVATIONTYPE_FROM_STORAGE = 4,
    ACTIVATIONTYPE_FROM_STREAM = 8,
    ACTIVATIONTYPE_FROM_FILE = 16,
}
pub use self::tagACTIVATIONTYPE as ACTIVATIONTYPE;
extern "C" {
    pub static IID_IActivationFilter: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IActivationFilter {
    pub _base: IUnknown,
}
pub type LPMARSHAL2 = *mut IMarshal2;
extern "C" {
    pub static IID_IMarshal2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMarshal2 {
    pub _base: IMarshal,
}
pub type LPMALLOC = *mut IMalloc;
extern "C" {
    pub static IID_IMalloc: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMalloc {
    pub _base: IUnknown,
}
pub type LPSTDMARSHALINFO = *mut IStdMarshalInfo;
extern "C" {
    pub static IID_IStdMarshalInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStdMarshalInfo {
    pub _base: IUnknown,
}
pub type LPEXTERNALCONNECTION = *mut IExternalConnection;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagEXTCONN {
    EXTCONN_STRONG = 1,
    EXTCONN_WEAK = 2,
    EXTCONN_CALLABLE = 4,
}
pub use self::tagEXTCONN as EXTCONN;
extern "C" {
    pub static IID_IExternalConnection: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IExternalConnection {
    pub _base: IUnknown,
}
pub type LPMULTIQI = *mut IMultiQI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMULTI_QI {
    pub pIID: *const IID,
    pub pItf: *mut IUnknown,
    pub hr: HRESULT,
}
pub type MULTI_QI = tagMULTI_QI;
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0008_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0008_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IMultiQI: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMultiQI {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_AsyncIMultiQI: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIMultiQI {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0009_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0009_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternalUnknown: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternalUnknown {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0010_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0010_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPENUMUNKNOWN = *mut IEnumUnknown;
extern "C" {
    pub static IID_IEnumUnknown: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumUnknown {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumUnknown_RemoteNext_Proxy(
        This: *mut IEnumUnknown,
        celt: ULONG,
        rgelt: *mut *mut IUnknown,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumUnknown_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPENUMSTRING = *mut IEnumString;
extern "C" {
    pub static IID_IEnumString: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumString {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumString_RemoteNext_Proxy(
        This: *mut IEnumString,
        celt: ULONG,
        rgelt: *mut LPOLESTR,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumString_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static IID_ISequentialStream: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
    pub _base: IUnknown,
}
extern "C" {
    pub fn ISequentialStream_RemoteRead_Proxy(
        This: *mut ISequentialStream,
        pv: *mut byte,
        cb: ULONG,
        pcbRead: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ISequentialStream_RemoteRead_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ISequentialStream_RemoteWrite_Proxy(
        This: *mut ISequentialStream,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ISequentialStream_RemoteWrite_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPSTREAM = *mut IStream;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTATSTG {
    pub pwcsName: LPOLESTR,
    pub type_: DWORD,
    pub cbSize: ULARGE_INTEGER,
    pub mtime: FILETIME,
    pub ctime: FILETIME,
    pub atime: FILETIME,
    pub grfMode: DWORD,
    pub grfLocksSupported: DWORD,
    pub clsid: CLSID,
    pub grfStateBits: DWORD,
    pub reserved: DWORD,
}
pub type STATSTG = tagSTATSTG;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSTGTY {
    STGTY_STORAGE = 1,
    STGTY_STREAM = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY = 4,
}
pub use self::tagSTGTY as STGTY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSTREAM_SEEK {
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2,
}
pub use self::tagSTREAM_SEEK as STREAM_SEEK;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagLOCKTYPE {
    LOCK_WRITE = 1,
    LOCK_EXCLUSIVE = 2,
    LOCK_ONLYONCE = 4,
}
pub use self::tagLOCKTYPE as LOCKTYPE;
extern "C" {
    pub static IID_IStream: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStream {
    pub _base: ISequentialStream,
}
extern "C" {
    pub fn IStream_RemoteSeek_Proxy(
        This: *mut IStream,
        dlibMove: LARGE_INTEGER,
        dwOrigin: DWORD,
        plibNewPosition: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStream_RemoteSeek_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IStream_RemoteCopyTo_Proxy(
        This: *mut IStream,
        pstm: *mut IStream,
        cb: ULARGE_INTEGER,
        pcbRead: *mut ULARGE_INTEGER,
        pcbWritten: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStream_RemoteCopyTo_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type RPCOLEDATAREP = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPCOLEMESSAGE {
    pub reserved1: *mut ::std::os::raw::c_void,
    pub dataRepresentation: RPCOLEDATAREP,
    pub Buffer: *mut ::std::os::raw::c_void,
    pub cbBuffer: ULONG,
    pub iMethod: ULONG,
    pub reserved2: [*mut ::std::os::raw::c_void; 5usize],
    pub rpcFlags: ULONG,
}
pub type RPCOLEMESSAGE = tagRPCOLEMESSAGE;
pub type PRPCOLEMESSAGE = *mut RPCOLEMESSAGE;
extern "C" {
    pub static IID_IRpcChannelBuffer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcChannelBuffer {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0015_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0015_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IRpcChannelBuffer2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcChannelBuffer2 {
    pub _base: IRpcChannelBuffer,
}
extern "C" {
    pub static IID_IAsyncRpcChannelBuffer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAsyncRpcChannelBuffer {
    pub _base: IRpcChannelBuffer2,
}
extern "C" {
    pub static IID_IRpcChannelBuffer3: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcChannelBuffer3 {
    pub _base: IRpcChannelBuffer2,
}
extern "C" {
    pub static IID_IRpcSyntaxNegotiate: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcSyntaxNegotiate {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IRpcProxyBuffer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcProxyBuffer {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0020_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0020_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IRpcStubBuffer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcStubBuffer {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IPSFactoryBuffer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPSFactoryBuffer {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SChannelHookCallInfo {
    pub iid: IID,
    pub cbSize: DWORD,
    pub uCausality: GUID,
    pub dwServerPid: DWORD,
    pub iMethod: DWORD,
    pub pObject: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0022_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0022_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IChannelHook: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IChannelHook {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0023_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0023_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_SERVICE {
    pub dwAuthnSvc: DWORD,
    pub dwAuthzSvc: DWORD,
    pub pPrincipalName: *mut OLECHAR,
    pub hr: HRESULT,
}
pub type SOLE_AUTHENTICATION_SERVICE = tagSOLE_AUTHENTICATION_SERVICE;
pub type PSOLE_AUTHENTICATION_SERVICE = *mut SOLE_AUTHENTICATION_SERVICE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagEOLE_AUTHENTICATION_CAPABILITIES {
    EOAC_NONE = 0,
    EOAC_MUTUAL_AUTH = 1,
    EOAC_STATIC_CLOAKING = 32,
    EOAC_DYNAMIC_CLOAKING = 64,
    EOAC_ANY_AUTHORITY = 128,
    EOAC_MAKE_FULLSIC = 256,
    EOAC_DEFAULT = 2048,
    EOAC_SECURE_REFS = 2,
    EOAC_ACCESS_CONTROL = 4,
    EOAC_APPID = 8,
    EOAC_DYNAMIC = 16,
    EOAC_REQUIRE_FULLSIC = 512,
    EOAC_AUTO_IMPERSONATE = 1024,
    EOAC_DISABLE_AAA = 4096,
    EOAC_NO_CUSTOM_MARSHAL = 8192,
    EOAC_RESERVED1 = 16384,
}
pub use self::tagEOLE_AUTHENTICATION_CAPABILITIES as EOLE_AUTHENTICATION_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_INFO {
    pub dwAuthnSvc: DWORD,
    pub dwAuthzSvc: DWORD,
    pub pAuthInfo: *mut ::std::os::raw::c_void,
}
pub type SOLE_AUTHENTICATION_INFO = tagSOLE_AUTHENTICATION_INFO;
pub type PSOLE_AUTHENTICATION_INFO = *mut tagSOLE_AUTHENTICATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_LIST {
    pub cAuthInfo: DWORD,
    pub aAuthInfo: *mut SOLE_AUTHENTICATION_INFO,
}
pub type SOLE_AUTHENTICATION_LIST = tagSOLE_AUTHENTICATION_LIST;
pub type PSOLE_AUTHENTICATION_LIST = *mut tagSOLE_AUTHENTICATION_LIST;
extern "C" {
    pub static IID_IClientSecurity: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IClientSecurity {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0024_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0024_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IServerSecurity: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IServerSecurity {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagRPCOPT_PROPERTIES {
    COMBND_RPCTIMEOUT = 1,
    COMBND_SERVER_LOCALITY = 2,
    COMBND_RESERVED1 = 4,
    COMBND_RESERVED2 = 5,
    COMBND_RESERVED3 = 8,
    COMBND_RESERVED4 = 16,
}
pub use self::tagRPCOPT_PROPERTIES as RPCOPT_PROPERTIES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagRPCOPT_SERVER_LOCALITY_VALUES {
    SERVER_LOCALITY_PROCESS_LOCAL = 0,
    SERVER_LOCALITY_MACHINE_LOCAL = 1,
    SERVER_LOCALITY_REMOTE = 2,
}
pub use self::tagRPCOPT_SERVER_LOCALITY_VALUES as RPCOPT_SERVER_LOCALITY_VALUES;
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0025_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0025_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IRpcOptions: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcOptions {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagGLOBALOPT_PROPERTIES {
    COMGLB_EXCEPTION_HANDLING = 1,
    COMGLB_APPID = 2,
    COMGLB_RPC_THREADPOOL_SETTING = 3,
    COMGLB_RO_SETTINGS = 4,
    COMGLB_UNMARSHALING_POLICY = 5,
    COMGLB_PROPERTIES_RESERVED1 = 6,
    COMGLB_PROPERTIES_RESERVED2 = 7,
    COMGLB_PROPERTIES_RESERVED3 = 8,
}
pub use self::tagGLOBALOPT_PROPERTIES as GLOBALOPT_PROPERTIES;
impl tagGLOBALOPT_EH_VALUES {
    pub const COMGLB_EXCEPTION_DONOT_HANDLE: tagGLOBALOPT_EH_VALUES =
        tagGLOBALOPT_EH_VALUES::COMGLB_EXCEPTION_DONOT_HANDLE_FATAL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagGLOBALOPT_EH_VALUES {
    COMGLB_EXCEPTION_HANDLE = 0,
    COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = 1,
    COMGLB_EXCEPTION_DONOT_HANDLE_ANY = 2,
}
pub use self::tagGLOBALOPT_EH_VALUES as GLOBALOPT_EH_VALUES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagGLOBALOPT_RPCTP_VALUES {
    COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = 0,
    COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = 1,
}
pub use self::tagGLOBALOPT_RPCTP_VALUES as GLOBALOPT_RPCTP_VALUES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagGLOBALOPT_RO_FLAGS {
    COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 1,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 2,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 4,
    COMGLB_FAST_RUNDOWN = 8,
    COMGLB_RESERVED1 = 16,
    COMGLB_RESERVED2 = 32,
    COMGLB_RESERVED3 = 64,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 128,
    COMGLB_RESERVED4 = 256,
    COMGLB_RESERVED5 = 512,
    COMGLB_RESERVED6 = 1024,
}
pub use self::tagGLOBALOPT_RO_FLAGS as GLOBALOPT_RO_FLAGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagGLOBALOPT_UNMARSHALING_POLICY_VALUES {
    COMGLB_UNMARSHALING_POLICY_NORMAL = 0,
    COMGLB_UNMARSHALING_POLICY_STRONG = 1,
    COMGLB_UNMARSHALING_POLICY_HYBRID = 2,
}
pub use self::tagGLOBALOPT_UNMARSHALING_POLICY_VALUES as GLOBALOPT_UNMARSHALING_POLICY_VALUES;
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0026_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0026_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IGlobalOptions: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IGlobalOptions {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0027_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0027_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPSURROGATE = *mut ISurrogate;
extern "C" {
    pub static IID_ISurrogate: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISurrogate {
    pub _base: IUnknown,
}
pub type LPGLOBALINTERFACETABLE = *mut IGlobalInterfaceTable;
extern "C" {
    pub static IID_IGlobalInterfaceTable: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IGlobalInterfaceTable {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0029_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0029_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_ISynchronize: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISynchronize {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ISynchronizeHandle: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISynchronizeHandle {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ISynchronizeEvent: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISynchronizeEvent {
    pub _base: ISynchronizeHandle,
}
extern "C" {
    pub static IID_ISynchronizeContainer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISynchronizeContainer {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ISynchronizeMutex: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISynchronizeMutex {
    pub _base: ISynchronize,
}
pub type LPCANCELMETHODCALLS = *mut ICancelMethodCalls;
extern "C" {
    pub static IID_ICancelMethodCalls: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICancelMethodCalls {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagDCOM_CALL_STATE {
    DCOM_NONE = 0,
    DCOM_CALL_COMPLETE = 1,
    DCOM_CALL_CANCELED = 2,
}
pub use self::tagDCOM_CALL_STATE as DCOM_CALL_STATE;
extern "C" {
    pub static IID_IAsyncManager: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAsyncManager {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ICallFactory: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICallFactory {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IRpcHelper: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcHelper {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IReleaseMarshalBuffers: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IReleaseMarshalBuffers {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IWaitMultiple: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWaitMultiple {
    pub _base: IUnknown,
}
pub type LPADDRTRACKINGCONTROL = *mut IAddrTrackingControl;
extern "C" {
    pub static IID_IAddrTrackingControl: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAddrTrackingControl {
    pub _base: IUnknown,
}
pub type LPADDREXCLUSIONCONTROL = *mut IAddrExclusionControl;
extern "C" {
    pub static IID_IAddrExclusionControl: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAddrExclusionControl {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IPipeByte: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPipeByte {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_AsyncIPipeByte: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIPipeByte {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IPipeLong: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPipeLong {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_AsyncIPipeLong: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIPipeLong {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IPipeDouble: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPipeDouble {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_AsyncIPipeDouble: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIPipeDouble {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _APTTYPEQUALIFIER {
    APTTYPEQUALIFIER_NONE = 0,
    APTTYPEQUALIFIER_IMPLICIT_MTA = 1,
    APTTYPEQUALIFIER_NA_ON_MTA = 2,
    APTTYPEQUALIFIER_NA_ON_STA = 3,
    APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = 4,
    APTTYPEQUALIFIER_NA_ON_MAINSTA = 5,
    APTTYPEQUALIFIER_APPLICATION_STA = 6,
    APTTYPEQUALIFIER_RESERVED_1 = 7,
}
pub use self::_APTTYPEQUALIFIER as APTTYPEQUALIFIER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _APTTYPE {
    APTTYPE_CURRENT = -1,
    APTTYPE_STA = 0,
    APTTYPE_MTA = 1,
    APTTYPE_NA = 2,
    APTTYPE_MAINSTA = 3,
}
pub use self::_APTTYPE as APTTYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _THDTYPE {
    THDTYPE_BLOCKMESSAGES = 0,
    THDTYPE_PROCESSMESSAGES = 1,
}
pub use self::_THDTYPE as THDTYPE;
pub type APARTMENTID = DWORD;
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0048_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0048_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IComThreadingInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IComThreadingInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IProcessInitControl: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IProcessInitControl {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IFastRundown: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IFastRundown {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CO_MARSHALING_CONTEXT_ATTRIBUTES {
    CO_MARSHALING_SOURCE_IS_APP_CONTAINER = 0,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = -2147483631,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0051_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0051_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IMarshalingStream: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMarshalingStream {
    pub _base: IStream,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0052_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0052_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IAgileReference: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAgileReference {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ICallbackWithNoReentrancyToApplicationSTA: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineGlobalObjectTableRegistrationToken__ {
    pub unused: ::std::os::raw::c_int,
}
pub type MachineGlobalObjectTableRegistrationToken =
    *mut MachineGlobalObjectTableRegistrationToken__;
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0053_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0053_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IMachineGlobalObjectTable: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMachineGlobalObjectTable {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0054_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0054_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_ISupportAllowLowerTrustActivation: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISupportAllowLowerTrustActivation {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0055_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidlbase_0000_0055_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn IEnumUnknown_Next_Proxy(
        This: *mut IEnumUnknown,
        celt: ULONG,
        rgelt: *mut *mut IUnknown,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumUnknown_Next_Stub(
        This: *mut IEnumUnknown,
        celt: ULONG,
        rgelt: *mut *mut IUnknown,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumString_Next_Proxy(
        This: *mut IEnumString,
        celt: ULONG,
        rgelt: *mut LPOLESTR,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumString_Next_Stub(
        This: *mut IEnumString,
        celt: ULONG,
        rgelt: *mut LPOLESTR,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ISequentialStream_Read_Proxy(
        This: *mut ISequentialStream,
        pv: *mut ::std::os::raw::c_void,
        cb: ULONG,
        pcbRead: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ISequentialStream_Read_Stub(
        This: *mut ISequentialStream,
        pv: *mut byte,
        cb: ULONG,
        pcbRead: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ISequentialStream_Write_Proxy(
        This: *mut ISequentialStream,
        pv: *const ::std::os::raw::c_void,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ISequentialStream_Write_Stub(
        This: *mut ISequentialStream,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStream_Seek_Proxy(
        This: *mut IStream,
        dlibMove: LARGE_INTEGER,
        dwOrigin: DWORD,
        plibNewPosition: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStream_Seek_Stub(
        This: *mut IStream,
        dlibMove: LARGE_INTEGER,
        dwOrigin: DWORD,
        plibNewPosition: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStream_CopyTo_Proxy(
        This: *mut IStream,
        pstm: *mut IStream,
        cb: ULARGE_INTEGER,
        pcbRead: *mut ULARGE_INTEGER,
        pcbWritten: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStream_CopyTo_Stub(
        This: *mut IStream,
        pstm: *mut IStream,
        cb: ULARGE_INTEGER,
        pcbRead: *mut ULARGE_INTEGER,
        pcbWritten: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub static GUID_NULL: IID;
}
extern "C" {
    pub static CATID_MARSHALER: IID;
}
extern "C" {
    pub static IID_IRpcChannel: IID;
}
extern "C" {
    pub static IID_IRpcStub: IID;
}
extern "C" {
    pub static IID_IStubManager: IID;
}
extern "C" {
    pub static IID_IRpcProxy: IID;
}
extern "C" {
    pub static IID_IProxyManager: IID;
}
extern "C" {
    pub static IID_IPSFactory: IID;
}
extern "C" {
    pub static IID_IInternalMoniker: IID;
}
extern "C" {
    pub static IID_IDfReserved1: IID;
}
extern "C" {
    pub static IID_IDfReserved2: IID;
}
extern "C" {
    pub static IID_IDfReserved3: IID;
}
extern "C" {
    pub static CLSID_StdMarshal: CLSID;
}
extern "C" {
    pub static CLSID_AggStdMarshal: CLSID;
}
extern "C" {
    pub static CLSID_StdAsyncActManager: CLSID;
}
extern "C" {
    pub static IID_IStub: IID;
}
extern "C" {
    pub static IID_IProxy: IID;
}
extern "C" {
    pub static IID_IEnumGeneric: IID;
}
extern "C" {
    pub static IID_IEnumHolder: IID;
}
extern "C" {
    pub static IID_IEnumCallback: IID;
}
extern "C" {
    pub static IID_IOleManager: IID;
}
extern "C" {
    pub static IID_IOlePresObj: IID;
}
extern "C" {
    pub static IID_IDebug: IID;
}
extern "C" {
    pub static IID_IDebugStream: IID;
}
extern "C" {
    pub static CLSID_PSGenObject: CLSID;
}
extern "C" {
    pub static CLSID_PSClientSite: CLSID;
}
extern "C" {
    pub static CLSID_PSClassObject: CLSID;
}
extern "C" {
    pub static CLSID_PSInPlaceActive: CLSID;
}
extern "C" {
    pub static CLSID_PSInPlaceFrame: CLSID;
}
extern "C" {
    pub static CLSID_PSDragDrop: CLSID;
}
extern "C" {
    pub static CLSID_PSBindCtx: CLSID;
}
extern "C" {
    pub static CLSID_PSEnumerators: CLSID;
}
extern "C" {
    pub static CLSID_StaticMetafile: CLSID;
}
extern "C" {
    pub static CLSID_StaticDib: CLSID;
}
extern "C" {
    pub static CID_CDfsVolume: CLSID;
}
extern "C" {
    pub static CLSID_DCOMAccessControl: CLSID;
}
extern "C" {
    pub static CLSID_GlobalOptions: CLSID;
}
extern "C" {
    pub static CLSID_StdGlobalInterfaceTable: CLSID;
}
extern "C" {
    pub static CLSID_MachineGlobalObjectTable: CLSID;
}
extern "C" {
    pub static CLSID_ActivationCapabilities: CLSID;
}
extern "C" {
    pub static CLSID_ComBinding: CLSID;
}
extern "C" {
    pub static CLSID_StdEvent: CLSID;
}
extern "C" {
    pub static CLSID_ManualResetEvent: CLSID;
}
extern "C" {
    pub static CLSID_SynchronizeContainer: CLSID;
}
extern "C" {
    pub static CLSID_AddrControl: CLSID;
}
extern "C" {
    pub static CLSID_ContextSwitcher: CLSID;
}
extern "C" {
    pub static CLSID_CCDFormKrnl: CLSID;
}
extern "C" {
    pub static CLSID_CCDPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDFormDialog: CLSID;
}
extern "C" {
    pub static CLSID_CCDCommandButton: CLSID;
}
extern "C" {
    pub static CLSID_CCDComboBox: CLSID;
}
extern "C" {
    pub static CLSID_CCDTextBox: CLSID;
}
extern "C" {
    pub static CLSID_CCDCheckBox: CLSID;
}
extern "C" {
    pub static CLSID_CCDLabel: CLSID;
}
extern "C" {
    pub static CLSID_CCDOptionButton: CLSID;
}
extern "C" {
    pub static CLSID_CCDListBox: CLSID;
}
extern "C" {
    pub static CLSID_CCDScrollBar: CLSID;
}
extern "C" {
    pub static CLSID_CCDGroupBox: CLSID;
}
extern "C" {
    pub static CLSID_CCDGeneralPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDGenericPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDFontPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDColorPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDLabelPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDCheckBoxPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDTextBoxPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDOptionButtonPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDListBoxPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDCommandButtonPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDComboBoxPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDScrollBarPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDGroupBoxPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CCDXObjectPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CStdPropertyFrame: CLSID;
}
extern "C" {
    pub static CLSID_CFormPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CGridPropertyPage: CLSID;
}
extern "C" {
    pub static CLSID_CWSJArticlePage: CLSID;
}
extern "C" {
    pub static CLSID_CSystemPage: CLSID;
}
extern "C" {
    pub static CLSID_IdentityUnmarshal: CLSID;
}
extern "C" {
    pub static CLSID_InProcFreeMarshaler: CLSID;
}
extern "C" {
    pub static CLSID_Picture_Metafile: CLSID;
}
extern "C" {
    pub static CLSID_Picture_EnhMetafile: CLSID;
}
extern "C" {
    pub static CLSID_Picture_Dib: CLSID;
}
extern "C" {
    pub static GUID_TRISTATE: GUID;
}
extern "C" {
    pub fn CoGetMalloc(dwMemContext: DWORD, ppMalloc: *mut LPMALLOC) -> HRESULT;
}
extern "C" {
    pub fn CreateStreamOnHGlobal(
        hGlobal: HGLOBAL,
        fDeleteOnRelease: BOOL,
        ppstm: *mut LPSTREAM,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetHGlobalFromStream(pstm: LPSTREAM, phglobal: *mut HGLOBAL) -> HRESULT;
}
extern "C" {
    pub fn CoUninitialize();
}
extern "C" {
    pub fn CoGetCurrentProcess() -> DWORD;
}
extern "C" {
    pub fn CoInitializeEx(pvReserved: LPVOID, dwCoInit: DWORD) -> HRESULT;
}
extern "C" {
    pub fn CoGetCallerTID(lpdwTID: LPDWORD) -> HRESULT;
}
extern "C" {
    pub fn CoGetCurrentLogicalThreadId(pguid: *mut GUID) -> HRESULT;
}
extern "C" {
    pub fn CoGetContextToken(pToken: *mut ULONG_PTR) -> HRESULT;
}
extern "C" {
    pub fn CoGetDefaultContext(
        aptType: APTTYPE,
        riid: *const IID,
        ppv: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetApartmentType(
        pAptType: *mut APTTYPE,
        pAptQualifier: *mut APTTYPEQUALIFIER,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagServerInformation {
    pub dwServerPid: DWORD,
    pub dwServerTid: DWORD,
    pub ui64ServerAddress: UINT64,
}
pub type ServerInformation = tagServerInformation;
pub type PServerInformation = *mut tagServerInformation;
extern "C" {
    pub fn CoDecodeProxy(
        dwClientPid: DWORD,
        ui64ProxyAddress: UINT64,
        pServerInformation: PServerInformation,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CO_MTA_USAGE_COOKIE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type CO_MTA_USAGE_COOKIE = *mut CO_MTA_USAGE_COOKIE__;
extern "C" {
    pub fn CoIncrementMTAUsage(pCookie: *mut CO_MTA_USAGE_COOKIE) -> HRESULT;
}
extern "C" {
    pub fn CoDecrementMTAUsage(Cookie: CO_MTA_USAGE_COOKIE) -> HRESULT;
}
extern "C" {
    pub fn CoAllowUnmarshalerCLSID(clsid: *const IID) -> HRESULT;
}
extern "C" {
    pub fn CoGetObjectContext(riid: *const IID, ppv: *mut LPVOID) -> HRESULT;
}
extern "C" {
    pub fn CoGetClassObject(
        rclsid: *const IID,
        dwClsContext: DWORD,
        pvReserved: LPVOID,
        riid: *const IID,
        ppv: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterClassObject(
        rclsid: *const IID,
        pUnk: LPUNKNOWN,
        dwClsContext: DWORD,
        flags: DWORD,
        lpdwRegister: LPDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoRevokeClassObject(dwRegister: DWORD) -> HRESULT;
}
extern "C" {
    pub fn CoResumeClassObjects() -> HRESULT;
}
extern "C" {
    pub fn CoSuspendClassObjects() -> HRESULT;
}
extern "C" {
    pub fn CoAddRefServerProcess() -> ULONG;
}
extern "C" {
    pub fn CoReleaseServerProcess() -> ULONG;
}
extern "C" {
    pub fn CoGetPSClsid(riid: *const IID, pClsid: *mut CLSID) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterPSClsid(riid: *const IID, rclsid: *const IID) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterSurrogate(pSurrogate: LPSURROGATE) -> HRESULT;
}
extern "C" {
    pub fn CoGetMarshalSizeMax(
        pulSize: *mut ULONG,
        riid: *const IID,
        pUnk: LPUNKNOWN,
        dwDestContext: DWORD,
        pvDestContext: LPVOID,
        mshlflags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoMarshalInterface(
        pStm: LPSTREAM,
        riid: *const IID,
        pUnk: LPUNKNOWN,
        dwDestContext: DWORD,
        pvDestContext: LPVOID,
        mshlflags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoUnmarshalInterface(pStm: LPSTREAM, riid: *const IID, ppv: *mut LPVOID) -> HRESULT;
}
extern "C" {
    pub fn CoMarshalHresult(pstm: LPSTREAM, hresult: HRESULT) -> HRESULT;
}
extern "C" {
    pub fn CoUnmarshalHresult(pstm: LPSTREAM, phresult: *mut HRESULT) -> HRESULT;
}
extern "C" {
    pub fn CoReleaseMarshalData(pStm: LPSTREAM) -> HRESULT;
}
extern "C" {
    pub fn CoDisconnectObject(pUnk: LPUNKNOWN, dwReserved: DWORD) -> HRESULT;
}
extern "C" {
    pub fn CoLockObjectExternal(pUnk: LPUNKNOWN, fLock: BOOL, fLastUnlockReleases: BOOL)
        -> HRESULT;
}
extern "C" {
    pub fn CoGetStandardMarshal(
        riid: *const IID,
        pUnk: LPUNKNOWN,
        dwDestContext: DWORD,
        pvDestContext: LPVOID,
        mshlflags: DWORD,
        ppMarshal: *mut LPMARSHAL,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetStdMarshalEx(
        pUnkOuter: LPUNKNOWN,
        smexflags: DWORD,
        ppUnkInner: *mut LPUNKNOWN,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSTDMSHLFLAGS {
    SMEXF_SERVER = 1,
    SMEXF_HANDLER = 2,
}
pub use self::tagSTDMSHLFLAGS as STDMSHLFLAGS;
extern "C" {
    pub fn CoIsHandlerConnected(pUnk: LPUNKNOWN) -> BOOL;
}
extern "C" {
    pub fn CoMarshalInterThreadInterfaceInStream(
        riid: *const IID,
        pUnk: LPUNKNOWN,
        ppStm: *mut LPSTREAM,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetInterfaceAndReleaseStream(
        pStm: LPSTREAM,
        iid: *const IID,
        ppv: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoCreateFreeThreadedMarshaler(
        punkOuter: LPUNKNOWN,
        ppunkMarshal: *mut LPUNKNOWN,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoFreeUnusedLibraries();
}
extern "C" {
    pub fn CoFreeUnusedLibrariesEx(dwUnloadDelay: DWORD, dwReserved: DWORD);
}
extern "C" {
    pub fn CoDisconnectContext(dwTimeout: DWORD) -> HRESULT;
}
extern "C" {
    pub fn CoInitializeSecurity(
        pSecDesc: PSECURITY_DESCRIPTOR,
        cAuthSvc: LONG,
        asAuthSvc: *mut SOLE_AUTHENTICATION_SERVICE,
        pReserved1: *mut ::std::os::raw::c_void,
        dwAuthnLevel: DWORD,
        dwImpLevel: DWORD,
        pAuthList: *mut ::std::os::raw::c_void,
        dwCapabilities: DWORD,
        pReserved3: *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetCallContext(
        riid: *const IID,
        ppInterface: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoQueryProxyBlanket(
        pProxy: *mut IUnknown,
        pwAuthnSvc: *mut DWORD,
        pAuthzSvc: *mut DWORD,
        pServerPrincName: *mut LPOLESTR,
        pAuthnLevel: *mut DWORD,
        pImpLevel: *mut DWORD,
        pAuthInfo: *mut RPC_AUTH_IDENTITY_HANDLE,
        pCapabilites: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoSetProxyBlanket(
        pProxy: *mut IUnknown,
        dwAuthnSvc: DWORD,
        dwAuthzSvc: DWORD,
        pServerPrincName: *mut OLECHAR,
        dwAuthnLevel: DWORD,
        dwImpLevel: DWORD,
        pAuthInfo: RPC_AUTH_IDENTITY_HANDLE,
        dwCapabilities: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoCopyProxy(pProxy: *mut IUnknown, ppCopy: *mut *mut IUnknown) -> HRESULT;
}
extern "C" {
    pub fn CoQueryClientBlanket(
        pAuthnSvc: *mut DWORD,
        pAuthzSvc: *mut DWORD,
        pServerPrincName: *mut LPOLESTR,
        pAuthnLevel: *mut DWORD,
        pImpLevel: *mut DWORD,
        pPrivs: *mut RPC_AUTHZ_HANDLE,
        pCapabilities: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoImpersonateClient() -> HRESULT;
}
extern "C" {
    pub fn CoRevertToSelf() -> HRESULT;
}
extern "C" {
    pub fn CoQueryAuthenticationServices(
        pcAuthSvc: *mut DWORD,
        asAuthSvc: *mut *mut SOLE_AUTHENTICATION_SERVICE,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoSwitchCallContext(
        pNewObject: *mut IUnknown,
        ppOldObject: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoCreateInstance(
        rclsid: *const IID,
        pUnkOuter: LPUNKNOWN,
        dwClsContext: DWORD,
        riid: *const IID,
        ppv: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoCreateInstanceEx(
        Clsid: *const IID,
        punkOuter: *mut IUnknown,
        dwClsCtx: DWORD,
        pServerInfo: *mut COSERVERINFO,
        dwCount: DWORD,
        pResults: *mut MULTI_QI,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoCreateInstanceFromApp(
        Clsid: *const IID,
        punkOuter: *mut IUnknown,
        dwClsCtx: DWORD,
        reserved: PVOID,
        dwCount: DWORD,
        pResults: *mut MULTI_QI,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterActivationFilter(pActivationFilter: *mut IActivationFilter) -> HRESULT;
}
extern "C" {
    pub fn CoGetCancelObject(
        dwThreadId: DWORD,
        iid: *const IID,
        ppUnk: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoSetCancelObject(pUnk: *mut IUnknown) -> HRESULT;
}
extern "C" {
    pub fn CoCancelCall(dwThreadId: DWORD, ulTimeout: ULONG) -> HRESULT;
}
extern "C" {
    pub fn CoTestCancel() -> HRESULT;
}
extern "C" {
    pub fn CoEnableCallCancellation(pReserved: LPVOID) -> HRESULT;
}
extern "C" {
    pub fn CoDisableCallCancellation(pReserved: LPVOID) -> HRESULT;
}
extern "C" {
    pub fn StringFromCLSID(rclsid: *const IID, lplpsz: *mut LPOLESTR) -> HRESULT;
}
extern "C" {
    pub fn CLSIDFromString(lpsz: LPCOLESTR, pclsid: LPCLSID) -> HRESULT;
}
extern "C" {
    pub fn StringFromIID(rclsid: *const IID, lplpsz: *mut LPOLESTR) -> HRESULT;
}
extern "C" {
    pub fn IIDFromString(lpsz: LPCOLESTR, lpiid: LPIID) -> HRESULT;
}
extern "C" {
    pub fn ProgIDFromCLSID(clsid: *const IID, lplpszProgID: *mut LPOLESTR) -> HRESULT;
}
extern "C" {
    pub fn CLSIDFromProgID(lpszProgID: LPCOLESTR, lpclsid: LPCLSID) -> HRESULT;
}
extern "C" {
    pub fn StringFromGUID2(
        rguid: *const GUID,
        lpsz: LPOLESTR,
        cchMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CoCreateGuid(pguid: *mut GUID) -> HRESULT;
}
pub type PROPVARIANT = tagPROPVARIANT;
extern "C" {
    pub fn PropVariantCopy(pvarDest: *mut PROPVARIANT, pvarSrc: *const PROPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn PropVariantClear(pvar: *mut PROPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn FreePropVariantArray(cVariants: ULONG, rgvars: *mut PROPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn CoWaitForMultipleHandles(
        dwFlags: DWORD,
        dwTimeout: DWORD,
        cHandles: ULONG,
        pHandles: LPHANDLE,
        lpdwindex: LPDWORD,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCOWAIT_FLAGS {
    COWAIT_DEFAULT = 0,
    COWAIT_WAITALL = 1,
    COWAIT_ALERTABLE = 2,
    COWAIT_INPUTAVAILABLE = 4,
    COWAIT_DISPATCH_CALLS = 8,
    COWAIT_DISPATCH_WINDOW_MESSAGES = 16,
}
pub use self::tagCOWAIT_FLAGS as COWAIT_FLAGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CWMO_FLAGS {
    CWMO_DEFAULT = 0,
    CWMO_DISPATCH_CALLS = 1,
    CWMO_DISPATCH_WINDOW_MESSAGES = 2,
}
extern "C" {
    pub fn CoWaitForMultipleObjects(
        dwFlags: DWORD,
        dwTimeout: DWORD,
        cHandles: ULONG,
        pHandles: *const HANDLE,
        lpdwindex: LPDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetTreatAsClass(clsidOld: *const IID, pClsidNew: LPCLSID) -> HRESULT;
}
extern "C" {
    pub fn CoInvalidateRemoteMachineBindings(pszMachineName: LPOLESTR) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AgileReferenceOptions {
    AGILEREFERENCE_DEFAULT = 0,
    AGILEREFERENCE_DELAYEDMARSHAL = 1,
}
extern "C" {
    pub fn RoGetAgileReference(
        options: AgileReferenceOptions,
        riid: *const IID,
        pUnk: *mut IUnknown,
        ppAgileReference: *mut *mut IAgileReference,
    ) -> HRESULT;
}
pub type LPFNGETCLASSOBJECT = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const IID, arg2: *const IID, arg3: *mut LPVOID) -> HRESULT,
>;
pub type LPFNCANUNLOADNOW = ::std::option::Option<unsafe extern "C" fn() -> HRESULT>;
extern "C" {
    pub fn DllGetClassObject(rclsid: *const IID, riid: *const IID, ppv: *mut LPVOID) -> HRESULT;
}
extern "C" {
    pub fn DllCanUnloadNow() -> HRESULT;
}
extern "C" {
    pub fn CoTaskMemAlloc(cb: SIZE_T) -> LPVOID;
}
extern "C" {
    pub fn CoTaskMemRealloc(pv: LPVOID, cb: SIZE_T) -> LPVOID;
}
extern "C" {
    pub fn CoTaskMemFree(pv: LPVOID);
}
extern "C" {
    pub fn CoFileTimeNow(lpFileTime: *mut FILETIME) -> HRESULT;
}
extern "C" {
    pub fn CLSIDFromProgIDEx(lpszProgID: LPCOLESTR, lpclsid: LPCLSID) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CO_DEVICE_CATALOG_COOKIE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type CO_DEVICE_CATALOG_COOKIE = *mut CO_DEVICE_CATALOG_COOKIE__;
extern "C" {
    pub fn CoRegisterDeviceCatalog(
        deviceInstanceId: PCWSTR,
        cookie: *mut CO_DEVICE_CATALOG_COOKIE,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoRevokeDeviceCatalog(cookie: CO_DEVICE_CATALOG_COOKIE) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0002_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0002_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_unknwn_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0055_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0055_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPMALLOCSPY = *mut IMallocSpy;
extern "C" {
    pub static IID_IMallocSpy: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMallocSpy {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0056_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0056_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBC = *mut IBindCtx;
pub type LPBINDCTX = *mut IBindCtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBIND_OPTS {
    pub cbStruct: DWORD,
    pub grfFlags: DWORD,
    pub grfMode: DWORD,
    pub dwTickCountDeadline: DWORD,
}
pub type BIND_OPTS = tagBIND_OPTS;
pub type LPBIND_OPTS = *mut tagBIND_OPTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBIND_OPTS2 {
    pub _base: tagBIND_OPTS,
    pub dwTrackFlags: DWORD,
    pub dwClassContext: DWORD,
    pub locale: LCID,
    pub pServerInfo: *mut COSERVERINFO,
}
pub type BIND_OPTS2 = tagBIND_OPTS2;
pub type LPBIND_OPTS2 = *mut tagBIND_OPTS2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBIND_OPTS3 {
    pub _base: tagBIND_OPTS2,
    pub hwnd: HWND,
}
pub type BIND_OPTS3 = tagBIND_OPTS3;
pub type LPBIND_OPTS3 = *mut tagBIND_OPTS3;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagBIND_FLAGS {
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2,
}
pub use self::tagBIND_FLAGS as BIND_FLAGS;
extern "C" {
    pub static IID_IBindCtx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindCtx {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IBindCtx_RemoteSetBindOptions_Proxy(
        This: *mut IBindCtx,
        pbindopts: *mut BIND_OPTS2,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindCtx_RemoteSetBindOptions_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IBindCtx_RemoteGetBindOptions_Proxy(
        This: *mut IBindCtx,
        pbindopts: *mut BIND_OPTS2,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindCtx_RemoteGetBindOptions_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPENUMMONIKER = *mut IEnumMoniker;
extern "C" {
    pub static IID_IEnumMoniker: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumMoniker {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumMoniker_RemoteNext_Proxy(
        This: *mut IEnumMoniker,
        celt: ULONG,
        rgelt: *mut *mut IMoniker,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumMoniker_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0058_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0058_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPRUNNABLEOBJECT = *mut IRunnableObject;
extern "C" {
    pub static IID_IRunnableObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRunnableObject {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IRunnableObject_RemoteIsRunning_Proxy(This: *mut IRunnableObject) -> HRESULT;
}
extern "C" {
    pub fn IRunnableObject_RemoteIsRunning_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPRUNNINGOBJECTTABLE = *mut IRunningObjectTable;
extern "C" {
    pub static IID_IRunningObjectTable: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRunningObjectTable {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0060_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0060_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPPERSIST = *mut IPersist;
extern "C" {
    pub static IID_IPersist: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersist {
    pub _base: IUnknown,
}
pub type LPPERSISTSTREAM = *mut IPersistStream;
extern "C" {
    pub static IID_IPersistStream: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersistStream {
    pub _base: IPersist,
}
pub type LPMONIKER = *mut IMoniker;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagMKSYS {
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5,
    MKSYS_CLASSMONIKER = 7,
    MKSYS_OBJREFMONIKER = 8,
    MKSYS_SESSIONMONIKER = 9,
    MKSYS_LUAMONIKER = 10,
}
pub use self::tagMKSYS as MKSYS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagMKREDUCE {
    MKRREDUCE_ONE = 196608,
    MKRREDUCE_TOUSER = 131072,
    MKRREDUCE_THROUGHUSER = 65536,
    MKRREDUCE_ALL = 0,
}
pub use self::tagMKREDUCE as MKRREDUCE;
extern "C" {
    pub static IID_IMoniker: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMoniker {
    pub _base: IPersistStream,
}
extern "C" {
    pub fn IMoniker_RemoteBindToObject_Proxy(
        This: *mut IMoniker,
        pbc: *mut IBindCtx,
        pmkToLeft: *mut IMoniker,
        riidResult: *const IID,
        ppvResult: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IMoniker_RemoteBindToObject_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IMoniker_RemoteBindToStorage_Proxy(
        This: *mut IMoniker,
        pbc: *mut IBindCtx,
        pmkToLeft: *mut IMoniker,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IMoniker_RemoteBindToStorage_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0063_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0063_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IROTData: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IROTData {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0064_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0064_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPENUMSTATSTG = *mut IEnumSTATSTG;
extern "C" {
    pub static IID_IEnumSTATSTG: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATSTG {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumSTATSTG_RemoteNext_Proxy(
        This: *mut IEnumSTATSTG,
        celt: ULONG,
        rgelt: *mut STATSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATSTG_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPSTORAGE = *mut IStorage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemSNB {
    pub ulCntStr: ULONG,
    pub ulCntChar: ULONG,
    pub rgString: [OLECHAR; 1usize],
}
pub type RemSNB = tagRemSNB;
pub type wireSNB = *mut RemSNB;
pub type SNB = *mut LPOLESTR;
extern "C" {
    pub static IID_IStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStorage {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IStorage_RemoteOpenStream_Proxy(
        This: *mut IStorage,
        pwcsName: *const OLECHAR,
        cbReserved1: ULONG,
        reserved1: *mut byte,
        grfMode: DWORD,
        reserved2: DWORD,
        ppstm: *mut *mut IStream,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_RemoteOpenStream_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IStorage_RemoteCopyTo_Proxy(
        This: *mut IStorage,
        ciidExclude: DWORD,
        rgiidExclude: *const IID,
        snbExclude: SNB,
        pstgDest: *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_RemoteCopyTo_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IStorage_RemoteEnumElements_Proxy(
        This: *mut IStorage,
        reserved1: DWORD,
        cbReserved2: ULONG,
        reserved2: *mut byte,
        reserved3: DWORD,
        ppenum: *mut *mut IEnumSTATSTG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_RemoteEnumElements_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0066_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0066_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPPERSISTFILE = *mut IPersistFile;
extern "C" {
    pub static IID_IPersistFile: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersistFile {
    pub _base: IPersist,
}
pub type LPPERSISTSTORAGE = *mut IPersistStorage;
extern "C" {
    pub static IID_IPersistStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersistStorage {
    pub _base: IPersist,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0068_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0068_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPLOCKBYTES = *mut ILockBytes;
extern "C" {
    pub static IID_ILockBytes: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ILockBytes {
    pub _base: IUnknown,
}
extern "C" {
    pub fn ILockBytes_RemoteReadAt_Proxy(
        This: *mut ILockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *mut byte,
        cb: ULONG,
        pcbRead: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ILockBytes_RemoteReadAt_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ILockBytes_RemoteWriteAt_Proxy(
        This: *mut ILockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ILockBytes_RemoteWriteAt_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPENUMFORMATETC = *mut IEnumFORMATETC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDVTARGETDEVICE {
    pub tdSize: DWORD,
    pub tdDriverNameOffset: WORD,
    pub tdDeviceNameOffset: WORD,
    pub tdPortNameOffset: WORD,
    pub tdExtDevmodeOffset: WORD,
    pub tdData: [BYTE; 1usize],
}
pub type DVTARGETDEVICE = tagDVTARGETDEVICE;
pub type LPCLIPFORMAT = *mut CLIPFORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFORMATETC {
    pub cfFormat: CLIPFORMAT,
    pub ptd: *mut DVTARGETDEVICE,
    pub dwAspect: DWORD,
    pub lindex: LONG,
    pub tymed: DWORD,
}
pub type FORMATETC = tagFORMATETC;
pub type LPFORMATETC = *mut tagFORMATETC;
extern "C" {
    pub static IID_IEnumFORMATETC: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumFORMATETC {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumFORMATETC_RemoteNext_Proxy(
        This: *mut IEnumFORMATETC,
        celt: ULONG,
        rgelt: *mut FORMATETC,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumFORMATETC_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPENUMSTATDATA = *mut IEnumSTATDATA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagADVF {
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32,
}
pub use self::tagADVF as ADVF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATDATA {
    pub formatetc: FORMATETC,
    pub advf: DWORD,
    pub pAdvSink: *mut IAdviseSink,
    pub dwConnection: DWORD,
}
pub type STATDATA = tagSTATDATA;
pub type LPSTATDATA = *mut STATDATA;
extern "C" {
    pub static IID_IEnumSTATDATA: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATDATA {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumSTATDATA_RemoteNext_Proxy(
        This: *mut IEnumSTATDATA,
        celt: ULONG,
        rgelt: *mut STATDATA,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATDATA_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPROOTSTORAGE = *mut IRootStorage;
extern "C" {
    pub static IID_IRootStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRootStorage {
    pub _base: IUnknown,
}
pub type LPADVISESINK = *mut IAdviseSink;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagTYMED {
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_ENHMF = 64,
    TYMED_NULL = 0,
}
pub use self::tagTYMED as TYMED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemSTGMEDIUM {
    pub tymed: DWORD,
    pub dwHandleType: DWORD,
    pub pData: ULONG,
    pub pUnkForRelease: ULONG,
    pub cbData: ULONG,
    pub data: [byte; 1usize],
}
pub type RemSTGMEDIUM = tagRemSTGMEDIUM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTGMEDIUM {
    pub tymed: DWORD,
    pub __bindgen_anon_1: tagSTGMEDIUM__bindgen_ty_1,
    pub pUnkForRelease: *mut IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagSTGMEDIUM__bindgen_ty_1 {
    pub hBitmap: HBITMAP,
    pub hMetaFilePict: HMETAFILEPICT,
    pub hEnhMetaFile: HENHMETAFILE,
    pub hGlobal: HGLOBAL,
    pub lpszFileName: LPOLESTR,
    pub pstm: *mut IStream,
    pub pstg: *mut IStorage,
}
pub type uSTGMEDIUM = tagSTGMEDIUM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GDI_OBJECT {
    pub ObjectType: DWORD,
    pub u: _GDI_OBJECT___MIDL_IAdviseSink_0002,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDI_OBJECT___MIDL_IAdviseSink_0002 {
    pub hBitmap: wireHBITMAP,
    pub hPalette: wireHPALETTE,
    pub hGeneric: wireHGLOBAL,
}
pub type GDI_OBJECT = _GDI_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _userSTGMEDIUM {
    pub pUnkForRelease: *mut IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _userSTGMEDIUM__STGMEDIUM_UNION {
    pub tymed: DWORD,
    pub u: _userSTGMEDIUM__STGMEDIUM_UNION___MIDL_IAdviseSink_0003,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _userSTGMEDIUM__STGMEDIUM_UNION___MIDL_IAdviseSink_0003 {
    pub hMetaFilePict: wireHMETAFILEPICT,
    pub hHEnhMetaFile: wireHENHMETAFILE,
    pub hGdiHandle: *mut GDI_OBJECT,
    pub hGlobal: wireHGLOBAL,
    pub lpszFileName: LPOLESTR,
    pub pstm: *mut BYTE_BLOB,
    pub pstg: *mut BYTE_BLOB,
}
pub type userSTGMEDIUM = _userSTGMEDIUM;
pub type wireSTGMEDIUM = *mut userSTGMEDIUM;
pub type STGMEDIUM = uSTGMEDIUM;
pub type wireASYNC_STGMEDIUM = *mut userSTGMEDIUM;
pub type ASYNC_STGMEDIUM = STGMEDIUM;
pub type LPSTGMEDIUM = *mut STGMEDIUM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _userFLAG_STGMEDIUM {
    pub ContextFlags: LONG,
    pub fPassOwnership: LONG,
    pub Stgmed: userSTGMEDIUM,
}
pub type userFLAG_STGMEDIUM = _userFLAG_STGMEDIUM;
pub type wireFLAG_STGMEDIUM = *mut userFLAG_STGMEDIUM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLAG_STGMEDIUM {
    pub ContextFlags: LONG,
    pub fPassOwnership: LONG,
    pub Stgmed: STGMEDIUM,
}
pub type FLAG_STGMEDIUM = _FLAG_STGMEDIUM;
extern "C" {
    pub static IID_IAdviseSink: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAdviseSink {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IAdviseSink_RemoteOnDataChange_Proxy(
        This: *mut IAdviseSink,
        pFormatetc: *mut FORMATETC,
        pStgmed: *mut ASYNC_STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_RemoteOnDataChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IAdviseSink_RemoteOnViewChange_Proxy(
        This: *mut IAdviseSink,
        dwAspect: DWORD,
        lindex: LONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_RemoteOnViewChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IAdviseSink_RemoteOnRename_Proxy(This: *mut IAdviseSink, pmk: *mut IMoniker) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_RemoteOnRename_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IAdviseSink_RemoteOnSave_Proxy(This: *mut IAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_RemoteOnSave_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IAdviseSink_RemoteOnClose_Proxy(This: *mut IAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_RemoteOnClose_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static IID_AsyncIAdviseSink: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIAdviseSink {
    pub _base: IUnknown,
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(
        This: *mut AsyncIAdviseSink,
        pFormatetc: *mut FORMATETC,
        pStgmed: *mut ASYNC_STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnDataChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(This: *mut AsyncIAdviseSink)
        -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnDataChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(
        This: *mut AsyncIAdviseSink,
        dwAspect: DWORD,
        lindex: LONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnViewChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(This: *mut AsyncIAdviseSink)
        -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnViewChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(
        This: *mut AsyncIAdviseSink,
        pmk: *mut IMoniker,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnRename_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnRename_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnSave_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnSave_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_RemoteOnClose_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_RemoteOnClose_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0073_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0073_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPADVISESINK2 = *mut IAdviseSink2;
extern "C" {
    pub static IID_IAdviseSink2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAdviseSink2 {
    pub _base: IAdviseSink,
}
extern "C" {
    pub fn IAdviseSink2_RemoteOnLinkSrcChange_Proxy(
        This: *mut IAdviseSink2,
        pmk: *mut IMoniker,
    ) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink2_RemoteOnLinkSrcChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static IID_AsyncIAdviseSink2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncIAdviseSink2 {
    pub _base: AsyncIAdviseSink,
}
extern "C" {
    pub fn AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(
        This: *mut AsyncIAdviseSink2,
        pmk: *mut IMoniker,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(
        This: *mut AsyncIAdviseSink2,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0074_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0074_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPDATAOBJECT = *mut IDataObject;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagDATADIR {
    DATADIR_GET = 1,
    DATADIR_SET = 2,
}
pub use self::tagDATADIR as DATADIR;
extern "C" {
    pub static IID_IDataObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDataObject {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IDataObject_RemoteGetData_Proxy(
        This: *mut IDataObject,
        pformatetcIn: *mut FORMATETC,
        pRemoteMedium: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_RemoteGetData_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IDataObject_RemoteGetDataHere_Proxy(
        This: *mut IDataObject,
        pformatetc: *mut FORMATETC,
        pRemoteMedium: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_RemoteGetDataHere_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IDataObject_RemoteSetData_Proxy(
        This: *mut IDataObject,
        pformatetc: *mut FORMATETC,
        pmedium: *mut FLAG_STGMEDIUM,
        fRelease: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_RemoteSetData_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0075_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0075_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPDATAADVISEHOLDER = *mut IDataAdviseHolder;
extern "C" {
    pub static IID_IDataAdviseHolder: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDataAdviseHolder {
    pub _base: IUnknown,
}
pub type LPMESSAGEFILTER = *mut IMessageFilter;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCALLTYPE {
    CALLTYPE_TOPLEVEL = 1,
    CALLTYPE_NESTED = 2,
    CALLTYPE_ASYNC = 3,
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,
    CALLTYPE_ASYNC_CALLPENDING = 5,
}
pub use self::tagCALLTYPE as CALLTYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSERVERCALL {
    SERVERCALL_ISHANDLED = 0,
    SERVERCALL_REJECTED = 1,
    SERVERCALL_RETRYLATER = 2,
}
pub use self::tagSERVERCALL as SERVERCALL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagPENDINGTYPE {
    PENDINGTYPE_TOPLEVEL = 1,
    PENDINGTYPE_NESTED = 2,
}
pub use self::tagPENDINGTYPE as PENDINGTYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagPENDINGMSG {
    PENDINGMSG_CANCELCALL = 0,
    PENDINGMSG_WAITNOPROCESS = 1,
    PENDINGMSG_WAITDEFPROCESS = 2,
}
pub use self::tagPENDINGMSG as PENDINGMSG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagINTERFACEINFO {
    pub pUnk: *mut IUnknown,
    pub iid: IID,
    pub wMethod: WORD,
}
pub type INTERFACEINFO = tagINTERFACEINFO;
pub type LPINTERFACEINFO = *mut tagINTERFACEINFO;
extern "C" {
    pub static IID_IMessageFilter: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMessageFilter {
    pub _base: IUnknown,
}
extern "C" {
    pub static FMTID_SummaryInformation: FMTID;
}
extern "C" {
    pub static FMTID_DocSummaryInformation: FMTID;
}
extern "C" {
    pub static FMTID_UserDefinedProperties: FMTID;
}
extern "C" {
    pub static FMTID_DiscardableInformation: FMTID;
}
extern "C" {
    pub static FMTID_ImageSummaryInformation: FMTID;
}
extern "C" {
    pub static FMTID_AudioSummaryInformation: FMTID;
}
extern "C" {
    pub static FMTID_VideoSummaryInformation: FMTID;
}
extern "C" {
    pub static FMTID_MediaFileSummaryInformation: FMTID;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0077_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0077_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IClassActivator: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IClassActivator {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0078_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0078_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IFillLockBytes: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IFillLockBytes {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IFillLockBytes_RemoteFillAppend_Proxy(
        This: *mut IFillLockBytes,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IFillLockBytes_RemoteFillAppend_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IFillLockBytes_RemoteFillAt_Proxy(
        This: *mut IFillLockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IFillLockBytes_RemoteFillAt_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0079_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0079_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IProgressNotify: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IProgressNotify {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0080_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0080_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagStorageLayout {
    pub LayoutType: DWORD,
    pub pwcsElementName: *mut OLECHAR,
    pub cOffset: LARGE_INTEGER,
    pub cBytes: LARGE_INTEGER,
}
pub type StorageLayout = tagStorageLayout;
extern "C" {
    pub static IID_ILayoutStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ILayoutStorage {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0081_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0081_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IBlockingLock: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBlockingLock {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ITimeAndNoticeControl: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITimeAndNoticeControl {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IOplockStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOplockStorage {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0084_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0084_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IDirectWriterLock: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDirectWriterLock {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0085_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0085_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IUrlMon: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUrlMon {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IForegroundTransfer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IForegroundTransfer {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IThumbnailExtractor: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IThumbnailExtractor {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IDummyHICONIncluder: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDummyHICONIncluder {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagApplicationType {
    ServerApplication = 0,
    LibraryApplication = 1,
}
pub use self::tagApplicationType as ApplicationType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagShutdownType {
    IdleShutdown = 0,
    ForcedShutdown = 1,
}
pub use self::tagShutdownType as ShutdownType;
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0089_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0089_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IProcessLock: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IProcessLock {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ISurrogateService: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISurrogateService {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0091_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0091_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPINITIALIZESPY = *mut IInitializeSpy;
extern "C" {
    pub static IID_IInitializeSpy: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInitializeSpy {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0092_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0092_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IApartmentShutdown: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IApartmentShutdown {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0093_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_objidl_0000_0093_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ASYNC_STGMEDIUM,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut ASYNC_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut ASYNC_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut ASYNC_STGMEDIUM);
}
extern "C" {
    pub fn CLIPFORMAT_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut CLIPFORMAT,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CLIPFORMAT_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLIPFORMAT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLIPFORMAT_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLIPFORMAT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLIPFORMAT_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut CLIPFORMAT);
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut FLAG_STGMEDIUM,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut FLAG_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut FLAG_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut FLAG_STGMEDIUM);
}
extern "C" {
    pub fn HBITMAP_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HBITMAP,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HBITMAP_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HBITMAP,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HBITMAP_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HBITMAP,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HBITMAP_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HBITMAP);
}
extern "C" {
    pub fn HDC_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HDC,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HDC_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HDC,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HDC_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HDC,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HDC_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HDC);
}
extern "C" {
    pub fn HICON_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HICON,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HICON_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HICON,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HICON_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HICON,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HICON_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HICON);
}
extern "C" {
    pub fn SNB_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut SNB,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SNB_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut SNB,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SNB_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut SNB,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SNB_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut SNB);
}
extern "C" {
    pub fn STGMEDIUM_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut STGMEDIUM,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn STGMEDIUM_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn STGMEDIUM_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn STGMEDIUM_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut STGMEDIUM);
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ASYNC_STGMEDIUM,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut ASYNC_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut ASYNC_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASYNC_STGMEDIUM_UserFree64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ASYNC_STGMEDIUM,
    );
}
extern "C" {
    pub fn CLIPFORMAT_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut CLIPFORMAT,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CLIPFORMAT_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLIPFORMAT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLIPFORMAT_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLIPFORMAT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLIPFORMAT_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut CLIPFORMAT);
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut FLAG_STGMEDIUM,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut FLAG_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut FLAG_STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn FLAG_STGMEDIUM_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut FLAG_STGMEDIUM);
}
extern "C" {
    pub fn HBITMAP_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HBITMAP,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HBITMAP_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HBITMAP,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HBITMAP_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HBITMAP,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HBITMAP_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HBITMAP);
}
extern "C" {
    pub fn HDC_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HDC,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HDC_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HDC,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HDC_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HDC,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HDC_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HDC);
}
extern "C" {
    pub fn HICON_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HICON,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HICON_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HICON,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HICON_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HICON,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HICON_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HICON);
}
extern "C" {
    pub fn SNB_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut SNB,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SNB_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut SNB,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SNB_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut SNB,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SNB_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut SNB);
}
extern "C" {
    pub fn STGMEDIUM_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut STGMEDIUM,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn STGMEDIUM_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn STGMEDIUM_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut STGMEDIUM,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn STGMEDIUM_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut STGMEDIUM);
}
extern "C" {
    pub fn IBindCtx_SetBindOptions_Proxy(This: *mut IBindCtx, pbindopts: *mut BIND_OPTS)
        -> HRESULT;
}
extern "C" {
    pub fn IBindCtx_SetBindOptions_Stub(This: *mut IBindCtx, pbindopts: *mut BIND_OPTS2)
        -> HRESULT;
}
extern "C" {
    pub fn IBindCtx_GetBindOptions_Proxy(This: *mut IBindCtx, pbindopts: *mut BIND_OPTS)
        -> HRESULT;
}
extern "C" {
    pub fn IBindCtx_GetBindOptions_Stub(This: *mut IBindCtx, pbindopts: *mut BIND_OPTS2)
        -> HRESULT;
}
extern "C" {
    pub fn IEnumMoniker_Next_Proxy(
        This: *mut IEnumMoniker,
        celt: ULONG,
        rgelt: *mut *mut IMoniker,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumMoniker_Next_Stub(
        This: *mut IEnumMoniker,
        celt: ULONG,
        rgelt: *mut *mut IMoniker,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IRunnableObject_IsRunning_Proxy(This: *mut IRunnableObject) -> BOOL;
}
extern "C" {
    pub fn IRunnableObject_IsRunning_Stub(This: *mut IRunnableObject) -> HRESULT;
}
extern "C" {
    pub fn IMoniker_BindToObject_Proxy(
        This: *mut IMoniker,
        pbc: *mut IBindCtx,
        pmkToLeft: *mut IMoniker,
        riidResult: *const IID,
        ppvResult: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IMoniker_BindToObject_Stub(
        This: *mut IMoniker,
        pbc: *mut IBindCtx,
        pmkToLeft: *mut IMoniker,
        riidResult: *const IID,
        ppvResult: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IMoniker_BindToStorage_Proxy(
        This: *mut IMoniker,
        pbc: *mut IBindCtx,
        pmkToLeft: *mut IMoniker,
        riid: *const IID,
        ppvObj: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IMoniker_BindToStorage_Stub(
        This: *mut IMoniker,
        pbc: *mut IBindCtx,
        pmkToLeft: *mut IMoniker,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATSTG_Next_Proxy(
        This: *mut IEnumSTATSTG,
        celt: ULONG,
        rgelt: *mut STATSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATSTG_Next_Stub(
        This: *mut IEnumSTATSTG,
        celt: ULONG,
        rgelt: *mut STATSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_OpenStream_Proxy(
        This: *mut IStorage,
        pwcsName: *const OLECHAR,
        reserved1: *mut ::std::os::raw::c_void,
        grfMode: DWORD,
        reserved2: DWORD,
        ppstm: *mut *mut IStream,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_OpenStream_Stub(
        This: *mut IStorage,
        pwcsName: *const OLECHAR,
        cbReserved1: ULONG,
        reserved1: *mut byte,
        grfMode: DWORD,
        reserved2: DWORD,
        ppstm: *mut *mut IStream,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_CopyTo_Proxy(
        This: *mut IStorage,
        ciidExclude: DWORD,
        rgiidExclude: *const IID,
        snbExclude: SNB,
        pstgDest: *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_CopyTo_Stub(
        This: *mut IStorage,
        ciidExclude: DWORD,
        rgiidExclude: *const IID,
        snbExclude: SNB,
        pstgDest: *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_EnumElements_Proxy(
        This: *mut IStorage,
        reserved1: DWORD,
        reserved2: *mut ::std::os::raw::c_void,
        reserved3: DWORD,
        ppenum: *mut *mut IEnumSTATSTG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IStorage_EnumElements_Stub(
        This: *mut IStorage,
        reserved1: DWORD,
        cbReserved2: ULONG,
        reserved2: *mut byte,
        reserved3: DWORD,
        ppenum: *mut *mut IEnumSTATSTG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ILockBytes_ReadAt_Proxy(
        This: *mut ILockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *mut ::std::os::raw::c_void,
        cb: ULONG,
        pcbRead: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ILockBytes_ReadAt_Stub(
        This: *mut ILockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *mut byte,
        cb: ULONG,
        pcbRead: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ILockBytes_WriteAt_Proxy(
        This: *mut ILockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *const ::std::os::raw::c_void,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ILockBytes_WriteAt_Stub(
        This: *mut ILockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumFORMATETC_Next_Proxy(
        This: *mut IEnumFORMATETC,
        celt: ULONG,
        rgelt: *mut FORMATETC,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumFORMATETC_Next_Stub(
        This: *mut IEnumFORMATETC,
        celt: ULONG,
        rgelt: *mut FORMATETC,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATDATA_Next_Proxy(
        This: *mut IEnumSTATDATA,
        celt: ULONG,
        rgelt: *mut STATDATA,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATDATA_Next_Stub(
        This: *mut IEnumSTATDATA,
        celt: ULONG,
        rgelt: *mut STATDATA,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_OnDataChange_Proxy(
        This: *mut IAdviseSink,
        pFormatetc: *mut FORMATETC,
        pStgmed: *mut STGMEDIUM,
    );
}
extern "C" {
    pub fn IAdviseSink_OnDataChange_Stub(
        This: *mut IAdviseSink,
        pFormatetc: *mut FORMATETC,
        pStgmed: *mut ASYNC_STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_OnViewChange_Proxy(This: *mut IAdviseSink, dwAspect: DWORD, lindex: LONG);
}
extern "C" {
    pub fn IAdviseSink_OnViewChange_Stub(
        This: *mut IAdviseSink,
        dwAspect: DWORD,
        lindex: LONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_OnRename_Proxy(This: *mut IAdviseSink, pmk: *mut IMoniker);
}
extern "C" {
    pub fn IAdviseSink_OnRename_Stub(This: *mut IAdviseSink, pmk: *mut IMoniker) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_OnSave_Proxy(This: *mut IAdviseSink);
}
extern "C" {
    pub fn IAdviseSink_OnSave_Stub(This: *mut IAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink_OnClose_Proxy(This: *mut IAdviseSink);
}
extern "C" {
    pub fn IAdviseSink_OnClose_Stub(This: *mut IAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnDataChange_Proxy(
        This: *mut AsyncIAdviseSink,
        pFormatetc: *mut FORMATETC,
        pStgmed: *mut STGMEDIUM,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnDataChange_Stub(
        This: *mut AsyncIAdviseSink,
        pFormatetc: *mut FORMATETC,
        pStgmed: *mut ASYNC_STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnDataChange_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnDataChange_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnViewChange_Proxy(
        This: *mut AsyncIAdviseSink,
        dwAspect: DWORD,
        lindex: LONG,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnViewChange_Stub(
        This: *mut AsyncIAdviseSink,
        dwAspect: DWORD,
        lindex: LONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnViewChange_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnViewChange_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnRename_Proxy(This: *mut AsyncIAdviseSink, pmk: *mut IMoniker);
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnRename_Stub(
        This: *mut AsyncIAdviseSink,
        pmk: *mut IMoniker,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnRename_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnRename_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnSave_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnSave_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnSave_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnSave_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnClose_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Begin_OnClose_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnClose_Proxy(This: *mut AsyncIAdviseSink);
}
extern "C" {
    pub fn AsyncIAdviseSink_Finish_OnClose_Stub(This: *mut AsyncIAdviseSink) -> HRESULT;
}
extern "C" {
    pub fn IAdviseSink2_OnLinkSrcChange_Proxy(This: *mut IAdviseSink2, pmk: *mut IMoniker);
}
extern "C" {
    pub fn IAdviseSink2_OnLinkSrcChange_Stub(
        This: *mut IAdviseSink2,
        pmk: *mut IMoniker,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(
        This: *mut AsyncIAdviseSink2,
        pmk: *mut IMoniker,
    );
}
extern "C" {
    pub fn AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(
        This: *mut AsyncIAdviseSink2,
        pmk: *mut IMoniker,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(This: *mut AsyncIAdviseSink2);
}
extern "C" {
    pub fn AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(This: *mut AsyncIAdviseSink2) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_GetData_Proxy(
        This: *mut IDataObject,
        pformatetcIn: *mut FORMATETC,
        pmedium: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_GetData_Stub(
        This: *mut IDataObject,
        pformatetcIn: *mut FORMATETC,
        pRemoteMedium: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_GetDataHere_Proxy(
        This: *mut IDataObject,
        pformatetc: *mut FORMATETC,
        pmedium: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_GetDataHere_Stub(
        This: *mut IDataObject,
        pformatetc: *mut FORMATETC,
        pRemoteMedium: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_SetData_Proxy(
        This: *mut IDataObject,
        pformatetc: *mut FORMATETC,
        pmedium: *mut STGMEDIUM,
        fRelease: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDataObject_SetData_Stub(
        This: *mut IDataObject,
        pformatetc: *mut FORMATETC,
        pmedium: *mut FLAG_STGMEDIUM,
        fRelease: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn IFillLockBytes_FillAppend_Proxy(
        This: *mut IFillLockBytes,
        pv: *const ::std::os::raw::c_void,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IFillLockBytes_FillAppend_Stub(
        This: *mut IFillLockBytes,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IFillLockBytes_FillAt_Proxy(
        This: *mut IFillLockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *const ::std::os::raw::c_void,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IFillLockBytes_FillAt_Stub(
        This: *mut IFillLockBytes,
        ulOffset: ULARGE_INTEGER,
        pv: *const byte,
        cb: ULONG,
        pcbWritten: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type CURRENCY = CY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAYBOUND {
    pub cElements: ULONG,
    pub lLbound: LONG,
}
pub type SAFEARRAYBOUND = tagSAFEARRAYBOUND;
pub type LPSAFEARRAYBOUND = *mut tagSAFEARRAYBOUND;
pub type wireVARIANT = *mut _wireVARIANT;
pub type wireBRECORD = *mut _wireBRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_BSTR {
    pub Size: ULONG,
    pub aBstr: *mut wireBSTR,
}
pub type SAFEARR_BSTR = _wireSAFEARR_BSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_UNKNOWN {
    pub Size: ULONG,
    pub apUnknown: *mut *mut IUnknown,
}
pub type SAFEARR_UNKNOWN = _wireSAFEARR_UNKNOWN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_DISPATCH {
    pub Size: ULONG,
    pub apDispatch: *mut *mut IDispatch,
}
pub type SAFEARR_DISPATCH = _wireSAFEARR_DISPATCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_VARIANT {
    pub Size: ULONG,
    pub aVariant: *mut wireVARIANT,
}
pub type SAFEARR_VARIANT = _wireSAFEARR_VARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_BRECORD {
    pub Size: ULONG,
    pub aRecord: *mut wireBRECORD,
}
pub type SAFEARR_BRECORD = _wireSAFEARR_BRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_HAVEIID {
    pub Size: ULONG,
    pub apUnknown: *mut *mut IUnknown,
    pub iid: IID,
}
pub type SAFEARR_HAVEIID = _wireSAFEARR_HAVEIID;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSF_TYPE {
    SF_ERROR = 10,
    SF_I1 = 16,
    SF_I2 = 2,
    SF_I4 = 3,
    SF_I8 = 20,
    SF_BSTR = 8,
    SF_UNKNOWN = 13,
    SF_DISPATCH = 9,
    SF_VARIANT = 12,
    SF_RECORD = 36,
    SF_HAVEIID = 32781,
}
pub use self::tagSF_TYPE as SF_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireSAFEARRAY_UNION {
    pub sfType: ULONG,
    pub u: _wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001 {
    pub BstrStr: SAFEARR_BSTR,
    pub UnknownStr: SAFEARR_UNKNOWN,
    pub DispatchStr: SAFEARR_DISPATCH,
    pub VariantStr: SAFEARR_VARIANT,
    pub RecordStr: SAFEARR_BRECORD,
    pub HaveIidStr: SAFEARR_HAVEIID,
    pub ByteStr: BYTE_SIZEDARR,
    pub WordStr: WORD_SIZEDARR,
    pub LongStr: DWORD_SIZEDARR,
    pub HyperStr: HYPER_SIZEDARR,
}
pub type SAFEARRAYUNION = _wireSAFEARRAY_UNION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireSAFEARRAY {
    pub cDims: USHORT,
    pub fFeatures: USHORT,
    pub cbElements: ULONG,
    pub cLocks: ULONG,
    pub uArrayStructs: SAFEARRAYUNION,
    pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
pub type wireSAFEARRAY = *mut _wireSAFEARRAY;
pub type wirePSAFEARRAY = *mut wireSAFEARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAY {
    pub cDims: USHORT,
    pub fFeatures: USHORT,
    pub cbElements: ULONG,
    pub cLocks: ULONG,
    pub pvData: PVOID,
    pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
pub type SAFEARRAY = tagSAFEARRAY;
pub type LPSAFEARRAY = *mut SAFEARRAY;
pub type VARIANT = tagVARIANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT {
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1 {
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1,
    pub decVal: DECIMAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1 {
    pub vt: VARTYPE,
    pub wReserved1: WORD,
    pub wReserved2: WORD,
    pub wReserved3: WORD,
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub llVal: LONGLONG,
    pub lVal: LONG,
    pub bVal: BYTE,
    pub iVal: SHORT,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub bstrVal: BSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub parray: *mut SAFEARRAY,
    pub pbVal: *mut BYTE,
    pub piVal: *mut SHORT,
    pub plVal: *mut LONG,
    pub pllVal: *mut LONGLONG,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_PBOOL: *mut VARIANT_BOOL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut BSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut *mut SAFEARRAY,
    pub pvarVal: *mut VARIANT,
    pub byref: PVOID,
    pub cVal: CHAR,
    pub uiVal: USHORT,
    pub ulVal: ULONG,
    pub ullVal: ULONGLONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub pdecVal: *mut DECIMAL,
    pub pcVal: *mut CHAR,
    pub puiVal: *mut USHORT,
    pub pulVal: *mut ULONG,
    pub pullVal: *mut ULONGLONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub pvRecord: PVOID,
    pub pRecInfo: *mut IRecordInfo,
}
pub type LPVARIANT = *mut VARIANT;
pub type VARIANTARG = VARIANT;
pub type LPVARIANTARG = *mut VARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireBRECORD {
    pub fFlags: ULONG,
    pub clSize: ULONG,
    pub pRecInfo: *mut IRecordInfo,
    pub pRecord: *mut byte,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireVARIANT {
    pub clSize: DWORD,
    pub rpcReserved: DWORD,
    pub vt: USHORT,
    pub wReserved1: USHORT,
    pub wReserved2: USHORT,
    pub wReserved3: USHORT,
    pub __bindgen_anon_1: _wireVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _wireVARIANT__bindgen_ty_1 {
    pub llVal: LONGLONG,
    pub lVal: LONG,
    pub bVal: BYTE,
    pub iVal: SHORT,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub bstrVal: wireBSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub parray: wirePSAFEARRAY,
    pub brecVal: wireBRECORD,
    pub pbVal: *mut BYTE,
    pub piVal: *mut SHORT,
    pub plVal: *mut LONG,
    pub pllVal: *mut LONGLONG,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut wireBSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut wirePSAFEARRAY,
    pub pvarVal: *mut wireVARIANT,
    pub cVal: CHAR,
    pub uiVal: USHORT,
    pub ulVal: ULONG,
    pub ullVal: ULONGLONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub decVal: DECIMAL,
    pub pdecVal: *mut DECIMAL,
    pub pcVal: *mut CHAR,
    pub puiVal: *mut USHORT,
    pub pulVal: *mut ULONG,
    pub pullVal: *mut ULONGLONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
}
pub type DISPID = LONG;
pub type MEMBERID = DISPID;
pub type HREFTYPE = DWORD;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagTYPEKIND {
    TKIND_ENUM = 0,
    TKIND_RECORD = 1,
    TKIND_MODULE = 2,
    TKIND_INTERFACE = 3,
    TKIND_DISPATCH = 4,
    TKIND_COCLASS = 5,
    TKIND_ALIAS = 6,
    TKIND_UNION = 7,
    TKIND_MAX = 8,
}
pub use self::tagTYPEKIND as TYPEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEDESC {
    pub __bindgen_anon_1: tagTYPEDESC__bindgen_ty_1,
    pub vt: VARTYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagTYPEDESC__bindgen_ty_1 {
    pub lptdesc: *mut tagTYPEDESC,
    pub lpadesc: *mut tagARRAYDESC,
    pub hreftype: HREFTYPE,
}
pub type TYPEDESC = tagTYPEDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagARRAYDESC {
    pub tdescElem: TYPEDESC,
    pub cDims: USHORT,
    pub rgbounds: [SAFEARRAYBOUND; 1usize],
}
pub type ARRAYDESC = tagARRAYDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPARAMDESCEX {
    pub cBytes: ULONG,
    pub varDefaultValue: VARIANTARG,
}
pub type PARAMDESCEX = tagPARAMDESCEX;
pub type LPPARAMDESCEX = *mut tagPARAMDESCEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPARAMDESC {
    pub pparamdescex: LPPARAMDESCEX,
    pub wParamFlags: USHORT,
}
pub type PARAMDESC = tagPARAMDESC;
pub type LPPARAMDESC = *mut tagPARAMDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIDLDESC {
    pub dwReserved: ULONG_PTR,
    pub wIDLFlags: USHORT,
}
pub type IDLDESC = tagIDLDESC;
pub type LPIDLDESC = *mut tagIDLDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagELEMDESC {
    pub tdesc: TYPEDESC,
    pub __bindgen_anon_1: tagELEMDESC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagELEMDESC__bindgen_ty_1 {
    pub idldesc: IDLDESC,
    pub paramdesc: PARAMDESC,
}
pub type ELEMDESC = tagELEMDESC;
pub type LPELEMDESC = *mut tagELEMDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEATTR {
    pub guid: GUID,
    pub lcid: LCID,
    pub dwReserved: DWORD,
    pub memidConstructor: MEMBERID,
    pub memidDestructor: MEMBERID,
    pub lpstrSchema: LPOLESTR,
    pub cbSizeInstance: ULONG,
    pub typekind: TYPEKIND,
    pub cFuncs: WORD,
    pub cVars: WORD,
    pub cImplTypes: WORD,
    pub cbSizeVft: WORD,
    pub cbAlignment: WORD,
    pub wTypeFlags: WORD,
    pub wMajorVerNum: WORD,
    pub wMinorVerNum: WORD,
    pub tdescAlias: TYPEDESC,
    pub idldescType: IDLDESC,
}
pub type TYPEATTR = tagTYPEATTR;
pub type LPTYPEATTR = *mut tagTYPEATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDISPPARAMS {
    pub rgvarg: *mut VARIANTARG,
    pub rgdispidNamedArgs: *mut DISPID,
    pub cArgs: UINT,
    pub cNamedArgs: UINT,
}
pub type DISPPARAMS = tagDISPPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXCEPINFO {
    pub wCode: WORD,
    pub wReserved: WORD,
    pub bstrSource: BSTR,
    pub bstrDescription: BSTR,
    pub bstrHelpFile: BSTR,
    pub dwHelpContext: DWORD,
    pub pvReserved: PVOID,
    pub pfnDeferredFillIn:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut tagEXCEPINFO) -> HRESULT>,
    pub scode: SCODE,
}
pub type EXCEPINFO = tagEXCEPINFO;
pub type LPEXCEPINFO = *mut tagEXCEPINFO;
impl tagCALLCONV {
    pub const CC_PASCAL: tagCALLCONV = tagCALLCONV::CC_MSCPASCAL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCALLCONV {
    CC_FASTCALL = 0,
    CC_CDECL = 1,
    CC_MSCPASCAL = 2,
    CC_MACPASCAL = 3,
    CC_STDCALL = 4,
    CC_FPFASTCALL = 5,
    CC_SYSCALL = 6,
    CC_MPWCDECL = 7,
    CC_MPWPASCAL = 8,
    CC_MAX = 9,
}
pub use self::tagCALLCONV as CALLCONV;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagFUNCKIND {
    FUNC_VIRTUAL = 0,
    FUNC_PUREVIRTUAL = 1,
    FUNC_NONVIRTUAL = 2,
    FUNC_STATIC = 3,
    FUNC_DISPATCH = 4,
}
pub use self::tagFUNCKIND as FUNCKIND;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagINVOKEKIND {
    INVOKE_FUNC = 1,
    INVOKE_PROPERTYGET = 2,
    INVOKE_PROPERTYPUT = 4,
    INVOKE_PROPERTYPUTREF = 8,
}
pub use self::tagINVOKEKIND as INVOKEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagFUNCDESC {
    pub memid: MEMBERID,
    pub lprgscode: *mut SCODE,
    pub lprgelemdescParam: *mut ELEMDESC,
    pub funckind: FUNCKIND,
    pub invkind: INVOKEKIND,
    pub callconv: CALLCONV,
    pub cParams: SHORT,
    pub cParamsOpt: SHORT,
    pub oVft: SHORT,
    pub cScodes: SHORT,
    pub elemdescFunc: ELEMDESC,
    pub wFuncFlags: WORD,
}
pub type FUNCDESC = tagFUNCDESC;
pub type LPFUNCDESC = *mut tagFUNCDESC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagVARKIND {
    VAR_PERINSTANCE = 0,
    VAR_STATIC = 1,
    VAR_CONST = 2,
    VAR_DISPATCH = 3,
}
pub use self::tagVARKIND as VARKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARDESC {
    pub memid: MEMBERID,
    pub lpstrSchema: LPOLESTR,
    pub __bindgen_anon_1: tagVARDESC__bindgen_ty_1,
    pub elemdescVar: ELEMDESC,
    pub wVarFlags: WORD,
    pub varkind: VARKIND,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARDESC__bindgen_ty_1 {
    pub oInst: ULONG,
    pub lpvarValue: *mut VARIANT,
}
pub type VARDESC = tagVARDESC;
pub type LPVARDESC = *mut tagVARDESC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagTYPEFLAGS {
    TYPEFLAG_FAPPOBJECT = 1,
    TYPEFLAG_FCANCREATE = 2,
    TYPEFLAG_FLICENSED = 4,
    TYPEFLAG_FPREDECLID = 8,
    TYPEFLAG_FHIDDEN = 16,
    TYPEFLAG_FCONTROL = 32,
    TYPEFLAG_FDUAL = 64,
    TYPEFLAG_FNONEXTENSIBLE = 128,
    TYPEFLAG_FOLEAUTOMATION = 256,
    TYPEFLAG_FRESTRICTED = 512,
    TYPEFLAG_FAGGREGATABLE = 1024,
    TYPEFLAG_FREPLACEABLE = 2048,
    TYPEFLAG_FDISPATCHABLE = 4096,
    TYPEFLAG_FREVERSEBIND = 8192,
    TYPEFLAG_FPROXY = 16384,
}
pub use self::tagTYPEFLAGS as TYPEFLAGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagFUNCFLAGS {
    FUNCFLAG_FRESTRICTED = 1,
    FUNCFLAG_FSOURCE = 2,
    FUNCFLAG_FBINDABLE = 4,
    FUNCFLAG_FREQUESTEDIT = 8,
    FUNCFLAG_FDISPLAYBIND = 16,
    FUNCFLAG_FDEFAULTBIND = 32,
    FUNCFLAG_FHIDDEN = 64,
    FUNCFLAG_FUSESGETLASTERROR = 128,
    FUNCFLAG_FDEFAULTCOLLELEM = 256,
    FUNCFLAG_FUIDEFAULT = 512,
    FUNCFLAG_FNONBROWSABLE = 1024,
    FUNCFLAG_FREPLACEABLE = 2048,
    FUNCFLAG_FIMMEDIATEBIND = 4096,
}
pub use self::tagFUNCFLAGS as FUNCFLAGS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagVARFLAGS {
    VARFLAG_FREADONLY = 1,
    VARFLAG_FSOURCE = 2,
    VARFLAG_FBINDABLE = 4,
    VARFLAG_FREQUESTEDIT = 8,
    VARFLAG_FDISPLAYBIND = 16,
    VARFLAG_FDEFAULTBIND = 32,
    VARFLAG_FHIDDEN = 64,
    VARFLAG_FRESTRICTED = 128,
    VARFLAG_FDEFAULTCOLLELEM = 256,
    VARFLAG_FUIDEFAULT = 512,
    VARFLAG_FNONBROWSABLE = 1024,
    VARFLAG_FREPLACEABLE = 2048,
    VARFLAG_FIMMEDIATEBIND = 4096,
}
pub use self::tagVARFLAGS as VARFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCLEANLOCALSTORAGE {
    pub pInterface: *mut IUnknown,
    pub pStorage: PVOID,
    pub flags: DWORD,
}
pub type CLEANLOCALSTORAGE = tagCLEANLOCALSTORAGE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagCUSTDATAITEM {
    pub guid: GUID,
    pub varValue: VARIANTARG,
}
pub type CUSTDATAITEM = tagCUSTDATAITEM;
pub type LPCUSTDATAITEM = *mut tagCUSTDATAITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCUSTDATA {
    pub cCustData: DWORD,
    pub prgCustData: LPCUSTDATAITEM,
}
pub type CUSTDATA = tagCUSTDATA;
pub type LPCUSTDATA = *mut tagCUSTDATA;
extern "C" {
    pub static mut IOleAutomationTypes_v1_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut IOleAutomationTypes_v1_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPCREATETYPEINFO = *mut ICreateTypeInfo;
extern "C" {
    pub static IID_ICreateTypeInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICreateTypeInfo {
    pub _base: IUnknown,
}
pub type LPCREATETYPEINFO2 = *mut ICreateTypeInfo2;
extern "C" {
    pub static IID_ICreateTypeInfo2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICreateTypeInfo2 {
    pub _base: ICreateTypeInfo,
}
pub type LPCREATETYPELIB = *mut ICreateTypeLib;
extern "C" {
    pub static IID_ICreateTypeLib: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICreateTypeLib {
    pub _base: IUnknown,
}
pub type LPCREATETYPELIB2 = *mut ICreateTypeLib2;
extern "C" {
    pub static IID_ICreateTypeLib2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICreateTypeLib2 {
    pub _base: ICreateTypeLib,
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0005_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0005_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPDISPATCH = *mut IDispatch;
extern "C" {
    pub static IID_IDispatch: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDispatch {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IDispatch_RemoteInvoke_Proxy(
        This: *mut IDispatch,
        dispIdMember: DISPID,
        riid: *const IID,
        lcid: LCID,
        dwFlags: DWORD,
        pDispParams: *mut DISPPARAMS,
        pVarResult: *mut VARIANT,
        pExcepInfo: *mut EXCEPINFO,
        pArgErr: *mut UINT,
        cVarRef: UINT,
        rgVarRefIdx: *mut UINT,
        rgVarRef: *mut VARIANTARG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDispatch_RemoteInvoke_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPENUMVARIANT = *mut IEnumVARIANT;
extern "C" {
    pub static IID_IEnumVARIANT: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumVARIANT {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumVARIANT_RemoteNext_Proxy(
        This: *mut IEnumVARIANT,
        celt: ULONG,
        rgVar: *mut VARIANT,
        pCeltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumVARIANT_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPTYPECOMP = *mut ITypeComp;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagDESCKIND {
    DESCKIND_NONE = 0,
    DESCKIND_FUNCDESC = 1,
    DESCKIND_VARDESC = 2,
    DESCKIND_TYPECOMP = 3,
    DESCKIND_IMPLICITAPPOBJ = 4,
    DESCKIND_MAX = 5,
}
pub use self::tagDESCKIND as DESCKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagBINDPTR {
    pub lpfuncdesc: *mut FUNCDESC,
    pub lpvardesc: *mut VARDESC,
    pub lptcomp: *mut ITypeComp,
}
pub type BINDPTR = tagBINDPTR;
pub type LPBINDPTR = *mut tagBINDPTR;
extern "C" {
    pub static IID_ITypeComp: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeComp {
    pub _base: IUnknown,
}
extern "C" {
    pub fn ITypeComp_RemoteBind_Proxy(
        This: *mut ITypeComp,
        szName: LPOLESTR,
        lHashVal: ULONG,
        wFlags: WORD,
        ppTInfo: *mut *mut ITypeInfo,
        pDescKind: *mut DESCKIND,
        ppFuncDesc: *mut LPFUNCDESC,
        ppVarDesc: *mut LPVARDESC,
        ppTypeComp: *mut *mut ITypeComp,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeComp_RemoteBind_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeComp_RemoteBindType_Proxy(
        This: *mut ITypeComp,
        szName: LPOLESTR,
        lHashVal: ULONG,
        ppTInfo: *mut *mut ITypeInfo,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeComp_RemoteBindType_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0008_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0008_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPTYPEINFO = *mut ITypeInfo;
extern "C" {
    pub static IID_ITypeInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub fn ITypeInfo_RemoteGetTypeAttr_Proxy(
        This: *mut ITypeInfo,
        ppTypeAttr: *mut LPTYPEATTR,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetTypeAttr_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteGetFuncDesc_Proxy(
        This: *mut ITypeInfo,
        index: UINT,
        ppFuncDesc: *mut LPFUNCDESC,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetFuncDesc_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteGetVarDesc_Proxy(
        This: *mut ITypeInfo,
        index: UINT,
        ppVarDesc: *mut LPVARDESC,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetVarDesc_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteGetNames_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        rgBstrNames: *mut BSTR,
        cMaxNames: UINT,
        pcNames: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetNames_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_LocalGetIDsOfNames_Proxy(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_LocalGetIDsOfNames_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_LocalInvoke_Proxy(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_LocalInvoke_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteGetDocumentation_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        refPtrFlags: DWORD,
        pBstrName: *mut BSTR,
        pBstrDocString: *mut BSTR,
        pdwHelpContext: *mut DWORD,
        pBstrHelpFile: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetDocumentation_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteGetDllEntry_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        invKind: INVOKEKIND,
        refPtrFlags: DWORD,
        pBstrDllName: *mut BSTR,
        pBstrName: *mut BSTR,
        pwOrdinal: *mut WORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetDllEntry_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_LocalAddressOfMember_Proxy(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_LocalAddressOfMember_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteCreateInstance_Proxy(
        This: *mut ITypeInfo,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteCreateInstance_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_RemoteGetContainingTypeLib_Proxy(
        This: *mut ITypeInfo,
        ppTLib: *mut *mut ITypeLib,
        pIndex: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_RemoteGetContainingTypeLib_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_LocalReleaseTypeAttr_Proxy(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_LocalReleaseTypeAttr_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_LocalReleaseFuncDesc_Proxy(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_LocalReleaseFuncDesc_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeInfo_LocalReleaseVarDesc_Proxy(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_LocalReleaseVarDesc_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPTYPEINFO2 = *mut ITypeInfo2;
extern "C" {
    pub static IID_ITypeInfo2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeInfo2 {
    pub _base: ITypeInfo,
}
extern "C" {
    pub fn ITypeInfo2_RemoteGetDocumentation2_Proxy(
        This: *mut ITypeInfo2,
        memid: MEMBERID,
        lcid: LCID,
        refPtrFlags: DWORD,
        pbstrHelpString: *mut BSTR,
        pdwHelpStringContext: *mut DWORD,
        pbstrHelpStringDll: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo2_RemoteGetDocumentation2_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0010_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0010_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagSYSKIND {
    SYS_WIN16 = 0,
    SYS_WIN32 = 1,
    SYS_MAC = 2,
    SYS_WIN64 = 3,
}
pub use self::tagSYSKIND as SYSKIND;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagLIBFLAGS {
    LIBFLAG_FRESTRICTED = 1,
    LIBFLAG_FCONTROL = 2,
    LIBFLAG_FHIDDEN = 4,
    LIBFLAG_FHASDISKIMAGE = 8,
}
pub use self::tagLIBFLAGS as LIBFLAGS;
pub type LPTYPELIB = *mut ITypeLib;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTLIBATTR {
    pub guid: GUID,
    pub lcid: LCID,
    pub syskind: SYSKIND,
    pub wMajorVerNum: WORD,
    pub wMinorVerNum: WORD,
    pub wLibFlags: WORD,
}
pub type TLIBATTR = tagTLIBATTR;
pub type LPTLIBATTR = *mut tagTLIBATTR;
extern "C" {
    pub static IID_ITypeLib: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLib {
    pub _base: IUnknown,
}
extern "C" {
    pub fn ITypeLib_RemoteGetTypeInfoCount_Proxy(
        This: *mut ITypeLib,
        pcTInfo: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_RemoteGetTypeInfoCount_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeLib_RemoteGetLibAttr_Proxy(
        This: *mut ITypeLib,
        ppTLibAttr: *mut LPTLIBATTR,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_RemoteGetLibAttr_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeLib_RemoteGetDocumentation_Proxy(
        This: *mut ITypeLib,
        index: INT,
        refPtrFlags: DWORD,
        pBstrName: *mut BSTR,
        pBstrDocString: *mut BSTR,
        pdwHelpContext: *mut DWORD,
        pBstrHelpFile: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_RemoteGetDocumentation_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeLib_RemoteIsName_Proxy(
        This: *mut ITypeLib,
        szNameBuf: LPOLESTR,
        lHashVal: ULONG,
        pfName: *mut BOOL,
        pBstrLibName: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_RemoteIsName_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeLib_RemoteFindName_Proxy(
        This: *mut ITypeLib,
        szNameBuf: LPOLESTR,
        lHashVal: ULONG,
        ppTInfo: *mut *mut ITypeInfo,
        rgMemId: *mut MEMBERID,
        pcFound: *mut USHORT,
        pBstrLibName: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_RemoteFindName_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeLib_LocalReleaseTLibAttr_Proxy(This: *mut ITypeLib) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_LocalReleaseTLibAttr_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0011_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0011_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPTYPELIB2 = *mut ITypeLib2;
extern "C" {
    pub static IID_ITypeLib2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLib2 {
    pub _base: ITypeLib,
}
extern "C" {
    pub fn ITypeLib2_RemoteGetLibStatistics_Proxy(
        This: *mut ITypeLib2,
        pcUniqueNames: *mut ULONG,
        pcchUniqueNames: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib2_RemoteGetLibStatistics_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn ITypeLib2_RemoteGetDocumentation2_Proxy(
        This: *mut ITypeLib2,
        index: INT,
        lcid: LCID,
        refPtrFlags: DWORD,
        pbstrHelpString: *mut BSTR,
        pdwHelpStringContext: *mut DWORD,
        pbstrHelpStringDll: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib2_RemoteGetDocumentation2_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPTYPECHANGEEVENTS = *mut ITypeChangeEvents;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCHANGEKIND {
    CHANGEKIND_ADDMEMBER = 0,
    CHANGEKIND_DELETEMEMBER = 1,
    CHANGEKIND_SETNAMES = 2,
    CHANGEKIND_SETDOCUMENTATION = 3,
    CHANGEKIND_GENERAL = 4,
    CHANGEKIND_INVALIDATE = 5,
    CHANGEKIND_CHANGEFAILED = 6,
    CHANGEKIND_MAX = 7,
}
pub use self::tagCHANGEKIND as CHANGEKIND;
extern "C" {
    pub static IID_ITypeChangeEvents: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeChangeEvents {
    pub _base: IUnknown,
}
pub type LPERRORINFO = *mut IErrorInfo;
extern "C" {
    pub static IID_IErrorInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IErrorInfo {
    pub _base: IUnknown,
}
pub type LPCREATEERRORINFO = *mut ICreateErrorInfo;
extern "C" {
    pub static IID_ICreateErrorInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICreateErrorInfo {
    pub _base: IUnknown,
}
pub type LPSUPPORTERRORINFO = *mut ISupportErrorInfo;
extern "C" {
    pub static IID_ISupportErrorInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISupportErrorInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ITypeFactory: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeFactory {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ITypeMarshal: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeMarshal {
    pub _base: IUnknown,
}
pub type LPRECORDINFO = *mut IRecordInfo;
extern "C" {
    pub static IID_IRecordInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRecordInfo {
    pub _base: IUnknown,
}
pub type LPERRORLOG = *mut IErrorLog;
extern "C" {
    pub static IID_IErrorLog: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IErrorLog {
    pub _base: IUnknown,
}
pub type LPPROPERTYBAG = *mut IPropertyBag;
extern "C" {
    pub static IID_IPropertyBag: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPropertyBag {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IPropertyBag_RemoteRead_Proxy(
        This: *mut IPropertyBag,
        pszPropName: LPCOLESTR,
        pVar: *mut VARIANT,
        pErrorLog: *mut IErrorLog,
        varType: DWORD,
        pUnkObj: *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IPropertyBag_RemoteRead_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static IID_ITypeLibRegistrationReader: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLibRegistrationReader {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_ITypeLibRegistration: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLibRegistration {
    pub _base: IUnknown,
}
extern "C" {
    pub static CLSID_TypeLibRegistrationReader: CLSID;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0023_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oaidl_0000_0023_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn BSTR_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut BSTR,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BSTR_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut BSTR,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn BSTR_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut BSTR,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn BSTR_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut BSTR);
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut CLEANLOCALSTORAGE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLEANLOCALSTORAGE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLEANLOCALSTORAGE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserFree(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut CLEANLOCALSTORAGE,
    );
}
extern "C" {
    pub fn VARIANT_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut VARIANT,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn VARIANT_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut VARIANT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn VARIANT_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut VARIANT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn VARIANT_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut VARIANT);
}
extern "C" {
    pub fn BSTR_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut BSTR,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BSTR_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut BSTR,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn BSTR_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut BSTR,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn BSTR_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut BSTR);
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut CLEANLOCALSTORAGE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLEANLOCALSTORAGE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut CLEANLOCALSTORAGE,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn CLEANLOCALSTORAGE_UserFree64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut CLEANLOCALSTORAGE,
    );
}
extern "C" {
    pub fn VARIANT_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut VARIANT,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn VARIANT_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut VARIANT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn VARIANT_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut VARIANT,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn VARIANT_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut VARIANT);
}
extern "C" {
    pub fn IDispatch_Invoke_Proxy(
        This: *mut IDispatch,
        dispIdMember: DISPID,
        riid: *const IID,
        lcid: LCID,
        wFlags: WORD,
        pDispParams: *mut DISPPARAMS,
        pVarResult: *mut VARIANT,
        pExcepInfo: *mut EXCEPINFO,
        puArgErr: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn IDispatch_Invoke_Stub(
        This: *mut IDispatch,
        dispIdMember: DISPID,
        riid: *const IID,
        lcid: LCID,
        dwFlags: DWORD,
        pDispParams: *mut DISPPARAMS,
        pVarResult: *mut VARIANT,
        pExcepInfo: *mut EXCEPINFO,
        pArgErr: *mut UINT,
        cVarRef: UINT,
        rgVarRefIdx: *mut UINT,
        rgVarRef: *mut VARIANTARG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumVARIANT_Next_Proxy(
        This: *mut IEnumVARIANT,
        celt: ULONG,
        rgVar: *mut VARIANT,
        pCeltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumVARIANT_Next_Stub(
        This: *mut IEnumVARIANT,
        celt: ULONG,
        rgVar: *mut VARIANT,
        pCeltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeComp_Bind_Proxy(
        This: *mut ITypeComp,
        szName: LPOLESTR,
        lHashVal: ULONG,
        wFlags: WORD,
        ppTInfo: *mut *mut ITypeInfo,
        pDescKind: *mut DESCKIND,
        pBindPtr: *mut BINDPTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeComp_Bind_Stub(
        This: *mut ITypeComp,
        szName: LPOLESTR,
        lHashVal: ULONG,
        wFlags: WORD,
        ppTInfo: *mut *mut ITypeInfo,
        pDescKind: *mut DESCKIND,
        ppFuncDesc: *mut LPFUNCDESC,
        ppVarDesc: *mut LPVARDESC,
        ppTypeComp: *mut *mut ITypeComp,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeComp_BindType_Proxy(
        This: *mut ITypeComp,
        szName: LPOLESTR,
        lHashVal: ULONG,
        ppTInfo: *mut *mut ITypeInfo,
        ppTComp: *mut *mut ITypeComp,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeComp_BindType_Stub(
        This: *mut ITypeComp,
        szName: LPOLESTR,
        lHashVal: ULONG,
        ppTInfo: *mut *mut ITypeInfo,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetTypeAttr_Proxy(
        This: *mut ITypeInfo,
        ppTypeAttr: *mut *mut TYPEATTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetTypeAttr_Stub(
        This: *mut ITypeInfo,
        ppTypeAttr: *mut LPTYPEATTR,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetFuncDesc_Proxy(
        This: *mut ITypeInfo,
        index: UINT,
        ppFuncDesc: *mut *mut FUNCDESC,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetFuncDesc_Stub(
        This: *mut ITypeInfo,
        index: UINT,
        ppFuncDesc: *mut LPFUNCDESC,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetVarDesc_Proxy(
        This: *mut ITypeInfo,
        index: UINT,
        ppVarDesc: *mut *mut VARDESC,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetVarDesc_Stub(
        This: *mut ITypeInfo,
        index: UINT,
        ppVarDesc: *mut LPVARDESC,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetNames_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        rgBstrNames: *mut BSTR,
        cMaxNames: UINT,
        pcNames: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetNames_Stub(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        rgBstrNames: *mut BSTR,
        cMaxNames: UINT,
        pcNames: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetIDsOfNames_Proxy(
        This: *mut ITypeInfo,
        rgszNames: *mut LPOLESTR,
        cNames: UINT,
        pMemId: *mut MEMBERID,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetIDsOfNames_Stub(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_Invoke_Proxy(
        This: *mut ITypeInfo,
        pvInstance: PVOID,
        memid: MEMBERID,
        wFlags: WORD,
        pDispParams: *mut DISPPARAMS,
        pVarResult: *mut VARIANT,
        pExcepInfo: *mut EXCEPINFO,
        puArgErr: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_Invoke_Stub(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetDocumentation_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        pBstrName: *mut BSTR,
        pBstrDocString: *mut BSTR,
        pdwHelpContext: *mut DWORD,
        pBstrHelpFile: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetDocumentation_Stub(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        refPtrFlags: DWORD,
        pBstrName: *mut BSTR,
        pBstrDocString: *mut BSTR,
        pdwHelpContext: *mut DWORD,
        pBstrHelpFile: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetDllEntry_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        invKind: INVOKEKIND,
        pBstrDllName: *mut BSTR,
        pBstrName: *mut BSTR,
        pwOrdinal: *mut WORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetDllEntry_Stub(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        invKind: INVOKEKIND,
        refPtrFlags: DWORD,
        pBstrDllName: *mut BSTR,
        pBstrName: *mut BSTR,
        pwOrdinal: *mut WORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_AddressOfMember_Proxy(
        This: *mut ITypeInfo,
        memid: MEMBERID,
        invKind: INVOKEKIND,
        ppv: *mut PVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_AddressOfMember_Stub(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_CreateInstance_Proxy(
        This: *mut ITypeInfo,
        pUnkOuter: *mut IUnknown,
        riid: *const IID,
        ppvObj: *mut PVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_CreateInstance_Stub(
        This: *mut ITypeInfo,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetContainingTypeLib_Proxy(
        This: *mut ITypeInfo,
        ppTLib: *mut *mut ITypeLib,
        pIndex: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_GetContainingTypeLib_Stub(
        This: *mut ITypeInfo,
        ppTLib: *mut *mut ITypeLib,
        pIndex: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_ReleaseTypeAttr_Proxy(This: *mut ITypeInfo, pTypeAttr: *mut TYPEATTR);
}
extern "C" {
    pub fn ITypeInfo_ReleaseTypeAttr_Stub(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_ReleaseFuncDesc_Proxy(This: *mut ITypeInfo, pFuncDesc: *mut FUNCDESC);
}
extern "C" {
    pub fn ITypeInfo_ReleaseFuncDesc_Stub(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo_ReleaseVarDesc_Proxy(This: *mut ITypeInfo, pVarDesc: *mut VARDESC);
}
extern "C" {
    pub fn ITypeInfo_ReleaseVarDesc_Stub(This: *mut ITypeInfo) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo2_GetDocumentation2_Proxy(
        This: *mut ITypeInfo2,
        memid: MEMBERID,
        lcid: LCID,
        pbstrHelpString: *mut BSTR,
        pdwHelpStringContext: *mut DWORD,
        pbstrHelpStringDll: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeInfo2_GetDocumentation2_Stub(
        This: *mut ITypeInfo2,
        memid: MEMBERID,
        lcid: LCID,
        refPtrFlags: DWORD,
        pbstrHelpString: *mut BSTR,
        pdwHelpStringContext: *mut DWORD,
        pbstrHelpStringDll: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_GetTypeInfoCount_Proxy(This: *mut ITypeLib) -> UINT;
}
extern "C" {
    pub fn ITypeLib_GetTypeInfoCount_Stub(This: *mut ITypeLib, pcTInfo: *mut UINT) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_GetLibAttr_Proxy(
        This: *mut ITypeLib,
        ppTLibAttr: *mut *mut TLIBATTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_GetLibAttr_Stub(
        This: *mut ITypeLib,
        ppTLibAttr: *mut LPTLIBATTR,
        pDummy: *mut CLEANLOCALSTORAGE,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_GetDocumentation_Proxy(
        This: *mut ITypeLib,
        index: INT,
        pBstrName: *mut BSTR,
        pBstrDocString: *mut BSTR,
        pdwHelpContext: *mut DWORD,
        pBstrHelpFile: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_GetDocumentation_Stub(
        This: *mut ITypeLib,
        index: INT,
        refPtrFlags: DWORD,
        pBstrName: *mut BSTR,
        pBstrDocString: *mut BSTR,
        pdwHelpContext: *mut DWORD,
        pBstrHelpFile: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_IsName_Proxy(
        This: *mut ITypeLib,
        szNameBuf: LPOLESTR,
        lHashVal: ULONG,
        pfName: *mut BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_IsName_Stub(
        This: *mut ITypeLib,
        szNameBuf: LPOLESTR,
        lHashVal: ULONG,
        pfName: *mut BOOL,
        pBstrLibName: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_FindName_Proxy(
        This: *mut ITypeLib,
        szNameBuf: LPOLESTR,
        lHashVal: ULONG,
        ppTInfo: *mut *mut ITypeInfo,
        rgMemId: *mut MEMBERID,
        pcFound: *mut USHORT,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_FindName_Stub(
        This: *mut ITypeLib,
        szNameBuf: LPOLESTR,
        lHashVal: ULONG,
        ppTInfo: *mut *mut ITypeInfo,
        rgMemId: *mut MEMBERID,
        pcFound: *mut USHORT,
        pBstrLibName: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib_ReleaseTLibAttr_Proxy(This: *mut ITypeLib, pTLibAttr: *mut TLIBATTR);
}
extern "C" {
    pub fn ITypeLib_ReleaseTLibAttr_Stub(This: *mut ITypeLib) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib2_GetLibStatistics_Proxy(
        This: *mut ITypeLib2,
        pcUniqueNames: *mut ULONG,
        pcchUniqueNames: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib2_GetLibStatistics_Stub(
        This: *mut ITypeLib2,
        pcUniqueNames: *mut ULONG,
        pcchUniqueNames: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib2_GetDocumentation2_Proxy(
        This: *mut ITypeLib2,
        index: INT,
        lcid: LCID,
        pbstrHelpString: *mut BSTR,
        pdwHelpStringContext: *mut DWORD,
        pbstrHelpStringDll: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn ITypeLib2_GetDocumentation2_Stub(
        This: *mut ITypeLib2,
        index: INT,
        lcid: LCID,
        refPtrFlags: DWORD,
        pbstrHelpString: *mut BSTR,
        pdwHelpStringContext: *mut DWORD,
        pbstrHelpStringDll: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn IPropertyBag_Read_Proxy(
        This: *mut IPropertyBag,
        pszPropName: LPCOLESTR,
        pVar: *mut VARIANT,
        pErrorLog: *mut IErrorLog,
    ) -> HRESULT;
}
extern "C" {
    pub fn IPropertyBag_Read_Stub(
        This: *mut IPropertyBag,
        pszPropName: LPCOLESTR,
        pVar: *mut VARIANT,
        pErrorLog: *mut IErrorLog,
        varType: DWORD,
        pUnkObj: *mut IUnknown,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVersionedStream {
    pub guidVersion: GUID,
    pub pStream: *mut IStream,
}
pub type VERSIONEDSTREAM = tagVersionedStream;
pub type LPVERSIONEDSTREAM = *mut tagVersionedStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAC {
    pub cElems: ULONG,
    pub pElems: *mut CHAR,
}
pub type CAC = tagCAC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUB {
    pub cElems: ULONG,
    pub pElems: *mut UCHAR,
}
pub type CAUB = tagCAUB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAI {
    pub cElems: ULONG,
    pub pElems: *mut SHORT,
}
pub type CAI = tagCAI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUI {
    pub cElems: ULONG,
    pub pElems: *mut USHORT,
}
pub type CAUI = tagCAUI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAL {
    pub cElems: ULONG,
    pub pElems: *mut LONG,
}
pub type CAL = tagCAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUL {
    pub cElems: ULONG,
    pub pElems: *mut ULONG,
}
pub type CAUL = tagCAUL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAFLT {
    pub cElems: ULONG,
    pub pElems: *mut FLOAT,
}
pub type CAFLT = tagCAFLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCADBL {
    pub cElems: ULONG,
    pub pElems: *mut DOUBLE,
}
pub type CADBL = tagCADBL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACY {
    pub cElems: ULONG,
    pub pElems: *mut CY,
}
pub type CACY = tagCACY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCADATE {
    pub cElems: ULONG,
    pub pElems: *mut DATE,
}
pub type CADATE = tagCADATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABSTR {
    pub cElems: ULONG,
    pub pElems: *mut BSTR,
}
pub type CABSTR = tagCABSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABSTRBLOB {
    pub cElems: ULONG,
    pub pElems: *mut BSTRBLOB,
}
pub type CABSTRBLOB = tagCABSTRBLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABOOL {
    pub cElems: ULONG,
    pub pElems: *mut VARIANT_BOOL,
}
pub type CABOOL = tagCABOOL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCASCODE {
    pub cElems: ULONG,
    pub pElems: *mut SCODE,
}
pub type CASCODE = tagCASCODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAPROPVARIANT {
    pub cElems: ULONG,
    pub pElems: *mut PROPVARIANT,
}
pub type CAPROPVARIANT = tagCAPROPVARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAH {
    pub cElems: ULONG,
    pub pElems: *mut LARGE_INTEGER,
}
pub type CAH = tagCAH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUH {
    pub cElems: ULONG,
    pub pElems: *mut ULARGE_INTEGER,
}
pub type CAUH = tagCAUH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCALPSTR {
    pub cElems: ULONG,
    pub pElems: *mut LPSTR,
}
pub type CALPSTR = tagCALPSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCALPWSTR {
    pub cElems: ULONG,
    pub pElems: *mut LPWSTR,
}
pub type CALPWSTR = tagCALPWSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAFILETIME {
    pub cElems: ULONG,
    pub pElems: *mut FILETIME,
}
pub type CAFILETIME = tagCAFILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACLIPDATA {
    pub cElems: ULONG,
    pub pElems: *mut CLIPDATA,
}
pub type CACLIPDATA = tagCACLIPDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACLSID {
    pub cElems: ULONG,
    pub pElems: *mut CLSID,
}
pub type CACLSID = tagCACLSID;
pub type PROPVAR_PAD1 = WORD;
pub type PROPVAR_PAD2 = WORD;
pub type PROPVAR_PAD3 = WORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPVARIANT {
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPVARIANT__bindgen_ty_1 {
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1,
    pub decVal: DECIMAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1 {
    pub vt: VARTYPE,
    pub wReserved1: PROPVAR_PAD1,
    pub wReserved2: PROPVAR_PAD2,
    pub wReserved3: PROPVAR_PAD3,
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub cVal: CHAR,
    pub bVal: UCHAR,
    pub iVal: SHORT,
    pub uiVal: USHORT,
    pub lVal: LONG,
    pub ulVal: ULONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub hVal: LARGE_INTEGER,
    pub uhVal: ULARGE_INTEGER,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub filetime: FILETIME,
    pub puuid: *mut CLSID,
    pub pclipdata: *mut CLIPDATA,
    pub bstrVal: BSTR,
    pub bstrblobVal: BSTRBLOB,
    pub blob: BLOB,
    pub pszVal: LPSTR,
    pub pwszVal: LPWSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub pStream: *mut IStream,
    pub pStorage: *mut IStorage,
    pub pVersionedStream: LPVERSIONEDSTREAM,
    pub parray: LPSAFEARRAY,
    pub cac: CAC,
    pub caub: CAUB,
    pub cai: CAI,
    pub caui: CAUI,
    pub cal: CAL,
    pub caul: CAUL,
    pub cah: CAH,
    pub cauh: CAUH,
    pub caflt: CAFLT,
    pub cadbl: CADBL,
    pub cabool: CABOOL,
    pub cascode: CASCODE,
    pub cacy: CACY,
    pub cadate: CADATE,
    pub cafiletime: CAFILETIME,
    pub cauuid: CACLSID,
    pub caclipdata: CACLIPDATA,
    pub cabstr: CABSTR,
    pub cabstrblob: CABSTRBLOB,
    pub calpstr: CALPSTR,
    pub calpwstr: CALPWSTR,
    pub capropvar: CAPROPVARIANT,
    pub pcVal: *mut CHAR,
    pub pbVal: *mut UCHAR,
    pub piVal: *mut SHORT,
    pub puiVal: *mut USHORT,
    pub plVal: *mut LONG,
    pub pulVal: *mut ULONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub pdecVal: *mut DECIMAL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut BSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut LPSAFEARRAY,
    pub pvarVal: *mut PROPVARIANT,
}
pub type LPPROPVARIANT = *mut tagPROPVARIANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPSPEC {
    pub ulKind: ULONG,
    pub __bindgen_anon_1: tagPROPSPEC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPSPEC__bindgen_ty_1 {
    pub propid: PROPID,
    pub lpwstr: LPOLESTR,
}
pub type PROPSPEC = tagPROPSPEC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATPROPSTG {
    pub lpwstrName: LPOLESTR,
    pub propid: PROPID,
    pub vt: VARTYPE,
}
pub type STATPROPSTG = tagSTATPROPSTG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATPROPSETSTG {
    pub fmtid: FMTID,
    pub clsid: CLSID,
    pub grfFlags: DWORD,
    pub mtime: FILETIME,
    pub ctime: FILETIME,
    pub atime: FILETIME,
    pub dwOSVersion: DWORD,
}
pub type STATPROPSETSTG = tagSTATPROPSETSTG;
extern "C" {
    pub static mut __MIDL_itf_propidlbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_propidlbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IPropertyStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPropertyStorage {
    pub _base: IUnknown,
}
pub type LPPROPERTYSETSTORAGE = *mut IPropertySetStorage;
extern "C" {
    pub static IID_IPropertySetStorage: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPropertySetStorage {
    pub _base: IUnknown,
}
pub type LPENUMSTATPROPSTG = *mut IEnumSTATPROPSTG;
extern "C" {
    pub static IID_IEnumSTATPROPSTG: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATPROPSTG {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumSTATPROPSTG_RemoteNext_Proxy(
        This: *mut IEnumSTATPROPSTG,
        celt: ULONG,
        rgelt: *mut STATPROPSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATPROPSTG_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPENUMSTATPROPSETSTG = *mut IEnumSTATPROPSETSTG;
extern "C" {
    pub static IID_IEnumSTATPROPSETSTG: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATPROPSETSTG {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumSTATPROPSETSTG_RemoteNext_Proxy(
        This: *mut IEnumSTATPROPSETSTG,
        celt: ULONG,
        rgelt: *mut STATPROPSETSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATPROPSETSTG_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPPROPERTYSTORAGE = *mut IPropertyStorage;
extern "C" {
    pub static mut __MIDL_itf_propidlbase_0000_0004_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_propidlbase_0000_0004_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn LPSAFEARRAY_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut LPSAFEARRAY,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn LPSAFEARRAY_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut LPSAFEARRAY,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn LPSAFEARRAY_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut LPSAFEARRAY,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn LPSAFEARRAY_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut LPSAFEARRAY);
}
extern "C" {
    pub fn LPSAFEARRAY_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut LPSAFEARRAY,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn LPSAFEARRAY_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut LPSAFEARRAY,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn LPSAFEARRAY_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut LPSAFEARRAY,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn LPSAFEARRAY_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut LPSAFEARRAY);
}
extern "C" {
    pub fn IEnumSTATPROPSTG_Next_Proxy(
        This: *mut IEnumSTATPROPSTG,
        celt: ULONG,
        rgelt: *mut STATPROPSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATPROPSTG_Next_Stub(
        This: *mut IEnumSTATPROPSTG,
        celt: ULONG,
        rgelt: *mut STATPROPSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATPROPSETSTG_Next_Proxy(
        This: *mut IEnumSTATPROPSETSTG,
        celt: ULONG,
        rgelt: *mut STATPROPSETSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumSTATPROPSETSTG_Next_Stub(
        This: *mut IEnumSTATPROPSETSTG,
        celt: ULONG,
        rgelt: *mut STATPROPSETSTG,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
pub type STGFMT = DWORD;
extern "C" {
    pub fn StgCreateDocfile(
        pwcsName: *const WCHAR,
        grfMode: DWORD,
        reserved: DWORD,
        ppstgOpen: *mut *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgCreateDocfileOnILockBytes(
        plkbyt: *mut ILockBytes,
        grfMode: DWORD,
        reserved: DWORD,
        ppstgOpen: *mut *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgOpenStorage(
        pwcsName: *const WCHAR,
        pstgPriority: *mut IStorage,
        grfMode: DWORD,
        snbExclude: SNB,
        reserved: DWORD,
        ppstgOpen: *mut *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgOpenStorageOnILockBytes(
        plkbyt: *mut ILockBytes,
        pstgPriority: *mut IStorage,
        grfMode: DWORD,
        snbExclude: SNB,
        reserved: DWORD,
        ppstgOpen: *mut *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgIsStorageFile(pwcsName: *const WCHAR) -> HRESULT;
}
extern "C" {
    pub fn StgIsStorageILockBytes(plkbyt: *mut ILockBytes) -> HRESULT;
}
extern "C" {
    pub fn StgSetTimes(
        lpszName: *const WCHAR,
        pctime: *const FILETIME,
        patime: *const FILETIME,
        pmtime: *const FILETIME,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTGOPTIONS {
    pub usVersion: USHORT,
    pub reserved: USHORT,
    pub ulSectorSize: ULONG,
    pub pwcsTemplateFile: *const WCHAR,
}
pub type STGOPTIONS = tagSTGOPTIONS;
extern "C" {
    pub fn StgCreateStorageEx(
        pwcsName: *const WCHAR,
        grfMode: DWORD,
        stgfmt: DWORD,
        grfAttrs: DWORD,
        pStgOptions: *mut STGOPTIONS,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        riid: *const IID,
        ppObjectOpen: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgOpenStorageEx(
        pwcsName: *const WCHAR,
        grfMode: DWORD,
        stgfmt: DWORD,
        grfAttrs: DWORD,
        pStgOptions: *mut STGOPTIONS,
        pSecurityDescriptor: PSECURITY_DESCRIPTOR,
        riid: *const IID,
        ppObjectOpen: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgCreatePropStg(
        pUnk: *mut IUnknown,
        fmtid: *const IID,
        pclsid: *const CLSID,
        grfFlags: DWORD,
        dwReserved: DWORD,
        ppPropStg: *mut *mut IPropertyStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgOpenPropStg(
        pUnk: *mut IUnknown,
        fmtid: *const IID,
        grfFlags: DWORD,
        dwReserved: DWORD,
        ppPropStg: *mut *mut IPropertyStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgCreatePropSetStg(
        pStorage: *mut IStorage,
        dwReserved: DWORD,
        ppPropSetStg: *mut *mut IPropertySetStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn FmtIdToPropStgName(pfmtid: *const FMTID, oszName: LPOLESTR) -> HRESULT;
}
extern "C" {
    pub fn PropStgNameToFmtId(oszName: LPOLESTR, pfmtid: *mut FMTID) -> HRESULT;
}
extern "C" {
    pub fn ReadClassStg(pStg: LPSTORAGE, pclsid: *mut CLSID) -> HRESULT;
}
extern "C" {
    pub fn WriteClassStg(pStg: LPSTORAGE, rclsid: *const IID) -> HRESULT;
}
extern "C" {
    pub fn ReadClassStm(pStm: LPSTREAM, pclsid: *mut CLSID) -> HRESULT;
}
extern "C" {
    pub fn WriteClassStm(pStm: LPSTREAM, rclsid: *const IID) -> HRESULT;
}
extern "C" {
    pub fn GetHGlobalFromILockBytes(plkbyt: LPLOCKBYTES, phglobal: *mut HGLOBAL) -> HRESULT;
}
extern "C" {
    pub fn CreateILockBytesOnHGlobal(
        hGlobal: HGLOBAL,
        fDeleteOnRelease: BOOL,
        pplkbyt: *mut LPLOCKBYTES,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetConvertStg(pStg: LPSTORAGE) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCOINIT {
    COINIT_APARTMENTTHREADED = 2,
    COINIT_MULTITHREADED = 0,
    COINIT_DISABLE_OLE1DDE = 4,
    COINIT_SPEED_OVER_MEMORY = 8,
}
pub use self::tagCOINIT as COINIT;
extern "C" {
    pub fn CoBuildVersion() -> DWORD;
}
extern "C" {
    pub fn CoInitialize(pvReserved: LPVOID) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterMallocSpy(pMallocSpy: LPMALLOCSPY) -> HRESULT;
}
extern "C" {
    pub fn CoRevokeMallocSpy() -> HRESULT;
}
extern "C" {
    pub fn CoCreateStandardMalloc(memctx: DWORD, ppMalloc: *mut *mut IMalloc) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterInitializeSpy(
        pSpy: *mut IInitializeSpy,
        puliCookie: *mut ULARGE_INTEGER,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoRevokeInitializeSpy(uliCookie: ULARGE_INTEGER) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagCOMSD {
    SD_LAUNCHPERMISSIONS = 0,
    SD_ACCESSPERMISSIONS = 1,
    SD_LAUNCHRESTRICTIONS = 2,
    SD_ACCESSRESTRICTIONS = 3,
}
pub use self::tagCOMSD as COMSD;
extern "C" {
    pub fn CoGetSystemSecurityPermissions(
        comSDType: COMSD,
        ppSD: *mut PSECURITY_DESCRIPTOR,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoLoadLibrary(lpszLibName: LPOLESTR, bAutoFree: BOOL) -> HINSTANCE;
}
extern "C" {
    pub fn CoFreeLibrary(hInst: HINSTANCE);
}
extern "C" {
    pub fn CoFreeAllLibraries();
}
extern "C" {
    pub fn CoGetInstanceFromFile(
        pServerInfo: *mut COSERVERINFO,
        pClsid: *mut CLSID,
        punkOuter: *mut IUnknown,
        dwClsCtx: DWORD,
        grfMode: DWORD,
        pwszName: *mut OLECHAR,
        dwCount: DWORD,
        pResults: *mut MULTI_QI,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetInstanceFromIStorage(
        pServerInfo: *mut COSERVERINFO,
        pClsid: *mut CLSID,
        punkOuter: *mut IUnknown,
        dwClsCtx: DWORD,
        pstg: *mut IStorage,
        dwCount: DWORD,
        pResults: *mut MULTI_QI,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoAllowSetForegroundWindow(pUnk: *mut IUnknown, lpvReserved: LPVOID) -> HRESULT;
}
extern "C" {
    pub fn DcomChannelSetHResult(
        pvReserved: LPVOID,
        pulReserved: *mut ULONG,
        appsHR: HRESULT,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoIsOle1Class(rclsid: *const IID) -> BOOL;
}
extern "C" {
    pub fn CoFileTimeToDosDateTime(
        lpFileTime: *mut FILETIME,
        lpDosDate: LPWORD,
        lpDosTime: LPWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn CoDosDateTimeToFileTime(
        nDosDate: WORD,
        nDosTime: WORD,
        lpFileTime: *mut FILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn CoRegisterMessageFilter(
        lpMessageFilter: LPMESSAGEFILTER,
        lplpMessageFilter: *mut LPMESSAGEFILTER,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoRegisterChannelHook(
        ExtensionUuid: *const GUID,
        pChannelHook: *mut IChannelHook,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoTreatAsClass(clsidOld: *const IID, clsidNew: *const IID) -> HRESULT;
}
extern "C" {
    pub fn CreateDataAdviseHolder(ppDAHolder: *mut LPDATAADVISEHOLDER) -> HRESULT;
}
extern "C" {
    pub fn CreateDataCache(
        pUnkOuter: LPUNKNOWN,
        rclsid: *const IID,
        iid: *const IID,
        ppv: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgOpenAsyncDocfileOnIFillLockBytes(
        pflb: *mut IFillLockBytes,
        grfMode: DWORD,
        asyncFlags: DWORD,
        ppstgOpen: *mut *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgGetIFillLockBytesOnILockBytes(
        pilb: *mut ILockBytes,
        ppflb: *mut *mut IFillLockBytes,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgGetIFillLockBytesOnFile(
        pwcsName: *const OLECHAR,
        ppflb: *mut *mut IFillLockBytes,
    ) -> HRESULT;
}
extern "C" {
    pub fn StgOpenLayoutDocfile(
        pwcsDfName: *const OLECHAR,
        grfMode: DWORD,
        reserved: DWORD,
        ppstgOpen: *mut *mut IStorage,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInstall(
        pbc: *mut IBindCtx,
        dwFlags: DWORD,
        pClassSpec: *mut uCLSSPEC,
        pQuery: *mut QUERYCONTEXT,
        pszCodeBase: LPWSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn BindMoniker(
        pmk: LPMONIKER,
        grfOpt: DWORD,
        iidResult: *const IID,
        ppvResult: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoGetObject(
        pszName: LPCWSTR,
        pBindOptions: *mut BIND_OPTS,
        riid: *const IID,
        ppv: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn MkParseDisplayName(
        pbc: LPBC,
        szUserName: LPCOLESTR,
        pchEaten: *mut ULONG,
        ppmk: *mut LPMONIKER,
    ) -> HRESULT;
}
extern "C" {
    pub fn MonikerRelativePathTo(
        pmkSrc: LPMONIKER,
        pmkDest: LPMONIKER,
        ppmkRelPath: *mut LPMONIKER,
        dwReserved: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn MonikerCommonPrefixWith(
        pmkThis: LPMONIKER,
        pmkOther: LPMONIKER,
        ppmkCommon: *mut LPMONIKER,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateBindCtx(reserved: DWORD, ppbc: *mut LPBC) -> HRESULT;
}
extern "C" {
    pub fn CreateGenericComposite(
        pmkFirst: LPMONIKER,
        pmkRest: LPMONIKER,
        ppmkComposite: *mut LPMONIKER,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetClassFile(szFilename: LPCOLESTR, pclsid: *mut CLSID) -> HRESULT;
}
extern "C" {
    pub fn CreateClassMoniker(rclsid: *const IID, ppmk: *mut LPMONIKER) -> HRESULT;
}
extern "C" {
    pub fn CreateFileMoniker(lpszPathName: LPCOLESTR, ppmk: *mut LPMONIKER) -> HRESULT;
}
extern "C" {
    pub fn CreateItemMoniker(
        lpszDelim: LPCOLESTR,
        lpszItem: LPCOLESTR,
        ppmk: *mut LPMONIKER,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateAntiMoniker(ppmk: *mut LPMONIKER) -> HRESULT;
}
extern "C" {
    pub fn CreatePointerMoniker(punk: LPUNKNOWN, ppmk: *mut LPMONIKER) -> HRESULT;
}
extern "C" {
    pub fn CreateObjrefMoniker(punk: LPUNKNOWN, ppmk: *mut LPMONIKER) -> HRESULT;
}
extern "C" {
    pub fn GetRunningObjectTable(reserved: DWORD, pprot: *mut LPRUNNINGOBJECTTABLE) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPOLEADVISEHOLDER = *mut IOleAdviseHolder;
extern "C" {
    pub static IID_IOleAdviseHolder: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleAdviseHolder {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPOLECACHE = *mut IOleCache;
extern "C" {
    pub static IID_IOleCache: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleCache {
    pub _base: IUnknown,
}
pub type LPOLECACHE2 = *mut IOleCache2;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagDISCARDCACHE {
    DISCARDCACHE_SAVEIFDIRTY = 0,
    DISCARDCACHE_NOSAVE = 1,
}
pub use self::tagDISCARDCACHE as DISCARDCACHE;
extern "C" {
    pub static IID_IOleCache2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleCache2 {
    pub _base: IOleCache,
}
extern "C" {
    pub fn IOleCache2_RemoteUpdateCache_Proxy(
        This: *mut IOleCache2,
        pDataObject: LPDATAOBJECT,
        grfUpdf: DWORD,
        pReserved: LONG_PTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleCache2_RemoteUpdateCache_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPOLECACHECONTROL = *mut IOleCacheControl;
extern "C" {
    pub static IID_IOleCacheControl: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleCacheControl {
    pub _base: IUnknown,
}
pub type LPPARSEDISPLAYNAME = *mut IParseDisplayName;
extern "C" {
    pub static IID_IParseDisplayName: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IParseDisplayName {
    pub _base: IUnknown,
}
pub type LPOLECONTAINER = *mut IOleContainer;
extern "C" {
    pub static IID_IOleContainer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleContainer {
    pub _base: IParseDisplayName,
}
pub type LPOLECLIENTSITE = *mut IOleClientSite;
extern "C" {
    pub static IID_IOleClientSite: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleClientSite {
    pub _base: IUnknown,
}
pub type LPOLEOBJECT = *mut IOleObject;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLEGETMONIKER {
    OLEGETMONIKER_ONLYIFTHERE = 1,
    OLEGETMONIKER_FORCEASSIGN = 2,
    OLEGETMONIKER_UNASSIGN = 3,
    OLEGETMONIKER_TEMPFORUSER = 4,
}
pub use self::tagOLEGETMONIKER as OLEGETMONIKER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLEWHICHMK {
    OLEWHICHMK_CONTAINER = 1,
    OLEWHICHMK_OBJREL = 2,
    OLEWHICHMK_OBJFULL = 3,
}
pub use self::tagOLEWHICHMK as OLEWHICHMK;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagUSERCLASSTYPE {
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT = 2,
    USERCLASSTYPE_APPNAME = 3,
}
pub use self::tagUSERCLASSTYPE as USERCLASSTYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLEMISC {
    OLEMISC_RECOMPOSEONRESIZE = 1,
    OLEMISC_ONLYICONIC = 2,
    OLEMISC_INSERTNOTREPLACE = 4,
    OLEMISC_STATIC = 8,
    OLEMISC_CANTLINKINSIDE = 16,
    OLEMISC_CANLINKBYOLE1 = 32,
    OLEMISC_ISLINKOBJECT = 64,
    OLEMISC_INSIDEOUT = 128,
    OLEMISC_ACTIVATEWHENVISIBLE = 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT = 512,
    OLEMISC_INVISIBLEATRUNTIME = 1024,
    OLEMISC_ALWAYSRUN = 2048,
    OLEMISC_ACTSLIKEBUTTON = 4096,
    OLEMISC_ACTSLIKELABEL = 8192,
    OLEMISC_NOUIACTIVATE = 16384,
    OLEMISC_ALIGNABLE = 32768,
    OLEMISC_SIMPLEFRAME = 65536,
    OLEMISC_SETCLIENTSITEFIRST = 131072,
    OLEMISC_IMEMODE = 262144,
    OLEMISC_IGNOREACTIVATEWHENVISIBLE = 524288,
    OLEMISC_WANTSTOMENUMERGE = 1048576,
    OLEMISC_SUPPORTSMULTILEVELUNDO = 2097152,
}
pub use self::tagOLEMISC as OLEMISC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLECLOSE {
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE = 1,
    OLECLOSE_PROMPTSAVE = 2,
}
pub use self::tagOLECLOSE as OLECLOSE;
extern "C" {
    pub static IID_IOleObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleObject {
    pub _base: IUnknown,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLERENDER {
    OLERENDER_NONE = 0,
    OLERENDER_DRAW = 1,
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS = 3,
}
pub use self::tagOLERENDER as OLERENDER;
pub type LPOLERENDER = *mut OLERENDER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOBJECTDESCRIPTOR {
    pub cbSize: ULONG,
    pub clsid: CLSID,
    pub dwDrawAspect: DWORD,
    pub sizel: SIZEL,
    pub pointl: POINTL,
    pub dwStatus: DWORD,
    pub dwFullUserTypeName: DWORD,
    pub dwSrcOfCopy: DWORD,
}
pub type OBJECTDESCRIPTOR = tagOBJECTDESCRIPTOR;
pub type POBJECTDESCRIPTOR = *mut tagOBJECTDESCRIPTOR;
pub type LPOBJECTDESCRIPTOR = *mut tagOBJECTDESCRIPTOR;
pub type LINKSRCDESCRIPTOR = tagOBJECTDESCRIPTOR;
pub type PLINKSRCDESCRIPTOR = *mut tagOBJECTDESCRIPTOR;
pub type LPLINKSRCDESCRIPTOR = *mut tagOBJECTDESCRIPTOR;
extern "C" {
    pub static mut IOLETypes_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut IOLETypes_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPOLEWINDOW = *mut IOleWindow;
extern "C" {
    pub static IID_IOleWindow: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleWindow {
    pub _base: IUnknown,
}
pub type LPOLELINK = *mut IOleLink;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLEUPDATE {
    OLEUPDATE_ALWAYS = 1,
    OLEUPDATE_ONCALL = 3,
}
pub use self::tagOLEUPDATE as OLEUPDATE;
pub type LPOLEUPDATE = *mut OLEUPDATE;
pub type POLEUPDATE = *mut OLEUPDATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLELINKBIND {
    OLELINKBIND_EVENIFCLASSDIFF = 1,
}
pub use self::tagOLELINKBIND as OLELINKBIND;
extern "C" {
    pub static IID_IOleLink: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleLink {
    pub _base: IUnknown,
}
pub type LPOLEITEMCONTAINER = *mut IOleItemContainer;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagBINDSPEED {
    BINDSPEED_INDEFINITE = 1,
    BINDSPEED_MODERATE = 2,
    BINDSPEED_IMMEDIATE = 3,
}
pub use self::tagBINDSPEED as BINDSPEED;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLECONTF {
    OLECONTF_EMBEDDINGS = 1,
    OLECONTF_LINKS = 2,
    OLECONTF_OTHERS = 4,
    OLECONTF_ONLYUSER = 8,
    OLECONTF_ONLYIFRUNNING = 16,
}
pub use self::tagOLECONTF as OLECONTF;
extern "C" {
    pub static IID_IOleItemContainer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleItemContainer {
    pub _base: IOleContainer,
}
pub type LPOLEINPLACEUIWINDOW = *mut IOleInPlaceUIWindow;
pub type BORDERWIDTHS = RECT;
pub type LPBORDERWIDTHS = LPRECT;
pub type LPCBORDERWIDTHS = LPCRECT;
extern "C" {
    pub static IID_IOleInPlaceUIWindow: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleInPlaceUIWindow {
    pub _base: IOleWindow,
}
pub type LPOLEINPLACEACTIVEOBJECT = *mut IOleInPlaceActiveObject;
extern "C" {
    pub static IID_IOleInPlaceActiveObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleInPlaceActiveObject {
    pub _base: IOleWindow,
}
extern "C" {
    pub fn IOleInPlaceActiveObject_RemoteTranslateAccelerator_Proxy(
        This: *mut IOleInPlaceActiveObject,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleInPlaceActiveObject_RemoteTranslateAccelerator_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(
        This: *mut IOleInPlaceActiveObject,
        prcBorder: LPCRECT,
        riid: *const IID,
        pUIWindow: *mut IOleInPlaceUIWindow,
        fFrameWindow: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleInPlaceActiveObject_RemoteResizeBorder_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPOLEINPLACEFRAME = *mut IOleInPlaceFrame;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOIFI {
    pub cb: UINT,
    pub fMDIApp: BOOL,
    pub hwndFrame: HWND,
    pub haccel: HACCEL,
    pub cAccelEntries: UINT,
}
pub type OLEINPLACEFRAMEINFO = tagOIFI;
pub type LPOLEINPLACEFRAMEINFO = *mut tagOIFI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOleMenuGroupWidths {
    pub width: [LONG; 6usize],
}
pub type OLEMENUGROUPWIDTHS = tagOleMenuGroupWidths;
pub type LPOLEMENUGROUPWIDTHS = *mut tagOleMenuGroupWidths;
pub type HOLEMENU = HGLOBAL;
extern "C" {
    pub static IID_IOleInPlaceFrame: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleInPlaceFrame {
    pub _base: IOleInPlaceUIWindow,
}
pub type LPOLEINPLACEOBJECT = *mut IOleInPlaceObject;
extern "C" {
    pub static IID_IOleInPlaceObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleInPlaceObject {
    pub _base: IOleWindow,
}
pub type LPOLEINPLACESITE = *mut IOleInPlaceSite;
extern "C" {
    pub static IID_IOleInPlaceSite: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOleInPlaceSite {
    pub _base: IOleWindow,
}
extern "C" {
    pub static IID_IContinue: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IContinue {
    pub _base: IUnknown,
}
pub type LPVIEWOBJECT = *mut IViewObject;
extern "C" {
    pub static IID_IViewObject: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IViewObject {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IViewObject_RemoteDraw_Proxy(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: ULONG_PTR,
        ptd: *mut DVTARGETDEVICE,
        hdcTargetDev: HDC,
        hdcDraw: HDC,
        lprcBounds: LPCRECTL,
        lprcWBounds: LPCRECTL,
        pContinue: *mut IContinue,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_RemoteDraw_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IViewObject_RemoteGetColorSet_Proxy(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: ULONG_PTR,
        ptd: *mut DVTARGETDEVICE,
        hicTargetDev: ULONG_PTR,
        ppColorSet: *mut *mut LOGPALETTE,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_RemoteGetColorSet_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IViewObject_RemoteFreeze_Proxy(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: ULONG_PTR,
        pdwFreeze: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_RemoteFreeze_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IViewObject_RemoteGetAdvise_Proxy(
        This: *mut IViewObject,
        pAspects: *mut DWORD,
        pAdvf: *mut DWORD,
        ppAdvSink: *mut *mut IAdviseSink,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_RemoteGetAdvise_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
pub type LPVIEWOBJECT2 = *mut IViewObject2;
extern "C" {
    pub static IID_IViewObject2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IViewObject2 {
    pub _base: IViewObject,
}
pub type LPDROPSOURCE = *mut IDropSource;
extern "C" {
    pub static IID_IDropSource: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDropSource {
    pub _base: IUnknown,
}
pub type LPDROPTARGET = *mut IDropTarget;
extern "C" {
    pub static IID_IDropTarget: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDropTarget {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IDropSourceNotify: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDropSourceNotify {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IEnterpriseDropTarget: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnterpriseDropTarget {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0024_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0024_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPENUMOLEVERB = *mut IEnumOLEVERB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOLEVERB {
    pub lVerb: LONG,
    pub lpszVerbName: LPOLESTR,
    pub fuFlags: DWORD,
    pub grfAttribs: DWORD,
}
pub type OLEVERB = tagOLEVERB;
pub type LPOLEVERB = *mut tagOLEVERB;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagOLEVERBATTRIB {
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2,
}
pub use self::tagOLEVERBATTRIB as OLEVERBATTRIB;
extern "C" {
    pub static IID_IEnumOLEVERB: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumOLEVERB {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IEnumOLEVERB_RemoteNext_Proxy(
        This: *mut IEnumOLEVERB,
        celt: ULONG,
        rgelt: LPOLEVERB,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumOLEVERB_RemoteNext_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0025_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_oleidl_0000_0025_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn HACCEL_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HACCEL,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HACCEL_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HACCEL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HACCEL_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HACCEL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HACCEL_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HACCEL);
}
extern "C" {
    pub fn HGLOBAL_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HGLOBAL,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HGLOBAL_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HGLOBAL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HGLOBAL_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HGLOBAL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HGLOBAL_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HGLOBAL);
}
extern "C" {
    pub fn HMENU_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HMENU,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HMENU_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HMENU,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HMENU_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HMENU,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HMENU_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HMENU);
}
extern "C" {
    pub fn HWND_UserSize(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HWND,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HWND_UserMarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HWND,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HWND_UserUnmarshal(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HWND,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HWND_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HWND);
}
extern "C" {
    pub fn HACCEL_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HACCEL,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HACCEL_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HACCEL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HACCEL_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HACCEL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HACCEL_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HACCEL);
}
extern "C" {
    pub fn HGLOBAL_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HGLOBAL,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HGLOBAL_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HGLOBAL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HGLOBAL_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HGLOBAL,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HGLOBAL_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HGLOBAL);
}
extern "C" {
    pub fn HMENU_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HMENU,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HMENU_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HMENU,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HMENU_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HMENU,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HMENU_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HMENU);
}
extern "C" {
    pub fn HWND_UserSize64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut HWND,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn HWND_UserMarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HWND,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HWND_UserUnmarshal64(
        arg1: *mut ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: *mut HWND,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HWND_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut HWND);
}
extern "C" {
    pub fn IOleCache2_UpdateCache_Proxy(
        This: *mut IOleCache2,
        pDataObject: LPDATAOBJECT,
        grfUpdf: DWORD,
        pReserved: LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleCache2_UpdateCache_Stub(
        This: *mut IOleCache2,
        pDataObject: LPDATAOBJECT,
        grfUpdf: DWORD,
        pReserved: LONG_PTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleInPlaceActiveObject_TranslateAccelerator_Proxy(
        This: *mut IOleInPlaceActiveObject,
        lpmsg: LPMSG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleInPlaceActiveObject_TranslateAccelerator_Stub(
        This: *mut IOleInPlaceActiveObject,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleInPlaceActiveObject_ResizeBorder_Proxy(
        This: *mut IOleInPlaceActiveObject,
        prcBorder: LPCRECT,
        pUIWindow: *mut IOleInPlaceUIWindow,
        fFrameWindow: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn IOleInPlaceActiveObject_ResizeBorder_Stub(
        This: *mut IOleInPlaceActiveObject,
        prcBorder: LPCRECT,
        riid: *const IID,
        pUIWindow: *mut IOleInPlaceUIWindow,
        fFrameWindow: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_Draw_Proxy(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: *mut ::std::os::raw::c_void,
        ptd: *mut DVTARGETDEVICE,
        hdcTargetDev: HDC,
        hdcDraw: HDC,
        lprcBounds: LPCRECTL,
        lprcWBounds: LPCRECTL,
        pfnContinue: ::std::option::Option<unsafe extern "C" fn(dwContinue: ULONG_PTR) -> BOOL>,
        dwContinue: ULONG_PTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_Draw_Stub(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: ULONG_PTR,
        ptd: *mut DVTARGETDEVICE,
        hdcTargetDev: HDC,
        hdcDraw: HDC,
        lprcBounds: LPCRECTL,
        lprcWBounds: LPCRECTL,
        pContinue: *mut IContinue,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_GetColorSet_Proxy(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: *mut ::std::os::raw::c_void,
        ptd: *mut DVTARGETDEVICE,
        hicTargetDev: HDC,
        ppColorSet: *mut *mut LOGPALETTE,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_GetColorSet_Stub(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: ULONG_PTR,
        ptd: *mut DVTARGETDEVICE,
        hicTargetDev: ULONG_PTR,
        ppColorSet: *mut *mut LOGPALETTE,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_Freeze_Proxy(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: *mut ::std::os::raw::c_void,
        pdwFreeze: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_Freeze_Stub(
        This: *mut IViewObject,
        dwDrawAspect: DWORD,
        lindex: LONG,
        pvAspect: ULONG_PTR,
        pdwFreeze: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_GetAdvise_Proxy(
        This: *mut IViewObject,
        pAspects: *mut DWORD,
        pAdvf: *mut DWORD,
        ppAdvSink: *mut *mut IAdviseSink,
    ) -> HRESULT;
}
extern "C" {
    pub fn IViewObject_GetAdvise_Stub(
        This: *mut IViewObject,
        pAspects: *mut DWORD,
        pAdvf: *mut DWORD,
        ppAdvSink: *mut *mut IAdviseSink,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumOLEVERB_Next_Proxy(
        This: *mut IEnumOLEVERB,
        celt: ULONG,
        rgelt: LPOLEVERB,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEnumOLEVERB_Next_Stub(
        This: *mut IEnumOLEVERB,
        celt: ULONG,
        rgelt: LPOLEVERB,
        pceltFetched: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_servprov_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_servprov_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPSERVICEPROVIDER = *mut IServiceProvider;
extern "C" {
    pub static IID_IServiceProvider: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IServiceProvider {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IServiceProvider_RemoteQueryService_Proxy(
        This: *mut IServiceProvider,
        guidService: *const GUID,
        riid: *const IID,
        ppvObject: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IServiceProvider_RemoteQueryService_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_servprov_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_servprov_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn IServiceProvider_QueryService_Proxy(
        This: *mut IServiceProvider,
        guidService: *const GUID,
        riid: *const IID,
        ppvObject: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IServiceProvider_QueryService_Stub(
        This: *mut IServiceProvider,
        guidService: *const GUID,
        riid: *const IID,
        ppvObject: *mut *mut IUnknown,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DOMDocument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DOMFreeThreadedDocument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMLHTTPRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMLDSOControl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMLDocument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xml_error {
    pub _nLine: ::std::os::raw::c_uint,
    pub _pchBuf: BSTR,
    pub _cchBuf: ::std::os::raw::c_uint,
    pub _ich: ::std::os::raw::c_uint,
    pub _pszFound: BSTR,
    pub _pszExpected: BSTR,
    pub _reserved1: DWORD,
    pub _reserved2: DWORD,
}
pub type XML_ERROR = _xml_error;
extern "C" {
    pub static mut __MIDL_itf_msxml_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_msxml_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagDOMNodeType {
    NODE_INVALID = 0,
    NODE_ELEMENT = 1,
    NODE_ATTRIBUTE = 2,
    NODE_TEXT = 3,
    NODE_CDATA_SECTION = 4,
    NODE_ENTITY_REFERENCE = 5,
    NODE_ENTITY = 6,
    NODE_PROCESSING_INSTRUCTION = 7,
    NODE_COMMENT = 8,
    NODE_DOCUMENT = 9,
    NODE_DOCUMENT_TYPE = 10,
    NODE_DOCUMENT_FRAGMENT = 11,
    NODE_NOTATION = 12,
}
pub use self::tagDOMNodeType as DOMNodeType;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagXMLEMEM_TYPE {
    XMLELEMTYPE_ELEMENT = 0,
    XMLELEMTYPE_TEXT = 1,
    XMLELEMTYPE_COMMENT = 2,
    XMLELEMTYPE_DOCUMENT = 3,
    XMLELEMTYPE_DTD = 4,
    XMLELEMTYPE_PI = 5,
    XMLELEMTYPE_OTHER = 6,
}
pub use self::tagXMLEMEM_TYPE as XMLELEM_TYPE;
extern "C" {
    pub static LIBID_MSXML: IID;
}
extern "C" {
    pub static IID_IXMLDOMImplementation: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMImplementation {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLDOMNode: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMNode {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLDOMDocumentFragment: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMDocumentFragment {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMDocument: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMDocument {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMNodeList: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMNodeList {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLDOMNamedNodeMap: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMNamedNodeMap {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLDOMCharacterData: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMCharacterData {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMAttribute: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMAttribute {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMElement: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMElement {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMText: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMText {
    pub _base: IXMLDOMCharacterData,
}
extern "C" {
    pub static IID_IXMLDOMComment: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMComment {
    pub _base: IXMLDOMCharacterData,
}
extern "C" {
    pub static IID_IXMLDOMProcessingInstruction: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMProcessingInstruction {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMCDATASection: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMCDATASection {
    pub _base: IXMLDOMText,
}
extern "C" {
    pub static IID_IXMLDOMDocumentType: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMDocumentType {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMNotation: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMNotation {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMEntity: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMEntity {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMEntityReference: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMEntityReference {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static IID_IXMLDOMParseError: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDOMParseError {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXTLRuntime: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXTLRuntime {
    pub _base: IXMLDOMNode,
}
extern "C" {
    pub static DIID_XMLDOMDocumentEvents: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XMLDOMDocumentEvents {
    pub _base: IDispatch,
}
extern "C" {
    pub static CLSID_DOMDocument: CLSID;
}
extern "C" {
    pub static CLSID_DOMFreeThreadedDocument: CLSID;
}
extern "C" {
    pub static IID_IXMLHttpRequest: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLHttpRequest {
    pub _base: IDispatch,
}
extern "C" {
    pub static CLSID_XMLHTTPRequest: CLSID;
}
extern "C" {
    pub static IID_IXMLDSOControl: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDSOControl {
    pub _base: IDispatch,
}
extern "C" {
    pub static CLSID_XMLDSOControl: CLSID;
}
extern "C" {
    pub static IID_IXMLElementCollection: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLElementCollection {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLDocument: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDocument {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLDocument2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLDocument2 {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLElement: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLElement {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLElement2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLElement2 {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLAttribute: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLAttribute {
    pub _base: IDispatch,
}
extern "C" {
    pub static IID_IXMLError: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IXMLError {
    pub _base: IUnknown,
}
extern "C" {
    pub static CLSID_XMLDocument: CLSID;
}
extern "C" {
    pub static mut __MIDL_itf_msxml_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_msxml_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static CLSID_SBS_StdURLMoniker: IID;
}
extern "C" {
    pub static CLSID_SBS_HttpProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_FtpProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_GopherProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_HttpSProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_FileProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_MkProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_UrlMkBindCtx: IID;
}
extern "C" {
    pub static CLSID_SBS_SoftDistExt: IID;
}
extern "C" {
    pub static CLSID_SBS_CdlProtocol: IID;
}
extern "C" {
    pub static CLSID_SBS_ClassInstallFilter: IID;
}
extern "C" {
    pub static CLSID_SBS_InternetSecurityManager: IID;
}
extern "C" {
    pub static CLSID_SBS_InternetZoneManager: IID;
}
extern "C" {
    pub static IID_IAsyncMoniker: IID;
}
extern "C" {
    pub static CLSID_StdURLMoniker: IID;
}
extern "C" {
    pub static CLSID_HttpProtocol: IID;
}
extern "C" {
    pub static CLSID_FtpProtocol: IID;
}
extern "C" {
    pub static CLSID_GopherProtocol: IID;
}
extern "C" {
    pub static CLSID_HttpSProtocol: IID;
}
extern "C" {
    pub static CLSID_FileProtocol: IID;
}
extern "C" {
    pub static CLSID_ResProtocol: IID;
}
extern "C" {
    pub static CLSID_AboutProtocol: IID;
}
extern "C" {
    pub static CLSID_JSProtocol: IID;
}
extern "C" {
    pub static CLSID_MailtoProtocol: IID;
}
extern "C" {
    pub static CLSID_IE4_PROTOCOLS: IID;
}
extern "C" {
    pub static CLSID_MkProtocol: IID;
}
extern "C" {
    pub static CLSID_StdURLProtocol: IID;
}
extern "C" {
    pub static CLSID_TBAuthProtocol: IID;
}
extern "C" {
    pub static CLSID_UrlMkBindCtx: IID;
}
extern "C" {
    pub static CLSID_CdlProtocol: IID;
}
extern "C" {
    pub static CLSID_ClassInstallFilter: IID;
}
extern "C" {
    pub static IID_IAsyncBindCtx: IID;
}
extern "C" {
    pub fn CreateURLMoniker(pMkCtx: LPMONIKER, szURL: LPCWSTR, ppmk: *mut LPMONIKER) -> HRESULT;
}
extern "C" {
    pub fn CreateURLMonikerEx(
        pMkCtx: LPMONIKER,
        szURL: LPCWSTR,
        ppmk: *mut LPMONIKER,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetClassURL(szURL: LPCWSTR, pClsID: *mut CLSID) -> HRESULT;
}
extern "C" {
    pub fn CreateAsyncBindCtx(
        reserved: DWORD,
        pBSCb: *mut IBindStatusCallback,
        pEFetc: *mut IEnumFORMATETC,
        ppBC: *mut *mut IBindCtx,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateURLMonikerEx2(
        pMkCtx: LPMONIKER,
        pUri: *mut IUri,
        ppmk: *mut LPMONIKER,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateAsyncBindCtxEx(
        pbc: *mut IBindCtx,
        dwOptions: DWORD,
        pBSCb: *mut IBindStatusCallback,
        pEnum: *mut IEnumFORMATETC,
        ppBC: *mut *mut IBindCtx,
        reserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn MkParseDisplayNameEx(
        pbc: *mut IBindCtx,
        szDisplayName: LPCWSTR,
        pchEaten: *mut ULONG,
        ppmk: *mut LPMONIKER,
    ) -> HRESULT;
}
extern "C" {
    pub fn RegisterBindStatusCallback(
        pBC: LPBC,
        pBSCb: *mut IBindStatusCallback,
        ppBSCBPrev: *mut *mut IBindStatusCallback,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn RevokeBindStatusCallback(pBC: LPBC, pBSCb: *mut IBindStatusCallback) -> HRESULT;
}
extern "C" {
    pub fn GetClassFileOrMime(
        pBC: LPBC,
        szFilename: LPCWSTR,
        pBuffer: LPVOID,
        cbSize: DWORD,
        szMime: LPCWSTR,
        dwReserved: DWORD,
        pclsid: *mut CLSID,
    ) -> HRESULT;
}
extern "C" {
    pub fn IsValidURL(pBC: LPBC, szURL: LPCWSTR, dwReserved: DWORD) -> HRESULT;
}
extern "C" {
    pub fn CoGetClassObjectFromURL(
        rCLASSID: *const IID,
        szCODE: LPCWSTR,
        dwFileVersionMS: DWORD,
        dwFileVersionLS: DWORD,
        szTYPE: LPCWSTR,
        pBindCtx: LPBINDCTX,
        dwClsContext: DWORD,
        pvReserved: LPVOID,
        riid: *const IID,
        ppv: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn IEInstallScope(pdwScope: LPDWORD) -> HRESULT;
}
extern "C" {
    pub fn FaultInIEFeature(
        hWnd: HWND,
        pClassSpec: *mut uCLSSPEC,
        pQuery: *mut QUERYCONTEXT,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetComponentIDFromCLSSPEC(
        pClassspec: *mut uCLSSPEC,
        ppszComponentID: *mut LPSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn IsAsyncMoniker(pmk: *mut IMoniker) -> HRESULT;
}
extern "C" {
    pub fn CreateURLBinding(
        lpszUrl: LPCWSTR,
        pbc: *mut IBindCtx,
        ppBdg: *mut *mut IBinding,
    ) -> HRESULT;
}
extern "C" {
    pub fn RegisterMediaTypes(
        ctypes: UINT,
        rgszTypes: *const LPCSTR,
        rgcfTypes: *mut CLIPFORMAT,
    ) -> HRESULT;
}
extern "C" {
    pub fn FindMediaType(rgszTypes: LPCSTR, rgcfTypes: *mut CLIPFORMAT) -> HRESULT;
}
extern "C" {
    pub fn CreateFormatEnumerator(
        cfmtetc: UINT,
        rgfmtetc: *mut FORMATETC,
        ppenumfmtetc: *mut *mut IEnumFORMATETC,
    ) -> HRESULT;
}
extern "C" {
    pub fn RegisterFormatEnumerator(
        pBC: LPBC,
        pEFetc: *mut IEnumFORMATETC,
        reserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn RevokeFormatEnumerator(pBC: LPBC, pEFetc: *mut IEnumFORMATETC) -> HRESULT;
}
extern "C" {
    pub fn RegisterMediaTypeClass(
        pBC: LPBC,
        ctypes: UINT,
        rgszTypes: *const LPCSTR,
        rgclsID: *mut CLSID,
        reserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn FindMediaTypeClass(
        pBC: LPBC,
        szType: LPCSTR,
        pclsID: *mut CLSID,
        reserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn UrlMkSetSessionOption(
        dwOption: DWORD,
        pBuffer: LPVOID,
        dwBufferLength: DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn UrlMkGetSessionOption(
        dwOption: DWORD,
        pBuffer: LPVOID,
        dwBufferLength: DWORD,
        pdwBufferLengthOut: *mut DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn FindMimeFromData(
        pBC: LPBC,
        pwzUrl: LPCWSTR,
        pBuffer: LPVOID,
        cbSize: DWORD,
        pwzMimeProposed: LPCWSTR,
        dwMimeFlags: DWORD,
        ppwzMimeOut: *mut LPWSTR,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn ObtainUserAgentString(dwOption: DWORD, pszUAOut: LPSTR, cbSize: *mut DWORD) -> HRESULT;
}
extern "C" {
    pub fn CompareSecurityIds(
        pbSecurityId1: *mut BYTE,
        dwLen1: DWORD,
        pbSecurityId2: *mut BYTE,
        dwLen2: DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CompatFlagsFromClsid(
        pclsid: *mut CLSID,
        pdwCompatFlags: LPDWORD,
        pdwMiscStatusFlags: LPDWORD,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IEObjectType {
    IE_EPM_OBJECT_EVENT = 0,
    IE_EPM_OBJECT_MUTEX = 1,
    IE_EPM_OBJECT_SEMAPHORE = 2,
    IE_EPM_OBJECT_SHARED_MEMORY = 3,
    IE_EPM_OBJECT_WAITABLE_TIMER = 4,
    IE_EPM_OBJECT_FILE = 5,
    IE_EPM_OBJECT_NAMED_PIPE = 6,
    IE_EPM_OBJECT_REGISTRY = 7,
}
extern "C" {
    pub fn SetAccessForIEAppContainer(
        hObject: HANDLE,
        ieObjectType: IEObjectType,
        dwAccessMask: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPPERSISTMONIKER = *mut IPersistMoniker;
extern "C" {
    pub static IID_IPersistMoniker: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersistMoniker {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPMONIKERPROP = *mut IMonikerProp;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IMonikerProp_0001 {
    MIMETYPEPROP = 0,
    USE_SRC_URL = 1,
    CLASSIDPROP = 2,
    TRUSTEDDOWNLOADPROP = 3,
    POPUPLEVELPROP = 4,
}
pub use self::__MIDL_IMonikerProp_0001 as MONIKERPROPERTY;
extern "C" {
    pub static IID_IMonikerProp: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMonikerProp {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBINDPROTOCOL = *mut IBindProtocol;
extern "C" {
    pub static IID_IBindProtocol: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindProtocol {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBINDING = *mut IBinding;
extern "C" {
    pub static IID_IBinding: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBinding {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IBinding_RemoteGetBindResult_Proxy(
        This: *mut IBinding,
        pclsidProtocol: *mut CLSID,
        pdwResult: *mut DWORD,
        pszResult: *mut LPOLESTR,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBinding_RemoteGetBindResult_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBINDSTATUSCALLBACK = *mut IBindStatusCallback;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallback_0001 {
    BINDVERB_GET = 0,
    BINDVERB_POST = 1,
    BINDVERB_PUT = 2,
    BINDVERB_CUSTOM = 3,
    BINDVERB_RESERVED1 = 4,
}
pub use self::__MIDL_IBindStatusCallback_0001 as BINDVERB;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallback_0002 {
    BINDINFOF_URLENCODESTGMEDDATA = 1,
    BINDINFOF_URLENCODEDEXTRAINFO = 2,
}
pub use self::__MIDL_IBindStatusCallback_0002 as BINDINFOF;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallback_0003 {
    BINDF_ASYNCHRONOUS = 1,
    BINDF_ASYNCSTORAGE = 2,
    BINDF_NOPROGRESSIVERENDERING = 4,
    BINDF_OFFLINEOPERATION = 8,
    BINDF_GETNEWESTVERSION = 16,
    BINDF_NOWRITECACHE = 32,
    BINDF_NEEDFILE = 64,
    BINDF_PULLDATA = 128,
    BINDF_IGNORESECURITYPROBLEM = 256,
    BINDF_RESYNCHRONIZE = 512,
    BINDF_HYPERLINK = 1024,
    BINDF_NO_UI = 2048,
    BINDF_SILENTOPERATION = 4096,
    BINDF_PRAGMA_NO_CACHE = 8192,
    BINDF_GETCLASSOBJECT = 16384,
    BINDF_RESERVED_1 = 32768,
    BINDF_FREE_THREADED = 65536,
    BINDF_DIRECT_READ = 131072,
    BINDF_FORMS_SUBMIT = 262144,
    BINDF_GETFROMCACHE_IF_NET_FAIL = 524288,
    BINDF_FROMURLMON = 1048576,
    BINDF_FWD_BACK = 2097152,
    BINDF_PREFERDEFAULTHANDLER = 4194304,
    BINDF_ENFORCERESTRICTED = 8388608,
    BINDF_RESERVED_2 = -2147483648,
    BINDF_RESERVED_3 = 16777216,
    BINDF_RESERVED_4 = 33554432,
    BINDF_RESERVED_5 = 67108864,
    BINDF_RESERVED_6 = 134217728,
    BINDF_RESERVED_7 = 1073741824,
    BINDF_RESERVED_8 = 536870912,
}
pub use self::__MIDL_IBindStatusCallback_0003 as BINDF;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallback_0004 {
    URL_ENCODING_NONE = 0,
    URL_ENCODING_ENABLE_UTF8 = 268435456,
    URL_ENCODING_DISABLE_UTF8 = 536870912,
}
pub use self::__MIDL_IBindStatusCallback_0004 as URL_ENCODING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _tagBINDINFO {
    pub cbSize: ULONG,
    pub szExtraInfo: LPWSTR,
    pub stgmedData: STGMEDIUM,
    pub grfBindInfoF: DWORD,
    pub dwBindVerb: DWORD,
    pub szCustomVerb: LPWSTR,
    pub cbstgmedData: DWORD,
    pub dwOptions: DWORD,
    pub dwOptionsFlags: DWORD,
    pub dwCodePage: DWORD,
    pub securityAttributes: SECURITY_ATTRIBUTES,
    pub iid: IID,
    pub pUnk: *mut IUnknown,
    pub dwReserved: DWORD,
}
pub type BINDINFO = _tagBINDINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REMSECURITY_ATTRIBUTES {
    pub nLength: DWORD,
    pub lpSecurityDescriptor: DWORD,
    pub bInheritHandle: BOOL,
}
pub type REMSECURITY_ATTRIBUTES = _REMSECURITY_ATTRIBUTES;
pub type PREMSECURITY_ATTRIBUTES = *mut _REMSECURITY_ATTRIBUTES;
pub type LPREMSECURITY_ATTRIBUTES = *mut _REMSECURITY_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagRemBINDINFO {
    pub cbSize: ULONG,
    pub szExtraInfo: LPWSTR,
    pub grfBindInfoF: DWORD,
    pub dwBindVerb: DWORD,
    pub szCustomVerb: LPWSTR,
    pub cbstgmedData: DWORD,
    pub dwOptions: DWORD,
    pub dwOptionsFlags: DWORD,
    pub dwCodePage: DWORD,
    pub securityAttributes: REMSECURITY_ATTRIBUTES,
    pub iid: IID,
    pub pUnk: *mut IUnknown,
    pub dwReserved: DWORD,
}
pub type RemBINDINFO = _tagRemBINDINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRemFORMATETC {
    pub cfFormat: DWORD,
    pub ptd: DWORD,
    pub dwAspect: DWORD,
    pub lindex: LONG,
    pub tymed: DWORD,
}
pub type RemFORMATETC = tagRemFORMATETC;
pub type LPREMFORMATETC = *mut tagRemFORMATETC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallback_0005 {
    BINDINFO_OPTIONS_WININETFLAG = 65536,
    BINDINFO_OPTIONS_ENABLE_UTF8 = 131072,
    BINDINFO_OPTIONS_DISABLE_UTF8 = 262144,
    BINDINFO_OPTIONS_USE_IE_ENCODING = 524288,
    BINDINFO_OPTIONS_BINDTOOBJECT = 1048576,
    BINDINFO_OPTIONS_SECURITYOPTOUT = 2097152,
    BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = 4194304,
    BINDINFO_OPTIONS_USEBINDSTRINGCREDS = 8388608,
    BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 16777216,
    BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = 33554432,
    BINDINFO_WPC_DOWNLOADBLOCKED = 134217728,
    BINDINFO_WPC_LOGGING_ENABLED = 268435456,
    BINDINFO_OPTIONS_ALLOWCONNECTDATA = 536870912,
    BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = 1073741824,
    BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = -2147483648,
}
pub use self::__MIDL_IBindStatusCallback_0005 as BINDINFO_OPTIONS;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallback_0006 {
    BSCF_FIRSTDATANOTIFICATION = 1,
    BSCF_INTERMEDIATEDATANOTIFICATION = 2,
    BSCF_LASTDATANOTIFICATION = 4,
    BSCF_DATAFULLYAVAILABLE = 8,
    BSCF_AVAILABLEDATASIZEUNKNOWN = 16,
    BSCF_SKIPDRAINDATAFORFILEURLS = 32,
    BSCF_64BITLENGTHDOWNLOAD = 64,
}
pub use self::__MIDL_IBindStatusCallback_0006 as BSCF;
impl tagBINDSTATUS {
    pub const BINDSTATUS_LAST: tagBINDSTATUS = tagBINDSTATUS::BINDSTATUS_64BIT_PROGRESS;
}
impl tagBINDSTATUS {
    pub const BINDSTATUS_LAST_PRIVATE: tagBINDSTATUS = tagBINDSTATUS::BINDSTATUS_RESERVED_14;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagBINDSTATUS {
    BINDSTATUS_FINDINGRESOURCE = 1,
    BINDSTATUS_CONNECTING = 2,
    BINDSTATUS_REDIRECTING = 3,
    BINDSTATUS_BEGINDOWNLOADDATA = 4,
    BINDSTATUS_DOWNLOADINGDATA = 5,
    BINDSTATUS_ENDDOWNLOADDATA = 6,
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS = 7,
    BINDSTATUS_INSTALLINGCOMPONENTS = 8,
    BINDSTATUS_ENDDOWNLOADCOMPONENTS = 9,
    BINDSTATUS_USINGCACHEDCOPY = 10,
    BINDSTATUS_SENDINGREQUEST = 11,
    BINDSTATUS_CLASSIDAVAILABLE = 12,
    BINDSTATUS_MIMETYPEAVAILABLE = 13,
    BINDSTATUS_CACHEFILENAMEAVAILABLE = 14,
    BINDSTATUS_BEGINSYNCOPERATION = 15,
    BINDSTATUS_ENDSYNCOPERATION = 16,
    BINDSTATUS_BEGINUPLOADDATA = 17,
    BINDSTATUS_UPLOADINGDATA = 18,
    BINDSTATUS_ENDUPLOADDATA = 19,
    BINDSTATUS_PROTOCOLCLASSID = 20,
    BINDSTATUS_ENCODING = 21,
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = 22,
    BINDSTATUS_CLASSINSTALLLOCATION = 23,
    BINDSTATUS_DECODING = 24,
    BINDSTATUS_LOADINGMIMEHANDLER = 25,
    BINDSTATUS_CONTENTDISPOSITIONATTACH = 26,
    BINDSTATUS_FILTERREPORTMIMETYPE = 27,
    BINDSTATUS_CLSIDCANINSTANTIATE = 28,
    BINDSTATUS_IUNKNOWNAVAILABLE = 29,
    BINDSTATUS_DIRECTBIND = 30,
    BINDSTATUS_RAWMIMETYPE = 31,
    BINDSTATUS_PROXYDETECTING = 32,
    BINDSTATUS_ACCEPTRANGES = 33,
    BINDSTATUS_COOKIE_SENT = 34,
    BINDSTATUS_COMPACT_POLICY_RECEIVED = 35,
    BINDSTATUS_COOKIE_SUPPRESSED = 36,
    BINDSTATUS_COOKIE_STATE_UNKNOWN = 37,
    BINDSTATUS_COOKIE_STATE_ACCEPT = 38,
    BINDSTATUS_COOKIE_STATE_REJECT = 39,
    BINDSTATUS_COOKIE_STATE_PROMPT = 40,
    BINDSTATUS_COOKIE_STATE_LEASH = 41,
    BINDSTATUS_COOKIE_STATE_DOWNGRADE = 42,
    BINDSTATUS_POLICY_HREF = 43,
    BINDSTATUS_P3P_HEADER = 44,
    BINDSTATUS_SESSION_COOKIE_RECEIVED = 45,
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = 46,
    BINDSTATUS_SESSION_COOKIES_ALLOWED = 47,
    BINDSTATUS_CACHECONTROL = 48,
    BINDSTATUS_CONTENTDISPOSITIONFILENAME = 49,
    BINDSTATUS_MIMETEXTPLAINMISMATCH = 50,
    BINDSTATUS_PUBLISHERAVAILABLE = 51,
    BINDSTATUS_DISPLAYNAMEAVAILABLE = 52,
    BINDSTATUS_SSLUX_NAVBLOCKED = 53,
    BINDSTATUS_SERVER_MIMETYPEAVAILABLE = 54,
    BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = 55,
    BINDSTATUS_64BIT_PROGRESS = 56,
    BINDSTATUS_RESERVED_0 = 57,
    BINDSTATUS_RESERVED_1 = 58,
    BINDSTATUS_RESERVED_2 = 59,
    BINDSTATUS_RESERVED_3 = 60,
    BINDSTATUS_RESERVED_4 = 61,
    BINDSTATUS_RESERVED_5 = 62,
    BINDSTATUS_RESERVED_6 = 63,
    BINDSTATUS_RESERVED_7 = 64,
    BINDSTATUS_RESERVED_8 = 65,
    BINDSTATUS_RESERVED_9 = 66,
    BINDSTATUS_RESERVED_A = 67,
    BINDSTATUS_RESERVED_B = 68,
    BINDSTATUS_RESERVED_C = 69,
    BINDSTATUS_RESERVED_D = 70,
    BINDSTATUS_RESERVED_E = 71,
    BINDSTATUS_RESERVED_F = 72,
    BINDSTATUS_RESERVED_10 = 73,
    BINDSTATUS_RESERVED_11 = 74,
    BINDSTATUS_RESERVED_12 = 75,
    BINDSTATUS_RESERVED_13 = 76,
    BINDSTATUS_RESERVED_14 = 77,
}
pub use self::tagBINDSTATUS as BINDSTATUS;
extern "C" {
    pub static IID_IBindStatusCallback: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindStatusCallback {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IBindStatusCallback_RemoteGetBindInfo_Proxy(
        This: *mut IBindStatusCallback,
        grfBINDF: *mut DWORD,
        pbindinfo: *mut RemBINDINFO,
        pstgmed: *mut RemSTGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallback_RemoteGetBindInfo_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IBindStatusCallback_RemoteOnDataAvailable_Proxy(
        This: *mut IBindStatusCallback,
        grfBSCF: DWORD,
        dwSize: DWORD,
        pformatetc: *mut RemFORMATETC,
        pstgmed: *mut RemSTGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallback_RemoteOnDataAvailable_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBINDSTATUSCALLBACKEX = *mut IBindStatusCallbackEx;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IBindStatusCallbackEx_0001 {
    BINDF2_DISABLEBASICOVERHTTP = 1,
    BINDF2_DISABLEAUTOCOOKIEHANDLING = 2,
    BINDF2_READ_DATA_GREATER_THAN_4GB = 4,
    BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = 8,
    BINDF2_SETDOWNLOADMODE = 32,
    BINDF2_DISABLE_HTTP_REDIRECT_CACHING = 64,
    BINDF2_KEEP_CALLBACK_MODULE_LOADED = 128,
    BINDF2_ALLOW_PROXY_CRED_PROMPT = 256,
    BINDF2_RESERVED_17 = 512,
    BINDF2_RESERVED_16 = 1024,
    BINDF2_RESERVED_15 = 2048,
    BINDF2_RESERVED_14 = 4096,
    BINDF2_RESERVED_13 = 8192,
    BINDF2_RESERVED_12 = 16384,
    BINDF2_RESERVED_11 = 32768,
    BINDF2_RESERVED_10 = 65536,
    BINDF2_RESERVED_F = 131072,
    BINDF2_RESERVED_E = 262144,
    BINDF2_RESERVED_D = 524288,
    BINDF2_RESERVED_C = 1048576,
    BINDF2_RESERVED_B = 2097152,
    BINDF2_RESERVED_A = 4194304,
    BINDF2_RESERVED_9 = 8388608,
    BINDF2_RESERVED_8 = 16777216,
    BINDF2_RESERVED_7 = 33554432,
    BINDF2_RESERVED_6 = 67108864,
    BINDF2_RESERVED_5 = 134217728,
    BINDF2_RESERVED_4 = 268435456,
    BINDF2_RESERVED_3 = 536870912,
    BINDF2_RESERVED_2 = 1073741824,
    BINDF2_RESERVED_1 = -2147483648,
}
pub use self::__MIDL_IBindStatusCallbackEx_0001 as BINDF2;
extern "C" {
    pub static IID_IBindStatusCallbackEx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindStatusCallbackEx {
    pub _base: IBindStatusCallback,
}
extern "C" {
    pub fn IBindStatusCallbackEx_RemoteGetBindInfoEx_Proxy(
        This: *mut IBindStatusCallbackEx,
        grfBINDF: *mut DWORD,
        pbindinfo: *mut RemBINDINFO,
        pstgmed: *mut RemSTGMEDIUM,
        grfBINDF2: *mut DWORD,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallbackEx_RemoteGetBindInfoEx_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPAUTHENTICATION = *mut IAuthenticate;
extern "C" {
    pub static IID_IAuthenticate: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAuthenticate {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPAUTHENTICATIONEX = *mut IAuthenticateEx;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IAuthenticateEx_0001 {
    AUTHENTICATEF_PROXY = 1,
    AUTHENTICATEF_BASIC = 2,
    AUTHENTICATEF_HTTP = 4,
}
pub use self::__MIDL_IAuthenticateEx_0001 as AUTHENTICATEF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagAUTHENTICATEINFO {
    pub dwFlags: DWORD,
    pub dwReserved: DWORD,
}
pub type AUTHENTICATEINFO = _tagAUTHENTICATEINFO;
extern "C" {
    pub static IID_IAuthenticateEx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAuthenticateEx {
    pub _base: IAuthenticate,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPHTTPNEGOTIATE = *mut IHttpNegotiate;
extern "C" {
    pub static IID_IHttpNegotiate: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHttpNegotiate {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPHTTPNEGOTIATE2 = *mut IHttpNegotiate2;
extern "C" {
    pub static IID_IHttpNegotiate2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHttpNegotiate2 {
    pub _base: IHttpNegotiate,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPHTTPNEGOTIATE3 = *mut IHttpNegotiate3;
extern "C" {
    pub static IID_IHttpNegotiate3: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHttpNegotiate3 {
    pub _base: IHttpNegotiate2,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPWININETFILESTREAM = *mut IWinInetFileStream;
extern "C" {
    pub static IID_IWinInetFileStream: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWinInetFileStream {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPWINDOWFORBINDINGUI = *mut IWindowForBindingUI;
extern "C" {
    pub static IID_IWindowForBindingUI: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWindowForBindingUI {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPCODEINSTALL = *mut ICodeInstall;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_ICodeInstall_0001 {
    CIP_DISK_FULL = 0,
    CIP_ACCESS_DENIED = 1,
    CIP_NEWER_VERSION_EXISTS = 2,
    CIP_OLDER_VERSION_EXISTS = 3,
    CIP_NAME_CONFLICT = 4,
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING = 5,
    CIP_EXE_SELF_REGISTERATION_TIMEOUT = 6,
    CIP_UNSAFE_TO_ABORT = 7,
    CIP_NEED_REBOOT = 8,
    CIP_NEED_REBOOT_UI_PERMISSION = 9,
}
pub use self::__MIDL_ICodeInstall_0001 as CIP_STATUS;
extern "C" {
    pub static IID_ICodeInstall: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICodeInstall {
    pub _base: IWindowForBindingUI,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0014_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0014_v0_0_s_ifspec: RPC_IF_HANDLE;
}
impl __MIDL_IUri_0001 {
    pub const Uri_PROPERTY_STRING_START: __MIDL_IUri_0001 =
        __MIDL_IUri_0001::Uri_PROPERTY_ABSOLUTE_URI;
}
impl __MIDL_IUri_0001 {
    pub const Uri_PROPERTY_STRING_LAST: __MIDL_IUri_0001 = __MIDL_IUri_0001::Uri_PROPERTY_USER_NAME;
}
impl __MIDL_IUri_0001 {
    pub const Uri_PROPERTY_DWORD_START: __MIDL_IUri_0001 = __MIDL_IUri_0001::Uri_PROPERTY_HOST_TYPE;
}
impl __MIDL_IUri_0001 {
    pub const Uri_PROPERTY_DWORD_LAST: __MIDL_IUri_0001 = __MIDL_IUri_0001::Uri_PROPERTY_ZONE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IUri_0001 {
    Uri_PROPERTY_ABSOLUTE_URI = 0,
    Uri_PROPERTY_AUTHORITY = 1,
    Uri_PROPERTY_DISPLAY_URI = 2,
    Uri_PROPERTY_DOMAIN = 3,
    Uri_PROPERTY_EXTENSION = 4,
    Uri_PROPERTY_FRAGMENT = 5,
    Uri_PROPERTY_HOST = 6,
    Uri_PROPERTY_PASSWORD = 7,
    Uri_PROPERTY_PATH = 8,
    Uri_PROPERTY_PATH_AND_QUERY = 9,
    Uri_PROPERTY_QUERY = 10,
    Uri_PROPERTY_RAW_URI = 11,
    Uri_PROPERTY_SCHEME_NAME = 12,
    Uri_PROPERTY_USER_INFO = 13,
    Uri_PROPERTY_USER_NAME = 14,
    Uri_PROPERTY_HOST_TYPE = 15,
    Uri_PROPERTY_PORT = 16,
    Uri_PROPERTY_SCHEME = 17,
    Uri_PROPERTY_ZONE = 18,
}
pub use self::__MIDL_IUri_0001 as Uri_PROPERTY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IUri_0002 {
    Uri_HOST_UNKNOWN = 0,
    Uri_HOST_DNS = 1,
    Uri_HOST_IPV4 = 2,
    Uri_HOST_IPV6 = 3,
    Uri_HOST_IDN = 4,
}
pub use self::__MIDL_IUri_0002 as Uri_HOST_TYPE;
extern "C" {
    pub static IID_IUri: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUri {
    pub _base: IUnknown,
}
extern "C" {
    pub fn CreateUri(
        pwzURI: LPCWSTR,
        dwFlags: DWORD,
        dwReserved: DWORD_PTR,
        ppURI: *mut *mut IUri,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateUriWithFragment(
        pwzURI: LPCWSTR,
        pwzFragment: LPCWSTR,
        dwFlags: DWORD,
        dwReserved: DWORD_PTR,
        ppURI: *mut *mut IUri,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateUriFromMultiByteString(
        pszANSIInputUri: LPCSTR,
        dwEncodingFlags: DWORD,
        dwCodePage: DWORD,
        dwCreateFlags: DWORD,
        dwReserved: DWORD_PTR,
        ppUri: *mut *mut IUri,
    ) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IUriContainer: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUriContainer {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IUriBuilder: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUriBuilder {
    pub _base: IUnknown,
}
extern "C" {
    pub static IID_IUriBuilderFactory: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUriBuilderFactory {
    pub _base: IUnknown,
}
extern "C" {
    pub fn CreateIUriBuilder(
        pIUri: *mut IUri,
        dwFlags: DWORD,
        dwReserved: DWORD_PTR,
        ppIUriBuilder: *mut *mut IUriBuilder,
    ) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPWININETINFO = *mut IWinInetInfo;
extern "C" {
    pub static IID_IWinInetInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWinInetInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IWinInetInfo_RemoteQueryOption_Proxy(
        This: *mut IWinInetInfo,
        dwOption: DWORD,
        pBuffer: *mut BYTE,
        pcbBuf: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IWinInetInfo_RemoteQueryOption_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPHTTPSECURITY = *mut IHttpSecurity;
extern "C" {
    pub static IID_IHttpSecurity: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IHttpSecurity {
    pub _base: IWindowForBindingUI,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPWININETHTTPINFO = *mut IWinInetHttpInfo;
extern "C" {
    pub static IID_IWinInetHttpInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWinInetHttpInfo {
    pub _base: IWinInetInfo,
}
extern "C" {
    pub fn IWinInetHttpInfo_RemoteQueryInfo_Proxy(
        This: *mut IWinInetHttpInfo,
        dwOption: DWORD,
        pBuffer: *mut BYTE,
        pcbBuf: *mut DWORD,
        pdwFlags: *mut DWORD,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IWinInetHttpInfo_RemoteQueryInfo_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IWinInetHttpTimeouts: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWinInetHttpTimeouts {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPWININETCACHEHINTS = *mut IWinInetCacheHints;
extern "C" {
    pub static IID_IWinInetCacheHints: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWinInetCacheHints {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPWININETCACHEHINTS2 = *mut IWinInetCacheHints2;
extern "C" {
    pub static IID_IWinInetCacheHints2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWinInetCacheHints2 {
    pub _base: IWinInetCacheHints,
}
extern "C" {
    pub static SID_BindHost: GUID;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBINDHOST = *mut IBindHost;
extern "C" {
    pub static IID_IBindHost: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindHost {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IBindHost_RemoteMonikerBindToStorage_Proxy(
        This: *mut IBindHost,
        pMk: *mut IMoniker,
        pBC: *mut IBindCtx,
        pBSC: *mut IBindStatusCallback,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindHost_RemoteMonikerBindToStorage_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn IBindHost_RemoteMonikerBindToObject_Proxy(
        This: *mut IBindHost,
        pMk: *mut IMoniker,
        pBC: *mut IBindCtx,
        pBSC: *mut IBindStatusCallback,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindHost_RemoteMonikerBindToObject_Stub(
        This: *mut IRpcStubBuffer,
        _pRpcChannelBuffer: *mut IRpcChannelBuffer,
        _pRpcMessage: PRPC_MESSAGE,
        _pdwStubPhase: *mut DWORD,
    );
}
extern "C" {
    pub fn HlinkSimpleNavigateToString(
        szTarget: LPCWSTR,
        szLocation: LPCWSTR,
        szTargetFrameName: LPCWSTR,
        pUnk: *mut IUnknown,
        pbc: *mut IBindCtx,
        arg1: *mut IBindStatusCallback,
        grfHLNF: DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn HlinkSimpleNavigateToMoniker(
        pmkTarget: *mut IMoniker,
        szLocation: LPCWSTR,
        szTargetFrameName: LPCWSTR,
        pUnk: *mut IUnknown,
        pbc: *mut IBindCtx,
        arg1: *mut IBindStatusCallback,
        grfHLNF: DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLOpenStreamA(
        arg1: LPUNKNOWN,
        arg2: LPCSTR,
        arg3: DWORD,
        arg4: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLOpenStreamW(
        arg1: LPUNKNOWN,
        arg2: LPCWSTR,
        arg3: DWORD,
        arg4: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLOpenPullStreamA(
        arg1: LPUNKNOWN,
        arg2: LPCSTR,
        arg3: DWORD,
        arg4: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLOpenPullStreamW(
        arg1: LPUNKNOWN,
        arg2: LPCWSTR,
        arg3: DWORD,
        arg4: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLDownloadToFileA(
        arg1: LPUNKNOWN,
        arg2: LPCSTR,
        arg3: LPCSTR,
        arg4: DWORD,
        arg5: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLDownloadToFileW(
        arg1: LPUNKNOWN,
        arg2: LPCWSTR,
        arg3: LPCWSTR,
        arg4: DWORD,
        arg5: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLDownloadToCacheFileA(
        arg1: LPUNKNOWN,
        arg2: LPCSTR,
        arg3: LPSTR,
        cchFileName: DWORD,
        arg4: DWORD,
        arg5: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLDownloadToCacheFileW(
        arg1: LPUNKNOWN,
        arg2: LPCWSTR,
        arg3: LPWSTR,
        cchFileName: DWORD,
        arg4: DWORD,
        arg5: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLOpenBlockingStreamA(
        arg1: LPUNKNOWN,
        arg2: LPCSTR,
        arg3: *mut LPSTREAM,
        arg4: DWORD,
        arg5: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn URLOpenBlockingStreamW(
        arg1: LPUNKNOWN,
        arg2: LPCWSTR,
        arg3: *mut LPSTREAM,
        arg4: DWORD,
        arg5: LPBINDSTATUSCALLBACK,
    ) -> HRESULT;
}
extern "C" {
    pub fn HlinkGoBack(pUnk: *mut IUnknown) -> HRESULT;
}
extern "C" {
    pub fn HlinkGoForward(pUnk: *mut IUnknown) -> HRESULT;
}
extern "C" {
    pub fn HlinkNavigateString(pUnk: *mut IUnknown, szTarget: LPCWSTR) -> HRESULT;
}
extern "C" {
    pub fn HlinkNavigateMoniker(pUnk: *mut IUnknown, pmkTarget: *mut IMoniker) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNET = *mut IInternet;
extern "C" {
    pub static IID_IInternet: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternet {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETBINDINFO = *mut IInternetBindInfo;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagBINDSTRING {
    BINDSTRING_HEADERS = 1,
    BINDSTRING_ACCEPT_MIMES = 2,
    BINDSTRING_EXTRA_URL = 3,
    BINDSTRING_LANGUAGE = 4,
    BINDSTRING_USERNAME = 5,
    BINDSTRING_PASSWORD = 6,
    BINDSTRING_UA_PIXELS = 7,
    BINDSTRING_UA_COLOR = 8,
    BINDSTRING_OS = 9,
    BINDSTRING_USER_AGENT = 10,
    BINDSTRING_ACCEPT_ENCODINGS = 11,
    BINDSTRING_POST_COOKIE = 12,
    BINDSTRING_POST_DATA_MIME = 13,
    BINDSTRING_URL = 14,
    BINDSTRING_IID = 15,
    BINDSTRING_FLAG_BIND_TO_OBJECT = 16,
    BINDSTRING_PTR_BIND_CONTEXT = 17,
    BINDSTRING_XDR_ORIGIN = 18,
    BINDSTRING_DOWNLOADPATH = 19,
    BINDSTRING_ROOTDOC_URL = 20,
    BINDSTRING_INITIAL_FILENAME = 21,
    BINDSTRING_PROXY_USERNAME = 22,
    BINDSTRING_PROXY_PASSWORD = 23,
    BINDSTRING_ENTERPRISE_ID = 24,
    BINDSTRING_DOC_URL = 25,
    BINDSTRING_SAMESITE_COOKIE_LEVEL = 26,
}
pub use self::tagBINDSTRING as BINDSTRING;
extern "C" {
    pub static IID_IInternetBindInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetBindInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETBINDINFOEX = *mut IInternetBindInfoEx;
extern "C" {
    pub static IID_IInternetBindInfoEx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetBindInfoEx {
    pub _base: IInternetBindInfo,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETPROTOCOLROOT = *mut IInternetProtocolRoot;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _tagPI_FLAGS {
    PI_PARSE_URL = 1,
    PI_FILTER_MODE = 2,
    PI_FORCE_ASYNC = 4,
    PI_USE_WORKERTHREAD = 8,
    PI_MIMEVERIFICATION = 16,
    PI_CLSIDLOOKUP = 32,
    PI_DATAPROGRESS = 64,
    PI_SYNCHRONOUS = 128,
    PI_APARTMENTTHREADED = 256,
    PI_CLASSINSTALL = 512,
    PI_PASSONBINDCTX = 8192,
    PI_NOMIMEHANDLER = 32768,
    PI_LOADAPPDIRECT = 16384,
    PD_FORCE_SWITCH = 65536,
    PI_PREFERDEFAULTHANDLER = 131072,
}
pub use self::_tagPI_FLAGS as PI_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagPROTOCOLDATA {
    pub grfFlags: DWORD,
    pub dwState: DWORD,
    pub pData: LPVOID,
    pub cbData: ULONG,
}
pub type PROTOCOLDATA = _tagPROTOCOLDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagStartParam {
    pub iid: IID,
    pub pIBindCtx: *mut IBindCtx,
    pub pItf: *mut IUnknown,
}
pub type StartParam = _tagStartParam;
extern "C" {
    pub static IID_IInternetProtocolRoot: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetProtocolRoot {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETPROTOCOL = *mut IInternetProtocol;
extern "C" {
    pub static IID_IInternetProtocol: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetProtocol {
    pub _base: IInternetProtocolRoot,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetProtocolEx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetProtocolEx {
    pub _base: IInternetProtocol,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETPROTOCOLSINK = *mut IInternetProtocolSink;
extern "C" {
    pub static IID_IInternetProtocolSink: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetProtocolSink {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETPROTOCOLSINKStackable = *mut IInternetProtocolSinkStackable;
extern "C" {
    pub static IID_IInternetProtocolSinkStackable: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetProtocolSinkStackable {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETSESSION = *mut IInternetSession;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _tagOIBDG_FLAGS {
    OIBDG_APARTMENTTHREADED = 256,
    OIBDG_DATAONLY = 4096,
}
pub use self::_tagOIBDG_FLAGS as OIBDG_FLAGS;
extern "C" {
    pub static IID_IInternetSession: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetSession {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETTHREADSWITCH = *mut IInternetThreadSwitch;
extern "C" {
    pub static IID_IInternetThreadSwitch: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetThreadSwitch {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETPRIORITY = *mut IInternetPriority;
extern "C" {
    pub static IID_IInternetPriority: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetPriority {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIINTERNETPROTOCOLINFO = *mut IInternetProtocolInfo;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _tagPARSEACTION {
    PARSE_CANONICALIZE = 1,
    PARSE_FRIENDLY = 2,
    PARSE_SECURITY_URL = 3,
    PARSE_ROOTDOCUMENT = 4,
    PARSE_DOCUMENT = 5,
    PARSE_ANCHOR = 6,
    PARSE_ENCODE_IS_UNESCAPE = 7,
    PARSE_DECODE_IS_ESCAPE = 8,
    PARSE_PATH_FROM_URL = 9,
    PARSE_URL_FROM_PATH = 10,
    PARSE_MIME = 11,
    PARSE_SERVER = 12,
    PARSE_SCHEMA = 13,
    PARSE_SITE = 14,
    PARSE_DOMAIN = 15,
    PARSE_LOCATION = 16,
    PARSE_SECURITY_DOMAIN = 17,
    PARSE_ESCAPE = 18,
    PARSE_UNESCAPE = 19,
}
pub use self::_tagPARSEACTION as PARSEACTION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _tagPSUACTION {
    PSU_DEFAULT = 1,
    PSU_SECURITY_URL_ONLY = 2,
}
pub use self::_tagPSUACTION as PSUACTION;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _tagQUERYOPTION {
    QUERY_EXPIRATION_DATE = 1,
    QUERY_TIME_OF_LAST_CHANGE = 2,
    QUERY_CONTENT_ENCODING = 3,
    QUERY_CONTENT_TYPE = 4,
    QUERY_REFRESH = 5,
    QUERY_RECOMBINE = 6,
    QUERY_CAN_NAVIGATE = 7,
    QUERY_USES_NETWORK = 8,
    QUERY_IS_CACHED = 9,
    QUERY_IS_INSTALLEDENTRY = 10,
    QUERY_IS_CACHED_OR_MAPPED = 11,
    QUERY_USES_CACHE = 12,
    QUERY_IS_SECURE = 13,
    QUERY_IS_SAFE = 14,
    QUERY_USES_HISTORYFOLDER = 15,
    QUERY_IS_CACHED_AND_USABLE_OFFLINE = 16,
}
pub use self::_tagQUERYOPTION as QUERYOPTION;
extern "C" {
    pub static IID_IInternetProtocolInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetProtocolInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub fn CoInternetParseUrl(
        pwzUrl: LPCWSTR,
        ParseAction: PARSEACTION,
        dwFlags: DWORD,
        pszResult: LPWSTR,
        cchResult: DWORD,
        pcchResult: *mut DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetParseIUri(
        pIUri: *mut IUri,
        ParseAction: PARSEACTION,
        dwFlags: DWORD,
        pwzResult: LPWSTR,
        cchResult: DWORD,
        pcchResult: *mut DWORD,
        dwReserved: DWORD_PTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetCombineUrl(
        pwzBaseUrl: LPCWSTR,
        pwzRelativeUrl: LPCWSTR,
        dwCombineFlags: DWORD,
        pszResult: LPWSTR,
        cchResult: DWORD,
        pcchResult: *mut DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetCombineUrlEx(
        pBaseUri: *mut IUri,
        pwzRelativeUrl: LPCWSTR,
        dwCombineFlags: DWORD,
        ppCombinedUri: *mut *mut IUri,
        dwReserved: DWORD_PTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetCombineIUri(
        pBaseUri: *mut IUri,
        pRelativeUri: *mut IUri,
        dwCombineFlags: DWORD,
        ppCombinedUri: *mut *mut IUri,
        dwReserved: DWORD_PTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetCompareUrl(pwzUrl1: LPCWSTR, pwzUrl2: LPCWSTR, dwFlags: DWORD) -> HRESULT;
}
extern "C" {
    pub fn CoInternetGetProtocolFlags(
        pwzUrl: LPCWSTR,
        pdwFlags: *mut DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetQueryInfo(
        pwzUrl: LPCWSTR,
        QueryOptions: QUERYOPTION,
        dwQueryFlags: DWORD,
        pvBuffer: LPVOID,
        cbBuffer: DWORD,
        pcbBuffer: *mut DWORD,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetGetSession(
        dwSessionMode: DWORD,
        ppIInternetSession: *mut *mut IInternetSession,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetGetSecurityUrl(
        pwszUrl: LPCWSTR,
        ppwszSecUrl: *mut LPWSTR,
        psuAction: PSUACTION,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn AsyncInstallDistributionUnit(
        szDistUnit: LPCWSTR,
        szTYPE: LPCWSTR,
        szExt: LPCWSTR,
        dwFileVersionMS: DWORD,
        dwFileVersionLS: DWORD,
        szURL: LPCWSTR,
        pbc: *mut IBindCtx,
        pvReserved: LPVOID,
        flags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetGetSecurityUrlEx(
        pUri: *mut IUri,
        ppSecUri: *mut *mut IUri,
        psuAction: PSUACTION,
        dwReserved: DWORD_PTR,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _tagINTERNETFEATURELIST {
    FEATURE_OBJECT_CACHING = 0,
    FEATURE_ZONE_ELEVATION = 1,
    FEATURE_MIME_HANDLING = 2,
    FEATURE_MIME_SNIFFING = 3,
    FEATURE_WINDOW_RESTRICTIONS = 4,
    FEATURE_WEBOC_POPUPMANAGEMENT = 5,
    FEATURE_BEHAVIORS = 6,
    FEATURE_DISABLE_MK_PROTOCOL = 7,
    FEATURE_LOCALMACHINE_LOCKDOWN = 8,
    FEATURE_SECURITYBAND = 9,
    FEATURE_RESTRICT_ACTIVEXINSTALL = 10,
    FEATURE_VALIDATE_NAVIGATE_URL = 11,
    FEATURE_RESTRICT_FILEDOWNLOAD = 12,
    FEATURE_ADDON_MANAGEMENT = 13,
    FEATURE_PROTOCOL_LOCKDOWN = 14,
    FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = 15,
    FEATURE_SAFE_BINDTOOBJECT = 16,
    FEATURE_UNC_SAVEDFILECHECK = 17,
    FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = 18,
    FEATURE_TABBED_BROWSING = 19,
    FEATURE_SSLUX = 20,
    FEATURE_DISABLE_NAVIGATION_SOUNDS = 21,
    FEATURE_DISABLE_LEGACY_COMPRESSION = 22,
    FEATURE_FORCE_ADDR_AND_STATUS = 23,
    FEATURE_XMLHTTP = 24,
    FEATURE_DISABLE_TELNET_PROTOCOL = 25,
    FEATURE_FEEDS = 26,
    FEATURE_BLOCK_INPUT_PROMPTS = 27,
    FEATURE_ENTRY_COUNT = 28,
}
pub use self::_tagINTERNETFEATURELIST as INTERNETFEATURELIST;
extern "C" {
    pub fn CoInternetSetFeatureEnabled(
        FeatureEntry: INTERNETFEATURELIST,
        dwFlags: DWORD,
        fEnable: BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetIsFeatureEnabled(FeatureEntry: INTERNETFEATURELIST, dwFlags: DWORD)
        -> HRESULT;
}
extern "C" {
    pub fn CoInternetIsFeatureEnabledForUrl(
        FeatureEntry: INTERNETFEATURELIST,
        dwFlags: DWORD,
        szURL: LPCWSTR,
        pSecMgr: *mut IInternetSecurityManager,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetIsFeatureEnabledForIUri(
        FeatureEntry: INTERNETFEATURELIST,
        dwFlags: DWORD,
        pIUri: *mut IUri,
        pSecMgr: *mut IInternetSecurityManagerEx2,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetIsFeatureZoneElevationEnabled(
        szFromURL: LPCWSTR,
        szToURL: LPCWSTR,
        pSecMgr: *mut IInternetSecurityManager,
        dwFlags: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CopyStgMedium(pcstgmedSrc: *const STGMEDIUM, pstgmedDest: *mut STGMEDIUM) -> HRESULT;
}
extern "C" {
    pub fn CopyBindInfo(pcbiSrc: *const BINDINFO, pbiDest: *mut BINDINFO) -> HRESULT;
}
extern "C" {
    pub fn ReleaseBindInfo(pbindinfo: *mut BINDINFO);
}
extern "C" {
    pub fn IEGetUserPrivateNamespaceName() -> PWSTR;
}
extern "C" {
    pub fn CoInternetCreateSecurityManager(
        pSP: *mut IServiceProvider,
        ppSM: *mut *mut IInternetSecurityManager,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn CoInternetCreateZoneManager(
        pSP: *mut IServiceProvider,
        ppZM: *mut *mut IInternetZoneManager,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub static CLSID_InternetSecurityManager: IID;
}
extern "C" {
    pub static CLSID_InternetZoneManager: IID;
}
extern "C" {
    pub static CLSID_PersistentZoneIdentifier: IID;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetSecurityMgrSite: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetSecurityMgrSite {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec: RPC_IF_HANDLE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IInternetSecurityManager_0001 {
    PUAF_DEFAULT = 0,
    PUAF_NOUI = 1,
    PUAF_ISFILE = 2,
    PUAF_WARN_IF_DENIED = 4,
    PUAF_FORCEUI_FOREGROUND = 8,
    PUAF_CHECK_TIFS = 16,
    PUAF_DONTCHECKBOXINDIALOG = 32,
    PUAF_TRUSTED = 64,
    PUAF_ACCEPT_WILDCARD_SCHEME = 128,
    PUAF_ENFORCERESTRICTED = 256,
    PUAF_NOSAVEDFILECHECK = 512,
    PUAF_REQUIRESAVEDFILECHECK = 1024,
    PUAF_DONT_USE_CACHE = 4096,
    PUAF_RESERVED1 = 8192,
    PUAF_RESERVED2 = 16384,
    PUAF_LMZ_UNLOCKED = 65536,
    PUAF_LMZ_LOCKED = 131072,
    PUAF_DEFAULTZONEPOL = 262144,
    PUAF_NPL_USE_LOCKED_IF_RESTRICTED = 524288,
    PUAF_NOUIIFLOCKED = 1048576,
    PUAF_DRAGPROTOCOLCHECK = 2097152,
}
pub use self::__MIDL_IInternetSecurityManager_0001 as PUAF;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IInternetSecurityManager_0002 {
    PUAFOUT_DEFAULT = 0,
    PUAFOUT_ISLOCKZONEPOLICY = 1,
}
pub use self::__MIDL_IInternetSecurityManager_0002 as PUAFOUT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IInternetSecurityManager_0003 {
    SZM_CREATE = 0,
    SZM_DELETE = 1,
}
pub use self::__MIDL_IInternetSecurityManager_0003 as SZM_FLAGS;
extern "C" {
    pub static IID_IInternetSecurityManager: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetSecurityManager {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetSecurityManagerEx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetSecurityManagerEx {
    pub _base: IInternetSecurityManager,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetSecurityManagerEx2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetSecurityManagerEx2 {
    pub _base: IInternetSecurityManagerEx,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IZoneIdentifier: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IZoneIdentifier {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IZoneIdentifier2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IZoneIdentifier2 {
    pub _base: IZoneIdentifier,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetHostSecurityManager: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetHostSecurityManager {
    pub _base: IUnknown,
}
extern "C" {
    pub static GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED: GUID;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPURLZONEMANAGER = *mut IInternetZoneManager;
impl tagURLZONE {
    pub const URLZONE_LOCAL_MACHINE: tagURLZONE = tagURLZONE::URLZONE_PREDEFINED_MIN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagURLZONE {
    URLZONE_INVALID = -1,
    URLZONE_PREDEFINED_MIN = 0,
    URLZONE_INTRANET = 1,
    URLZONE_TRUSTED = 2,
    URLZONE_INTERNET = 3,
    URLZONE_UNTRUSTED = 4,
    URLZONE_PREDEFINED_MAX = 999,
    URLZONE_USER_MIN = 1000,
    URLZONE_USER_MAX = 10000,
}
pub use self::tagURLZONE as URLZONE;
impl tagURLTEMPLATE {
    pub const URLTEMPLATE_LOW: tagURLTEMPLATE = tagURLTEMPLATE::URLTEMPLATE_PREDEFINED_MIN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagURLTEMPLATE {
    URLTEMPLATE_CUSTOM = 0,
    URLTEMPLATE_PREDEFINED_MIN = 65536,
    URLTEMPLATE_MEDLOW = 66816,
    URLTEMPLATE_MEDIUM = 69632,
    URLTEMPLATE_MEDHIGH = 70912,
    URLTEMPLATE_HIGH = 73728,
    URLTEMPLATE_PREDEFINED_MAX = 131072,
}
pub use self::tagURLTEMPLATE as URLTEMPLATE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IInternetZoneManager_0001 {
    MAX_ZONE_PATH = 260,
    MAX_ZONE_DESCRIPTION = 200,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IInternetZoneManager_0002 {
    ZAFLAGS_CUSTOM_EDIT = 1,
    ZAFLAGS_ADD_SITES = 2,
    ZAFLAGS_REQUIRE_VERIFICATION = 4,
    ZAFLAGS_INCLUDE_PROXY_OVERRIDE = 8,
    ZAFLAGS_INCLUDE_INTRANET_SITES = 16,
    ZAFLAGS_NO_UI = 32,
    ZAFLAGS_SUPPORTS_VERIFICATION = 64,
    ZAFLAGS_UNC_AS_INTRANET = 128,
    ZAFLAGS_DETECT_INTRANET = 256,
    ZAFLAGS_USE_LOCKED_ZONES = 65536,
    ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = 131072,
    ZAFLAGS_NO_CACHE = 262144,
}
pub use self::__MIDL_IInternetZoneManager_0002 as ZAFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ZONEATTRIBUTES {
    pub cbSize: ULONG,
    pub szDisplayName: [WCHAR; 260usize],
    pub szDescription: [WCHAR; 200usize],
    pub szIconPath: [WCHAR; 260usize],
    pub dwTemplateMinLevel: DWORD,
    pub dwTemplateRecommended: DWORD,
    pub dwTemplateCurrentLevel: DWORD,
    pub dwFlags: DWORD,
}
pub type ZONEATTRIBUTES = _ZONEATTRIBUTES;
pub type LPZONEATTRIBUTES = *mut _ZONEATTRIBUTES;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _URLZONEREG {
    URLZONEREG_DEFAULT = 0,
    URLZONEREG_HKLM = 1,
    URLZONEREG_HKCU = 2,
}
pub use self::_URLZONEREG as URLZONEREG;
extern "C" {
    pub static IID_IInternetZoneManager: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetZoneManager {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetZoneManagerEx: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetZoneManagerEx {
    pub _base: IInternetZoneManager,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IInternetZoneManagerEx2: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IInternetZoneManagerEx2 {
    pub _base: IInternetZoneManagerEx,
}
extern "C" {
    pub static CLSID_SoftDistExt: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagCODEBASEHOLD {
    pub cbSize: ULONG,
    pub szDistUnit: LPWSTR,
    pub szCodeBase: LPWSTR,
    pub dwVersionMS: DWORD,
    pub dwVersionLS: DWORD,
    pub dwStyle: DWORD,
}
pub type CODEBASEHOLD = _tagCODEBASEHOLD;
pub type LPCODEBASEHOLD = *mut _tagCODEBASEHOLD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagSOFTDISTINFO {
    pub cbSize: ULONG,
    pub dwFlags: DWORD,
    pub dwAdState: DWORD,
    pub szTitle: LPWSTR,
    pub szAbstract: LPWSTR,
    pub szHREF: LPWSTR,
    pub dwInstalledVersionMS: DWORD,
    pub dwInstalledVersionLS: DWORD,
    pub dwUpdateVersionMS: DWORD,
    pub dwUpdateVersionLS: DWORD,
    pub dwAdvertisedVersionMS: DWORD,
    pub dwAdvertisedVersionLS: DWORD,
    pub dwReserved: DWORD,
}
pub type SOFTDISTINFO = _tagSOFTDISTINFO;
pub type LPSOFTDISTINFO = *mut _tagSOFTDISTINFO;
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_ISoftDistExt: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISoftDistExt {
    pub _base: IUnknown,
}
extern "C" {
    pub fn GetSoftwareUpdateInfo(szDistUnit: LPCWSTR, psdi: LPSOFTDISTINFO) -> HRESULT;
}
extern "C" {
    pub fn SetSoftwareUpdateAdvertisementState(
        szDistUnit: LPCWSTR,
        dwAdState: DWORD,
        dwAdvertisedVersionMS: DWORD,
        dwAdvertisedVersionLS: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPCATALOGFILEINFO = *mut ICatalogFileInfo;
extern "C" {
    pub static IID_ICatalogFileInfo: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICatalogFileInfo {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0049_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0049_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPDATAFILTER = *mut IDataFilter;
extern "C" {
    pub static IID_IDataFilter: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDataFilter {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagPROTOCOLFILTERDATA {
    pub cbSize: DWORD,
    pub pProtocolSink: *mut IInternetProtocolSink,
    pub pProtocol: *mut IInternetProtocol,
    pub pUnk: *mut IUnknown,
    pub dwFilterFlags: DWORD,
}
pub type PROTOCOLFILTERDATA = _tagPROTOCOLFILTERDATA;
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0050_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0050_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPENCODINGFILTERFACTORY = *mut IEncodingFilterFactory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagDATAINFO {
    pub ulTotalSize: ULONG,
    pub ulavrPacketSize: ULONG,
    pub ulConnectSpeed: ULONG,
    pub ulProcessorSpeed: ULONG,
}
pub type DATAINFO = _tagDATAINFO;
extern "C" {
    pub static IID_IEncodingFilterFactory: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEncodingFilterFactory {
    pub _base: IUnknown,
}
extern "C" {
    pub fn IsLoggingEnabledA(pszUrl: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn IsLoggingEnabledW(pwszUrl: LPCWSTR) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagHIT_LOGGING_INFO {
    pub dwStructSize: DWORD,
    pub lpszLoggedUrlName: LPSTR,
    pub StartTime: SYSTEMTIME,
    pub EndTime: SYSTEMTIME,
    pub lpszExtendedInfo: LPSTR,
}
pub type HIT_LOGGING_INFO = _tagHIT_LOGGING_INFO;
pub type LPHIT_LOGGING_INFO = *mut _tagHIT_LOGGING_INFO;
extern "C" {
    pub fn WriteHitLogging(lpLogginginfo: LPHIT_LOGGING_INFO) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CONFIRMSAFETY {
    pub clsid: CLSID,
    pub pUnk: *mut IUnknown,
    pub dwFlags: DWORD,
}
extern "C" {
    pub static GUID_CUSTOM_CONFIRMOBJECTSAFETY: GUID;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0051_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0051_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPIWRAPPEDPROTOCOL = *mut IWrappedProtocol;
extern "C" {
    pub static IID_IWrappedProtocol: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWrappedProtocol {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0052_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0052_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPGETBINDHANDLE = *mut IGetBindHandle;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __MIDL_IGetBindHandle_0001 {
    BINDHANDLETYPES_APPCACHE = 0,
    BINDHANDLETYPES_DEPENDENCY = 1,
    BINDHANDLETYPES_COUNT = 2,
}
pub use self::__MIDL_IGetBindHandle_0001 as BINDHANDLETYPES;
extern "C" {
    pub static IID_IGetBindHandle: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IGetBindHandle {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagPROTOCOL_ARGUMENT {
    pub szMethod: LPCWSTR,
    pub szTargetUrl: LPCWSTR,
}
pub type PROTOCOL_ARGUMENT = _tagPROTOCOL_ARGUMENT;
pub type LPPROTOCOL_ARGUMENT = *mut _tagPROTOCOL_ARGUMENT;
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0053_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0053_v0_0_s_ifspec: RPC_IF_HANDLE;
}
pub type LPBINDCALLBACKREDIRECT = *mut IBindCallbackRedirect;
extern "C" {
    pub static IID_IBindCallbackRedirect: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindCallbackRedirect {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0054_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0054_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static IID_IBindHttpSecurity: IID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindHttpSecurity {
    pub _base: IUnknown,
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0055_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_urlmon_0000_0055_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn IBinding_GetBindResult_Proxy(
        This: *mut IBinding,
        pclsidProtocol: *mut CLSID,
        pdwResult: *mut DWORD,
        pszResult: *mut LPOLESTR,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBinding_GetBindResult_Stub(
        This: *mut IBinding,
        pclsidProtocol: *mut CLSID,
        pdwResult: *mut DWORD,
        pszResult: *mut LPOLESTR,
        dwReserved: DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallback_GetBindInfo_Proxy(
        This: *mut IBindStatusCallback,
        grfBINDF: *mut DWORD,
        pbindinfo: *mut BINDINFO,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallback_GetBindInfo_Stub(
        This: *mut IBindStatusCallback,
        grfBINDF: *mut DWORD,
        pbindinfo: *mut RemBINDINFO,
        pstgmed: *mut RemSTGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallback_OnDataAvailable_Proxy(
        This: *mut IBindStatusCallback,
        grfBSCF: DWORD,
        dwSize: DWORD,
        pformatetc: *mut FORMATETC,
        pstgmed: *mut STGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallback_OnDataAvailable_Stub(
        This: *mut IBindStatusCallback,
        grfBSCF: DWORD,
        dwSize: DWORD,
        pformatetc: *mut RemFORMATETC,
        pstgmed: *mut RemSTGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallbackEx_GetBindInfoEx_Proxy(
        This: *mut IBindStatusCallbackEx,
        grfBINDF: *mut DWORD,
        pbindinfo: *mut BINDINFO,
        grfBINDF2: *mut DWORD,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindStatusCallbackEx_GetBindInfoEx_Stub(
        This: *mut IBindStatusCallbackEx,
        grfBINDF: *mut DWORD,
        pbindinfo: *mut RemBINDINFO,
        pstgmed: *mut RemSTGMEDIUM,
        grfBINDF2: *mut DWORD,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IWinInetInfo_QueryOption_Proxy(
        This: *mut IWinInetInfo,
        dwOption: DWORD,
        pBuffer: LPVOID,
        pcbBuf: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IWinInetInfo_QueryOption_Stub(
        This: *mut IWinInetInfo,
        dwOption: DWORD,
        pBuffer: *mut BYTE,
        pcbBuf: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IWinInetHttpInfo_QueryInfo_Proxy(
        This: *mut IWinInetHttpInfo,
        dwOption: DWORD,
        pBuffer: LPVOID,
        pcbBuf: *mut DWORD,
        pdwFlags: *mut DWORD,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IWinInetHttpInfo_QueryInfo_Stub(
        This: *mut IWinInetHttpInfo,
        dwOption: DWORD,
        pBuffer: *mut BYTE,
        pcbBuf: *mut DWORD,
        pdwFlags: *mut DWORD,
        pdwReserved: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindHost_MonikerBindToStorage_Proxy(
        This: *mut IBindHost,
        pMk: *mut IMoniker,
        pBC: *mut IBindCtx,
        pBSC: *mut IBindStatusCallback,
        riid: *const IID,
        ppvObj: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindHost_MonikerBindToStorage_Stub(
        This: *mut IBindHost,
        pMk: *mut IMoniker,
        pBC: *mut IBindCtx,
        pBSC: *mut IBindStatusCallback,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindHost_MonikerBindToObject_Proxy(
        This: *mut IBindHost,
        pMk: *mut IMoniker,
        pBC: *mut IBindCtx,
        pBSC: *mut IBindStatusCallback,
        riid: *const IID,
        ppvObj: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn IBindHost_MonikerBindToObject_Stub(
        This: *mut IBindHost,
        pMk: *mut IMoniker,
        pBC: *mut IBindCtx,
        pBSC: *mut IBindStatusCallback,
        riid: *const IID,
        ppvObj: *mut *mut IUnknown,
    ) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PIDMSI_STATUS_VALUE {
    PIDMSI_STATUS_NORMAL = 0,
    PIDMSI_STATUS_NEW = 1,
    PIDMSI_STATUS_PRELIM = 2,
    PIDMSI_STATUS_DRAFT = 3,
    PIDMSI_STATUS_INPROGRESS = 4,
    PIDMSI_STATUS_EDIT = 5,
    PIDMSI_STATUS_REVIEW = 6,
    PIDMSI_STATUS_PROOF = 7,
    PIDMSI_STATUS_FINAL = 8,
    PIDMSI_STATUS_OTHER = 32767,
}
extern "C" {
    pub fn PropVariantInit(pvar: *mut PROPVARIANT);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALIZEDPROPERTYVALUE {
    pub dwType: DWORD,
    pub rgb: [BYTE; 1usize],
}
pub type SERIALIZEDPROPERTYVALUE = tagSERIALIZEDPROPERTYVALUE;
extern "C" {
    pub fn StgConvertVariantToProperty(
        pvar: *const PROPVARIANT,
        CodePage: USHORT,
        pprop: *mut SERIALIZEDPROPERTYVALUE,
        pcb: *mut ULONG,
        pid: PROPID,
        fReserved: BOOLEAN,
        pcIndirect: *mut ULONG,
    ) -> *mut SERIALIZEDPROPERTYVALUE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PMemoryAllocator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn StgConvertPropertyToVariant(
        pprop: *const SERIALIZEDPROPERTYVALUE,
        CodePage: USHORT,
        pvar: *mut PROPVARIANT,
        pma: *mut PMemoryAllocator,
    ) -> BOOLEAN;
}
extern "C" {
    pub static mut __MIDL_itf_propidl_0000_0004_v0_0_c_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub static mut __MIDL_itf_propidl_0000_0004_v0_0_s_ifspec: RPC_IF_HANDLE;
}
extern "C" {
    pub fn CreateStdProgressIndicator(
        hwndParent: HWND,
        pszTitle: LPCOLESTR,
        pIbscCaller: *mut IBindStatusCallback,
        ppIbsc: *mut *mut IBindStatusCallback,
    ) -> HRESULT;
}
extern "C" {
    pub static IID_StdOle: IID;
}
extern "C" {
    pub fn SysAllocString(psz: *const OLECHAR) -> BSTR;
}
extern "C" {
    pub fn SysReAllocString(pbstr: *mut BSTR, psz: *const OLECHAR) -> INT;
}
extern "C" {
    pub fn SysAllocStringLen(strIn: *const OLECHAR, ui: UINT) -> BSTR;
}
extern "C" {
    pub fn SysReAllocStringLen(
        pbstr: *mut BSTR,
        psz: *const OLECHAR,
        len: ::std::os::raw::c_uint,
    ) -> INT;
}
extern "C" {
    pub fn SysAddRefString(bstrString: BSTR) -> HRESULT;
}
extern "C" {
    pub fn SysReleaseString(bstrString: BSTR);
}
extern "C" {
    pub fn SysFreeString(bstrString: BSTR);
}
extern "C" {
    pub fn SysStringLen(pbstr: BSTR) -> UINT;
}
extern "C" {
    pub fn SysStringByteLen(bstr: BSTR) -> UINT;
}
extern "C" {
    pub fn SysAllocStringByteLen(psz: LPCSTR, len: UINT) -> BSTR;
}
extern "C" {
    pub fn DosDateTimeToVariantTime(wDosDate: USHORT, wDosTime: USHORT, pvtime: *mut DOUBLE)
        -> INT;
}
extern "C" {
    pub fn VariantTimeToDosDateTime(
        vtime: DOUBLE,
        pwDosDate: *mut USHORT,
        pwDosTime: *mut USHORT,
    ) -> INT;
}
extern "C" {
    pub fn SystemTimeToVariantTime(lpSystemTime: LPSYSTEMTIME, pvtime: *mut DOUBLE) -> INT;
}
extern "C" {
    pub fn VariantTimeToSystemTime(vtime: DOUBLE, lpSystemTime: LPSYSTEMTIME) -> INT;
}
extern "C" {
    pub fn SafeArrayAllocDescriptor(cDims: UINT, ppsaOut: *mut *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayAllocDescriptorEx(
        vt: VARTYPE,
        cDims: UINT,
        ppsaOut: *mut *mut SAFEARRAY,
    ) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayAllocData(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayCreate(
        vt: VARTYPE,
        cDims: UINT,
        rgsabound: *mut SAFEARRAYBOUND,
    ) -> *mut SAFEARRAY;
}
extern "C" {
    pub fn SafeArrayCreateEx(
        vt: VARTYPE,
        cDims: UINT,
        rgsabound: *mut SAFEARRAYBOUND,
        pvExtra: PVOID,
    ) -> *mut SAFEARRAY;
}
extern "C" {
    pub fn SafeArrayCopyData(psaSource: *mut SAFEARRAY, psaTarget: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayReleaseDescriptor(psa: *mut SAFEARRAY);
}
extern "C" {
    pub fn SafeArrayDestroyDescriptor(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayReleaseData(pData: PVOID);
}
extern "C" {
    pub fn SafeArrayDestroyData(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayAddRef(psa: *mut SAFEARRAY, ppDataToRelease: *mut PVOID) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayDestroy(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayRedim(psa: *mut SAFEARRAY, psaboundNew: *mut SAFEARRAYBOUND) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayGetDim(psa: *mut SAFEARRAY) -> UINT;
}
extern "C" {
    pub fn SafeArrayGetElemsize(psa: *mut SAFEARRAY) -> UINT;
}
extern "C" {
    pub fn SafeArrayGetUBound(psa: *mut SAFEARRAY, nDim: UINT, plUbound: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayGetLBound(psa: *mut SAFEARRAY, nDim: UINT, plLbound: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayLock(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayUnlock(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayAccessData(
        psa: *mut SAFEARRAY,
        ppvData: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayUnaccessData(psa: *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayGetElement(
        psa: *mut SAFEARRAY,
        rgIndices: *mut LONG,
        pv: *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayPutElement(
        psa: *mut SAFEARRAY,
        rgIndices: *mut LONG,
        pv: *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayCopy(psa: *mut SAFEARRAY, ppsaOut: *mut *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayPtrOfIndex(
        psa: *mut SAFEARRAY,
        rgIndices: *mut LONG,
        ppvData: *mut *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn SafeArraySetRecordInfo(psa: *mut SAFEARRAY, prinfo: *mut IRecordInfo) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayGetRecordInfo(psa: *mut SAFEARRAY, prinfo: *mut *mut IRecordInfo) -> HRESULT;
}
extern "C" {
    pub fn SafeArraySetIID(psa: *mut SAFEARRAY, guid: *const GUID) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayGetIID(psa: *mut SAFEARRAY, pguid: *mut GUID) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayGetVartype(psa: *mut SAFEARRAY, pvt: *mut VARTYPE) -> HRESULT;
}
extern "C" {
    pub fn SafeArrayCreateVector(vt: VARTYPE, lLbound: LONG, cElements: ULONG) -> *mut SAFEARRAY;
}
extern "C" {
    pub fn SafeArrayCreateVectorEx(
        vt: VARTYPE,
        lLbound: LONG,
        cElements: ULONG,
        pvExtra: PVOID,
    ) -> *mut SAFEARRAY;
}
extern "C" {
    pub fn VariantInit(pvarg: *mut VARIANTARG);
}
extern "C" {
    pub fn VariantClear(pvarg: *mut VARIANTARG) -> HRESULT;
}
extern "C" {
    pub fn VariantCopy(pvargDest: *mut VARIANTARG, pvargSrc: *const VARIANTARG) -> HRESULT;
}
extern "C" {
    pub fn VariantCopyInd(pvarDest: *mut VARIANT, pvargSrc: *const VARIANTARG) -> HRESULT;
}
extern "C" {
    pub fn VariantChangeType(
        pvargDest: *mut VARIANTARG,
        pvarSrc: *const VARIANTARG,
        wFlags: USHORT,
        vt: VARTYPE,
    ) -> HRESULT;
}
extern "C" {
    pub fn VariantChangeTypeEx(
        pvargDest: *mut VARIANTARG,
        pvarSrc: *const VARIANTARG,
        lcid: LCID,
        wFlags: USHORT,
        vt: VARTYPE,
    ) -> HRESULT;
}
extern "C" {
    pub fn VectorFromBstr(bstr: BSTR, ppsa: *mut *mut SAFEARRAY) -> HRESULT;
}
extern "C" {
    pub fn BstrFromVector(psa: *mut SAFEARRAY, pbstr: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromI2(sIn: SHORT, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromI4(lIn: LONG, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromI8(i64In: LONG64, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromR4(fltIn: FLOAT, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromR8(dblIn: DOUBLE, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromCy(cyIn: CY, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromDate(dateIn: DATE, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pbOut: *mut BYTE)
        -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromBool(boolIn: VARIANT_BOOL, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromI1(cIn: CHAR, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromUI2(uiIn: USHORT, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromUI4(ulIn: ULONG, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromUI8(ui64In: ULONG64, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarUI1FromDec(pdecIn: *const DECIMAL, pbOut: *mut BYTE) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromUI1(bIn: BYTE, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromI4(lIn: LONG, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromI8(i64In: LONG64, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromR4(fltIn: FLOAT, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromR8(dblIn: DOUBLE, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromCy(cyIn: CY, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromDate(dateIn: DATE, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, psOut: *mut SHORT)
        -> HRESULT;
}
extern "C" {
    pub fn VarI2FromDisp(pdispIn: *mut IDispatch, lcid: LCID, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromBool(boolIn: VARIANT_BOOL, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromI1(cIn: CHAR, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromUI2(uiIn: USHORT, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromUI4(ulIn: ULONG, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromUI8(ui64In: ULONG64, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI2FromDec(pdecIn: *const DECIMAL, psOut: *mut SHORT) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromUI1(bIn: BYTE, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromI2(sIn: SHORT, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromI8(i64In: LONG64, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromR4(fltIn: FLOAT, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromR8(dblIn: DOUBLE, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromCy(cyIn: CY, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromDate(dateIn: DATE, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromDisp(pdispIn: *mut IDispatch, lcid: LCID, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromBool(boolIn: VARIANT_BOOL, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromI1(cIn: CHAR, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromUI2(uiIn: USHORT, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromUI4(ulIn: ULONG, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromUI8(ui64In: ULONG64, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI4FromDec(pdecIn: *const DECIMAL, plOut: *mut LONG) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromUI1(bIn: BYTE, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromI2(sIn: SHORT, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromR4(fltIn: FLOAT, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromR8(dblIn: DOUBLE, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromCy(cyIn: CY, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromDate(dateIn: DATE, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pi64Out: *mut LONG64,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromBool(boolIn: VARIANT_BOOL, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromI1(cIn: CHAR, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromUI2(uiIn: USHORT, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromUI4(ulIn: ULONG, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromUI8(ui64In: ULONG64, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarI8FromDec(pdecIn: *const DECIMAL, pi64Out: *mut LONG64) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromUI1(bIn: BYTE, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromI2(sIn: SHORT, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromI4(lIn: LONG, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromI8(i64In: LONG64, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromR8(dblIn: DOUBLE, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromCy(cyIn: CY, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromDate(dateIn: DATE, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pfltOut: *mut FLOAT,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromBool(boolIn: VARIANT_BOOL, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromI1(cIn: CHAR, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromUI2(uiIn: USHORT, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromUI4(ulIn: ULONG, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromUI8(ui64In: ULONG64, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR4FromDec(pdecIn: *const DECIMAL, pfltOut: *mut FLOAT) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromUI1(bIn: BYTE, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromI2(sIn: SHORT, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromI4(lIn: LONG, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromI8(i64In: LONG64, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromR4(fltIn: FLOAT, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromCy(cyIn: CY, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromDate(dateIn: DATE, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pdblOut: *mut DOUBLE,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromBool(boolIn: VARIANT_BOOL, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromI1(cIn: CHAR, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromUI2(uiIn: USHORT, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromUI4(ulIn: ULONG, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromUI8(ui64In: ULONG64, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarR8FromDec(pdecIn: *const DECIMAL, pdblOut: *mut DOUBLE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromUI1(bIn: BYTE, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromI2(sIn: SHORT, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromI4(lIn: LONG, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromI8(i64In: LONG64, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromR4(fltIn: FLOAT, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromR8(dblIn: DOUBLE, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromCy(cyIn: CY, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pdateOut: *mut DATE,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromDisp(pdispIn: *mut IDispatch, lcid: LCID, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromBool(boolIn: VARIANT_BOOL, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromI1(cIn: CHAR, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromUI2(uiIn: USHORT, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromUI4(ulIn: ULONG, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromUI8(ui64In: ULONG64, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromDec(pdecIn: *const DECIMAL, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromUI1(bIn: BYTE, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromI2(sIn: SHORT, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromI4(lIn: LONG, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromI8(i64In: LONG64, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromR4(fltIn: FLOAT, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromR8(dblIn: DOUBLE, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromDate(dateIn: DATE, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromDisp(pdispIn: *mut IDispatch, lcid: LCID, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromBool(boolIn: VARIANT_BOOL, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromI1(cIn: CHAR, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromUI2(uiIn: USHORT, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromUI4(ulIn: ULONG, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromUI8(ui64In: ULONG64, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFromDec(pdecIn: *const DECIMAL, pcyOut: *mut CY) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromUI1(bVal: BYTE, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromI2(iVal: SHORT, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromI4(lIn: LONG, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromI8(i64In: LONG64, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR)
        -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromR4(fltIn: FLOAT, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromR8(dblIn: DOUBLE, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR)
        -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromCy(cyIn: CY, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromDate(
        dateIn: DATE,
        lcid: LCID,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromDisp(
        pdispIn: *mut IDispatch,
        lcid: LCID,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromBool(
        boolIn: VARIANT_BOOL,
        lcid: LCID,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromI1(cIn: CHAR, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromUI2(uiIn: USHORT, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR)
        -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromUI4(ulIn: ULONG, lcid: LCID, dwFlags: ULONG, pbstrOut: *mut BSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromUI8(
        ui64In: ULONG64,
        lcid: LCID,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBstrFromDec(
        pdecIn: *const DECIMAL,
        lcid: LCID,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromUI1(bIn: BYTE, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromI2(sIn: SHORT, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromI4(lIn: LONG, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromI8(i64In: LONG64, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromR4(fltIn: FLOAT, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromR8(dblIn: DOUBLE, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromDate(dateIn: DATE, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromCy(cyIn: CY, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pboolOut: *mut VARIANT_BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromDisp(
        pdispIn: *mut IDispatch,
        lcid: LCID,
        pboolOut: *mut VARIANT_BOOL,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromI1(cIn: CHAR, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromUI2(uiIn: USHORT, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromUI4(ulIn: ULONG, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromUI8(i64In: ULONG64, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarBoolFromDec(pdecIn: *const DECIMAL, pboolOut: *mut VARIANT_BOOL) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromUI1(bIn: BYTE, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromI2(uiIn: SHORT, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromI4(lIn: LONG, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromI8(i64In: LONG64, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromR4(fltIn: FLOAT, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromR8(dblIn: DOUBLE, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromDate(dateIn: DATE, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromCy(cyIn: CY, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromBool(boolIn: VARIANT_BOOL, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromUI2(uiIn: USHORT, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromUI4(ulIn: ULONG, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromUI8(i64In: ULONG64, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarI1FromDec(pdecIn: *const DECIMAL, pcOut: *mut CHAR) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromUI1(bIn: BYTE, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromI2(uiIn: SHORT, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromI4(lIn: LONG, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromI8(i64In: LONG64, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromR4(fltIn: FLOAT, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromR8(dblIn: DOUBLE, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromDate(dateIn: DATE, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromCy(cyIn: CY, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        puiOut: *mut USHORT,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromDisp(pdispIn: *mut IDispatch, lcid: LCID, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromBool(boolIn: VARIANT_BOOL, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromI1(cIn: CHAR, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromUI4(ulIn: ULONG, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromUI8(i64In: ULONG64, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI2FromDec(pdecIn: *const DECIMAL, puiOut: *mut USHORT) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromUI1(bIn: BYTE, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromI2(uiIn: SHORT, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromI4(lIn: LONG, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromI8(i64In: LONG64, plOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromR4(fltIn: FLOAT, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromR8(dblIn: DOUBLE, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromDate(dateIn: DATE, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromCy(cyIn: CY, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pulOut: *mut ULONG,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromBool(boolIn: VARIANT_BOOL, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromI1(cIn: CHAR, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromUI2(uiIn: USHORT, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromUI8(ui64In: ULONG64, plOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI4FromDec(pdecIn: *const DECIMAL, pulOut: *mut ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromUI1(bIn: BYTE, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromI2(sIn: SHORT, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromI4(lIn: LONG, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromI8(ui64In: LONG64, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromR4(fltIn: FLOAT, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromR8(dblIn: DOUBLE, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromCy(cyIn: CY, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromDate(dateIn: DATE, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pi64Out: *mut ULONG64,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromDisp(pdispIn: *mut IDispatch, lcid: LCID, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromBool(boolIn: VARIANT_BOOL, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromI1(cIn: CHAR, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromUI2(uiIn: USHORT, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromUI4(ulIn: ULONG, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarUI8FromDec(pdecIn: *const DECIMAL, pi64Out: *mut ULONG64) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromUI1(bIn: BYTE, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromI2(uiIn: SHORT, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromI4(lIn: LONG, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromI8(i64In: LONG64, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromR4(fltIn: FLOAT, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromR8(dblIn: DOUBLE, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromDate(dateIn: DATE, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromCy(cyIn: CY, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pdecOut: *mut DECIMAL,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromDisp(pdispIn: *mut IDispatch, lcid: LCID, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromBool(boolIn: VARIANT_BOOL, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromI1(cIn: CHAR, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromUI2(uiIn: USHORT, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromUI4(ulIn: ULONG, pdecOut: *mut DECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFromUI8(ui64In: ULONG64, pdecOut: *mut DECIMAL) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NUMPARSE {
    pub cDig: INT,
    pub dwInFlags: ULONG,
    pub dwOutFlags: ULONG,
    pub cchUsed: INT,
    pub nBaseShift: INT,
    pub nPwr10: INT,
}
extern "C" {
    pub fn VarParseNumFromStr(
        strIn: LPCOLESTR,
        lcid: LCID,
        dwFlags: ULONG,
        pnumprs: *mut NUMPARSE,
        rgbDig: *mut BYTE,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarNumFromParseNum(
        pnumprs: *mut NUMPARSE,
        rgbDig: *mut BYTE,
        dwVtBits: ULONG,
        pvar: *mut VARIANT,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarAdd(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarAnd(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarCat(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarDiv(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarEqv(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarIdiv(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarImp(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarMod(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarMul(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarOr(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarPow(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarSub(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarXor(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarAbs(pvarIn: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarFix(pvarIn: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarInt(pvarIn: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarNeg(pvarIn: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarNot(pvarIn: LPVARIANT, pvarResult: LPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn VarRound(
        pvarIn: LPVARIANT,
        cDecimals: ::std::os::raw::c_int,
        pvarResult: LPVARIANT,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarCmp(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, lcid: LCID, dwFlags: ULONG)
        -> HRESULT;
}
extern "C" {
    #[link_name = "\u{1}?VarCmp@@YAJPEAUtagVARIANT@@0K@Z"]
    pub fn VarCmp1(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, lcid: LCID) -> HRESULT;
}
extern "C" {
    pub fn VarDecAdd(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecDiv(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecMul(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecSub(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecAbs(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecFix(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecInt(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecNeg(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecRound(
        pdecIn: LPDECIMAL,
        cDecimals: ::std::os::raw::c_int,
        pdecResult: LPDECIMAL,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarDecCmp(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL) -> HRESULT;
}
extern "C" {
    pub fn VarDecCmpR8(pdecLeft: LPDECIMAL, dblRight: f64) -> HRESULT;
}
extern "C" {
    pub fn VarCyAdd(cyLeft: CY, cyRight: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyMul(cyLeft: CY, cyRight: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyMulI4(cyLeft: CY, lRight: LONG, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyMulI8(cyLeft: CY, lRight: LONG64, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCySub(cyLeft: CY, cyRight: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyAbs(cyIn: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyFix(cyIn: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyInt(cyIn: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyNeg(cyIn: CY, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyRound(cyIn: CY, cDecimals: ::std::os::raw::c_int, pcyResult: LPCY) -> HRESULT;
}
extern "C" {
    pub fn VarCyCmp(cyLeft: CY, cyRight: CY) -> HRESULT;
}
extern "C" {
    pub fn VarCyCmpR8(cyLeft: CY, dblRight: f64) -> HRESULT;
}
extern "C" {
    pub fn VarBstrCat(bstrLeft: BSTR, bstrRight: BSTR, pbstrResult: LPBSTR) -> HRESULT;
}
extern "C" {
    pub fn VarBstrCmp(bstrLeft: BSTR, bstrRight: BSTR, lcid: LCID, dwFlags: ULONG) -> HRESULT;
}
extern "C" {
    pub fn VarR8Pow(dblLeft: f64, dblRight: f64, pdblResult: *mut f64) -> HRESULT;
}
extern "C" {
    pub fn VarR4CmpR8(fltLeft: f32, dblRight: f64) -> HRESULT;
}
extern "C" {
    pub fn VarR8Round(
        dblIn: f64,
        cDecimals: ::std::os::raw::c_int,
        pdblResult: *mut f64,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDATE {
    pub st: SYSTEMTIME,
    pub wDayOfYear: USHORT,
}
extern "C" {
    pub fn VarDateFromUdate(pudateIn: *mut UDATE, dwFlags: ULONG, pdateOut: *mut DATE) -> HRESULT;
}
extern "C" {
    pub fn VarDateFromUdateEx(
        pudateIn: *mut UDATE,
        lcid: LCID,
        dwFlags: ULONG,
        pdateOut: *mut DATE,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarUdateFromDate(dateIn: DATE, dwFlags: ULONG, pudateOut: *mut UDATE) -> HRESULT;
}
extern "C" {
    pub fn GetAltMonthNames(lcid: LCID, prgp: *mut *mut LPOLESTR) -> HRESULT;
}
extern "C" {
    pub fn VarFormat(
        pvarIn: LPVARIANT,
        pstrFormat: LPOLESTR,
        iFirstDay: ::std::os::raw::c_int,
        iFirstWeek: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarFormatDateTime(
        pvarIn: LPVARIANT,
        iNamedFormat: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarFormatNumber(
        pvarIn: LPVARIANT,
        iNumDig: ::std::os::raw::c_int,
        iIncLead: ::std::os::raw::c_int,
        iUseParens: ::std::os::raw::c_int,
        iGroup: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarFormatPercent(
        pvarIn: LPVARIANT,
        iNumDig: ::std::os::raw::c_int,
        iIncLead: ::std::os::raw::c_int,
        iUseParens: ::std::os::raw::c_int,
        iGroup: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarFormatCurrency(
        pvarIn: LPVARIANT,
        iNumDig: ::std::os::raw::c_int,
        iIncLead: ::std::os::raw::c_int,
        iUseParens: ::std::os::raw::c_int,
        iGroup: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarWeekdayName(
        iWeekday: ::std::os::raw::c_int,
        fAbbrev: ::std::os::raw::c_int,
        iFirstDay: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarMonthName(
        iMonth: ::std::os::raw::c_int,
        fAbbrev: ::std::os::raw::c_int,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarFormatFromTokens(
        pvarIn: LPVARIANT,
        pstrFormat: LPOLESTR,
        pbTokCur: LPBYTE,
        dwFlags: ULONG,
        pbstrOut: *mut BSTR,
        lcid: LCID,
    ) -> HRESULT;
}
extern "C" {
    pub fn VarTokenizeFormatString(
        pstrFormat: LPOLESTR,
        rgbTok: LPBYTE,
        cbTok: ::std::os::raw::c_int,
        iFirstDay: ::std::os::raw::c_int,
        iFirstWeek: ::std::os::raw::c_int,
        lcid: LCID,
        pcbActual: *mut ::std::os::raw::c_int,
    ) -> HRESULT;
}
extern "C" {
    pub fn LHashValOfNameSysA(syskind: SYSKIND, lcid: LCID, szName: LPCSTR) -> ULONG;
}
extern "C" {
    pub fn LHashValOfNameSys(syskind: SYSKIND, lcid: LCID, szName: *const OLECHAR) -> ULONG;
}
extern "C" {
    pub fn LoadTypeLib(szFile: LPCOLESTR, pptlib: *mut *mut ITypeLib) -> HRESULT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tagREGKIND {
    REGKIND_DEFAULT = 0,
    REGKIND_REGISTER = 1,
    REGKIND_NONE = 2,
}
pub use self::tagREGKIND as REGKIND;
extern "C" {
    pub fn LoadTypeLibEx(
        szFile: LPCOLESTR,
        regkind: REGKIND,
        pptlib: *mut *mut ITypeLib,
    ) -> HRESULT;
}
extern "C" {
    pub fn LoadRegTypeLib(
        rguid: *const GUID,
        wVerMajor: WORD,
        wVerMinor: WORD,
        lcid: LCID,
        pptlib: *mut *mut ITypeLib,
    ) -> HRESULT;
}
extern "C" {
    pub fn QueryPathOfRegTypeLib(
        guid: *const GUID,
        wMaj: USHORT,
        wMin: USHORT,
        lcid: LCID,
        lpbstrPathName: LPBSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn RegisterTypeLib(
        ptlib: *mut ITypeLib,
        szFullPath: LPCOLESTR,
        szHelpDir: LPCOLESTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn UnRegisterTypeLib(
        libID: *const GUID,
        wVerMajor: WORD,
        wVerMinor: WORD,
        lcid: LCID,
        syskind: SYSKIND,
    ) -> HRESULT;
}
extern "C" {
    pub fn RegisterTypeLibForUser(
        ptlib: *mut ITypeLib,
        szFullPath: *mut OLECHAR,
        szHelpDir: *mut OLECHAR,
    ) -> HRESULT;
}
extern "C" {
    pub fn UnRegisterTypeLibForUser(
        libID: *const GUID,
        wMajorVerNum: WORD,
        wMinorVerNum: WORD,
        lcid: LCID,
        syskind: SYSKIND,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateTypeLib(
        syskind: SYSKIND,
        szFile: LPCOLESTR,
        ppctlib: *mut *mut ICreateTypeLib,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateTypeLib2(
        syskind: SYSKIND,
        szFile: LPCOLESTR,
        ppctlib: *mut *mut ICreateTypeLib2,
    ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPARAMDATA {
    pub szName: *mut OLECHAR,
    pub vt: VARTYPE,
}
pub type PARAMDATA = tagPARAMDATA;
pub type LPPARAMDATA = *mut tagPARAMDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMETHODDATA {
    pub szName: *mut OLECHAR,
    pub ppdata: *mut PARAMDATA,
    pub dispid: DISPID,
    pub iMeth: UINT,
    pub cc: CALLCONV,
    pub cArgs: UINT,
    pub wFlags: WORD,
    pub vtReturn: VARTYPE,
}
pub type METHODDATA = tagMETHODDATA;
pub type LPMETHODDATA = *mut tagMETHODDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagINTERFACEDATA {
    pub pmethdata: *mut METHODDATA,
    pub cMembers: UINT,
}
pub type INTERFACEDATA = tagINTERFACEDATA;
pub type LPINTERFACEDATA = *mut tagINTERFACEDATA;
extern "C" {
    pub fn DispGetParam(
        pdispparams: *mut DISPPARAMS,
        position: UINT,
        vtTarg: VARTYPE,
        pvarResult: *mut VARIANT,
        puArgErr: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn DispGetIDsOfNames(
        ptinfo: *mut ITypeInfo,
        rgszNames: *mut LPOLESTR,
        cNames: UINT,
        rgdispid: *mut DISPID,
    ) -> HRESULT;
}
extern "C" {
    pub fn DispInvoke(
        _this: *mut ::std::os::raw::c_void,
        ptinfo: *mut ITypeInfo,
        dispidMember: DISPID,
        wFlags: WORD,
        pparams: *mut DISPPARAMS,
        pvarResult: *mut VARIANT,
        pexcepinfo: *mut EXCEPINFO,
        puArgErr: *mut UINT,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateDispTypeInfo(
        pidata: *mut INTERFACEDATA,
        lcid: LCID,
        pptinfo: *mut *mut ITypeInfo,
    ) -> HRESULT;
}
extern "C" {
    pub fn CreateStdDispatch(
        punkOuter: *mut IUnknown,
        pvThis: *mut ::std::os::raw::c_void,
        ptinfo: *mut ITypeInfo,
        ppunkStdDisp: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn DispCallFunc(
        pvInstance: *mut ::std::os::raw::c_void,
        oVft: ULONG_PTR,
        cc: CALLCONV,
        vtReturn: VARTYPE,
        cActuals: UINT,
        prgvt: *mut VARTYPE,
        prgpvarg: *mut *mut VARIANTARG,
        pvargResult: *mut VARIANT,
    ) -> HRESULT;
}
extern "C" {
    pub fn RegisterActiveObject(
        punk: *mut IUnknown,
        rclsid: *const IID,
        dwFlags: DWORD,
        pdwRegister: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn RevokeActiveObject(
        dwRegister: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetActiveObject(
        rclsid: *const IID,
        pvReserved: *mut ::std::os::raw::c_void,
        ppunk: *mut *mut IUnknown,
    ) -> HRESULT;
}
extern "C" {
    pub fn SetErrorInfo(dwReserved: ULONG, perrinfo: *mut IErrorInfo) -> HRESULT;
}
extern "C" {
    pub fn GetErrorInfo(dwReserved: ULONG, pperrinfo: *mut *mut IErrorInfo) -> HRESULT;
}
extern "C" {
    pub fn CreateErrorInfo(pperrinfo: *mut *mut ICreateErrorInfo) -> HRESULT;
}
extern "C" {
    pub fn GetRecordInfoFromTypeInfo(
        pTypeInfo: *mut ITypeInfo,
        ppRecInfo: *mut *mut IRecordInfo,
    ) -> HRESULT;
}
extern "C" {
    pub fn GetRecordInfoFromGuids(
        rGuidTypeLib: *const GUID,
        uVerMajor: ULONG,
        uVerMinor: ULONG,
        lcid: LCID,
        rGuidTypeInfo: *const GUID,
        ppRecInfo: *mut *mut IRecordInfo,
    ) -> HRESULT;
}
extern "C" {
    pub fn OaBuildVersion() -> ULONG;
}
extern "C" {
    pub fn ClearCustData(pCustData: LPCUSTDATA);
}
extern "C" {
    pub fn OaEnablePerUserTLibRegistration();
}
extern "C" {
    pub fn OleBuildVersion() -> DWORD;
}
extern "C" {
    pub fn WriteFmtUserTypeStg(pstg: LPSTORAGE, cf: CLIPFORMAT, lpszUserType: LPOLESTR) -> HRESULT;
}
extern "C" {
    pub fn ReadFmtUserTypeStg(
        pstg: LPSTORAGE,
        pcf: *mut CLIPFORMAT,
        lplpszUserType: *mut LPOLESTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleInitialize(pvReserved: LPVOID) -> HRESULT;
}
extern "C" {
    pub fn OleUninitialize();
}
extern "C" {
    pub fn OleQueryLinkFromData(pSrcDataObject: LPDATAOBJECT) -> HRESULT;
}
extern "C" {
    pub fn OleQueryCreateFromData(pSrcDataObject: LPDATAOBJECT) -> HRESULT;
}
extern "C" {
    pub fn OleCreate(
        rclsid: *const IID,
        riid: *const IID,
        renderopt: DWORD,
        pFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateEx(
        rclsid: *const IID,
        riid: *const IID,
        dwFlags: DWORD,
        renderopt: DWORD,
        cFormats: ULONG,
        rgAdvf: *mut DWORD,
        rgFormatEtc: LPFORMATETC,
        lpAdviseSink: *mut IAdviseSink,
        rgdwConnection: *mut DWORD,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateFromData(
        pSrcDataObj: LPDATAOBJECT,
        riid: *const IID,
        renderopt: DWORD,
        pFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateFromDataEx(
        pSrcDataObj: LPDATAOBJECT,
        riid: *const IID,
        dwFlags: DWORD,
        renderopt: DWORD,
        cFormats: ULONG,
        rgAdvf: *mut DWORD,
        rgFormatEtc: LPFORMATETC,
        lpAdviseSink: *mut IAdviseSink,
        rgdwConnection: *mut DWORD,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateLinkFromData(
        pSrcDataObj: LPDATAOBJECT,
        riid: *const IID,
        renderopt: DWORD,
        pFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateLinkFromDataEx(
        pSrcDataObj: LPDATAOBJECT,
        riid: *const IID,
        dwFlags: DWORD,
        renderopt: DWORD,
        cFormats: ULONG,
        rgAdvf: *mut DWORD,
        rgFormatEtc: LPFORMATETC,
        lpAdviseSink: *mut IAdviseSink,
        rgdwConnection: *mut DWORD,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateStaticFromData(
        pSrcDataObj: LPDATAOBJECT,
        iid: *const IID,
        renderopt: DWORD,
        pFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateLink(
        pmkLinkSrc: LPMONIKER,
        riid: *const IID,
        renderopt: DWORD,
        lpFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateLinkEx(
        pmkLinkSrc: LPMONIKER,
        riid: *const IID,
        dwFlags: DWORD,
        renderopt: DWORD,
        cFormats: ULONG,
        rgAdvf: *mut DWORD,
        rgFormatEtc: LPFORMATETC,
        lpAdviseSink: *mut IAdviseSink,
        rgdwConnection: *mut DWORD,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateLinkToFile(
        lpszFileName: LPCOLESTR,
        riid: *const IID,
        renderopt: DWORD,
        lpFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateLinkToFileEx(
        lpszFileName: LPCOLESTR,
        riid: *const IID,
        dwFlags: DWORD,
        renderopt: DWORD,
        cFormats: ULONG,
        rgAdvf: *mut DWORD,
        rgFormatEtc: LPFORMATETC,
        lpAdviseSink: *mut IAdviseSink,
        rgdwConnection: *mut DWORD,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateFromFile(
        rclsid: *const IID,
        lpszFileName: LPCOLESTR,
        riid: *const IID,
        renderopt: DWORD,
        lpFormatEtc: LPFORMATETC,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateFromFileEx(
        rclsid: *const IID,
        lpszFileName: LPCOLESTR,
        riid: *const IID,
        dwFlags: DWORD,
        renderopt: DWORD,
        cFormats: ULONG,
        rgAdvf: *mut DWORD,
        rgFormatEtc: LPFORMATETC,
        lpAdviseSink: *mut IAdviseSink,
        rgdwConnection: *mut DWORD,
        pClientSite: LPOLECLIENTSITE,
        pStg: LPSTORAGE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleLoad(
        pStg: LPSTORAGE,
        riid: *const IID,
        pClientSite: LPOLECLIENTSITE,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleSave(pPS: LPPERSISTSTORAGE, pStg: LPSTORAGE, fSameAsLoad: BOOL) -> HRESULT;
}
extern "C" {
    pub fn OleLoadFromStream(
        pStm: LPSTREAM,
        iidInterface: *const IID,
        ppvObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleSaveToStream(pPStm: LPPERSISTSTREAM, pStm: LPSTREAM) -> HRESULT;
}
extern "C" {
    pub fn OleSetContainedObject(pUnknown: LPUNKNOWN, fContained: BOOL) -> HRESULT;
}
extern "C" {
    pub fn OleNoteObjectVisible(pUnknown: LPUNKNOWN, fVisible: BOOL) -> HRESULT;
}
extern "C" {
    pub fn RegisterDragDrop(hwnd: HWND, pDropTarget: LPDROPTARGET) -> HRESULT;
}
extern "C" {
    pub fn RevokeDragDrop(hwnd: HWND) -> HRESULT;
}
extern "C" {
    pub fn DoDragDrop(
        pDataObj: LPDATAOBJECT,
        pDropSource: LPDROPSOURCE,
        dwOKEffects: DWORD,
        pdwEffect: LPDWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleSetClipboard(pDataObj: LPDATAOBJECT) -> HRESULT;
}
extern "C" {
    pub fn OleGetClipboard(ppDataObj: *mut LPDATAOBJECT) -> HRESULT;
}
extern "C" {
    pub fn OleGetClipboardWithEnterpriseInfo(
        dataObject: *mut *mut IDataObject,
        dataEnterpriseId: *mut PWSTR,
        sourceDescription: *mut PWSTR,
        targetDescription: *mut PWSTR,
        dataDescription: *mut PWSTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleFlushClipboard() -> HRESULT;
}
extern "C" {
    pub fn OleIsCurrentClipboard(pDataObj: LPDATAOBJECT) -> HRESULT;
}
extern "C" {
    pub fn OleCreateMenuDescriptor(
        hmenuCombined: HMENU,
        lpMenuWidths: LPOLEMENUGROUPWIDTHS,
    ) -> HOLEMENU;
}
extern "C" {
    pub fn OleSetMenuDescriptor(
        holemenu: HOLEMENU,
        hwndFrame: HWND,
        hwndActiveObject: HWND,
        lpFrame: LPOLEINPLACEFRAME,
        lpActiveObj: LPOLEINPLACEACTIVEOBJECT,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleDestroyMenuDescriptor(holemenu: HOLEMENU) -> HRESULT;
}
extern "C" {
    pub fn OleTranslateAccelerator(
        lpFrame: LPOLEINPLACEFRAME,
        lpFrameInfo: LPOLEINPLACEFRAMEINFO,
        lpmsg: LPMSG,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleDuplicateData(hSrc: HANDLE, cfFormat: CLIPFORMAT, uiFlags: UINT) -> HANDLE;
}
extern "C" {
    pub fn OleDraw(
        pUnknown: LPUNKNOWN,
        dwAspect: DWORD,
        hdcDraw: HDC,
        lprcBounds: LPCRECT,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleRun(pUnknown: LPUNKNOWN) -> HRESULT;
}
extern "C" {
    pub fn OleIsRunning(pObject: LPOLEOBJECT) -> BOOL;
}
extern "C" {
    pub fn OleLockRunning(pUnknown: LPUNKNOWN, fLock: BOOL, fLastUnlockCloses: BOOL) -> HRESULT;
}
extern "C" {
    pub fn ReleaseStgMedium(arg1: LPSTGMEDIUM);
}
extern "C" {
    pub fn CreateOleAdviseHolder(ppOAHolder: *mut LPOLEADVISEHOLDER) -> HRESULT;
}
extern "C" {
    pub fn OleCreateDefaultHandler(
        clsid: *const IID,
        pUnkOuter: LPUNKNOWN,
        riid: *const IID,
        lplpObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleCreateEmbeddingHelper(
        clsid: *const IID,
        pUnkOuter: LPUNKNOWN,
        flags: DWORD,
        pCF: LPCLASSFACTORY,
        riid: *const IID,
        lplpObj: *mut LPVOID,
    ) -> HRESULT;
}
extern "C" {
    pub fn IsAccelerator(
        hAccel: HACCEL,
        cAccelEntries: ::std::os::raw::c_int,
        lpMsg: LPMSG,
        lpwCmd: *mut WORD,
    ) -> BOOL;
}
extern "C" {
    pub fn OleGetIconOfFile(lpszPath: LPOLESTR, fUseFileAsLabel: BOOL) -> HGLOBAL;
}
extern "C" {
    pub fn OleGetIconOfClass(
        rclsid: *const IID,
        lpszLabel: LPOLESTR,
        fUseTypeAsLabel: BOOL,
    ) -> HGLOBAL;
}
extern "C" {
    pub fn OleMetafilePictFromIconAndLabel(
        hIcon: HICON,
        lpszLabel: LPOLESTR,
        lpszSourceFile: LPOLESTR,
        iIconIndex: UINT,
    ) -> HGLOBAL;
}
extern "C" {
    pub fn OleRegGetUserType(
        clsid: *const IID,
        dwFormOfType: DWORD,
        pszUserType: *mut LPOLESTR,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleRegGetMiscStatus(
        clsid: *const IID,
        dwAspect: DWORD,
        pdwStatus: *mut DWORD,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleRegEnumFormatEtc(
        clsid: *const IID,
        dwDirection: DWORD,
        ppenum: *mut LPENUMFORMATETC,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleRegEnumVerbs(clsid: *const IID, ppenum: *mut LPENUMOLEVERB) -> HRESULT;
}
pub type LPOLESTREAM = *mut _OLESTREAM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OLESTREAMVTBL {
    pub Get: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LPOLESTREAM,
            arg2: *mut ::std::os::raw::c_void,
            arg3: DWORD,
        ) -> DWORD,
    >,
    pub Put: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: LPOLESTREAM,
            arg2: *const ::std::os::raw::c_void,
            arg3: DWORD,
        ) -> DWORD,
    >,
}
pub type OLESTREAMVTBL = _OLESTREAMVTBL;
pub type LPOLESTREAMVTBL = *mut OLESTREAMVTBL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OLESTREAM {
    pub lpstbl: LPOLESTREAMVTBL,
}
pub type OLESTREAM = _OLESTREAM;
extern "C" {
    pub fn OleConvertOLESTREAMToIStorage(
        lpolestream: LPOLESTREAM,
        pstg: LPSTORAGE,
        ptd: *const DVTARGETDEVICE,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleConvertIStorageToOLESTREAM(pstg: LPSTORAGE, lpolestream: LPOLESTREAM) -> HRESULT;
}
extern "C" {
    pub fn OleDoAutoConvert(pStg: LPSTORAGE, pClsidNew: LPCLSID) -> HRESULT;
}
extern "C" {
    pub fn OleGetAutoConvert(clsidOld: *const IID, pClsidNew: LPCLSID) -> HRESULT;
}
extern "C" {
    pub fn OleSetAutoConvert(clsidOld: *const IID, clsidNew: *const IID) -> HRESULT;
}
extern "C" {
    pub fn SetConvertStg(pStg: LPSTORAGE, fConvert: BOOL) -> HRESULT;
}
extern "C" {
    pub fn OleConvertIStorageToOLESTREAMEx(
        pstg: LPSTORAGE,
        cfFormat: CLIPFORMAT,
        lWidth: LONG,
        lHeight: LONG,
        dwSize: DWORD,
        pmedium: LPSTGMEDIUM,
        polestm: LPOLESTREAM,
    ) -> HRESULT;
}
extern "C" {
    pub fn OleConvertOLESTREAMToIStorageEx(
        polestm: LPOLESTREAM,
        pstg: LPSTORAGE,
        pcfFormat: *mut CLIPFORMAT,
        plwWidth: *mut LONG,
        plHeight: *mut LONG,
        pdwSize: *mut DWORD,
        pmedium: LPSTGMEDIUM,
    ) -> HRESULT;
}
extern "C" {
    pub static IID_IPrintDialogCallback: GUID;
}
extern "C" {
    pub static IID_IPrintDialogServices: GUID;
}
pub type LPOFNHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOFN_NT4A {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub lpstrFilter: LPCSTR,
    pub lpstrCustomFilter: LPSTR,
    pub nMaxCustFilter: DWORD,
    pub nFilterIndex: DWORD,
    pub lpstrFile: LPSTR,
    pub nMaxFile: DWORD,
    pub lpstrFileTitle: LPSTR,
    pub nMaxFileTitle: DWORD,
    pub lpstrInitialDir: LPCSTR,
    pub lpstrTitle: LPCSTR,
    pub Flags: DWORD,
    pub nFileOffset: WORD,
    pub nFileExtension: WORD,
    pub lpstrDefExt: LPCSTR,
    pub lCustData: LPARAM,
    pub lpfnHook: LPOFNHOOKPROC,
    pub lpTemplateName: LPCSTR,
}
pub type OPENFILENAME_NT4A = tagOFN_NT4A;
pub type LPOPENFILENAME_NT4A = *mut tagOFN_NT4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOFN_NT4W {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub lpstrFilter: LPCWSTR,
    pub lpstrCustomFilter: LPWSTR,
    pub nMaxCustFilter: DWORD,
    pub nFilterIndex: DWORD,
    pub lpstrFile: LPWSTR,
    pub nMaxFile: DWORD,
    pub lpstrFileTitle: LPWSTR,
    pub nMaxFileTitle: DWORD,
    pub lpstrInitialDir: LPCWSTR,
    pub lpstrTitle: LPCWSTR,
    pub Flags: DWORD,
    pub nFileOffset: WORD,
    pub nFileExtension: WORD,
    pub lpstrDefExt: LPCWSTR,
    pub lCustData: LPARAM,
    pub lpfnHook: LPOFNHOOKPROC,
    pub lpTemplateName: LPCWSTR,
}
pub type OPENFILENAME_NT4W = tagOFN_NT4W;
pub type LPOPENFILENAME_NT4W = *mut tagOFN_NT4W;
pub type OPENFILENAME_NT4 = OPENFILENAME_NT4A;
pub type LPOPENFILENAME_NT4 = LPOPENFILENAME_NT4A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOFNA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub lpstrFilter: LPCSTR,
    pub lpstrCustomFilter: LPSTR,
    pub nMaxCustFilter: DWORD,
    pub nFilterIndex: DWORD,
    pub lpstrFile: LPSTR,
    pub nMaxFile: DWORD,
    pub lpstrFileTitle: LPSTR,
    pub nMaxFileTitle: DWORD,
    pub lpstrInitialDir: LPCSTR,
    pub lpstrTitle: LPCSTR,
    pub Flags: DWORD,
    pub nFileOffset: WORD,
    pub nFileExtension: WORD,
    pub lpstrDefExt: LPCSTR,
    pub lCustData: LPARAM,
    pub lpfnHook: LPOFNHOOKPROC,
    pub lpTemplateName: LPCSTR,
    pub pvReserved: *mut ::std::os::raw::c_void,
    pub dwReserved: DWORD,
    pub FlagsEx: DWORD,
}
pub type OPENFILENAMEA = tagOFNA;
pub type LPOPENFILENAMEA = *mut tagOFNA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagOFNW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub lpstrFilter: LPCWSTR,
    pub lpstrCustomFilter: LPWSTR,
    pub nMaxCustFilter: DWORD,
    pub nFilterIndex: DWORD,
    pub lpstrFile: LPWSTR,
    pub nMaxFile: DWORD,
    pub lpstrFileTitle: LPWSTR,
    pub nMaxFileTitle: DWORD,
    pub lpstrInitialDir: LPCWSTR,
    pub lpstrTitle: LPCWSTR,
    pub Flags: DWORD,
    pub nFileOffset: WORD,
    pub nFileExtension: WORD,
    pub lpstrDefExt: LPCWSTR,
    pub lCustData: LPARAM,
    pub lpfnHook: LPOFNHOOKPROC,
    pub lpTemplateName: LPCWSTR,
    pub pvReserved: *mut ::std::os::raw::c_void,
    pub dwReserved: DWORD,
    pub FlagsEx: DWORD,
}
pub type OPENFILENAMEW = tagOFNW;
pub type LPOPENFILENAMEW = *mut tagOFNW;
pub type OPENFILENAME = OPENFILENAMEA;
pub type LPOPENFILENAME = LPOPENFILENAMEA;
extern "C" {
    pub fn GetOpenFileNameA(arg1: LPOPENFILENAMEA) -> BOOL;
}
extern "C" {
    pub fn GetOpenFileNameW(arg1: LPOPENFILENAMEW) -> BOOL;
}
extern "C" {
    pub fn GetSaveFileNameA(arg1: LPOPENFILENAMEA) -> BOOL;
}
extern "C" {
    pub fn GetSaveFileNameW(arg1: LPOPENFILENAMEW) -> BOOL;
}
extern "C" {
    pub fn GetFileTitleA(arg1: LPCSTR, Buf: LPSTR, cchSize: WORD) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn GetFileTitleW(arg1: LPCWSTR, Buf: LPWSTR, cchSize: WORD) -> ::std::os::raw::c_short;
}
pub type LPCCHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OFNOTIFYA {
    pub hdr: NMHDR,
    pub lpOFN: LPOPENFILENAMEA,
    pub pszFile: LPSTR,
}
pub type OFNOTIFYA = _OFNOTIFYA;
pub type LPOFNOTIFYA = *mut _OFNOTIFYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OFNOTIFYW {
    pub hdr: NMHDR,
    pub lpOFN: LPOPENFILENAMEW,
    pub pszFile: LPWSTR,
}
pub type OFNOTIFYW = _OFNOTIFYW;
pub type LPOFNOTIFYW = *mut _OFNOTIFYW;
pub type OFNOTIFY = OFNOTIFYA;
pub type LPOFNOTIFY = LPOFNOTIFYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OFNOTIFYEXA {
    pub hdr: NMHDR,
    pub lpOFN: LPOPENFILENAMEA,
    pub psf: LPVOID,
    pub pidl: LPVOID,
}
pub type OFNOTIFYEXA = _OFNOTIFYEXA;
pub type LPOFNOTIFYEXA = *mut _OFNOTIFYEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OFNOTIFYEXW {
    pub hdr: NMHDR,
    pub lpOFN: LPOPENFILENAMEW,
    pub psf: LPVOID,
    pub pidl: LPVOID,
}
pub type OFNOTIFYEXW = _OFNOTIFYEXW;
pub type LPOFNOTIFYEXW = *mut _OFNOTIFYEXW;
pub type OFNOTIFYEX = OFNOTIFYEXA;
pub type LPOFNOTIFYEX = LPOFNOTIFYEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCHOOSECOLORA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HWND,
    pub rgbResult: COLORREF,
    pub lpCustColors: *mut COLORREF,
    pub Flags: DWORD,
    pub lCustData: LPARAM,
    pub lpfnHook: LPCCHOOKPROC,
    pub lpTemplateName: LPCSTR,
}
pub type CHOOSECOLORA = tagCHOOSECOLORA;
pub type LPCHOOSECOLORA = *mut tagCHOOSECOLORA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCHOOSECOLORW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HWND,
    pub rgbResult: COLORREF,
    pub lpCustColors: *mut COLORREF,
    pub Flags: DWORD,
    pub lCustData: LPARAM,
    pub lpfnHook: LPCCHOOKPROC,
    pub lpTemplateName: LPCWSTR,
}
pub type CHOOSECOLORW = tagCHOOSECOLORW;
pub type LPCHOOSECOLORW = *mut tagCHOOSECOLORW;
pub type CHOOSECOLOR = CHOOSECOLORA;
pub type LPCHOOSECOLOR = LPCHOOSECOLORA;
extern "C" {
    pub fn ChooseColorA(arg1: LPCHOOSECOLORA) -> BOOL;
}
extern "C" {
    pub fn ChooseColorW(arg1: LPCHOOSECOLORW) -> BOOL;
}
pub type LPFRHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFINDREPLACEA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub Flags: DWORD,
    pub lpstrFindWhat: LPSTR,
    pub lpstrReplaceWith: LPSTR,
    pub wFindWhatLen: WORD,
    pub wReplaceWithLen: WORD,
    pub lCustData: LPARAM,
    pub lpfnHook: LPFRHOOKPROC,
    pub lpTemplateName: LPCSTR,
}
pub type FINDREPLACEA = tagFINDREPLACEA;
pub type LPFINDREPLACEA = *mut tagFINDREPLACEA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFINDREPLACEW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hInstance: HINSTANCE,
    pub Flags: DWORD,
    pub lpstrFindWhat: LPWSTR,
    pub lpstrReplaceWith: LPWSTR,
    pub wFindWhatLen: WORD,
    pub wReplaceWithLen: WORD,
    pub lCustData: LPARAM,
    pub lpfnHook: LPFRHOOKPROC,
    pub lpTemplateName: LPCWSTR,
}
pub type FINDREPLACEW = tagFINDREPLACEW;
pub type LPFINDREPLACEW = *mut tagFINDREPLACEW;
pub type FINDREPLACE = FINDREPLACEA;
pub type LPFINDREPLACE = LPFINDREPLACEA;
extern "C" {
    pub fn FindTextA(arg1: LPFINDREPLACEA) -> HWND;
}
extern "C" {
    pub fn FindTextW(arg1: LPFINDREPLACEW) -> HWND;
}
extern "C" {
    pub fn ReplaceTextA(arg1: LPFINDREPLACEA) -> HWND;
}
extern "C" {
    pub fn ReplaceTextW(arg1: LPFINDREPLACEW) -> HWND;
}
pub type LPCFHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCHOOSEFONTA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDC: HDC,
    pub lpLogFont: LPLOGFONTA,
    pub iPointSize: INT,
    pub Flags: DWORD,
    pub rgbColors: COLORREF,
    pub lCustData: LPARAM,
    pub lpfnHook: LPCFHOOKPROC,
    pub lpTemplateName: LPCSTR,
    pub hInstance: HINSTANCE,
    pub lpszStyle: LPSTR,
    pub nFontType: WORD,
    pub ___MISSING_ALIGNMENT__: WORD,
    pub nSizeMin: INT,
    pub nSizeMax: INT,
}
pub type CHOOSEFONTA = tagCHOOSEFONTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCHOOSEFONTW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDC: HDC,
    pub lpLogFont: LPLOGFONTW,
    pub iPointSize: INT,
    pub Flags: DWORD,
    pub rgbColors: COLORREF,
    pub lCustData: LPARAM,
    pub lpfnHook: LPCFHOOKPROC,
    pub lpTemplateName: LPCWSTR,
    pub hInstance: HINSTANCE,
    pub lpszStyle: LPWSTR,
    pub nFontType: WORD,
    pub ___MISSING_ALIGNMENT__: WORD,
    pub nSizeMin: INT,
    pub nSizeMax: INT,
}
pub type CHOOSEFONTW = tagCHOOSEFONTW;
pub type CHOOSEFONT = CHOOSEFONTA;
pub type LPCHOOSEFONTA = *mut CHOOSEFONTA;
pub type LPCHOOSEFONTW = *mut CHOOSEFONTW;
pub type LPCHOOSEFONT = LPCHOOSEFONTA;
pub type PCCHOOSEFONTA = *const CHOOSEFONTA;
pub type PCCHOOSEFONTW = *const CHOOSEFONTW;
pub type PCCHOOSEFONT = PCCHOOSEFONTA;
extern "C" {
    pub fn ChooseFontA(arg1: LPCHOOSEFONTA) -> BOOL;
}
extern "C" {
    pub fn ChooseFontW(arg1: LPCHOOSEFONTW) -> BOOL;
}
pub type LPPRINTHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
pub type LPSETUPHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub nFromPage: WORD,
    pub nToPage: WORD,
    pub nMinPage: WORD,
    pub nMaxPage: WORD,
    pub nCopies: WORD,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPrintHook: LPPRINTHOOKPROC,
    pub lpfnSetupHook: LPSETUPHOOKPROC,
    pub lpPrintTemplateName: LPCSTR,
    pub lpSetupTemplateName: LPCSTR,
    pub hPrintTemplate: HGLOBAL,
    pub hSetupTemplate: HGLOBAL,
}
pub type PRINTDLGA = tagPDA;
pub type LPPRINTDLGA = *mut tagPDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub nFromPage: WORD,
    pub nToPage: WORD,
    pub nMinPage: WORD,
    pub nMaxPage: WORD,
    pub nCopies: WORD,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPrintHook: LPPRINTHOOKPROC,
    pub lpfnSetupHook: LPSETUPHOOKPROC,
    pub lpPrintTemplateName: LPCWSTR,
    pub lpSetupTemplateName: LPCWSTR,
    pub hPrintTemplate: HGLOBAL,
    pub hSetupTemplate: HGLOBAL,
}
pub type PRINTDLGW = tagPDW;
pub type LPPRINTDLGW = *mut tagPDW;
pub type PRINTDLG = PRINTDLGA;
pub type LPPRINTDLG = LPPRINTDLGA;
extern "C" {
    pub fn PrintDlgA(pPD: LPPRINTDLGA) -> BOOL;
}
extern "C" {
    pub fn PrintDlgW(pPD: LPPRINTDLGW) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPrintDialogCallback {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPrintDialogServices {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPRINTPAGERANGE {
    pub nFromPage: DWORD,
    pub nToPage: DWORD,
}
pub type PRINTPAGERANGE = tagPRINTPAGERANGE;
pub type LPPRINTPAGERANGE = *mut PRINTPAGERANGE;
pub type PCPRINTPAGERANGE = *const PRINTPAGERANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDEXA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub Flags2: DWORD,
    pub ExclusionFlags: DWORD,
    pub nPageRanges: DWORD,
    pub nMaxPageRanges: DWORD,
    pub lpPageRanges: LPPRINTPAGERANGE,
    pub nMinPage: DWORD,
    pub nMaxPage: DWORD,
    pub nCopies: DWORD,
    pub hInstance: HINSTANCE,
    pub lpPrintTemplateName: LPCSTR,
    pub lpCallback: LPUNKNOWN,
    pub nPropertyPages: DWORD,
    pub lphPropertyPages: *mut HPROPSHEETPAGE,
    pub nStartPage: DWORD,
    pub dwResultAction: DWORD,
}
pub type PRINTDLGEXA = tagPDEXA;
pub type LPPRINTDLGEXA = *mut tagPDEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDEXW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub Flags2: DWORD,
    pub ExclusionFlags: DWORD,
    pub nPageRanges: DWORD,
    pub nMaxPageRanges: DWORD,
    pub lpPageRanges: LPPRINTPAGERANGE,
    pub nMinPage: DWORD,
    pub nMaxPage: DWORD,
    pub nCopies: DWORD,
    pub hInstance: HINSTANCE,
    pub lpPrintTemplateName: LPCWSTR,
    pub lpCallback: LPUNKNOWN,
    pub nPropertyPages: DWORD,
    pub lphPropertyPages: *mut HPROPSHEETPAGE,
    pub nStartPage: DWORD,
    pub dwResultAction: DWORD,
}
pub type PRINTDLGEXW = tagPDEXW;
pub type LPPRINTDLGEXW = *mut tagPDEXW;
pub type PRINTDLGEX = PRINTDLGEXA;
pub type LPPRINTDLGEX = LPPRINTDLGEXA;
extern "C" {
    pub fn PrintDlgExA(pPD: LPPRINTDLGEXA) -> HRESULT;
}
extern "C" {
    pub fn PrintDlgExW(pPD: LPPRINTDLGEXW) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEVNAMES {
    pub wDriverOffset: WORD,
    pub wDeviceOffset: WORD,
    pub wOutputOffset: WORD,
    pub wDefault: WORD,
}
pub type DEVNAMES = tagDEVNAMES;
pub type LPDEVNAMES = *mut DEVNAMES;
pub type PCDEVNAMES = *const DEVNAMES;
extern "C" {
    pub fn CommDlgExtendedError() -> DWORD;
}
pub type LPPAGEPAINTHOOK = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
pub type LPPAGESETUPHOOK = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPSDA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub Flags: DWORD,
    pub ptPaperSize: POINT,
    pub rtMinMargin: RECT,
    pub rtMargin: RECT,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPageSetupHook: LPPAGESETUPHOOK,
    pub lpfnPagePaintHook: LPPAGEPAINTHOOK,
    pub lpPageSetupTemplateName: LPCSTR,
    pub hPageSetupTemplate: HGLOBAL,
}
pub type PAGESETUPDLGA = tagPSDA;
pub type LPPAGESETUPDLGA = *mut tagPSDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPSDW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub Flags: DWORD,
    pub ptPaperSize: POINT,
    pub rtMinMargin: RECT,
    pub rtMargin: RECT,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPageSetupHook: LPPAGESETUPHOOK,
    pub lpfnPagePaintHook: LPPAGEPAINTHOOK,
    pub lpPageSetupTemplateName: LPCWSTR,
    pub hPageSetupTemplate: HGLOBAL,
}
pub type PAGESETUPDLGW = tagPSDW;
pub type LPPAGESETUPDLGW = *mut tagPSDW;
pub type PAGESETUPDLG = PAGESETUPDLGA;
pub type LPPAGESETUPDLG = LPPAGESETUPDLGA;
extern "C" {
    pub fn PageSetupDlgA(arg1: LPPAGESETUPDLGA) -> BOOL;
}
extern "C" {
    pub fn PageSetupDlgW(arg1: LPPAGESETUPDLGW) -> BOOL;
}
extern "C" {
    pub fn uaw_CharUpperW(String: LPUWSTR) -> LPUWSTR;
}
extern "C" {
    pub fn uaw_lstrcmpW(String1: PCUWSTR, String2: PCUWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uaw_lstrcmpiW(String1: PCUWSTR, String2: PCUWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uaw_lstrlenW(String: LPCUWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uaw_wcschr(String: PCUWSTR, Character: WCHAR) -> PUWSTR;
}
extern "C" {
    pub fn uaw_wcscpy(Destination: PUWSTR, Source: PCUWSTR) -> PUWSTR;
}
extern "C" {
    pub fn uaw_wcsicmp(String1: PCUWSTR, String2: PCUWSTR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uaw_wcslen(String: PCUWSTR) -> usize;
}
extern "C" {
    pub fn uaw_wcsrchr(String: PCUWSTR, Character: WCHAR) -> PUWSTR;
}
pub type PUWSTR_C = *const WCHAR;
extern "C" {
    pub static NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID: GUID;
}
extern "C" {
    pub static NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID: GUID;
}
extern "C" {
    pub static DOMAIN_JOIN_GUID: GUID;
}
extern "C" {
    pub static DOMAIN_LEAVE_GUID: GUID;
}
extern "C" {
    pub static FIREWALL_PORT_OPEN_GUID: GUID;
}
extern "C" {
    pub static FIREWALL_PORT_CLOSE_GUID: GUID;
}
extern "C" {
    pub static MACHINE_POLICY_PRESENT_GUID: GUID;
}
extern "C" {
    pub static USER_POLICY_PRESENT_GUID: GUID;
}
extern "C" {
    pub static RPC_INTERFACE_EVENT_GUID: GUID;
}
extern "C" {
    pub static NAMED_PIPE_EVENT_GUID: GUID;
}
extern "C" {
    pub static CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_TRIGGER_CUSTOM_STATE_ID {
    pub Data: [DWORD; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
    pub u: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {
    pub CustomStateId: SERVICE_TRIGGER_CUSTOM_STATE_ID,
    pub s: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1 {
    pub DataOffset: DWORD,
    pub Data: [BYTE; 1usize],
}
pub type SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM =
    _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
pub type LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM =
    *mut _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DESCRIPTIONA {
    pub lpDescription: LPSTR,
}
pub type SERVICE_DESCRIPTIONA = _SERVICE_DESCRIPTIONA;
pub type LPSERVICE_DESCRIPTIONA = *mut _SERVICE_DESCRIPTIONA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DESCRIPTIONW {
    pub lpDescription: LPWSTR,
}
pub type SERVICE_DESCRIPTIONW = _SERVICE_DESCRIPTIONW;
pub type LPSERVICE_DESCRIPTIONW = *mut _SERVICE_DESCRIPTIONW;
pub type SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONA;
pub type LPSERVICE_DESCRIPTION = LPSERVICE_DESCRIPTIONA;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SC_ACTION_TYPE {
    SC_ACTION_NONE = 0,
    SC_ACTION_RESTART = 1,
    SC_ACTION_REBOOT = 2,
    SC_ACTION_RUN_COMMAND = 3,
    SC_ACTION_OWN_RESTART = 4,
}
pub use self::_SC_ACTION_TYPE as SC_ACTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SC_ACTION {
    pub Type: SC_ACTION_TYPE,
    pub Delay: DWORD,
}
pub type SC_ACTION = _SC_ACTION;
pub type LPSC_ACTION = *mut _SC_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONSA {
    pub dwResetPeriod: DWORD,
    pub lpRebootMsg: LPSTR,
    pub lpCommand: LPSTR,
    pub cActions: DWORD,
    pub lpsaActions: *mut SC_ACTION,
}
pub type SERVICE_FAILURE_ACTIONSA = _SERVICE_FAILURE_ACTIONSA;
pub type LPSERVICE_FAILURE_ACTIONSA = *mut _SERVICE_FAILURE_ACTIONSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONSW {
    pub dwResetPeriod: DWORD,
    pub lpRebootMsg: LPWSTR,
    pub lpCommand: LPWSTR,
    pub cActions: DWORD,
    pub lpsaActions: *mut SC_ACTION,
}
pub type SERVICE_FAILURE_ACTIONSW = _SERVICE_FAILURE_ACTIONSW;
pub type LPSERVICE_FAILURE_ACTIONSW = *mut _SERVICE_FAILURE_ACTIONSW;
pub type SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSA;
pub type LPSERVICE_FAILURE_ACTIONS = LPSERVICE_FAILURE_ACTIONSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DELAYED_AUTO_START_INFO {
    pub fDelayedAutostart: BOOL,
}
pub type SERVICE_DELAYED_AUTO_START_INFO = _SERVICE_DELAYED_AUTO_START_INFO;
pub type LPSERVICE_DELAYED_AUTO_START_INFO = *mut _SERVICE_DELAYED_AUTO_START_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONS_FLAG {
    pub fFailureActionsOnNonCrashFailures: BOOL,
}
pub type SERVICE_FAILURE_ACTIONS_FLAG = _SERVICE_FAILURE_ACTIONS_FLAG;
pub type LPSERVICE_FAILURE_ACTIONS_FLAG = *mut _SERVICE_FAILURE_ACTIONS_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_SID_INFO {
    pub dwServiceSidType: DWORD,
}
pub type SERVICE_SID_INFO = _SERVICE_SID_INFO;
pub type LPSERVICE_SID_INFO = *mut _SERVICE_SID_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    pub pmszRequiredPrivileges: LPSTR,
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOA = _SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub type LPSERVICE_REQUIRED_PRIVILEGES_INFOA = *mut _SERVICE_REQUIRED_PRIVILEGES_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    pub pmszRequiredPrivileges: LPWSTR,
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOW = _SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub type LPSERVICE_REQUIRED_PRIVILEGES_INFOW = *mut _SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub type SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub type LPSERVICE_REQUIRED_PRIVILEGES_INFO = LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_PRESHUTDOWN_INFO {
    pub dwPreshutdownTimeout: DWORD,
}
pub type SERVICE_PRESHUTDOWN_INFO = _SERVICE_PRESHUTDOWN_INFO;
pub type LPSERVICE_PRESHUTDOWN_INFO = *mut _SERVICE_PRESHUTDOWN_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
    pub dwDataType: DWORD,
    pub cbData: DWORD,
    pub pData: PBYTE,
}
pub type SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub type PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = *mut _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER {
    pub dwTriggerType: DWORD,
    pub dwAction: DWORD,
    pub pTriggerSubtype: *mut GUID,
    pub cDataItems: DWORD,
    pub pDataItems: PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM,
}
pub type SERVICE_TRIGGER = _SERVICE_TRIGGER;
pub type PSERVICE_TRIGGER = *mut _SERVICE_TRIGGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER_INFO {
    pub cTriggers: DWORD,
    pub pTriggers: PSERVICE_TRIGGER,
    pub pReserved: PBYTE,
}
pub type SERVICE_TRIGGER_INFO = _SERVICE_TRIGGER_INFO;
pub type PSERVICE_TRIGGER_INFO = *mut _SERVICE_TRIGGER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_PREFERRED_NODE_INFO {
    pub usPreferredNode: USHORT,
    pub fDelete: BOOLEAN,
}
pub type SERVICE_PREFERRED_NODE_INFO = _SERVICE_PREFERRED_NODE_INFO;
pub type LPSERVICE_PREFERRED_NODE_INFO = *mut _SERVICE_PREFERRED_NODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_TIMECHANGE_INFO {
    pub liNewTime: LARGE_INTEGER,
    pub liOldTime: LARGE_INTEGER,
}
pub type SERVICE_TIMECHANGE_INFO = _SERVICE_TIMECHANGE_INFO;
pub type PSERVICE_TIMECHANGE_INFO = *mut _SERVICE_TIMECHANGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_LAUNCH_PROTECTED_INFO {
    pub dwLaunchProtected: DWORD,
}
pub type SERVICE_LAUNCH_PROTECTED_INFO = _SERVICE_LAUNCH_PROTECTED_INFO;
pub type PSERVICE_LAUNCH_PROTECTED_INFO = *mut _SERVICE_LAUNCH_PROTECTED_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SC_HANDLE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type SC_HANDLE = *mut SC_HANDLE__;
pub type LPSC_HANDLE = *mut SC_HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_STATUS_HANDLE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type SERVICE_STATUS_HANDLE = *mut SERVICE_STATUS_HANDLE__;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO = 0,
}
pub use self::_SC_STATUS_TYPE as SC_STATUS_TYPE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO = 0,
}
pub use self::_SC_ENUM_TYPE as SC_ENUM_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_STATUS {
    pub dwServiceType: DWORD,
    pub dwCurrentState: DWORD,
    pub dwControlsAccepted: DWORD,
    pub dwWin32ExitCode: DWORD,
    pub dwServiceSpecificExitCode: DWORD,
    pub dwCheckPoint: DWORD,
    pub dwWaitHint: DWORD,
}
pub type SERVICE_STATUS = _SERVICE_STATUS;
pub type LPSERVICE_STATUS = *mut _SERVICE_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_STATUS_PROCESS {
    pub dwServiceType: DWORD,
    pub dwCurrentState: DWORD,
    pub dwControlsAccepted: DWORD,
    pub dwWin32ExitCode: DWORD,
    pub dwServiceSpecificExitCode: DWORD,
    pub dwCheckPoint: DWORD,
    pub dwWaitHint: DWORD,
    pub dwProcessId: DWORD,
    pub dwServiceFlags: DWORD,
}
pub type SERVICE_STATUS_PROCESS = _SERVICE_STATUS_PROCESS;
pub type LPSERVICE_STATUS_PROCESS = *mut _SERVICE_STATUS_PROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENUM_SERVICE_STATUSA {
    pub lpServiceName: LPSTR,
    pub lpDisplayName: LPSTR,
    pub ServiceStatus: SERVICE_STATUS,
}
pub type ENUM_SERVICE_STATUSA = _ENUM_SERVICE_STATUSA;
pub type LPENUM_SERVICE_STATUSA = *mut _ENUM_SERVICE_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENUM_SERVICE_STATUSW {
    pub lpServiceName: LPWSTR,
    pub lpDisplayName: LPWSTR,
    pub ServiceStatus: SERVICE_STATUS,
}
pub type ENUM_SERVICE_STATUSW = _ENUM_SERVICE_STATUSW;
pub type LPENUM_SERVICE_STATUSW = *mut _ENUM_SERVICE_STATUSW;
pub type ENUM_SERVICE_STATUS = ENUM_SERVICE_STATUSA;
pub type LPENUM_SERVICE_STATUS = LPENUM_SERVICE_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENUM_SERVICE_STATUS_PROCESSA {
    pub lpServiceName: LPSTR,
    pub lpDisplayName: LPSTR,
    pub ServiceStatusProcess: SERVICE_STATUS_PROCESS,
}
pub type ENUM_SERVICE_STATUS_PROCESSA = _ENUM_SERVICE_STATUS_PROCESSA;
pub type LPENUM_SERVICE_STATUS_PROCESSA = *mut _ENUM_SERVICE_STATUS_PROCESSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENUM_SERVICE_STATUS_PROCESSW {
    pub lpServiceName: LPWSTR,
    pub lpDisplayName: LPWSTR,
    pub ServiceStatusProcess: SERVICE_STATUS_PROCESS,
}
pub type ENUM_SERVICE_STATUS_PROCESSW = _ENUM_SERVICE_STATUS_PROCESSW;
pub type LPENUM_SERVICE_STATUS_PROCESSW = *mut _ENUM_SERVICE_STATUS_PROCESSW;
pub type ENUM_SERVICE_STATUS_PROCESS = ENUM_SERVICE_STATUS_PROCESSA;
pub type LPENUM_SERVICE_STATUS_PROCESS = LPENUM_SERVICE_STATUS_PROCESSA;
pub type SC_LOCK = LPVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_SERVICE_LOCK_STATUSA {
    pub fIsLocked: DWORD,
    pub lpLockOwner: LPSTR,
    pub dwLockDuration: DWORD,
}
pub type QUERY_SERVICE_LOCK_STATUSA = _QUERY_SERVICE_LOCK_STATUSA;
pub type LPQUERY_SERVICE_LOCK_STATUSA = *mut _QUERY_SERVICE_LOCK_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_SERVICE_LOCK_STATUSW {
    pub fIsLocked: DWORD,
    pub lpLockOwner: LPWSTR,
    pub dwLockDuration: DWORD,
}
pub type QUERY_SERVICE_LOCK_STATUSW = _QUERY_SERVICE_LOCK_STATUSW;
pub type LPQUERY_SERVICE_LOCK_STATUSW = *mut _QUERY_SERVICE_LOCK_STATUSW;
pub type QUERY_SERVICE_LOCK_STATUS = QUERY_SERVICE_LOCK_STATUSA;
pub type LPQUERY_SERVICE_LOCK_STATUS = LPQUERY_SERVICE_LOCK_STATUSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_SERVICE_CONFIGA {
    pub dwServiceType: DWORD,
    pub dwStartType: DWORD,
    pub dwErrorControl: DWORD,
    pub lpBinaryPathName: LPSTR,
    pub lpLoadOrderGroup: LPSTR,
    pub dwTagId: DWORD,
    pub lpDependencies: LPSTR,
    pub lpServiceStartName: LPSTR,
    pub lpDisplayName: LPSTR,
}
pub type QUERY_SERVICE_CONFIGA = _QUERY_SERVICE_CONFIGA;
pub type LPQUERY_SERVICE_CONFIGA = *mut _QUERY_SERVICE_CONFIGA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _QUERY_SERVICE_CONFIGW {
    pub dwServiceType: DWORD,
    pub dwStartType: DWORD,
    pub dwErrorControl: DWORD,
    pub lpBinaryPathName: LPWSTR,
    pub lpLoadOrderGroup: LPWSTR,
    pub dwTagId: DWORD,
    pub lpDependencies: LPWSTR,
    pub lpServiceStartName: LPWSTR,
    pub lpDisplayName: LPWSTR,
}
pub type QUERY_SERVICE_CONFIGW = _QUERY_SERVICE_CONFIGW;
pub type LPQUERY_SERVICE_CONFIGW = *mut _QUERY_SERVICE_CONFIGW;
pub type QUERY_SERVICE_CONFIG = QUERY_SERVICE_CONFIGA;
pub type LPQUERY_SERVICE_CONFIG = LPQUERY_SERVICE_CONFIGA;
pub type LPSERVICE_MAIN_FUNCTIONW = ::std::option::Option<
    unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPWSTR),
>;
pub type LPSERVICE_MAIN_FUNCTIONA = ::std::option::Option<
    unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPSTR),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TABLE_ENTRYA {
    pub lpServiceName: LPSTR,
    pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONA,
}
pub type SERVICE_TABLE_ENTRYA = _SERVICE_TABLE_ENTRYA;
pub type LPSERVICE_TABLE_ENTRYA = *mut _SERVICE_TABLE_ENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TABLE_ENTRYW {
    pub lpServiceName: LPWSTR,
    pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONW,
}
pub type SERVICE_TABLE_ENTRYW = _SERVICE_TABLE_ENTRYW;
pub type LPSERVICE_TABLE_ENTRYW = *mut _SERVICE_TABLE_ENTRYW;
pub type SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYA;
pub type LPSERVICE_TABLE_ENTRY = LPSERVICE_TABLE_ENTRYA;
pub type LPHANDLER_FUNCTION = ::std::option::Option<unsafe extern "C" fn(dwControl: DWORD)>;
pub type LPHANDLER_FUNCTION_EX = ::std::option::Option<
    unsafe extern "C" fn(
        dwControl: DWORD,
        dwEventType: DWORD,
        lpEventData: LPVOID,
        lpContext: LPVOID,
    ) -> DWORD,
>;
pub type PFN_SC_NOTIFY_CALLBACK = ::std::option::Option<unsafe extern "C" fn(pParameter: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_1 {
    pub dwVersion: DWORD,
    pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pub pContext: PVOID,
    pub dwNotificationStatus: DWORD,
    pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
pub type SERVICE_NOTIFY_1 = _SERVICE_NOTIFY_1;
pub type PSERVICE_NOTIFY_1 = *mut _SERVICE_NOTIFY_1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_2A {
    pub dwVersion: DWORD,
    pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pub pContext: PVOID,
    pub dwNotificationStatus: DWORD,
    pub ServiceStatus: SERVICE_STATUS_PROCESS,
    pub dwNotificationTriggered: DWORD,
    pub pszServiceNames: LPSTR,
}
pub type SERVICE_NOTIFY_2A = _SERVICE_NOTIFY_2A;
pub type PSERVICE_NOTIFY_2A = *mut _SERVICE_NOTIFY_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_2W {
    pub dwVersion: DWORD,
    pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pub pContext: PVOID,
    pub dwNotificationStatus: DWORD,
    pub ServiceStatus: SERVICE_STATUS_PROCESS,
    pub dwNotificationTriggered: DWORD,
    pub pszServiceNames: LPWSTR,
}
pub type SERVICE_NOTIFY_2W = _SERVICE_NOTIFY_2W;
pub type PSERVICE_NOTIFY_2W = *mut _SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2A;
pub type PSERVICE_NOTIFY_2 = PSERVICE_NOTIFY_2A;
pub type SERVICE_NOTIFYA = SERVICE_NOTIFY_2A;
pub type PSERVICE_NOTIFYA = *mut SERVICE_NOTIFY_2A;
pub type SERVICE_NOTIFYW = SERVICE_NOTIFY_2W;
pub type PSERVICE_NOTIFYW = *mut SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY = SERVICE_NOTIFYA;
pub type PSERVICE_NOTIFY = PSERVICE_NOTIFYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    pub dwReason: DWORD,
    pub pszComment: LPSTR,
    pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSA = _SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub type PSERVICE_CONTROL_STATUS_REASON_PARAMSA = *mut _SERVICE_CONTROL_STATUS_REASON_PARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    pub dwReason: DWORD,
    pub pszComment: LPWSTR,
    pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSW = _SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub type PSERVICE_CONTROL_STATUS_REASON_PARAMSW = *mut _SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub type SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub type PSERVICE_CONTROL_STATUS_REASON_PARAMS = PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_START_REASON {
    pub dwReason: DWORD,
}
pub type SERVICE_START_REASON = _SERVICE_START_REASON;
pub type PSERVICE_START_REASON = *mut _SERVICE_START_REASON;
extern "C" {
    pub fn ChangeServiceConfigA(
        hService: SC_HANDLE,
        dwServiceType: DWORD,
        dwStartType: DWORD,
        dwErrorControl: DWORD,
        lpBinaryPathName: LPCSTR,
        lpLoadOrderGroup: LPCSTR,
        lpdwTagId: LPDWORD,
        lpDependencies: LPCSTR,
        lpServiceStartName: LPCSTR,
        lpPassword: LPCSTR,
        lpDisplayName: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ChangeServiceConfigW(
        hService: SC_HANDLE,
        dwServiceType: DWORD,
        dwStartType: DWORD,
        dwErrorControl: DWORD,
        lpBinaryPathName: LPCWSTR,
        lpLoadOrderGroup: LPCWSTR,
        lpdwTagId: LPDWORD,
        lpDependencies: LPCWSTR,
        lpServiceStartName: LPCWSTR,
        lpPassword: LPCWSTR,
        lpDisplayName: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ChangeServiceConfig2A(hService: SC_HANDLE, dwInfoLevel: DWORD, lpInfo: LPVOID) -> BOOL;
}
extern "C" {
    pub fn ChangeServiceConfig2W(hService: SC_HANDLE, dwInfoLevel: DWORD, lpInfo: LPVOID) -> BOOL;
}
extern "C" {
    pub fn CloseServiceHandle(hSCObject: SC_HANDLE) -> BOOL;
}
extern "C" {
    pub fn ControlService(
        hService: SC_HANDLE,
        dwControl: DWORD,
        lpServiceStatus: LPSERVICE_STATUS,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateServiceA(
        hSCManager: SC_HANDLE,
        lpServiceName: LPCSTR,
        lpDisplayName: LPCSTR,
        dwDesiredAccess: DWORD,
        dwServiceType: DWORD,
        dwStartType: DWORD,
        dwErrorControl: DWORD,
        lpBinaryPathName: LPCSTR,
        lpLoadOrderGroup: LPCSTR,
        lpdwTagId: LPDWORD,
        lpDependencies: LPCSTR,
        lpServiceStartName: LPCSTR,
        lpPassword: LPCSTR,
    ) -> SC_HANDLE;
}
extern "C" {
    pub fn CreateServiceW(
        hSCManager: SC_HANDLE,
        lpServiceName: LPCWSTR,
        lpDisplayName: LPCWSTR,
        dwDesiredAccess: DWORD,
        dwServiceType: DWORD,
        dwStartType: DWORD,
        dwErrorControl: DWORD,
        lpBinaryPathName: LPCWSTR,
        lpLoadOrderGroup: LPCWSTR,
        lpdwTagId: LPDWORD,
        lpDependencies: LPCWSTR,
        lpServiceStartName: LPCWSTR,
        lpPassword: LPCWSTR,
    ) -> SC_HANDLE;
}
extern "C" {
    pub fn DeleteService(hService: SC_HANDLE) -> BOOL;
}
extern "C" {
    pub fn EnumDependentServicesA(
        hService: SC_HANDLE,
        dwServiceState: DWORD,
        lpServices: LPENUM_SERVICE_STATUSA,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
        lpServicesReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumDependentServicesW(
        hService: SC_HANDLE,
        dwServiceState: DWORD,
        lpServices: LPENUM_SERVICE_STATUSW,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
        lpServicesReturned: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumServicesStatusA(
        hSCManager: SC_HANDLE,
        dwServiceType: DWORD,
        dwServiceState: DWORD,
        lpServices: LPENUM_SERVICE_STATUSA,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
        lpServicesReturned: LPDWORD,
        lpResumeHandle: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumServicesStatusW(
        hSCManager: SC_HANDLE,
        dwServiceType: DWORD,
        dwServiceState: DWORD,
        lpServices: LPENUM_SERVICE_STATUSW,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
        lpServicesReturned: LPDWORD,
        lpResumeHandle: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumServicesStatusExA(
        hSCManager: SC_HANDLE,
        InfoLevel: SC_ENUM_TYPE,
        dwServiceType: DWORD,
        dwServiceState: DWORD,
        lpServices: LPBYTE,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
        lpServicesReturned: LPDWORD,
        lpResumeHandle: LPDWORD,
        pszGroupName: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn EnumServicesStatusExW(
        hSCManager: SC_HANDLE,
        InfoLevel: SC_ENUM_TYPE,
        dwServiceType: DWORD,
        dwServiceState: DWORD,
        lpServices: LPBYTE,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
        lpServicesReturned: LPDWORD,
        lpResumeHandle: LPDWORD,
        pszGroupName: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn GetServiceKeyNameA(
        hSCManager: SC_HANDLE,
        lpDisplayName: LPCSTR,
        lpServiceName: LPSTR,
        lpcchBuffer: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetServiceKeyNameW(
        hSCManager: SC_HANDLE,
        lpDisplayName: LPCWSTR,
        lpServiceName: LPWSTR,
        lpcchBuffer: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetServiceDisplayNameA(
        hSCManager: SC_HANDLE,
        lpServiceName: LPCSTR,
        lpDisplayName: LPSTR,
        lpcchBuffer: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetServiceDisplayNameW(
        hSCManager: SC_HANDLE,
        lpServiceName: LPCWSTR,
        lpDisplayName: LPWSTR,
        lpcchBuffer: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn LockServiceDatabase(hSCManager: SC_HANDLE) -> SC_LOCK;
}
extern "C" {
    pub fn NotifyBootConfigStatus(BootAcceptable: BOOL) -> BOOL;
}
extern "C" {
    pub fn OpenSCManagerA(
        lpMachineName: LPCSTR,
        lpDatabaseName: LPCSTR,
        dwDesiredAccess: DWORD,
    ) -> SC_HANDLE;
}
extern "C" {
    pub fn OpenSCManagerW(
        lpMachineName: LPCWSTR,
        lpDatabaseName: LPCWSTR,
        dwDesiredAccess: DWORD,
    ) -> SC_HANDLE;
}
extern "C" {
    pub fn OpenServiceA(
        hSCManager: SC_HANDLE,
        lpServiceName: LPCSTR,
        dwDesiredAccess: DWORD,
    ) -> SC_HANDLE;
}
extern "C" {
    pub fn OpenServiceW(
        hSCManager: SC_HANDLE,
        lpServiceName: LPCWSTR,
        dwDesiredAccess: DWORD,
    ) -> SC_HANDLE;
}
extern "C" {
    pub fn QueryServiceConfigA(
        hService: SC_HANDLE,
        lpServiceConfig: LPQUERY_SERVICE_CONFIGA,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceConfigW(
        hService: SC_HANDLE,
        lpServiceConfig: LPQUERY_SERVICE_CONFIGW,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceConfig2A(
        hService: SC_HANDLE,
        dwInfoLevel: DWORD,
        lpBuffer: LPBYTE,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceConfig2W(
        hService: SC_HANDLE,
        dwInfoLevel: DWORD,
        lpBuffer: LPBYTE,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceLockStatusA(
        hSCManager: SC_HANDLE,
        lpLockStatus: LPQUERY_SERVICE_LOCK_STATUSA,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceLockStatusW(
        hSCManager: SC_HANDLE,
        lpLockStatus: LPQUERY_SERVICE_LOCK_STATUSW,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceObjectSecurity(
        hService: SC_HANDLE,
        dwSecurityInformation: SECURITY_INFORMATION,
        lpSecurityDescriptor: PSECURITY_DESCRIPTOR,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceStatus(hService: SC_HANDLE, lpServiceStatus: LPSERVICE_STATUS) -> BOOL;
}
extern "C" {
    pub fn QueryServiceStatusEx(
        hService: SC_HANDLE,
        InfoLevel: SC_STATUS_TYPE,
        lpBuffer: LPBYTE,
        cbBufSize: DWORD,
        pcbBytesNeeded: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn RegisterServiceCtrlHandlerA(
        lpServiceName: LPCSTR,
        lpHandlerProc: LPHANDLER_FUNCTION,
    ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
    pub fn RegisterServiceCtrlHandlerW(
        lpServiceName: LPCWSTR,
        lpHandlerProc: LPHANDLER_FUNCTION,
    ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
    pub fn RegisterServiceCtrlHandlerExA(
        lpServiceName: LPCSTR,
        lpHandlerProc: LPHANDLER_FUNCTION_EX,
        lpContext: LPVOID,
    ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
    pub fn RegisterServiceCtrlHandlerExW(
        lpServiceName: LPCWSTR,
        lpHandlerProc: LPHANDLER_FUNCTION_EX,
        lpContext: LPVOID,
    ) -> SERVICE_STATUS_HANDLE;
}
extern "C" {
    pub fn SetServiceObjectSecurity(
        hService: SC_HANDLE,
        dwSecurityInformation: SECURITY_INFORMATION,
        lpSecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> BOOL;
}
extern "C" {
    pub fn SetServiceStatus(
        hServiceStatus: SERVICE_STATUS_HANDLE,
        lpServiceStatus: LPSERVICE_STATUS,
    ) -> BOOL;
}
extern "C" {
    pub fn StartServiceCtrlDispatcherA(lpServiceStartTable: *const SERVICE_TABLE_ENTRYA) -> BOOL;
}
extern "C" {
    pub fn StartServiceCtrlDispatcherW(lpServiceStartTable: *const SERVICE_TABLE_ENTRYW) -> BOOL;
}
extern "C" {
    pub fn StartServiceA(
        hService: SC_HANDLE,
        dwNumServiceArgs: DWORD,
        lpServiceArgVectors: *mut LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn StartServiceW(
        hService: SC_HANDLE,
        dwNumServiceArgs: DWORD,
        lpServiceArgVectors: *mut LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn UnlockServiceDatabase(ScLock: SC_LOCK) -> BOOL;
}
extern "C" {
    pub fn NotifyServiceStatusChangeA(
        hService: SC_HANDLE,
        dwNotifyMask: DWORD,
        pNotifyBuffer: PSERVICE_NOTIFYA,
    ) -> DWORD;
}
extern "C" {
    pub fn NotifyServiceStatusChangeW(
        hService: SC_HANDLE,
        dwNotifyMask: DWORD,
        pNotifyBuffer: PSERVICE_NOTIFYW,
    ) -> DWORD;
}
extern "C" {
    pub fn ControlServiceExA(
        hService: SC_HANDLE,
        dwControl: DWORD,
        dwInfoLevel: DWORD,
        pControlParams: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn ControlServiceExW(
        hService: SC_HANDLE,
        dwControl: DWORD,
        dwInfoLevel: DWORD,
        pControlParams: PVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn QueryServiceDynamicInformation(
        hServiceStatus: SERVICE_STATUS_HANDLE,
        dwInfoLevel: DWORD,
        ppDynamicInfo: *mut PVOID,
    ) -> BOOL;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _SC_EVENT_TYPE {
    SC_EVENT_DATABASE_CHANGE = 0,
    SC_EVENT_PROPERTY_CHANGE = 1,
    SC_EVENT_STATUS_CHANGE = 2,
}
pub use self::_SC_EVENT_TYPE as SC_EVENT_TYPE;
pub type PSC_EVENT_TYPE = *mut _SC_EVENT_TYPE;
pub type PSC_NOTIFICATION_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SC_NOTIFICATION_REGISTRATION {
    _unused: [u8; 0],
}
pub type PSC_NOTIFICATION_REGISTRATION = *mut _SC_NOTIFICATION_REGISTRATION;
extern "C" {
    pub fn SubscribeServiceChangeNotifications(
        hService: SC_HANDLE,
        eEventType: SC_EVENT_TYPE,
        pCallback: PSC_NOTIFICATION_CALLBACK,
        pCallbackContext: PVOID,
        pSubscription: *mut PSC_NOTIFICATION_REGISTRATION,
    ) -> DWORD;
}
extern "C" {
    pub fn UnsubscribeServiceChangeNotifications(pSubscription: PSC_NOTIFICATION_REGISTRATION);
}
extern "C" {
    pub fn WaitServiceState(
        hService: SC_HANDLE,
        dwNotify: DWORD,
        dwTimeout: DWORD,
        hCancelEvent: HANDLE,
    ) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SERVICE_REGISTRY_STATE_TYPE {
    ServiceRegistryStateParameters = 0,
    ServiceRegistryStatePersistent = 1,
    MaxServiceRegistryStateType = 2,
}
extern "C" {
    pub fn GetServiceRegistryStateKey(
        ServiceStatusHandle: SERVICE_STATUS_HANDLE,
        StateType: SERVICE_REGISTRY_STATE_TYPE,
        AccessMask: DWORD,
        ServiceStateKey: *mut HKEY,
    ) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SERVICE_DIRECTORY_TYPE {
    ServiceDirectoryPersistentState = 0,
    ServiceDirectoryTypeMax = 1,
}
extern "C" {
    pub fn GetServiceDirectory(
        hServiceStatus: SERVICE_STATUS_HANDLE,
        eDirectoryType: SERVICE_DIRECTORY_TYPE,
        lpPathBuffer: PWCHAR,
        cchPathBufferLength: DWORD,
        lpcchRequiredBufferLength: *mut DWORD,
    ) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SERVICE_SHARED_REGISTRY_STATE_TYPE {
    ServiceSharedRegistryPersistentState = 0,
}
extern "C" {
    pub fn GetSharedServiceRegistryStateKey(
        ServiceHandle: SC_HANDLE,
        StateType: SERVICE_SHARED_REGISTRY_STATE_TYPE,
        AccessMask: DWORD,
        ServiceStateKey: *mut HKEY,
    ) -> DWORD;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SERVICE_SHARED_DIRECTORY_TYPE {
    ServiceSharedDirectoryPersistentState = 0,
}
extern "C" {
    pub fn GetSharedServiceDirectory(
        ServiceHandle: SC_HANDLE,
        DirectoryType: SERVICE_SHARED_DIRECTORY_TYPE,
        PathBuffer: PWCHAR,
        PathBufferLength: DWORD,
        RequiredBufferLength: *mut DWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MODEMDEVCAPS {
    pub dwActualSize: DWORD,
    pub dwRequiredSize: DWORD,
    pub dwDevSpecificOffset: DWORD,
    pub dwDevSpecificSize: DWORD,
    pub dwModemProviderVersion: DWORD,
    pub dwModemManufacturerOffset: DWORD,
    pub dwModemManufacturerSize: DWORD,
    pub dwModemModelOffset: DWORD,
    pub dwModemModelSize: DWORD,
    pub dwModemVersionOffset: DWORD,
    pub dwModemVersionSize: DWORD,
    pub dwDialOptions: DWORD,
    pub dwCallSetupFailTimer: DWORD,
    pub dwInactivityTimeout: DWORD,
    pub dwSpeakerVolume: DWORD,
    pub dwSpeakerMode: DWORD,
    pub dwModemOptions: DWORD,
    pub dwMaxDTERate: DWORD,
    pub dwMaxDCERate: DWORD,
    pub abVariablePortion: [BYTE; 1usize],
}
pub type MODEMDEVCAPS = _MODEMDEVCAPS;
pub type PMODEMDEVCAPS = *mut _MODEMDEVCAPS;
pub type LPMODEMDEVCAPS = *mut _MODEMDEVCAPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MODEMSETTINGS {
    pub dwActualSize: DWORD,
    pub dwRequiredSize: DWORD,
    pub dwDevSpecificOffset: DWORD,
    pub dwDevSpecificSize: DWORD,
    pub dwCallSetupFailTimer: DWORD,
    pub dwInactivityTimeout: DWORD,
    pub dwSpeakerVolume: DWORD,
    pub dwSpeakerMode: DWORD,
    pub dwPreferredModemOptions: DWORD,
    pub dwNegotiatedModemOptions: DWORD,
    pub dwNegotiatedDCERate: DWORD,
    pub abVariablePortion: [BYTE; 1usize],
}
pub type MODEMSETTINGS = _MODEMSETTINGS;
pub type PMODEMSETTINGS = *mut _MODEMSETTINGS;
pub type LPMODEMSETTINGS = *mut _MODEMSETTINGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIMC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HIMC = *mut HIMC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIMCC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HIMCC = *mut HIMCC__;
pub type LPHKL = *mut HKL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCOMPOSITIONFORM {
    pub dwStyle: DWORD,
    pub ptCurrentPos: POINT,
    pub rcArea: RECT,
}
pub type COMPOSITIONFORM = tagCOMPOSITIONFORM;
pub type PCOMPOSITIONFORM = *mut tagCOMPOSITIONFORM;
pub type NPCOMPOSITIONFORM = *mut tagCOMPOSITIONFORM;
pub type LPCOMPOSITIONFORM = *mut tagCOMPOSITIONFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCANDIDATEFORM {
    pub dwIndex: DWORD,
    pub dwStyle: DWORD,
    pub ptCurrentPos: POINT,
    pub rcArea: RECT,
}
pub type CANDIDATEFORM = tagCANDIDATEFORM;
pub type PCANDIDATEFORM = *mut tagCANDIDATEFORM;
pub type NPCANDIDATEFORM = *mut tagCANDIDATEFORM;
pub type LPCANDIDATEFORM = *mut tagCANDIDATEFORM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCANDIDATELIST {
    pub dwSize: DWORD,
    pub dwStyle: DWORD,
    pub dwCount: DWORD,
    pub dwSelection: DWORD,
    pub dwPageStart: DWORD,
    pub dwPageSize: DWORD,
    pub dwOffset: [DWORD; 1usize],
}
pub type CANDIDATELIST = tagCANDIDATELIST;
pub type PCANDIDATELIST = *mut tagCANDIDATELIST;
pub type NPCANDIDATELIST = *mut tagCANDIDATELIST;
pub type LPCANDIDATELIST = *mut tagCANDIDATELIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagREGISTERWORDA {
    pub lpReading: LPSTR,
    pub lpWord: LPSTR,
}
pub type REGISTERWORDA = tagREGISTERWORDA;
pub type PREGISTERWORDA = *mut tagREGISTERWORDA;
pub type NPREGISTERWORDA = *mut tagREGISTERWORDA;
pub type LPREGISTERWORDA = *mut tagREGISTERWORDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagREGISTERWORDW {
    pub lpReading: LPWSTR,
    pub lpWord: LPWSTR,
}
pub type REGISTERWORDW = tagREGISTERWORDW;
pub type PREGISTERWORDW = *mut tagREGISTERWORDW;
pub type NPREGISTERWORDW = *mut tagREGISTERWORDW;
pub type LPREGISTERWORDW = *mut tagREGISTERWORDW;
pub type REGISTERWORD = REGISTERWORDA;
pub type PREGISTERWORD = PREGISTERWORDA;
pub type NPREGISTERWORD = NPREGISTERWORDA;
pub type LPREGISTERWORD = LPREGISTERWORDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRECONVERTSTRING {
    pub dwSize: DWORD,
    pub dwVersion: DWORD,
    pub dwStrLen: DWORD,
    pub dwStrOffset: DWORD,
    pub dwCompStrLen: DWORD,
    pub dwCompStrOffset: DWORD,
    pub dwTargetStrLen: DWORD,
    pub dwTargetStrOffset: DWORD,
}
pub type RECONVERTSTRING = tagRECONVERTSTRING;
pub type PRECONVERTSTRING = *mut tagRECONVERTSTRING;
pub type NPRECONVERTSTRING = *mut tagRECONVERTSTRING;
pub type LPRECONVERTSTRING = *mut tagRECONVERTSTRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLEBUFA {
    pub dwStyle: DWORD,
    pub szDescription: [CHAR; 32usize],
}
pub type STYLEBUFA = tagSTYLEBUFA;
pub type PSTYLEBUFA = *mut tagSTYLEBUFA;
pub type NPSTYLEBUFA = *mut tagSTYLEBUFA;
pub type LPSTYLEBUFA = *mut tagSTYLEBUFA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLEBUFW {
    pub dwStyle: DWORD,
    pub szDescription: [WCHAR; 32usize],
}
pub type STYLEBUFW = tagSTYLEBUFW;
pub type PSTYLEBUFW = *mut tagSTYLEBUFW;
pub type NPSTYLEBUFW = *mut tagSTYLEBUFW;
pub type LPSTYLEBUFW = *mut tagSTYLEBUFW;
pub type STYLEBUF = STYLEBUFA;
pub type PSTYLEBUF = PSTYLEBUFA;
pub type NPSTYLEBUF = NPSTYLEBUFA;
pub type LPSTYLEBUF = LPSTYLEBUFA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIMEMENUITEMINFOA {
    pub cbSize: UINT,
    pub fType: UINT,
    pub fState: UINT,
    pub wID: UINT,
    pub hbmpChecked: HBITMAP,
    pub hbmpUnchecked: HBITMAP,
    pub dwItemData: DWORD,
    pub szString: [CHAR; 80usize],
    pub hbmpItem: HBITMAP,
}
pub type IMEMENUITEMINFOA = tagIMEMENUITEMINFOA;
pub type PIMEMENUITEMINFOA = *mut tagIMEMENUITEMINFOA;
pub type NPIMEMENUITEMINFOA = *mut tagIMEMENUITEMINFOA;
pub type LPIMEMENUITEMINFOA = *mut tagIMEMENUITEMINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIMEMENUITEMINFOW {
    pub cbSize: UINT,
    pub fType: UINT,
    pub fState: UINT,
    pub wID: UINT,
    pub hbmpChecked: HBITMAP,
    pub hbmpUnchecked: HBITMAP,
    pub dwItemData: DWORD,
    pub szString: [WCHAR; 80usize],
    pub hbmpItem: HBITMAP,
}
pub type IMEMENUITEMINFOW = tagIMEMENUITEMINFOW;
pub type PIMEMENUITEMINFOW = *mut tagIMEMENUITEMINFOW;
pub type NPIMEMENUITEMINFOW = *mut tagIMEMENUITEMINFOW;
pub type LPIMEMENUITEMINFOW = *mut tagIMEMENUITEMINFOW;
pub type IMEMENUITEMINFO = IMEMENUITEMINFOA;
pub type PIMEMENUITEMINFO = PIMEMENUITEMINFOA;
pub type NPIMEMENUITEMINFO = NPIMEMENUITEMINFOA;
pub type LPIMEMENUITEMINFO = LPIMEMENUITEMINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIMECHARPOSITION {
    pub dwSize: DWORD,
    pub dwCharPos: DWORD,
    pub pt: POINT,
    pub cLineHeight: UINT,
    pub rcDocument: RECT,
}
pub type IMECHARPOSITION = tagIMECHARPOSITION;
pub type PIMECHARPOSITION = *mut tagIMECHARPOSITION;
pub type NPIMECHARPOSITION = *mut tagIMECHARPOSITION;
pub type LPIMECHARPOSITION = *mut tagIMECHARPOSITION;
pub type IMCENUMPROC =
    ::std::option::Option<unsafe extern "C" fn(arg1: HIMC, arg2: LPARAM) -> BOOL>;
extern "C" {
    pub fn ImmInstallIMEA(lpszIMEFileName: LPCSTR, lpszLayoutText: LPCSTR) -> HKL;
}
extern "C" {
    pub fn ImmInstallIMEW(lpszIMEFileName: LPCWSTR, lpszLayoutText: LPCWSTR) -> HKL;
}
extern "C" {
    pub fn ImmGetDefaultIMEWnd(arg1: HWND) -> HWND;
}
extern "C" {
    pub fn ImmGetDescriptionA(arg1: HKL, lpszDescription: LPSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
    pub fn ImmGetDescriptionW(arg1: HKL, lpszDescription: LPWSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
    pub fn ImmGetIMEFileNameA(arg1: HKL, lpszFileName: LPSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
    pub fn ImmGetIMEFileNameW(arg1: HKL, lpszFileName: LPWSTR, uBufLen: UINT) -> UINT;
}
extern "C" {
    pub fn ImmGetProperty(arg1: HKL, arg2: DWORD) -> DWORD;
}
extern "C" {
    pub fn ImmIsIME(arg1: HKL) -> BOOL;
}
extern "C" {
    pub fn ImmSimulateHotKey(arg1: HWND, arg2: DWORD) -> BOOL;
}
extern "C" {
    pub fn ImmCreateContext() -> HIMC;
}
extern "C" {
    pub fn ImmDestroyContext(arg1: HIMC) -> BOOL;
}
extern "C" {
    pub fn ImmGetContext(arg1: HWND) -> HIMC;
}
extern "C" {
    pub fn ImmReleaseContext(arg1: HWND, arg2: HIMC) -> BOOL;
}
extern "C" {
    pub fn ImmAssociateContext(arg1: HWND, arg2: HIMC) -> HIMC;
}
extern "C" {
    pub fn ImmAssociateContextEx(arg1: HWND, arg2: HIMC, arg3: DWORD) -> BOOL;
}
extern "C" {
    pub fn ImmGetCompositionStringA(
        arg1: HIMC,
        arg2: DWORD,
        lpBuf: LPVOID,
        dwBufLen: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn ImmGetCompositionStringW(
        arg1: HIMC,
        arg2: DWORD,
        lpBuf: LPVOID,
        dwBufLen: DWORD,
    ) -> LONG;
}
extern "C" {
    pub fn ImmSetCompositionStringA(
        arg1: HIMC,
        dwIndex: DWORD,
        lpComp: LPVOID,
        dwCompLen: DWORD,
        lpRead: LPVOID,
        dwReadLen: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmSetCompositionStringW(
        arg1: HIMC,
        dwIndex: DWORD,
        lpComp: LPVOID,
        dwCompLen: DWORD,
        lpRead: LPVOID,
        dwReadLen: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmGetCandidateListCountA(arg1: HIMC, lpdwListCount: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn ImmGetCandidateListCountW(arg1: HIMC, lpdwListCount: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn ImmGetCandidateListA(
        arg1: HIMC,
        deIndex: DWORD,
        lpCandList: LPCANDIDATELIST,
        dwBufLen: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn ImmGetCandidateListW(
        arg1: HIMC,
        deIndex: DWORD,
        lpCandList: LPCANDIDATELIST,
        dwBufLen: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn ImmGetGuideLineA(arg1: HIMC, dwIndex: DWORD, lpBuf: LPSTR, dwBufLen: DWORD) -> DWORD;
}
extern "C" {
    pub fn ImmGetGuideLineW(arg1: HIMC, dwIndex: DWORD, lpBuf: LPWSTR, dwBufLen: DWORD) -> DWORD;
}
extern "C" {
    pub fn ImmGetConversionStatus(
        arg1: HIMC,
        lpfdwConversion: LPDWORD,
        lpfdwSentence: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmSetConversionStatus(arg1: HIMC, arg2: DWORD, arg3: DWORD) -> BOOL;
}
extern "C" {
    pub fn ImmGetOpenStatus(arg1: HIMC) -> BOOL;
}
extern "C" {
    pub fn ImmSetOpenStatus(arg1: HIMC, arg2: BOOL) -> BOOL;
}
extern "C" {
    pub fn ImmGetCompositionFontA(arg1: HIMC, lplf: LPLOGFONTA) -> BOOL;
}
extern "C" {
    pub fn ImmGetCompositionFontW(arg1: HIMC, lplf: LPLOGFONTW) -> BOOL;
}
extern "C" {
    pub fn ImmSetCompositionFontA(arg1: HIMC, lplf: LPLOGFONTA) -> BOOL;
}
extern "C" {
    pub fn ImmSetCompositionFontW(arg1: HIMC, lplf: LPLOGFONTW) -> BOOL;
}
extern "C" {
    pub fn ImmConfigureIMEA(arg1: HKL, arg2: HWND, arg3: DWORD, arg4: LPVOID) -> BOOL;
}
extern "C" {
    pub fn ImmConfigureIMEW(arg1: HKL, arg2: HWND, arg3: DWORD, arg4: LPVOID) -> BOOL;
}
extern "C" {
    pub fn ImmEscapeA(arg1: HKL, arg2: HIMC, arg3: UINT, arg4: LPVOID) -> LRESULT;
}
extern "C" {
    pub fn ImmEscapeW(arg1: HKL, arg2: HIMC, arg3: UINT, arg4: LPVOID) -> LRESULT;
}
extern "C" {
    pub fn ImmGetConversionListA(
        arg1: HKL,
        arg2: HIMC,
        lpSrc: LPCSTR,
        lpDst: LPCANDIDATELIST,
        dwBufLen: DWORD,
        uFlag: UINT,
    ) -> DWORD;
}
extern "C" {
    pub fn ImmGetConversionListW(
        arg1: HKL,
        arg2: HIMC,
        lpSrc: LPCWSTR,
        lpDst: LPCANDIDATELIST,
        dwBufLen: DWORD,
        uFlag: UINT,
    ) -> DWORD;
}
extern "C" {
    pub fn ImmNotifyIME(arg1: HIMC, dwAction: DWORD, dwIndex: DWORD, dwValue: DWORD) -> BOOL;
}
extern "C" {
    pub fn ImmGetStatusWindowPos(arg1: HIMC, lpptPos: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn ImmSetStatusWindowPos(arg1: HIMC, lpptPos: LPPOINT) -> BOOL;
}
extern "C" {
    pub fn ImmGetCompositionWindow(arg1: HIMC, lpCompForm: LPCOMPOSITIONFORM) -> BOOL;
}
extern "C" {
    pub fn ImmSetCompositionWindow(arg1: HIMC, lpCompForm: LPCOMPOSITIONFORM) -> BOOL;
}
extern "C" {
    pub fn ImmGetCandidateWindow(arg1: HIMC, arg2: DWORD, lpCandidate: LPCANDIDATEFORM) -> BOOL;
}
extern "C" {
    pub fn ImmSetCandidateWindow(arg1: HIMC, lpCandidate: LPCANDIDATEFORM) -> BOOL;
}
extern "C" {
    pub fn ImmIsUIMessageA(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> BOOL;
}
extern "C" {
    pub fn ImmIsUIMessageW(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> BOOL;
}
extern "C" {
    pub fn ImmGetVirtualKey(arg1: HWND) -> UINT;
}
pub type REGISTERWORDENUMPROCA = ::std::option::Option<
    unsafe extern "C" fn(
        lpszReading: LPCSTR,
        arg1: DWORD,
        lpszString: LPCSTR,
        arg2: LPVOID,
    ) -> ::std::os::raw::c_int,
>;
pub type REGISTERWORDENUMPROCW = ::std::option::Option<
    unsafe extern "C" fn(
        lpszReading: LPCWSTR,
        arg1: DWORD,
        lpszString: LPCWSTR,
        arg2: LPVOID,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ImmRegisterWordA(
        arg1: HKL,
        lpszReading: LPCSTR,
        arg2: DWORD,
        lpszRegister: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmRegisterWordW(
        arg1: HKL,
        lpszReading: LPCWSTR,
        arg2: DWORD,
        lpszRegister: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmUnregisterWordA(
        arg1: HKL,
        lpszReading: LPCSTR,
        arg2: DWORD,
        lpszUnregister: LPCSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmUnregisterWordW(
        arg1: HKL,
        lpszReading: LPCWSTR,
        arg2: DWORD,
        lpszUnregister: LPCWSTR,
    ) -> BOOL;
}
extern "C" {
    pub fn ImmGetRegisterWordStyleA(arg1: HKL, nItem: UINT, lpStyleBuf: LPSTYLEBUFA) -> UINT;
}
extern "C" {
    pub fn ImmGetRegisterWordStyleW(arg1: HKL, nItem: UINT, lpStyleBuf: LPSTYLEBUFW) -> UINT;
}
extern "C" {
    pub fn ImmEnumRegisterWordA(
        arg1: HKL,
        arg2: REGISTERWORDENUMPROCA,
        lpszReading: LPCSTR,
        arg3: DWORD,
        lpszRegister: LPCSTR,
        arg4: LPVOID,
    ) -> UINT;
}
extern "C" {
    pub fn ImmEnumRegisterWordW(
        arg1: HKL,
        arg2: REGISTERWORDENUMPROCW,
        lpszReading: LPCWSTR,
        arg3: DWORD,
        lpszRegister: LPCWSTR,
        arg4: LPVOID,
    ) -> UINT;
}
extern "C" {
    pub fn ImmDisableIME(arg1: DWORD) -> BOOL;
}
extern "C" {
    pub fn ImmEnumInputContext(idThread: DWORD, lpfn: IMCENUMPROC, lParam: LPARAM) -> BOOL;
}
extern "C" {
    pub fn ImmGetImeMenuItemsA(
        arg1: HIMC,
        arg2: DWORD,
        arg3: DWORD,
        lpImeParentMenu: LPIMEMENUITEMINFOA,
        lpImeMenu: LPIMEMENUITEMINFOA,
        dwSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn ImmGetImeMenuItemsW(
        arg1: HIMC,
        arg2: DWORD,
        arg3: DWORD,
        lpImeParentMenu: LPIMEMENUITEMINFOW,
        lpImeMenu: LPIMEMENUITEMINFOW,
        dwSize: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn ImmDisableTextFrameService(idThread: DWORD) -> BOOL;
}
extern "C" {
    pub fn ImmDisableLegacyIME() -> BOOL;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(i32)]
#[doc = " Audio sample formats\n\n - The data described by the sample format is always in native-endian order.\n   Sample values can be expressed by native C types, hence the lack of a signed\n   24-bit sample format even though it is a common raw audio data format.\n\n - The floating-point formats are based on full volume being in the range\n   [-1.0, 1.0]. Any values outside this range are beyond full volume level.\n\n - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg\n   (such as AVFrame in libavcodec) is as follows:\n\n @par\n For planar sample formats, each audio channel is in a separate data plane,\n and linesize is the buffer size, in bytes, for a single plane. All data\n planes must be the same size. For packed sample formats, only the first data\n plane is used, and samples for each channel are interleaved. In this case,\n linesize is the buffer size, in bytes, for the 1 plane.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    #[doc = "< unsigned 8 bits"]
    AV_SAMPLE_FMT_U8 = 0,
    #[doc = "< signed 16 bits"]
    AV_SAMPLE_FMT_S16 = 1,
    #[doc = "< signed 32 bits"]
    AV_SAMPLE_FMT_S32 = 2,
    #[doc = "< float"]
    AV_SAMPLE_FMT_FLT = 3,
    #[doc = "< double"]
    AV_SAMPLE_FMT_DBL = 4,
    #[doc = "< unsigned 8 bits, planar"]
    AV_SAMPLE_FMT_U8P = 5,
    #[doc = "< signed 16 bits, planar"]
    AV_SAMPLE_FMT_S16P = 6,
    #[doc = "< signed 32 bits, planar"]
    AV_SAMPLE_FMT_S32P = 7,
    #[doc = "< float, planar"]
    AV_SAMPLE_FMT_FLTP = 8,
    #[doc = "< double, planar"]
    AV_SAMPLE_FMT_DBLP = 9,
    #[doc = "< signed 64 bits"]
    AV_SAMPLE_FMT_S64 = 10,
    #[doc = "< signed 64 bits, planar"]
    AV_SAMPLE_FMT_S64P = 11,
    #[doc = "< Number of sample formats. DO NOT USE if linking dynamically"]
    AV_SAMPLE_FMT_NB = 12,
}
extern "C" {
    #[doc = " Return the name of sample_fmt, or NULL if sample_fmt is not\n recognized."]
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE\n on error."]
    pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Return the planar<->packed alternative form of the given sample format, or\n AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the\n requested planar/packed format, the format returned is the same as the\n input."]
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: ::std::os::raw::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the packed alternative form of the given sample format.\n\n If the passed sample_fmt is already in packed format, the format returned is\n the same as the input.\n\n @return  the packed alternative form of the given sample format or\nAV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the planar alternative form of the given sample format.\n\n If the passed sample_fmt is already in planar format, the format returned is\n the same as the input.\n\n @return  the planar alternative form of the given sample format or\nAV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Generate a string corresponding to the sample format with\n sample_fmt, or a header if sample_fmt is negative.\n\n @param buf the buffer where to write the string\n @param buf_size the size of buf\n @param sample_fmt the number of the sample format to print the\n corresponding info string, or a negative value to print the\n corresponding header.\n @return the pointer to the filled buffer or NULL if sample_fmt is\n unknown or in case of other errors"]
    pub fn av_get_sample_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return number of bytes per sample.\n\n @param sample_fmt the sample format\n @return number of bytes per sample or zero if unknown for the given\n sample format"]
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the sample format is planar.\n\n @param sample_fmt the sample format to inspect\n @return 1 if the sample format is planar, 0 if it is interleaved"]
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the required buffer size for the given audio parameters.\n\n @param[out] linesize calculated linesize, may be NULL\n @param nb_channels   the number of channels\n @param nb_samples    the number of samples in a single channel\n @param sample_fmt    the sample format\n @param align         buffer size alignment (0 = default, 1 = no alignment)\n @return              required buffer size, or negative error code on failure"]
    pub fn av_samples_get_buffer_size(
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers and linesize for samples with sample\n format sample_fmt.\n\n The audio_data array is filled with the pointers to the samples data planes:\n for planar, set the start point of each channel's data within the buffer,\n for packed, set the start point of the entire buffer only.\n\n The value pointed to by linesize is set to the aligned size of each\n channel's data buffer for planar layout, or to the aligned size of the\n buffer for all channels for packed layout.\n\n The buffer in buf must be big enough to contain all the samples\n (use av_samples_get_buffer_size() to compute its minimum size),\n otherwise the audio_data pointers will point to invalid data.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param[out] audio_data  array to be filled with the pointer for each channel\n @param[out] linesize    calculated linesize, may be NULL\n @param buf              the pointer to a buffer containing the samples\n @param nb_channels      the number of channels\n @param nb_samples       the number of samples in a single channel\n @param sample_fmt       the sample format\n @param align            buffer size alignment (0 = default, 1 = no alignment)\n @return                 minimum size in bytes required for the buffer on success,\n                         or a negative error code on failure"]
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        buf: *const u8,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a samples buffer for nb_samples samples, and fill data pointers and\n linesize accordingly.\n The allocated samples buffer can be freed by using av_freep(&audio_data[0])\n Allocated data will be initialized to silence.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param[out] audio_data  array to be filled with the pointer for each channel\n @param[out] linesize    aligned size for audio buffer(s), may be NULL\n @param nb_channels      number of audio channels\n @param nb_samples       number of samples per channel\n @param align            buffer size alignment (0 = default, 1 = no alignment)\n @return                 >=0 on success or a negative error code on failure\n @todo return the size of the allocated buffer in case of success at the next bump\n @see av_samples_fill_arrays()\n @see av_samples_alloc_array_and_samples()"]
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a data pointers array, samples buffer for nb_samples\n samples, and fill data pointers and linesize accordingly.\n\n This is the same as av_samples_alloc(), but also allocates the data\n pointers array.\n\n @see av_samples_alloc()"]
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy samples from src to dst.\n\n @param dst destination array of pointers to data planes\n @param src source array of pointers to data planes\n @param dst_offset offset in samples at which the data will be written to dst\n @param src_offset offset in samples at which the data will be read from src\n @param nb_samples number of samples to be copied\n @param nb_channels number of audio channels\n @param sample_fmt audio sample format"]
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: ::std::os::raw::c_int,
        src_offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill an audio buffer with silence.\n\n @param audio_data  array of pointers to data planes\n @param offset      offset in samples at which to start filling\n @param nb_samples  number of samples to fill\n @param nb_channels number of audio channels\n @param sample_fmt  audio sample format"]
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the LIBAVUTIL_VERSION_INT constant."]
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return an informative version string. This usually is the actual release\n version number or a git commit description. This string has no fixed format\n and can change any time. It should never be parsed by code."]
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavutil build-time configuration."]
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavutil license."]
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[doc = " @addtogroup lavu_media Media Type\n @brief Media Type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVMediaType {
    #[doc = "< Usually treated as AVMEDIA_TYPE_DATA"]
    AVMEDIA_TYPE_UNKNOWN = -1,
    AVMEDIA_TYPE_VIDEO = 0,
    AVMEDIA_TYPE_AUDIO = 1,
    #[doc = "< Opaque data information usually continuous"]
    AVMEDIA_TYPE_DATA = 2,
    AVMEDIA_TYPE_SUBTITLE = 3,
    #[doc = "< Opaque data information usually sparse"]
    AVMEDIA_TYPE_ATTACHMENT = 4,
    AVMEDIA_TYPE_NB = 5,
}
extern "C" {
    #[doc = " Return a string describing the media_type enum, NULL if media_type\n is unknown."]
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[doc = " @}\n @}\n @defgroup lavu_picture Image related\n\n AVPicture types, pixel formats and basic image planes manipulation.\n\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPictureType {
    #[doc = "< Undefined"]
    AV_PICTURE_TYPE_NONE = 0,
    #[doc = "< Intra"]
    AV_PICTURE_TYPE_I = 1,
    #[doc = "< Predicted"]
    AV_PICTURE_TYPE_P = 2,
    #[doc = "< Bi-dir predicted"]
    AV_PICTURE_TYPE_B = 3,
    #[doc = "< S(GMC)-VOP MPEG-4"]
    AV_PICTURE_TYPE_S = 4,
    #[doc = "< Switching Intra"]
    AV_PICTURE_TYPE_SI = 5,
    #[doc = "< Switching Predicted"]
    AV_PICTURE_TYPE_SP = 6,
    #[doc = "< BI type"]
    AV_PICTURE_TYPE_BI = 7,
}
extern "C" {
    #[doc = " Return a single letter to describe the given picture type\n pict_type.\n\n @param[in] pict_type the picture type @return a single character\n representing the picture type, '?' if pict_type is unknown"]
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
pub type imaxdiv_t = _Lldiv_t;
extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub static _HUGE: f64;
}
extern "C" {
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
}
extern "C" {
    pub static _Denorm_C: _float_const;
}
extern "C" {
    pub static _Inf_C: _float_const;
}
extern "C" {
    pub static _Nan_C: _float_const;
}
extern "C" {
    pub static _Snan_C: _float_const;
}
extern "C" {
    pub static _Hugeval_C: _float_const;
}
extern "C" {
    pub static _FDenorm_C: _float_const;
}
extern "C" {
    pub static _FInf_C: _float_const;
}
extern "C" {
    pub static _FNan_C: _float_const;
}
extern "C" {
    pub static _FSnan_C: _float_const;
}
extern "C" {
    pub static _LDenorm_C: _float_const;
}
extern "C" {
    pub static _LInf_C: _float_const;
}
extern "C" {
    pub static _LNan_C: _float_const;
}
extern "C" {
    pub static _LSnan_C: _float_const;
}
extern "C" {
    pub static _Eps_C: _float_const;
}
extern "C" {
    pub static _Rteps_C: _float_const;
}
extern "C" {
    pub static _FEps_C: _float_const;
}
extern "C" {
    pub static _FRteps_C: _float_const;
}
extern "C" {
    pub static _LEps_C: _float_const;
}
extern "C" {
    pub static _LRteps_C: _float_const;
}
extern "C" {
    pub static _Zero_C: f64;
}
extern "C" {
    pub static _Xbig_C: f64;
}
extern "C" {
    pub static _FZero_C: f32;
}
extern "C" {
    pub static _FXbig_C: f32;
}
extern "C" {
    pub static _LZero_C: f64;
}
extern "C" {
    pub static _LXbig_C: f64;
}
extern "C" {
    #[link_name = "\u{1}?fpclassify@@YAHM@Z"]
    pub fn fpclassify(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?fpclassify@@YAHN@Z"]
    pub fn fpclassify1(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?fpclassify@@YAHO@Z"]
    pub fn fpclassify2(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?signbit@@YA_NM@Z"]
    pub fn signbit(_X: f32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?signbit@@YA_NN@Z"]
    pub fn signbit1(_X: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?signbit@@YA_NO@Z"]
    pub fn signbit2(_X: f64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?_fpcomp@@YAHMM@Z"]
    pub fn _fpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_fpcomp@@YAHNN@Z"]
    pub fn _fpcomp1(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_fpcomp@@YAHOO@Z"]
    pub fn _fpcomp2(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Combined_type {
    pub _address: u8,
}
pub type _Combined_type__Type = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Real_widened {
    pub _address: u8,
}
pub type _Real_widened__Type = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Real_type {
    pub _address: u8,
}
pub type _Real_type__Type = f64;
extern "C" {
    pub fn acos(_X: f64) -> f64;
}
extern "C" {
    pub fn asin(_X: f64) -> f64;
}
extern "C" {
    pub fn atan(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn cos(_X: f64) -> f64;
}
extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
extern "C" {
    pub fn exp(_X: f64) -> f64;
}
extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn log(_X: f64) -> f64;
}
extern "C" {
    pub fn log10(_X: f64) -> f64;
}
extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sin(_X: f64) -> f64;
}
extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
    pub fn tan(_X: f64) -> f64;
}
extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
extern "C" {
    pub fn acosh(_X: f64) -> f64;
}
extern "C" {
    pub fn asinh(_X: f64) -> f64;
}
extern "C" {
    pub fn atanh(_X: f64) -> f64;
}
extern "C" {
    pub fn _cabs(_Complex_value: _complex) -> f64;
}
extern "C" {
    pub fn cbrt(_X: f64) -> f64;
}
extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erf(_X: f64) -> f64;
}
extern "C" {
    pub fn erfc(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1(_X: f64) -> f64;
}
extern "C" {
    pub fn fdim(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn floor(_X: f64) -> f64;
}
extern "C" {
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmax(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmin(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1p(_X: f64) -> f64;
}
extern "C" {
    pub fn log2(_X: f64) -> f64;
}
extern "C" {
    pub fn logb(_X: f64) -> f64;
}
extern "C" {
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyint(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainder(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(_X: f64) -> f64;
}
extern "C" {
    pub fn round(_X: f64) -> f64;
}
extern "C" {
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn trunc(_X: f64) -> f64;
}
extern "C" {
    pub fn _j0(_X: f64) -> f64;
}
extern "C" {
    pub fn _j1(_X: f64) -> f64;
}
extern "C" {
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _y0(_X: f64) -> f64;
}
extern "C" {
    pub fn _y1(_X: f64) -> f64;
}
extern "C" {
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn acoshf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn atanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn erff(_X: f32) -> f32;
}
extern "C" {
    pub fn erfcf(_X: f32) -> f32;
}
extern "C" {
    pub fn expm1f(_X: f32) -> f32;
}
extern "C" {
    pub fn exp2f(_X: f32) -> f32;
}
extern "C" {
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fminf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pf(_X: f32) -> f32;
}
extern "C" {
    pub fn log2f(_X: f32) -> f32;
}
extern "C" {
    pub fn logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nearbyintf(_X: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(_X: f32) -> f32;
}
extern "C" {
    pub fn roundf(_X: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn tgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn truncf(_X: f32) -> f32;
}
extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
extern "C" {
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
extern "C" {
    pub fn atanf(_X: f32) -> f32;
}
extern "C" {
    pub fn ceilf(_X: f32) -> f32;
}
extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
extern "C" {
    pub fn expf(_X: f32) -> f32;
}
extern "C" {
    pub fn fabsf(_X: f32) -> f32;
}
extern "C" {
    pub fn floorf(_X: f32) -> f32;
}
extern "C" {
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn frexpf(_X: f32, _Y: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn log10f(_X: f32) -> f32;
}
extern "C" {
    pub fn logf(_X: f32) -> f32;
}
extern "C" {
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn acoshl(_X: f64) -> f64;
}
extern "C" {
    pub fn acosl(_X: f64) -> f64;
}
extern "C" {
    pub fn asinhl(_X: f64) -> f64;
}
extern "C" {
    pub fn asinl(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2l(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn atanhl(_X: f64) -> f64;
}
extern "C" {
    pub fn atanl(_X: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(_X: f64) -> f64;
}
extern "C" {
    pub fn ceill(_X: f64) -> f64;
}
extern "C" {
    pub fn _chgsignl(_X: f64) -> f64;
}
extern "C" {
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn coshl(_X: f64) -> f64;
}
extern "C" {
    pub fn cosl(_X: f64) -> f64;
}
extern "C" {
    pub fn erfl(_X: f64) -> f64;
}
extern "C" {
    pub fn erfcl(_X: f64) -> f64;
}
extern "C" {
    pub fn expl(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2l(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1l(_X: f64) -> f64;
}
extern "C" {
    pub fn fabsl(_X: f64) -> f64;
}
extern "C" {
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn floorl(_X: f64) -> f64;
}
extern "C" {
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fminl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmodl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn frexpl(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _hypotl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn hypotl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn logl(_X: f64) -> f64;
}
extern "C" {
    pub fn log10l(_X: f64) -> f64;
}
extern "C" {
    pub fn log1pl(_X: f64) -> f64;
}
extern "C" {
    pub fn log2l(_X: f64) -> f64;
}
extern "C" {
    pub fn logbl(_X: f64) -> f64;
}
extern "C" {
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn modfl(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyintl(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn powl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(_X: f64) -> f64;
}
extern "C" {
    pub fn roundl(_X: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn sinhl(_X: f64) -> f64;
}
extern "C" {
    pub fn sinl(_X: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(_X: f64) -> f64;
}
extern "C" {
    pub fn tanhl(_X: f64) -> f64;
}
extern "C" {
    pub fn tanl(_X: f64) -> f64;
}
extern "C" {
    pub fn tgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn truncl(_X: f64) -> f64;
}
extern "C" {
    pub static mut HUGE: f64;
}
extern "C" {
    pub fn j0(_X: f64) -> f64;
}
extern "C" {
    pub fn j1(_X: f64) -> f64;
}
extern "C" {
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn y0(_X: f64) -> f64;
}
extern "C" {
    pub fn y1(_X: f64) -> f64;
}
extern "C" {
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn __local_stdio_printf_options() -> *mut ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __local_stdio_scanf_options() -> *mut ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut u16,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut u16;
}
extern "C" {
    pub fn fputws(_Buffer: *const u16, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut u16, _BufferCount: usize) -> *mut u16;
}
extern "C" {
    pub fn putwc(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(_Stream: *mut *mut FILE, _FileName: *const u16, _Mode: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(_FileName: *const u16, _Mode: *const u16, _OldStream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const u16,
        _Mode: *const u16,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const u16,
        _Mode: *const u16,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wpopen(_Command: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const u16, _FilePrefix: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut u16, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        _Stream: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_s_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf_s(
        _Stream: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_p_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwprintf_p(
        _Stream: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_s_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf_s(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_p_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwprintf_p(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(_Stream: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_s_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf_s(_Stream: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_p_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwprintf_p(_Stream: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_s_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf_s(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwscanf_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        _Stream: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfwscanf_s_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf_s(
        _Stream: *mut FILE,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwscanf_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vwscanf_s_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf_s(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwscanf_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(_Stream: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fwscanf_s_l(
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf_s(_Stream: *mut FILE, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wscanf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wscanf_s_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf_s(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_s_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf_s(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwprintf(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_c_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_c(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vswprintf_l(
        _Buffer: *mut u16,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf(
        _Buffer: *mut u16,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_s_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf_s(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_p_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswprintf_p(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_p_l(
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscwprintf_p(_Format: *const u16, _ArgList: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swprintf_l(
        _Buffer: *mut u16,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf(_Buffer: *mut u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_s_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf_s(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_p_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_p(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_c_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swprintf_c(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_s_l(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwprintf_s(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_p_l(_Format: *const u16, _Locale: _locale_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scwprintf_p(_Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?swprintf@@YAHQEA_WQEB_WZZ"]
    pub fn swprintf1(_Buffer: *mut u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?vswprintf@@YAHQEA_WQEB_WPEAD@Z"]
    pub fn vswprintf1(
        _Buffer: *mut u16,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_swprintf_l@@YAHQEA_WQEB_WQEAU__crt_locale_pointers@@ZZ"]
    pub fn _swprintf_l1(
        _Buffer: *mut u16,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?_vswprintf_l@@YAHQEA_WQEB_WQEAU__crt_locale_pointers@@PEAD@Z"]
    pub fn _vswprintf_l1(
        _Buffer: *mut u16,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswscanf_l(
        _Buffer: *const u16,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        _Buffer: *const u16,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vswscanf_s_l(
        _Buffer: *const u16,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf_s(
        _Buffer: *const u16,
        _Format: *const u16,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwscanf_l(
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnwscanf_s_l(
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swscanf_l(
        _Buffer: *const u16,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(_Buffer: *const u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swscanf_s_l(
        _Buffer: *const u16,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf_s(_Buffer: *const u16, _Format: *const u16, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_l(
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf(
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_s_l(
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snwscanf_s(
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_s_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf_s(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_p_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_p(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf_s(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_p(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_s_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf_s(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_p_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fprintf_p(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf_s(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printf_p(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfscanf_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfscanf_s_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf_s(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscanf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscanf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf_s(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fscanf_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fscanf_s_l(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf_s(
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_s_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf_s(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        _Buffer: *mut ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_s_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_p_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_p(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_s_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscprintf_p(
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_c_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_c(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        _Buffer: *mut ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_s_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_p_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_p(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_c_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_c(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_s_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf_p_l(
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scprintf_p(_Format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsscanf_l(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsscanf_s_l(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf_s(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_l(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_s_l(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf_s(
        _Buffer: *const ::std::os::raw::c_char,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf_l(
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf(
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf_s_l(
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snscanf_s(
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses\n (including vectors if available on the CPU).\n\n @param size Size in bytes for the memory block to be allocated\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n @see av_mallocz()"]
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses\n (including vectors if available on the CPU) and zero all the bytes of the\n block.\n\n @param size Size in bytes for the memory block to be allocated\n @return Pointer to the allocated block, or `NULL` if it cannot be allocated\n @see av_malloc()"]
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_malloc().\n\n The allocated memory will have size `size * nmemb` bytes.\n\n @param nmemb Number of element\n @param size  Size of a single element\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n @see av_malloc()"]
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_mallocz().\n\n The allocated memory will have size `size * nmemb` bytes.\n\n @param nmemb Number of elements\n @param size  Size of the single element\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n\n @see av_mallocz()\n @see av_malloc_array()"]
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @deprecated use av_calloc()"]
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory.\n\n If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or\n shrink that block of memory according to `size`.\n\n @param ptr  Pointer to a memory block already allocated with\n             av_realloc() or `NULL`\n @param size Size in bytes of the memory block to be allocated or\n             reallocated\n\n @return Pointer to a newly-reallocated block or `NULL` if the block\n         cannot be reallocated\n\n @warning Unlike av_malloc(), the returned pointer is not guaranteed to be\n          correctly aligned. The returned pointer must be freed after even\n          if size is zero.\n @see av_fast_realloc()\n @see av_reallocp()"]
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory through a pointer to a\n pointer.\n\n If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n zero, free the memory block pointed to by `*ptr`. Otherwise, expand or\n shrink that block of memory according to `size`.\n\n @param[in,out] ptr  Pointer to a pointer to a memory block already allocated\n                     with av_realloc(), or a pointer to `NULL`. The pointer\n                     is updated on success, or freed on failure.\n @param[in]     size Size in bytes for the memory block to be allocated or\n                     reallocated\n\n @return Zero on success, an AVERROR error code on failure\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned."]
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory.\n\n This function does the same thing as av_realloc(), except:\n - It takes two size arguments and allocates `nelem * elsize` bytes,\n   after checking the result of the multiplication for integer overflow.\n - It frees the input block in case of failure, thus avoiding the memory\n   leak with the classic\n   @code{.c}\n   buf = realloc(buf);\n   if (!buf)\n       return -1;\n   @endcode\n   pattern."]
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free an array.\n\n If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.\n\n @param ptr   Pointer to a memory block already allocated with\n              av_realloc() or `NULL`\n @param nmemb Number of elements in the array\n @param size  Size of the single element of the array\n\n @return Pointer to a newly-reallocated block or NULL if the block\n         cannot be reallocated\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned. The returned pointer must be freed after even if\n          nmemb is zero.\n @see av_reallocp_array()"]
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate an array through a pointer to a pointer.\n\n If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.\n\n @param[in,out] ptr   Pointer to a pointer to a memory block already\n                      allocated with av_realloc(), or a pointer to `NULL`.\n                      The pointer is updated on success, or freed on failure.\n @param[in]     nmemb Number of elements\n @param[in]     size  Size of the single element\n\n @return Zero on success, an AVERROR error code on failure\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned. *ptr must be freed after even if nmemb is zero."]
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reallocate the given buffer if it is not large enough, otherwise do nothing.\n\n If the given buffer is `NULL`, then a new uninitialized buffer is allocated.\n\n If the given buffer is not large enough, and reallocation fails, `NULL` is\n returned and `*size` is set to 0, but the original buffer is not changed or\n freed.\n\n A typical use pattern follows:\n\n @code{.c}\n uint8_t *buf = ...;\n uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);\n if (!new_buf) {\n     // Allocation failed; clean up original buffer\n     av_freep(&buf);\n     return AVERROR(ENOMEM);\n }\n @endcode\n\n @param[in,out] ptr      Already allocated buffer, or `NULL`\n @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `ptr`\n @return `ptr` if the buffer is large enough, a pointer to newly reallocated\n         buffer if the buffer was not large enough, or `NULL` in case of\n         error\n @see av_realloc()\n @see av_fast_malloc()"]
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a buffer, reusing the given one if large enough.\n\n Contrary to av_fast_realloc(), the current buffer contents might not be\n preserved and on error the old buffer is freed, thus no special handling to\n avoid memleaks is necessary.\n\n `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n `size_needed` is greater than 0.\n\n @code{.c}\n uint8_t *buf = ...;\n av_fast_malloc(&buf, &current_size, size_needed);\n if (!buf) {\n     // Allocation failed; buf already freed\n     return AVERROR(ENOMEM);\n }\n @endcode\n\n @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n                         `*ptr` will be overwritten with pointer to new\n                         buffer on success or `NULL` on failure\n @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `*ptr`\n @see av_realloc()\n @see av_fast_mallocz()"]
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Allocate and clear a buffer, reusing the given one if large enough.\n\n Like av_fast_malloc(), but all newly allocated space is initially cleared.\n Reused buffer is not cleared.\n\n `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n `size_needed` is greater than 0.\n\n @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n                         `*ptr` will be overwritten with pointer to new\n                         buffer on success or `NULL` on failure\n @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `*ptr`\n @see av_fast_malloc()"]
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()\n or av_realloc() family.\n\n @param ptr Pointer to the memory block which should be freed.\n\n @note `ptr = NULL` is explicitly allowed.\n @note It is recommended that you use av_freep() instead, to prevent leaving\n       behind dangling pointers.\n @see av_freep()"]
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()\n or av_realloc() family, and set the pointer pointing to it to `NULL`.\n\n @code{.c}\n uint8_t *buf = av_malloc(16);\n av_free(buf);\n // buf now contains a dangling pointer to freed memory, and accidental\n // dereference of buf will result in a use-after-free, which may be a\n // security risk.\n\n uint8_t *buf = av_malloc(16);\n av_freep(&buf);\n // buf is now NULL, and accidental dereference will only result in a\n // NULL-pointer dereference.\n @endcode\n\n @param ptr Pointer to the pointer to the memory block which should be freed\n @note `*ptr = NULL` is safe and leads to no action.\n @see av_free()"]
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Duplicate a string.\n\n @param s String to be duplicated\n @return Pointer to a newly-allocated string containing a\n         copy of `s` or `NULL` if the string cannot be allocated\n @see av_strndup()"]
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate a substring of a string.\n\n @param s   String to be duplicated\n @param len Maximum length of the resulting string (not counting the\n            terminating byte)\n @return Pointer to a newly-allocated string containing a\n         substring of `s` or `NULL` if the string cannot be allocated"]
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate a buffer with av_malloc().\n\n @param p    Buffer to be duplicated\n @param size Size in bytes of the buffer copied\n @return Pointer to a newly allocated buffer containing a\n         copy of `p` or `NULL` if the buffer cannot be allocated"]
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Overlapping memcpy() implementation.\n\n @param dst  Destination buffer\n @param back Number of bytes back to start copying (i.e. the initial size of\n             the overlapping window); must be > 0\n @param cnt  Number of bytes to copy; must be >= 0\n\n @note `cnt > back` is valid, this will copy the bytes we just copied,\n       thus creating a repeating pattern with a period length of `back`."]
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Add the pointer to an element to a dynamic array.\n\n The array to grow is supposed to be an array of pointers to\n structures, and the element to add must be a pointer to an already\n allocated structure.\n\n The array is reallocated when its size reaches powers of 2.\n Therefore, the amortized cost of adding an element is constant.\n\n In case of success, the pointer to the array is updated in order to\n point to the new grown array, and the number pointed to by `nb_ptr`\n is incremented.\n In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n `*nb_ptr` is set to 0.\n\n @param[in,out] tab_ptr Pointer to the array to grow\n @param[in,out] nb_ptr  Pointer to the number of elements in the array\n @param[in]     elem    Element to add\n @see av_dynarray_add_nofree(), av_dynarray2_add()"]
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Add an element to a dynamic array.\n\n Function has the same functionality as av_dynarray_add(),\n but it doesn't free memory on fails. It returns error code\n instead and leave current buffer untouched.\n\n @return >=0 on success, negative otherwise\n @see av_dynarray_add(), av_dynarray2_add()"]
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an element of size `elem_size` to a dynamic array.\n\n The array is reallocated when its number of elements reaches powers of 2.\n Therefore, the amortized cost of adding an element is constant.\n\n In case of success, the pointer to the array is updated in order to\n point to the new grown array, and the number pointed to by `nb_ptr`\n is incremented.\n In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n `*nb_ptr` is set to 0.\n\n @param[in,out] tab_ptr   Pointer to the array to grow\n @param[in,out] nb_ptr    Pointer to the number of elements in the array\n @param[in]     elem_size Size in bytes of an element in the array\n @param[in]     elem_data Pointer to the data of the element to add. If\n                          `NULL`, the space of the newly added element is\n                          allocated but left uninitialized.\n\n @return Pointer to the data of the element to copy in the newly allocated\n         space\n @see av_dynarray_add(), av_dynarray_add_nofree()"]
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Multiply two `size_t` values checking for overflow.\n\n @param[in]  a,b Operands of multiplication\n @param[out] r   Pointer to the result of the operation\n @return 0 on success, AVERROR(EINVAL) on overflow"]
    pub fn av_size_mult(a: usize, b: usize, r: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the maximum size that may be allocated in one block.\n\n The value specified with this function is effective for all libavutil's @ref\n lavu_mem_funcs \"heap management functions.\"\n\n By default, the max value is defined as `INT_MAX`.\n\n @param max Value to be set as the new maximum size\n\n @warning Exercise extreme caution when using this function. Don't touch\n          this if you do not understand the full consequence of doing so."]
    pub fn av_max_alloc(max: usize);
}
extern "C" {
    #[doc = " Put a description of the AVERROR code errnum in errbuf.\n In case of failure the global variable errno is set to indicate the\n error. Even in case of failure av_strerror() will print a generic\n error message indicating the errnum provided to errbuf.\n\n @param errnum      error code to describe\n @param errbuf      buffer to which description is written\n @param errbuf_size the size in bytes of errbuf\n @return 0 on success, a negative value if a description for errnum\n cannot be found"]
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Rational number (pair of numerator and denominator)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
    #[doc = "< Numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = "< Denominator"]
    pub den: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Reduce a fraction.\n\n This is useful for framerate calculations.\n\n @param[out] dst_num Destination numerator\n @param[out] dst_den Destination denominator\n @param[in]      num Source numerator\n @param[in]      den Source denominator\n @param[in]      max Maximum allowed values for `dst_num` & `dst_den`\n @return 1 if the operation is exact, 0 otherwise"]
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Multiply two rationals.\n @param b First rational\n @param c Second rational\n @return b*c"]
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Divide one rational by another.\n @param b First rational\n @param c Second rational\n @return b/c"]
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Add two rationals.\n @param b First rational\n @param c Second rational\n @return b+c"]
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Subtract one rational from another.\n @param b First rational\n @param c Second rational\n @return b-c"]
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Convert a double precision floating point number to a rational.\n\n In case of infinity, the returned value is expressed as `{1, 0}` or\n `{-1, 0}` depending on the sign.\n\n @param d   `double` to convert\n @param max Maximum allowed numerator and denominator\n @return `d` in AVRational form\n @see av_q2d()"]
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    #[doc = " Find which of the two rationals is closer to another rational.\n\n @param q     Rational to be compared against\n @param q1,q2 Rationals to be tested\n @return One of the following values:\n         - 1 if `q1` is nearer to `q` than `q2`\n         - -1 if `q2` is nearer to `q` than `q1`\n         - 0 if they have the same distance"]
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the value in a list of rationals nearest a given reference rational.\n\n @param q      Reference rational\n @param q_list Array of rationals terminated by `{0, 0}`\n @return Index of the nearest value found in the array"]
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point\n format.\n\n @param q Rational to be converted\n @return Equivalent floating-point value, expressed as an unsigned 32-bit\n         integer.\n @note The returned value is platform-indepedant."]
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
    #[doc = " Return the best rational so that a and b are multiple of it.\n If the resulting denominator is larger than max_den, return def."]
    pub fn av_gcd_q(
        a: AVRational,
        b: AVRational,
        max_den: ::std::os::raw::c_int,
        def: AVRational,
    ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
}
#[repr(i32)]
#[doc = " Rounding methods."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVRounding {
    #[doc = "< Round toward zero."]
    AV_ROUND_ZERO = 0,
    #[doc = "< Round away from zero."]
    AV_ROUND_INF = 1,
    #[doc = "< Round toward -infinity."]
    AV_ROUND_DOWN = 2,
    #[doc = "< Round toward +infinity."]
    AV_ROUND_UP = 3,
    #[doc = "< Round to nearest and halfway cases away from zero."]
    AV_ROUND_NEAR_INF = 5,
    #[doc = " Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through\n unchanged, avoiding special cases for #AV_NOPTS_VALUE.\n\n Unlike other values of the enumeration AVRounding, this value is a\n bitmask that must be used in conjunction with another value of the\n enumeration through a bitwise OR, in order to set behavior for normal\n cases.\n\n @code{.c}\n av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n // Rescaling 3:\n //     Calculating 3 * 1 / 2\n //     3 / 2 is rounded up to 2\n //     => 2\n\n av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n // Rescaling AV_NOPTS_VALUE:\n //     AV_NOPTS_VALUE == INT64_MIN\n //     AV_NOPTS_VALUE is passed through\n //     => AV_NOPTS_VALUE\n @endcode"]
    AV_ROUND_PASS_MINMAX = 8192,
}
extern "C" {
    #[doc = " Compute the greatest common divisor of two integer operands.\n\n @param a,b Operands\n @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;\n if a == 0 and b == 0, returns 0."]
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with rounding to nearest.\n\n The operation is mathematically equivalent to `a * b / c`, but writing that\n directly can overflow.\n\n This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.\n\n @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with specified rounding.\n\n The operation is mathematically equivalent to `a * b / c`, but writing that\n directly can overflow, and does not support different rounding methods.\n If the result is not representable then INT64_MIN is returned.\n\n @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers.\n\n The operation is mathematically equivalent to `a * bq / cq`.\n\n This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.\n\n @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()"]
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers with specified rounding.\n\n The operation is mathematically equivalent to `a * bq / cq`.\n\n @see av_rescale(), av_rescale_rnd(), av_rescale_q()"]
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Compare two timestamps each in its own time base.\n\n @return One of the following values:\n         - -1 if `ts_a` is before `ts_b`\n         - 1 if `ts_a` is after `ts_b`\n         - 0 if they represent the same position\n\n @warning\n The result of the function is undefined if one of the timestamps is outside\n the `int64_t` range when represented in the other's timebase."]
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the remainders of two integer operands divided by a common divisor.\n\n In other words, compare the least significant `log2(mod)` bits of integers\n `a` and `b`.\n\n @code{.c}\n av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)\n av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)\n @endcode\n\n @param a,b Operands\n @param mod Divisor; must be a power of 2\n @return\n         - a negative value if `a % mod < b % mod`\n         - a positive value if `a % mod > b % mod`\n         - zero             if `a % mod == b % mod`"]
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    #[doc = " Rescale a timestamp while preserving known durations.\n\n This function is designed to be called per audio packet to scale the input\n timestamp to a different time base. Compared to a simple av_rescale_q()\n call, this function is robust against possible inconsistent frame durations.\n\n The `last` parameter is a state variable that must be preserved for all\n subsequent calls for the same stream. For the first call, `*last` should be\n initialized to #AV_NOPTS_VALUE.\n\n @param[in]     in_tb    Input time base\n @param[in]     in_ts    Input timestamp\n @param[in]     fs_tb    Duration time base; typically this is finer-grained\n                         (greater) than `in_tb` and `out_tb`\n @param[in]     duration Duration till the next call to this function (i.e.\n                         duration of the current packet/frame)\n @param[in,out] last     Pointer to a timestamp expressed in terms of\n                         `fs_tb`, acting as a state variable\n @param[in]     out_tb   Output timebase\n @return        Timestamp expressed in terms of `out_tb`\n\n @note In the context of this function, \"duration\" is in term of samples, not\n       seconds."]
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    #[doc = " Add a value to a timestamp.\n\n This function guarantees that when the same value is repeatly added that\n no accumulation of rounding errors occurs.\n\n @param[in] ts     Input timestamp\n @param[in] ts_tb  Input timestamp time base\n @param[in] inc    Value to be added\n @param[in] inc_tb Time base of `inc`"]
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVClassCategory {
    AV_CLASS_CATEGORY_NA = 0,
    AV_CLASS_CATEGORY_INPUT = 1,
    AV_CLASS_CATEGORY_OUTPUT = 2,
    AV_CLASS_CATEGORY_MUXER = 3,
    AV_CLASS_CATEGORY_DEMUXER = 4,
    AV_CLASS_CATEGORY_ENCODER = 5,
    AV_CLASS_CATEGORY_DECODER = 6,
    AV_CLASS_CATEGORY_FILTER = 7,
    AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8,
    AV_CLASS_CATEGORY_SWSCALER = 9,
    AV_CLASS_CATEGORY_SWRESAMPLER = 10,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43,
    AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44,
    AV_CLASS_CATEGORY_DEVICE_INPUT = 45,
    #[doc = "< not part of ABI/API"]
    AV_CLASS_CATEGORY_NB = 46,
}
#[doc = " Describe the class of an AVClass context structure. That is an\n arbitrary struct of which the first field is a pointer to an\n AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    #[doc = " The name of the class; usually it is the same name as the\n context structure type to which the AVClass is associated."]
    pub class_name: *const ::std::os::raw::c_char,
    #[doc = " A pointer to a function which returns the name of a context\n instance ctx associated with the class."]
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " a pointer to the first option specified in the class if any or NULL\n\n @see av_set_default_options()"]
    pub option: *const AVOption,
    #[doc = " LIBAVUTIL_VERSION with which this structure was created.\n This is used to allow fields to be added without requiring major\n version bumps everywhere."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where log_level_offset is stored.\n 0 means there is no such variable"]
    pub log_level_offset_offset: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where a pointer to the parent context for\n logging is stored. For example a decoder could pass its AVCodecContext\n to eval as such a parent context, which an av_log() implementation\n could then leverage to display the parent context.\n The offset can be NULL."]
    pub parent_log_context_offset: ::std::os::raw::c_int,
    #[doc = " Category used for visualization (like color)\n This is only set if the category is equal for all objects using this class.\n available since version (51 << 16 | 56 << 8 | 100)"]
    pub category: AVClassCategory,
    #[doc = " Callback to return the category.\n available since version (51 << 16 | 59 << 8 | 100)"]
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    #[doc = " Callback to return the supported/allowed ranges.\n available since version (52.12)"]
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return next AVOptions-enabled child or NULL"]
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled\n children.\n\n @param iter pointer to opaque iteration state. The caller must initialize\n             *iter to NULL before the first call.\n @return AVClass for the next AVOptions-enabled child or NULL if there are\n         no more such children.\n\n @note The difference between child_next and this is that child_next\n       iterates over _already existing_ objects, while child_class_iterate\n       iterates over _all possible_ children."]
    pub child_class_iterate: ::std::option::Option<
        unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const AVClass,
    >,
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output."]
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log once with the initial_level and then with\n the subsequent_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param initial_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" for the first occurance.\n @param subsequent_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" after the first occurance.\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param state a variable to keep trak of if a message has already been printed\n        this must be initialized to 0 before the first use. The same state\n        must not be accessed by 2 Threads simultaneously."]
    pub fn av_log_once(
        avcl: *mut ::std::os::raw::c_void,
        initial_level: ::std::os::raw::c_int,
        subsequent_level: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    #[doc = " Get the current log level\n\n @see lavu_log_constants\n\n @return Current log level"]
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level\n\n @see lavu_log_constants\n\n @param level Logging level"]
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the logging callback\n\n @note The callback must be thread safe, even if the application does not use\n       threads itself as some codecs are multithreaded.\n\n @see av_log_default_callback\n\n @param callback A logging function with a compatible signature."]
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: va_list,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Default logging callback\n\n It prints the message to stderr, optionally colorizing it.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    #[doc = " Return the context name\n\n @param  ctx The AVClass context\n\n @return The AVClass class_name"]
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line\n @param line_size     size of the buffer\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1"]
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line;\n                      may be NULL if line_size is 0\n @param line_size     size of the buffer; at most line_size-1 characters will\n                      be written to the buffer, plus one null terminator\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1\n @return Returns a negative value if an error occurred, otherwise returns\n         the number of characters that would have been written for a\n         sufficiently large buffer, not including the terminating null\n         character. If the return value is not less than line_size, it means\n         that the log message was truncated to fit the buffer."]
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_Y400A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
}
impl AVPixelFormat {
    pub const AV_PIX_FMT_GBR24P: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_GBRP;
}
#[repr(i32)]
#[doc = " Pixel format.\n\n @note\n AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA\n color is put together as:\n  (A << 24) | (R << 16) | (G << 8) | B\n This is stored as BGRA on little-endian CPU architectures and ARGB on\n big-endian CPUs.\n\n @note\n If the resolution is not a multiple of the chroma subsampling factor\n then the chroma plane resolution must be rounded up.\n\n @par\n When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized\n image data is stored in AVFrame.data[0]. The palette is transported in\n AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is\n formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is\n also endian-specific). Note also that the individual RGB32 palette\n components stored in AVFrame.data[1] should be in the range 0..255.\n This is important as many custom PAL8 video codecs that were designed\n to run on the IBM VGA graphics adapter use 6-bit palette components.\n\n @par\n For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like\n for pal8. This palette is filled in automatically by the function\n allocating the picture."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPixelFormat {
    AV_PIX_FMT_NONE = -1,
    #[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
    AV_PIX_FMT_YUV420P = 0,
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
    AV_PIX_FMT_YUYV422 = 1,
    #[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
    AV_PIX_FMT_RGB24 = 2,
    #[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
    AV_PIX_FMT_BGR24 = 3,
    #[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    AV_PIX_FMT_YUV422P = 4,
    #[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
    AV_PIX_FMT_YUV444P = 5,
    #[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
    AV_PIX_FMT_YUV410P = 6,
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
    AV_PIX_FMT_YUV411P = 7,
    #[doc = "<        Y        ,  8bpp"]
    AV_PIX_FMT_GRAY8 = 8,
    #[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
    AV_PIX_FMT_MONOWHITE = 9,
    #[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
    AV_PIX_FMT_MONOBLACK = 10,
    #[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
    AV_PIX_FMT_PAL8 = 11,
    #[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
    AV_PIX_FMT_YUVJ420P = 12,
    #[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
    AV_PIX_FMT_YUVJ422P = 13,
    #[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
    AV_PIX_FMT_YUVJ444P = 14,
    #[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
    AV_PIX_FMT_UYVY422 = 15,
    #[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
    AV_PIX_FMT_UYYVYY411 = 16,
    #[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
    AV_PIX_FMT_BGR8 = 17,
    #[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
    AV_PIX_FMT_BGR4 = 18,
    #[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
    AV_PIX_FMT_BGR4_BYTE = 19,
    #[doc = "< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"]
    AV_PIX_FMT_RGB8 = 20,
    #[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
    AV_PIX_FMT_RGB4 = 21,
    #[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
    AV_PIX_FMT_RGB4_BYTE = 22,
    #[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    AV_PIX_FMT_NV12 = 23,
    #[doc = "< as above, but U and V bytes are swapped"]
    AV_PIX_FMT_NV21 = 24,
    #[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
    AV_PIX_FMT_ARGB = 25,
    #[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
    AV_PIX_FMT_RGBA = 26,
    #[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
    AV_PIX_FMT_ABGR = 27,
    #[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
    AV_PIX_FMT_BGRA = 28,
    #[doc = "<        Y        , 16bpp, big-endian"]
    AV_PIX_FMT_GRAY16BE = 29,
    #[doc = "<        Y        , 16bpp, little-endian"]
    AV_PIX_FMT_GRAY16LE = 30,
    #[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
    AV_PIX_FMT_YUV440P = 31,
    #[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
    AV_PIX_FMT_YUVJ440P = 32,
    #[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
    AV_PIX_FMT_YUVA420P = 33,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
    AV_PIX_FMT_RGB48BE = 34,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
    AV_PIX_FMT_RGB48LE = 35,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
    AV_PIX_FMT_RGB565BE = 36,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
    AV_PIX_FMT_RGB565LE = 37,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
    AV_PIX_FMT_RGB555BE = 38,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_RGB555LE = 39,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
    AV_PIX_FMT_BGR565BE = 40,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
    AV_PIX_FMT_BGR565LE = 41,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
    AV_PIX_FMT_BGR555BE = 42,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_BGR555LE = 43,
    #[doc = "  Hardware acceleration through VA-API, data[3] contains a\n  VASurfaceID."]
    AV_PIX_FMT_VAAPI = 44,
    #[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P16LE = 45,
    #[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P16BE = 46,
    #[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P16LE = 47,
    #[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P16BE = 48,
    #[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P16LE = 49,
    #[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P16BE = 50,
    #[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
    AV_PIX_FMT_DXVA2_VLD = 51,
    #[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_RGB444LE = 52,
    #[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
    AV_PIX_FMT_RGB444BE = 53,
    #[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_BGR444LE = 54,
    #[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
    AV_PIX_FMT_BGR444BE = 55,
    #[doc = "< 8 bits gray, 8 bits alpha"]
    AV_PIX_FMT_YA8 = 56,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
    AV_PIX_FMT_BGR48BE = 57,
    #[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
    AV_PIX_FMT_BGR48LE = 58,
    #[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P9BE = 59,
    #[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P9LE = 60,
    #[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P10BE = 61,
    #[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P10LE = 62,
    #[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P10BE = 63,
    #[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P10LE = 64,
    #[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P9BE = 65,
    #[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P9LE = 66,
    #[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P10BE = 67,
    #[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P10LE = 68,
    #[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P9BE = 69,
    #[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P9LE = 70,
    #[doc = "< planar GBR 4:4:4 24bpp"]
    AV_PIX_FMT_GBRP = 71,
    #[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
    AV_PIX_FMT_GBRP9BE = 72,
    #[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
    AV_PIX_FMT_GBRP9LE = 73,
    #[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
    AV_PIX_FMT_GBRP10BE = 74,
    #[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
    AV_PIX_FMT_GBRP10LE = 75,
    #[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
    AV_PIX_FMT_GBRP16BE = 76,
    #[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
    AV_PIX_FMT_GBRP16LE = 77,
    #[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
    AV_PIX_FMT_YUVA422P = 78,
    #[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
    AV_PIX_FMT_YUVA444P = 79,
    #[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
    AV_PIX_FMT_YUVA420P9BE = 80,
    #[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
    AV_PIX_FMT_YUVA420P9LE = 81,
    #[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
    AV_PIX_FMT_YUVA422P9BE = 82,
    #[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
    AV_PIX_FMT_YUVA422P9LE = 83,
    #[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
    AV_PIX_FMT_YUVA444P9BE = 84,
    #[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
    AV_PIX_FMT_YUVA444P9LE = 85,
    #[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA420P10BE = 86,
    #[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA420P10LE = 87,
    #[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA422P10BE = 88,
    #[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA422P10LE = 89,
    #[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA444P10BE = 90,
    #[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA444P10LE = 91,
    #[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA420P16BE = 92,
    #[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA420P16LE = 93,
    #[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA422P16BE = 94,
    #[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA422P16LE = 95,
    #[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
    AV_PIX_FMT_YUVA444P16BE = 96,
    #[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
    AV_PIX_FMT_YUVA444P16LE = 97,
    #[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
    AV_PIX_FMT_VDPAU = 98,
    #[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
    AV_PIX_FMT_XYZ12LE = 99,
    #[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
    AV_PIX_FMT_XYZ12BE = 100,
    #[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    AV_PIX_FMT_NV16 = 101,
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_NV20LE = 102,
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_NV20BE = 103,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
    AV_PIX_FMT_RGBA64BE = 104,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
    AV_PIX_FMT_RGBA64LE = 105,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
    AV_PIX_FMT_BGRA64BE = 106,
    #[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
    AV_PIX_FMT_BGRA64LE = 107,
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
    AV_PIX_FMT_YVYU422 = 108,
    #[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
    AV_PIX_FMT_YA16BE = 109,
    #[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
    AV_PIX_FMT_YA16LE = 110,
    #[doc = "< planar GBRA 4:4:4:4 32bpp"]
    AV_PIX_FMT_GBRAP = 111,
    #[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
    AV_PIX_FMT_GBRAP16BE = 112,
    #[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
    AV_PIX_FMT_GBRAP16LE = 113,
    #[doc = "  HW acceleration through QSV, data[3] contains a pointer to the\n  mfxFrameSurface1 structure."]
    AV_PIX_FMT_QSV = 114,
    #[doc = " HW acceleration though MMAL, data[3] contains a pointer to the\n MMAL_BUFFER_HEADER_T structure."]
    AV_PIX_FMT_MMAL = 115,
    #[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
    AV_PIX_FMT_D3D11VA_VLD = 116,
    #[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers\n exactly as for system memory frames."]
    AV_PIX_FMT_CUDA = 117,
    #[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
    AV_PIX_FMT_0RGB = 118,
    #[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
    AV_PIX_FMT_RGB0 = 119,
    #[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
    AV_PIX_FMT_0BGR = 120,
    #[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
    AV_PIX_FMT_BGR0 = 121,
    #[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P12BE = 122,
    #[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P12LE = 123,
    #[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV420P14BE = 124,
    #[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV420P14LE = 125,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P12BE = 126,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P12LE = 127,
    #[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV422P14BE = 128,
    #[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV422P14LE = 129,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P12BE = 130,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P12LE = 131,
    #[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
    AV_PIX_FMT_YUV444P14BE = 132,
    #[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
    AV_PIX_FMT_YUV444P14LE = 133,
    #[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
    AV_PIX_FMT_GBRP12BE = 134,
    #[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
    AV_PIX_FMT_GBRP12LE = 135,
    #[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
    AV_PIX_FMT_GBRP14BE = 136,
    #[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
    AV_PIX_FMT_GBRP14LE = 137,
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
    AV_PIX_FMT_YUVJ411P = 138,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_BGGR8 = 139,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_RGGB8 = 140,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_GBRG8 = 141,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
    AV_PIX_FMT_BAYER_GRBG8 = 142,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_BGGR16LE = 143,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_BGGR16BE = 144,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_RGGB16LE = 145,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_RGGB16BE = 146,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_GBRG16LE = 147,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_GBRG16BE = 148,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
    AV_PIX_FMT_BAYER_GRBG16LE = 149,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
    AV_PIX_FMT_BAYER_GRBG16BE = 150,
    #[doc = "< XVideo Motion Acceleration via common packet passing"]
    AV_PIX_FMT_XVMC = 151,
    #[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV440P10LE = 152,
    #[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV440P10BE = 153,
    #[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
    AV_PIX_FMT_YUV440P12LE = 154,
    #[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
    AV_PIX_FMT_YUV440P12BE = 155,
    #[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
    AV_PIX_FMT_AYUV64LE = 156,
    #[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
    AV_PIX_FMT_AYUV64BE = 157,
    #[doc = "< hardware decoding through Videotoolbox"]
    AV_PIX_FMT_VIDEOTOOLBOX = 158,
    #[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
    AV_PIX_FMT_P010LE = 159,
    #[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
    AV_PIX_FMT_P010BE = 160,
    #[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
    AV_PIX_FMT_GBRAP12BE = 161,
    #[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
    AV_PIX_FMT_GBRAP12LE = 162,
    #[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
    AV_PIX_FMT_GBRAP10BE = 163,
    #[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
    AV_PIX_FMT_GBRAP10LE = 164,
    #[doc = "< hardware decoding through MediaCodec"]
    AV_PIX_FMT_MEDIACODEC = 165,
    #[doc = "<        Y        , 12bpp, big-endian"]
    AV_PIX_FMT_GRAY12BE = 166,
    #[doc = "<        Y        , 12bpp, little-endian"]
    AV_PIX_FMT_GRAY12LE = 167,
    #[doc = "<        Y        , 10bpp, big-endian"]
    AV_PIX_FMT_GRAY10BE = 168,
    #[doc = "<        Y        , 10bpp, little-endian"]
    AV_PIX_FMT_GRAY10LE = 169,
    #[doc = "< like NV12, with 16bpp per component, little-endian"]
    AV_PIX_FMT_P016LE = 170,
    #[doc = "< like NV12, with 16bpp per component, big-endian"]
    AV_PIX_FMT_P016BE = 171,
    #[doc = " Hardware surfaces for Direct3D11.\n\n This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11\n hwaccel API and filtering support AV_PIX_FMT_D3D11 only.\n\n data[0] contains a ID3D11Texture2D pointer, and data[1] contains the\n texture array index of the frame as intptr_t if the ID3D11Texture2D is\n an array texture (or always 0 if it's a normal texture)."]
    AV_PIX_FMT_D3D11 = 172,
    #[doc = "<        Y        , 9bpp, big-endian"]
    AV_PIX_FMT_GRAY9BE = 173,
    #[doc = "<        Y        , 9bpp, little-endian"]
    AV_PIX_FMT_GRAY9LE = 174,
    #[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
    AV_PIX_FMT_GBRPF32BE = 175,
    #[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
    AV_PIX_FMT_GBRPF32LE = 176,
    #[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
    AV_PIX_FMT_GBRAPF32BE = 177,
    #[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
    AV_PIX_FMT_GBRAPF32LE = 178,
    #[doc = " DRM-managed buffers exposed through PRIME buffer sharing.\n\n data[0] points to an AVDRMFrameDescriptor."]
    AV_PIX_FMT_DRM_PRIME = 179,
    #[doc = " Hardware surfaces for OpenCL.\n\n data[i] contain 2D image objects (typed in C as cl_mem, used\n in OpenCL as image2d_t) for each plane of the surface."]
    AV_PIX_FMT_OPENCL = 180,
    #[doc = "<        Y        , 14bpp, big-endian"]
    AV_PIX_FMT_GRAY14BE = 181,
    #[doc = "<        Y        , 14bpp, little-endian"]
    AV_PIX_FMT_GRAY14LE = 182,
    #[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
    AV_PIX_FMT_GRAYF32BE = 183,
    #[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
    AV_PIX_FMT_GRAYF32LE = 184,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
    AV_PIX_FMT_YUVA422P12BE = 185,
    #[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
    AV_PIX_FMT_YUVA422P12LE = 186,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
    AV_PIX_FMT_YUVA444P12BE = 187,
    #[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
    AV_PIX_FMT_YUVA444P12LE = 188,
    #[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    AV_PIX_FMT_NV24 = 189,
    #[doc = "< as above, but U and V bytes are swapped"]
    AV_PIX_FMT_NV42 = 190,
    #[doc = " Vulkan hardware images.\n\n data[0] points to an AVVkFrame"]
    AV_PIX_FMT_VULKAN = 191,
    #[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
    AV_PIX_FMT_Y210BE = 192,
    #[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
    AV_PIX_FMT_Y210LE = 193,
    #[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_X2RGB10LE = 194,
    #[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
    AV_PIX_FMT_X2RGB10BE = 195,
    #[doc = "< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), little-endian, X=unused/undefined"]
    AV_PIX_FMT_X2BGR10LE = 196,
    #[doc = "< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), big-endian, X=unused/undefined"]
    AV_PIX_FMT_X2BGR10BE = 197,
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, big-endian"]
    AV_PIX_FMT_P210BE = 198,
    #[doc = "< interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, little-endian"]
    AV_PIX_FMT_P210LE = 199,
    #[doc = "< interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, big-endian"]
    AV_PIX_FMT_P410BE = 200,
    #[doc = "< interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, little-endian"]
    AV_PIX_FMT_P410LE = 201,
    #[doc = "< interleaved chroma YUV 4:2:2, 32bpp, big-endian"]
    AV_PIX_FMT_P216BE = 202,
    #[doc = "< interleaved chroma YUV 4:2:2, 32bpp, little-endian"]
    AV_PIX_FMT_P216LE = 203,
    #[doc = "< interleaved chroma YUV 4:4:4, 48bpp, big-endian"]
    AV_PIX_FMT_P416BE = 204,
    #[doc = "< interleaved chroma YUV 4:4:4, 48bpp, little-endian"]
    AV_PIX_FMT_P416LE = 205,
    #[doc = "< packed VUYA 4:4:4, 32bpp, VUYAVUYA..."]
    AV_PIX_FMT_VUYA = 206,
    #[doc = "< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., big-endian"]
    AV_PIX_FMT_RGBAF16BE = 207,
    #[doc = "< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., little-endian"]
    AV_PIX_FMT_RGBAF16LE = 208,
    #[doc = "< packed VUYX 4:4:4, 32bpp, Variant of VUYA where alpha channel is left undefined"]
    AV_PIX_FMT_VUYX = 209,
    #[doc = "< like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, little-endian"]
    AV_PIX_FMT_P012LE = 210,
    #[doc = "< like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, big-endian"]
    AV_PIX_FMT_P012BE = 211,
    #[doc = "< packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, big-endian"]
    AV_PIX_FMT_Y212BE = 212,
    #[doc = "< packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, little-endian"]
    AV_PIX_FMT_Y212LE = 213,
    #[doc = "< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), big-endian, variant of Y410 where alpha channel is left undefined"]
    AV_PIX_FMT_XV30BE = 214,
    #[doc = "< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), little-endian, variant of Y410 where alpha channel is left undefined"]
    AV_PIX_FMT_XV30LE = 215,
    #[doc = "< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, big-endian, variant of Y412 where alpha channel is left undefined"]
    AV_PIX_FMT_XV36BE = 216,
    #[doc = "< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, little-endian, variant of Y412 where alpha channel is left undefined"]
    AV_PIX_FMT_XV36LE = 217,
    #[doc = "< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., big-endian"]
    AV_PIX_FMT_RGBF32BE = 218,
    #[doc = "< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., little-endian"]
    AV_PIX_FMT_RGBF32LE = 219,
    #[doc = "< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., big-endian"]
    AV_PIX_FMT_RGBAF32BE = 220,
    #[doc = "< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., little-endian"]
    AV_PIX_FMT_RGBAF32LE = 221,
    #[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
    AV_PIX_FMT_NB = 222,
}
impl AVColorPrimaries {
    pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_SMPTE428;
}
impl AVColorPrimaries {
    pub const AVCOL_PRI_JEDEC_P22: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_EBU3213;
}
#[repr(i32)]
#[doc = " Chromaticity coordinates of the source primaries.\n These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorPrimaries {
    AVCOL_PRI_RESERVED0 = 0,
    #[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B"]
    AVCOL_PRI_BT709 = 1,
    AVCOL_PRI_UNSPECIFIED = 2,
    AVCOL_PRI_RESERVED = 3,
    #[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
    AVCOL_PRI_BT470M = 4,
    #[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
    AVCOL_PRI_BT470BG = 5,
    #[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
    AVCOL_PRI_SMPTE170M = 6,
    #[doc = "< identical to above, also called \"SMPTE C\" even though it uses D65"]
    AVCOL_PRI_SMPTE240M = 7,
    #[doc = "< colour filters using Illuminant C"]
    AVCOL_PRI_FILM = 8,
    #[doc = "< ITU-R BT2020"]
    AVCOL_PRI_BT2020 = 9,
    #[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
    AVCOL_PRI_SMPTE428 = 10,
    #[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
    AVCOL_PRI_SMPTE431 = 11,
    #[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
    AVCOL_PRI_SMPTE432 = 12,
    #[doc = "< EBU Tech. 3213-E (nothing there) / one of JEDEC P22 group phosphors"]
    AVCOL_PRI_EBU3213 = 22,
    #[doc = "< Not part of ABI"]
    AVCOL_PRI_NB = 23,
}
impl AVColorTransferCharacteristic {
    pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic =
        AVColorTransferCharacteristic::AVCOL_TRC_SMPTE2084;
}
impl AVColorTransferCharacteristic {
    pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic =
        AVColorTransferCharacteristic::AVCOL_TRC_SMPTE428;
}
#[repr(i32)]
#[doc = " Color Transfer Characteristic.\n These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorTransferCharacteristic {
    AVCOL_TRC_RESERVED0 = 0,
    #[doc = "< also ITU-R BT1361"]
    AVCOL_TRC_BT709 = 1,
    AVCOL_TRC_UNSPECIFIED = 2,
    AVCOL_TRC_RESERVED = 3,
    #[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
    AVCOL_TRC_GAMMA22 = 4,
    #[doc = "< also ITU-R BT470BG"]
    AVCOL_TRC_GAMMA28 = 5,
    #[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
    AVCOL_TRC_SMPTE170M = 6,
    AVCOL_TRC_SMPTE240M = 7,
    #[doc = "< \"Linear transfer characteristics\""]
    AVCOL_TRC_LINEAR = 8,
    #[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
    AVCOL_TRC_LOG = 9,
    #[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
    AVCOL_TRC_LOG_SQRT = 10,
    #[doc = "< IEC 61966-2-4"]
    AVCOL_TRC_IEC61966_2_4 = 11,
    #[doc = "< ITU-R BT1361 Extended Colour Gamut"]
    AVCOL_TRC_BT1361_ECG = 12,
    #[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
    AVCOL_TRC_IEC61966_2_1 = 13,
    #[doc = "< ITU-R BT2020 for 10-bit system"]
    AVCOL_TRC_BT2020_10 = 14,
    #[doc = "< ITU-R BT2020 for 12-bit system"]
    AVCOL_TRC_BT2020_12 = 15,
    #[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
    AVCOL_TRC_SMPTE2084 = 16,
    #[doc = "< SMPTE ST 428-1"]
    AVCOL_TRC_SMPTE428 = 17,
    #[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
    AVCOL_TRC_ARIB_STD_B67 = 18,
    #[doc = "< Not part of ABI"]
    AVCOL_TRC_NB = 19,
}
impl AVColorSpace {
    pub const AVCOL_SPC_YCOCG: AVColorSpace = AVColorSpace::AVCOL_SPC_YCGCO;
}
#[repr(i32)]
#[doc = " YUV colorspace type.\n These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorSpace {
    #[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB), YZX and ST 428-1"]
    AVCOL_SPC_RGB = 0,
    #[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / derived in SMPTE RP 177 Annex B"]
    AVCOL_SPC_BT709 = 1,
    AVCOL_SPC_UNSPECIFIED = 2,
    #[doc = "< reserved for future use by ITU-T and ISO/IEC just like 15-255 are"]
    AVCOL_SPC_RESERVED = 3,
    #[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
    AVCOL_SPC_FCC = 4,
    #[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
    AVCOL_SPC_BT470BG = 5,
    #[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above"]
    AVCOL_SPC_SMPTE170M = 6,
    #[doc = "< derived from 170M primaries and D65 white point, 170M is derived from BT470 System M's primaries"]
    AVCOL_SPC_SMPTE240M = 7,
    #[doc = "< used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
    AVCOL_SPC_YCGCO = 8,
    #[doc = "< ITU-R BT2020 non-constant luminance system"]
    AVCOL_SPC_BT2020_NCL = 9,
    #[doc = "< ITU-R BT2020 constant luminance system"]
    AVCOL_SPC_BT2020_CL = 10,
    #[doc = "< SMPTE 2085, Y'D'zD'x"]
    AVCOL_SPC_SMPTE2085 = 11,
    #[doc = "< Chromaticity-derived non-constant luminance system"]
    AVCOL_SPC_CHROMA_DERIVED_NCL = 12,
    #[doc = "< Chromaticity-derived constant luminance system"]
    AVCOL_SPC_CHROMA_DERIVED_CL = 13,
    #[doc = "< ITU-R BT.2100-0, ICtCp"]
    AVCOL_SPC_ICTCP = 14,
    #[doc = "< Not part of ABI"]
    AVCOL_SPC_NB = 15,
}
#[repr(i32)]
#[doc = " Visual content value range.\n\n These values are based on definitions that can be found in multiple\n specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance\n and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital\n Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit\n integer representation). At the time of writing, the BT.2100 one is\n recommended, as it also defines the full range representation.\n\n Common definitions:\n   - For RGB and luma planes such as Y in YCbCr and I in ICtCp,\n     'E' is the original value in range of 0.0 to 1.0.\n   - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original\n     value in range of -0.5 to 0.5.\n   - 'n' is the output bit depth.\n   - For additional definitions such as rounding and clipping to valid n\n     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVColorRange {
    AVCOL_RANGE_UNSPECIFIED = 0,
    #[doc = " Narrow or limited range content.\n\n - For luma planes:\n\n       (219 * E + 16) * 2^(n-8)\n\n   F.ex. the range of 16-235 for 8 bits\n\n - For chroma planes:\n\n       (224 * E + 128) * 2^(n-8)\n\n   F.ex. the range of 16-240 for 8 bits"]
    AVCOL_RANGE_MPEG = 1,
    #[doc = " Full range content.\n\n - For RGB and luma planes:\n\n       (2^n - 1) * E\n\n   F.ex. the range of 0-255 for 8 bits\n\n - For chroma planes:\n\n       (2^n - 1) * E + 2^(n - 1)\n\n   F.ex. the range of 1-255 for 8 bits"]
    AVCOL_RANGE_JPEG = 2,
    #[doc = "< Not part of ABI"]
    AVCOL_RANGE_NB = 3,
}
#[repr(i32)]
#[doc = " Location of chroma samples.\n\n Illustration showing the location of the first (top left) chroma sample of the\n image, the left shows only luma, the right\n shows the location of the chroma sample, the 2 could be imagined to overlay\n each other but are drawn separately due to limitations of ASCII\n\n                1st 2nd       1st 2nd horizontal luma sample positions\n                 v   v         v   v\n                 ______        ______\n1st luma line > |X   X ...    |3 4 X ...     X are luma samples,\n                |             |1 2           1-6 are possible chroma positions\n2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChromaLocation {
    AVCHROMA_LOC_UNSPECIFIED = 0,
    #[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
    AVCHROMA_LOC_LEFT = 1,
    #[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
    AVCHROMA_LOC_CENTER = 2,
    #[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
    AVCHROMA_LOC_TOPLEFT = 3,
    AVCHROMA_LOC_TOP = 4,
    AVCHROMA_LOC_BOTTOMLEFT = 5,
    AVCHROMA_LOC_BOTTOM = 6,
    #[doc = "< Not part of ABI"]
    AVCHROMA_LOC_NB = 7,
}
extern "C" {
    #[doc = " Compute the length of an integer list.\n\n @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)\n @param term    list terminator (usually 0 or -1)\n @param list    pointer to the list\n @return  length of the list, in elements, not counting the terminator"]
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Open a file using a UTF-8 filename.\n The API of this function matches POSIX fopen(), errors are returned through\n errno.\n @deprecated Avoid using it, as on Windows, the FILE* allocated by this\n             function may be allocated with a different CRT than the caller\n             who uses the FILE*. No replacement provided in public API."]
    pub fn av_fopen_utf8(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Return the fractional representation of the internal time base."]
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    #[doc = " Fill the provided buffer with a string containing a FourCC (four-character\n code) representation.\n\n @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE\n @param fourcc the fourcc to represent\n @return the buffer in input"]
    pub fn av_fourcc_make_string(
        buf: *mut ::std::os::raw::c_char,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[doc = " A reference to a data buffer.\n\n The size of this struct is not a part of the public ABI and it is not meant\n to be allocated directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    #[doc = " The data buffer. It is considered writable if and only if\n this is the only reference to the buffer, in which case\n av_buffer_is_writable() returns 1."]
    pub data: *mut u8,
    #[doc = " Size of data in bytes."]
    pub size: usize,
}
extern "C" {
    #[doc = " Allocate an AVBuffer of the given size using av_malloc().\n\n @return an AVBufferRef of given size or NULL when out of memory"]
    pub fn av_buffer_alloc(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Same as av_buffer_alloc(), except the returned buffer will be initialized\n to zero."]
    pub fn av_buffer_allocz(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Create an AVBuffer from an existing array.\n\n If this function is successful, data is owned by the AVBuffer. The caller may\n only access data through the returned AVBufferRef and references derived from\n it.\n If this function fails, data is left untouched.\n @param data   data array\n @param size   size of data in bytes\n @param free   a callback for freeing this buffer's data\n @param opaque parameter to be got for processing or passed to free\n @param flags  a combination of AV_BUFFER_FLAG_*\n\n @return an AVBufferRef referring to data on success, NULL on failure."]
    pub fn av_buffer_create(
        data: *mut u8,
        size: usize,
        free: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
        >,
        opaque: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Default free callback, which calls av_free() on the buffer data.\n This function is meant to be passed to av_buffer_create(), not called\n directly."]
    pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
    #[doc = " Create a new reference to an AVBuffer.\n\n @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on\n failure."]
    pub fn av_buffer_ref(buf: *const AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Free a given reference and automatically free the buffer if there are no more\n references to it.\n\n @param buf the reference to be freed. The pointer is set to NULL on return."]
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    #[doc = " @return 1 if the caller may write to the data referred to by buf (which is\n true if and only if buf is the only reference to the underlying AVBuffer).\n Return 0 otherwise.\n A positive answer is valid until av_buffer_ref() is called on buf."]
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the opaque parameter set by av_buffer_create."]
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a writable reference from a given buffer reference, avoiding data copy\n if possible.\n\n @param buf buffer reference to make writable. On success, buf is either left\n            untouched, or it is unreferenced and a new writable AVBufferRef is\n            written in its place. On failure, buf is left untouched.\n @return 0 on success, a negative AVERROR on failure."]
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reallocate a given buffer.\n\n @param buf  a buffer reference to reallocate. On success, buf will be\n             unreferenced and a new reference with the required size will be\n             written in its place. On failure buf will be left untouched. *buf\n             may be NULL, then a new buffer is allocated.\n @param size required new buffer size.\n @return 0 on success, a negative AVERROR on failure.\n\n @note the buffer is actually reallocated with av_realloc() only if it was\n initially allocated through av_buffer_realloc(NULL) and there is only one\n reference to it (i.e. the one passed to this function). In all other cases\n a new buffer is allocated and the data is copied."]
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure dst refers to the same data as src.\n\n When *dst is already equivalent to src, do nothing. Otherwise unreference dst\n and replace it with a new reference to src.\n\n @param dst Pointer to either a valid buffer reference or NULL. On success,\n            this will point to a buffer reference equivalent to src. On\n            failure, dst will be left untouched.\n @param src A buffer reference to replace dst with. May be NULL, then this\n            function is equivalent to av_buffer_unref(dst).\n @return 0 on success\n         AVERROR(ENOMEM) on memory allocation failure."]
    pub fn av_buffer_replace(
        dst: *mut *mut AVBufferRef,
        src: *const AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize a buffer pool.\n\n @param size size of each buffer in this pool\n @param alloc a function that will be used to allocate new buffers when the\n pool is empty. May be NULL, then the default allocator will be used\n (av_buffer_alloc()).\n @return newly created buffer pool on success, NULL on error."]
    pub fn av_buffer_pool_init(
        size: usize,
        alloc: ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut AVBufferRef>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Allocate and initialize a buffer pool with a more complex allocator.\n\n @param size size of each buffer in this pool\n @param opaque arbitrary user data used by the allocator\n @param alloc a function that will be used to allocate new buffers when the\n              pool is empty. May be NULL, then the default allocator will be\n              used (av_buffer_alloc()).\n @param pool_free a function that will be called immediately before the pool\n                  is freed. I.e. after av_buffer_pool_uninit() is called\n                  by the caller and all the frames are returned to the pool\n                  and freed. It is intended to uninitialize the user opaque\n                  data. May be NULL.\n @return newly created buffer pool on success, NULL on error."]
    pub fn av_buffer_pool_init2(
        size: usize,
        opaque: *mut ::std::os::raw::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Mark the pool as being available for freeing. It will actually be freed only\n once all the allocated buffers associated with the pool are released. Thus it\n is safe to call this function while some of the allocated buffers are still\n in use.\n\n @param pool pointer to the pool to be freed. It will be set to NULL."]
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    #[doc = " Allocate a new AVBuffer, reusing an old buffer from the pool when available.\n This function may be called simultaneously from multiple threads.\n\n @return a reference to the new buffer on success, NULL on error."]
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Query the original opaque parameter of an allocated buffer in the pool.\n\n @param ref a buffer reference to a buffer returned by av_buffer_pool_get.\n @return the opaque parameter set by the buffer allocator function of the\n         buffer pool.\n\n @note the opaque parameter of ref is used by the buffer pool implementation,\n therefore you have to use this function to access the original opaque\n parameter of an allocated buffer."]
    pub fn av_buffer_pool_buffer_get_opaque(
        ref_: *const AVBufferRef,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionaryEntry {
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a dictionary entry with matching key.\n\n The returned entry key or value must not be changed, or it will\n cause undefined behavior.\n\n To iterate through all the dictionary entries, you can set the matching key\n to the null string \"\" and set the AV_DICT_IGNORE_SUFFIX flag.\n\n @param prev Set to the previous matching element to find the next.\n             If set to NULL the first matching element is returned.\n @param key matching key\n @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved\n @return found entry or NULL in case no matching entry was found in the dictionary"]
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const ::std::os::raw::c_char,
        prev: *const AVDictionaryEntry,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    #[doc = " Get number of entries in dictionary.\n\n @param m dictionary\n @return  number of entries in dictionary"]
    pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the given entry in *pm, overwriting an existing entry.\n\n Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,\n these arguments will be freed on error.\n\n Warning: Adding a new entry to a dictionary invalidates all existing entries\n previously returned with av_dict_get.\n\n @param pm pointer to a pointer to a dictionary struct. If *pm is NULL\n a dictionary struct is allocated and put in *pm.\n @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)\n @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).\n        Passing a NULL value will cause an existing entry to be deleted.\n @return >= 0 on success otherwise an error code <0"]
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience wrapper for av_dict_set that converts the value to a string\n and stores it.\n\n Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error."]
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse the key/value pairs list and add the parsed entries to a dictionary.\n\n In case of failure, all the successfully set entries are stored in\n *pm. You may need to manually free the created dictionary.\n\n @param key_val_sep  a 0-terminated list of characters used to separate\n                     key from value\n @param pairs_sep    a 0-terminated list of characters used to separate\n                     two pairs from each other\n @param flags        flags to use when adding to dictionary.\n                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL\n                     are ignored since the key/value tokens will always\n                     be duplicated.\n @return             0 on success, negative AVERROR code on failure"]
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str_: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy entries from one AVDictionary struct into another.\n @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,\n            this function will allocate a struct for you and put it in *dst\n @param src pointer to source AVDictionary struct\n @param flags flags to use when setting entries in *dst\n @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag\n @return 0 on success, negative AVERROR code on failure. If dst was allocated\n           by this function, callers should free the associated memory."]
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all the memory allocated for an AVDictionary struct\n and all keys and values."]
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    #[doc = " Get dictionary entries as a string.\n\n Create a string containing dictionary's entries.\n Such string may be passed back to av_dict_parse_string().\n @note String is escaped with backslashes ('\\').\n\n @param[in]  m             dictionary\n @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.\n                           Buffer must be freed by the caller when is no longer needed.\n @param[in]  key_val_sep   character used to separate key from value\n @param[in]  pairs_sep     character used to separate two pairs from each other\n @return                   >= 0 on success, negative on error\n @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @addtogroup lavu_audio\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChannel {
    AV_CHAN_NONE = -1,
    AV_CHAN_FRONT_LEFT = 0,
    AV_CHAN_FRONT_RIGHT = 1,
    AV_CHAN_FRONT_CENTER = 2,
    AV_CHAN_LOW_FREQUENCY = 3,
    AV_CHAN_BACK_LEFT = 4,
    AV_CHAN_BACK_RIGHT = 5,
    AV_CHAN_FRONT_LEFT_OF_CENTER = 6,
    AV_CHAN_FRONT_RIGHT_OF_CENTER = 7,
    AV_CHAN_BACK_CENTER = 8,
    AV_CHAN_SIDE_LEFT = 9,
    AV_CHAN_SIDE_RIGHT = 10,
    AV_CHAN_TOP_CENTER = 11,
    AV_CHAN_TOP_FRONT_LEFT = 12,
    AV_CHAN_TOP_FRONT_CENTER = 13,
    AV_CHAN_TOP_FRONT_RIGHT = 14,
    AV_CHAN_TOP_BACK_LEFT = 15,
    AV_CHAN_TOP_BACK_CENTER = 16,
    AV_CHAN_TOP_BACK_RIGHT = 17,
    #[doc = " Stereo downmix."]
    AV_CHAN_STEREO_LEFT = 29,
    #[doc = " See above."]
    AV_CHAN_STEREO_RIGHT = 30,
    #[doc = " See above."]
    AV_CHAN_WIDE_LEFT = 31,
    #[doc = " See above."]
    AV_CHAN_WIDE_RIGHT = 32,
    #[doc = " See above."]
    AV_CHAN_SURROUND_DIRECT_LEFT = 33,
    #[doc = " See above."]
    AV_CHAN_SURROUND_DIRECT_RIGHT = 34,
    #[doc = " See above."]
    AV_CHAN_LOW_FREQUENCY_2 = 35,
    #[doc = " See above."]
    AV_CHAN_TOP_SIDE_LEFT = 36,
    #[doc = " See above."]
    AV_CHAN_TOP_SIDE_RIGHT = 37,
    #[doc = " See above."]
    AV_CHAN_BOTTOM_FRONT_CENTER = 38,
    #[doc = " See above."]
    AV_CHAN_BOTTOM_FRONT_LEFT = 39,
    #[doc = " See above."]
    AV_CHAN_BOTTOM_FRONT_RIGHT = 40,
    #[doc = " Channel is empty can be safely skipped."]
    AV_CHAN_UNUSED = 512,
    #[doc = " Channel contains data, but its position is unknown."]
    AV_CHAN_UNKNOWN = 768,
    #[doc = " Range of channels between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.\n\n Given a channel id <i> between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel <n> is\n <n> = <i> - AV_CHAN_AMBISONIC_BASE.\n\n @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel\n orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels\n implicitly by their position in the stream."]
    AV_CHAN_AMBISONIC_BASE = 1024,
    #[doc = " Range of channels between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.\n\n Given a channel id <i> between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel <n> is\n <n> = <i> - AV_CHAN_AMBISONIC_BASE.\n\n @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel\n orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels\n implicitly by their position in the stream."]
    AV_CHAN_AMBISONIC_END = 2047,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVChannelOrder {
    #[doc = " Only the channel count is specified, without any further information\n about the channel order."]
    AV_CHANNEL_ORDER_UNSPEC = 0,
    #[doc = " The native channel order, i.e. the channels are in the same order in\n which they are defined in the AVChannel enum. This supports up to 63\n different channels."]
    AV_CHANNEL_ORDER_NATIVE = 1,
    #[doc = " The channel order does not correspond to any other predefined order and\n is stored as an explicit map. For example, this could be used to support\n layouts with 64 or more channels, or with empty/skipped (AV_CHAN_SILENCE)\n channels at arbitrary positions."]
    AV_CHANNEL_ORDER_CUSTOM = 2,
    #[doc = " The audio is represented as the decomposition of the sound field into\n spherical harmonics. Each channel corresponds to a single expansion\n component. Channels are ordered according to ACN (Ambisonic Channel\n Number).\n\n The channel with the index n in the stream contains the spherical\n harmonic of degree l and order m given by\n @code{.unparsed}\n   l   = floor(sqrt(n)),\n   m   = n - l * (l + 1).\n @endcode\n\n Conversely given a spherical harmonic of degree l and order m, the\n corresponding channel index n is given by\n @code{.unparsed}\n   n = l * (l + 1) + m.\n @endcode\n\n Normalization is assumed to be SN3D (Schmidt Semi-Normalization)\n as defined in AmbiX format $ 2.1."]
    AV_CHANNEL_ORDER_AMBISONIC = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVMatrixEncoding {
    AV_MATRIX_ENCODING_NONE = 0,
    AV_MATRIX_ENCODING_DOLBY = 1,
    AV_MATRIX_ENCODING_DPLII = 2,
    AV_MATRIX_ENCODING_DPLIIX = 3,
    AV_MATRIX_ENCODING_DPLIIZ = 4,
    AV_MATRIX_ENCODING_DOLBYEX = 5,
    AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6,
    AV_MATRIX_ENCODING_NB = 7,
}
#[doc = " An AVChannelCustom defines a single channel within a custom order layout\n\n Unlike most structures in FFmpeg, sizeof(AVChannelCustom) is a part of the\n public ABI.\n\n No new fields may be added to it without a major version bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVChannelCustom {
    pub id: AVChannel,
    pub name: [::std::os::raw::c_char; 16usize],
    pub opaque: *mut ::std::os::raw::c_void,
}
#[doc = " An AVChannelLayout holds information about the channel layout of audio data.\n\n A channel layout here is defined as a set of channels ordered in a specific\n way (unless the channel order is AV_CHANNEL_ORDER_UNSPEC, in which case an\n AVChannelLayout carries only the channel count).\n\n Unlike most structures in Libav, sizeof(AVChannelLayout) is a part of the\n public ABI and may be used by the caller. E.g. it may be allocated on stack\n or embedded in caller-defined structs.\n\n AVChannelLayout can be initialized as follows:\n - default initialization with {0}, followed by setting all used fields\n   correctly;\n - by assigning one of the predefined AV_CHANNEL_LAYOUT_* initializers;\n - with a constructor function, such as av_channel_layout_default(),\n   av_channel_layout_from_mask() or av_channel_layout_from_string().\n\n The channel layout must be unitialized with av_channel_layout_uninit()\n\n Copying an AVChannelLayout via assigning is forbidden,\n av_channel_layout_copy() must be used instead (and its return value should\n be checked)\n\n No new fields may be added to it without a major version bump, except for\n new elements of the union fitting in sizeof(uint64_t)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVChannelLayout {
    #[doc = " Channel order used in this layout.\n Any value not defined in the AVChannelOrder enum in a layout that\n av_channel_layout_check() doesn't reject must be treated as if it was\n AV_CHANNEL_ORDER_UNSPEC.\n This is a mandatory field."]
    pub order: AVChannelOrder,
    #[doc = " Number of channels in this layout. Mandatory field."]
    pub nb_channels: ::std::os::raw::c_int,
    pub u: AVChannelLayout__bindgen_ty_1,
    #[doc = " For some private data of the user."]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[doc = " Details about which channels are present in this layout.\n For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be\n used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVChannelLayout__bindgen_ty_1 {
    #[doc = " This member must be used for AV_CHANNEL_ORDER_NATIVE, and may be used\n for AV_CHANNEL_ORDER_AMBISONIC to signal non-diegetic channels.\n It is a bitmask, where the position of each set bit means that the\n AVChannel with the corresponding value is present.\n\n I.e. when (mask & (1 << AV_CHAN_FOO)) is non-zero, then AV_CHAN_FOO\n is present in the layout. Otherwise it is not present.\n\n @note when a channel layout using a bitmask is constructed or\n modified manually (i.e.  not using any of the av_channel_layout_*\n functions), the code doing it must ensure that the number of set bits\n is equal to nb_channels."]
    pub mask: u64,
    #[doc = " This member must be used when the channel order is\n AV_CHANNEL_ORDER_CUSTOM. It is a nb_channels-sized array, with each\n element signalling the presence of the AVChannel with the\n corresponding value in map[i].id.\n\n I.e. when map[i].id is equal to AV_CHAN_FOO, then AV_CH_FOO is the\n i-th channel in the audio data.\n\n When map[i].id is in the range between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END (inclusive), the channel contains an ambisonic\n component with ACN index (as defined above)\n n = map[i].id - AV_CHAN_AMBISONIC_BASE.\n\n map[i].name may be filled with a 0-terminated string, in which case\n it will be used for the purpose of identifying the channel with the\n convenience functions below. Otherise it must be zeroed."]
    pub map: *mut AVChannelCustom,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return a channel layout id that matches name, or 0 if no match is found.\n\n name can be one or several of the following notations,\n separated by '+' or '|':\n - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,\n   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);\n - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,\n   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);\n - a number of channels, in decimal, followed by 'c', yielding\n   the default channel layout for that number of channels (@see\n   av_get_default_channel_layout);\n - a channel layout mask, in hexadecimal starting with \"0x\" (see the\n   AV_CH_* macros).\n\n Example: \"stereo+FC\" = \"2c+FC\" = \"2c+1c\" = \"0x7\"\n\n @deprecated use av_channel_layout_from_string()"]
    pub fn av_get_channel_layout(name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[doc = " Return a channel layout and the number of channels based on the specified name.\n\n This function is similar to (@see av_get_channel_layout), but can also parse\n unknown channel layout specifications.\n\n @param[in]  name             channel layout specification string\n @param[out] channel_layout   parsed channel layout (0 if unknown)\n @param[out] nb_channels      number of channels\n\n @return 0 on success, AVERROR(EINVAL) if the parsing fails.\n @deprecated use av_channel_layout_from_string()"]
    pub fn av_get_extended_channel_layout(
        name: *const ::std::os::raw::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a description of a channel layout.\n If nb_channels is <= 0, it is guessed from the channel_layout.\n\n @param buf put here the string containing the channel layout\n @param buf_size size in bytes of the buffer\n @deprecated use av_channel_layout_describe()"]
    pub fn av_get_channel_layout_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    #[doc = " Append a description of a channel layout to a bprint buffer.\n @deprecated use av_channel_layout_describe()"]
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: ::std::os::raw::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    #[doc = " Return the number of channels in the channel layout.\n @deprecated use AVChannelLayout.nb_channels"]
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return default channel layout for a given number of channels.\n\n @deprecated use av_channel_layout_default()"]
    pub fn av_get_default_channel_layout(nb_channels: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    #[doc = " Get the index of a channel in channel_layout.\n\n @param channel a channel layout describing exactly one channel which must be\n                present in channel_layout.\n\n @return index of channel in channel_layout on success, a negative AVERROR\n         on error.\n\n @deprecated use av_channel_layout_index_from_channel()"]
    pub fn av_get_channel_layout_channel_index(
        channel_layout: u64,
        channel: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel with the given index in channel_layout.\n @deprecated use av_channel_layout_channel_from_index()"]
    pub fn av_channel_layout_extract_channel(
        channel_layout: u64,
        index: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    #[doc = " Get the name of a given channel.\n\n @return channel name on success, NULL on error.\n\n @deprecated use av_channel_name()"]
    pub fn av_get_channel_name(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the description of a given channel.\n\n @param channel  a channel layout with a single channel\n @return  channel description on success, NULL on error\n @deprecated use av_channel_description()"]
    pub fn av_get_channel_description(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value and name of a standard channel layout.\n\n @param[in]  index   index in an internal list, starting at 0\n @param[out] layout  channel layout mask\n @param[out] name    name of the layout\n @return  0  if the layout exists,\n          <0 if index is beyond the limits\n @deprecated use av_channel_layout_standard()"]
    pub fn av_get_standard_channel_layout(
        index: ::std::os::raw::c_uint,
        layout: *mut u64,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a human readable string in an abbreviated form describing a given channel.\n This is the inverse function of @ref av_channel_from_string().\n\n @param buf pre-allocated buffer where to put the generated string\n @param buf_size size in bytes of the buffer.\n @return amount of bytes needed to hold the output string, or a negative AVERROR\n         on failure. If the returned value is bigger than buf_size, then the\n         string was truncated."]
    pub fn av_channel_name(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bprint variant of av_channel_name().\n\n @note the string will be appended to the bprint buffer."]
    pub fn av_channel_name_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    #[doc = " Get a human readable string describing a given channel.\n\n @param buf pre-allocated buffer where to put the generated string\n @param buf_size size in bytes of the buffer.\n @return amount of bytes needed to hold the output string, or a negative AVERROR\n         on failure. If the returned value is bigger than buf_size, then the\n         string was truncated."]
    pub fn av_channel_description(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bprint variant of av_channel_description().\n\n @note the string will be appended to the bprint buffer."]
    pub fn av_channel_description_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    #[doc = " This is the inverse function of @ref av_channel_name().\n\n @return the channel with the given name\n         AV_CHAN_NONE when name does not identify a known channel"]
    pub fn av_channel_from_string(name: *const ::std::os::raw::c_char) -> AVChannel;
}
extern "C" {
    #[doc = " Initialize a native channel layout from a bitmask indicating which channels\n are present.\n\n @param channel_layout the layout structure to be initialized\n @param mask bitmask describing the channel layout\n\n @return 0 on success\n         AVERROR(EINVAL) for invalid mask values"]
    pub fn av_channel_layout_from_mask(
        channel_layout: *mut AVChannelLayout,
        mask: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a channel layout from a given string description.\n The input string can be represented by:\n  - the formal channel layout name (returned by av_channel_layout_describe())\n  - single or multiple channel names (returned by av_channel_name(), eg. \"FL\",\n    or concatenated with \"+\", each optionally containing a custom name after\n    a \"@\", eg. \"FL@Left+FR@Right+LFE\")\n  - a decimal or hexadecimal value of a native channel layout (eg. \"4\" or \"0x4\")\n  - the number of channels with default layout (eg. \"4c\")\n  - the number of unordered channels (eg. \"4C\" or \"4 channels\")\n  - the ambisonic order followed by optional non-diegetic channels (eg.\n    \"ambisonic 2+stereo\")\n\n @param channel_layout input channel layout\n @param str string describing the channel layout\n @return 0 channel layout was detected, AVERROR_INVALIDATATA otherwise"]
    pub fn av_channel_layout_from_string(
        channel_layout: *mut AVChannelLayout,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default channel layout for a given number of channels.\n\n @param channel_layout the layout structure to be initialized\n @param nb_channels number of channels"]
    pub fn av_channel_layout_default(
        ch_layout: *mut AVChannelLayout,
        nb_channels: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Iterate over all standard channel layouts.\n\n @param opaque a pointer where libavutil will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the standard channel layout or NULL when the iteration is\n         finished"]
    pub fn av_channel_layout_standard(
        opaque: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVChannelLayout;
}
extern "C" {
    #[doc = " Free any allocated data in the channel layout and reset the channel\n count to 0.\n\n @param channel_layout the layout structure to be uninitialized"]
    pub fn av_channel_layout_uninit(channel_layout: *mut AVChannelLayout);
}
extern "C" {
    #[doc = " Make a copy of a channel layout. This differs from just assigning src to dst\n in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.\n\n @note the destination channel_layout will be always uninitialized before copy.\n\n @param dst destination channel layout\n @param src source channel layout\n @return 0 on success, a negative AVERROR on error."]
    pub fn av_channel_layout_copy(
        dst: *mut AVChannelLayout,
        src: *const AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a human-readable string describing the channel layout properties.\n The string will be in the same format that is accepted by\n @ref av_channel_layout_from_string(), allowing to rebuild the same\n channel layout, except for opaque pointers.\n\n @param channel_layout channel layout to be described\n @param buf pre-allocated buffer where to put the generated string\n @param buf_size size in bytes of the buffer.\n @return amount of bytes needed to hold the output string, or a negative AVERROR\n         on failure. If the returned value is bigger than buf_size, then the\n         string was truncated."]
    pub fn av_channel_layout_describe(
        channel_layout: *const AVChannelLayout,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bprint variant of av_channel_layout_describe().\n\n @note the string will be appended to the bprint buffer.\n @return 0 on success, or a negative AVERROR value on failure."]
    pub fn av_channel_layout_describe_bprint(
        channel_layout: *const AVChannelLayout,
        bp: *mut AVBPrint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel with the given index in a channel layout.\n\n @param channel_layout input channel layout\n @return channel with the index idx in channel_layout on success or\n         AV_CHAN_NONE on failure (if idx is not valid or the channel order is\n         unspecified)"]
    pub fn av_channel_layout_channel_from_index(
        channel_layout: *const AVChannelLayout,
        idx: ::std::os::raw::c_uint,
    ) -> AVChannel;
}
extern "C" {
    #[doc = " Get the index of a given channel in a channel layout. In case multiple\n channels are found, only the first match will be returned.\n\n @param channel_layout input channel layout\n @return index of channel in channel_layout on success or a negative number if\n         channel is not present in channel_layout."]
    pub fn av_channel_layout_index_from_channel(
        channel_layout: *const AVChannelLayout,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the index in a channel layout of a channel described by the given string.\n In case multiple channels are found, only the first match will be returned.\n\n This function accepts channel names in the same format as\n @ref av_channel_from_string().\n\n @param channel_layout input channel layout\n @return a channel index described by the given string, or a negative AVERROR\n         value."]
    pub fn av_channel_layout_index_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a channel described by the given string.\n\n This function accepts channel names in the same format as\n @ref av_channel_from_string().\n\n @param channel_layout input channel layout\n @return a channel described by the given string in channel_layout on success\n         or AV_CHAN_NONE on failure (if the string is not valid or the channel\n         order is unspecified)"]
    pub fn av_channel_layout_channel_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const ::std::os::raw::c_char,
    ) -> AVChannel;
}
extern "C" {
    #[doc = " Find out what channels from a given set are present in a channel layout,\n without regard for their positions.\n\n @param channel_layout input channel layout\n @param mask a combination of AV_CH_* representing a set of channels\n @return a bitfield representing all the channels from mask that are present\n         in channel_layout"]
    pub fn av_channel_layout_subset(channel_layout: *const AVChannelLayout, mask: u64) -> u64;
}
extern "C" {
    #[doc = " Check whether a channel layout is valid, i.e. can possibly describe audio\n data.\n\n @param channel_layout input channel layout\n @return 1 if channel_layout is valid, 0 otherwise."]
    pub fn av_channel_layout_check(channel_layout: *const AVChannelLayout)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether two channel layouts are semantically the same, i.e. the same\n channels are present on the same positions in both.\n\n If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is\n not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC,\n they are considered equal iff the channel counts are the same in both.\n\n @param chl input channel layout\n @param chl1 input channel layout\n @return 0 if chl and chl1 are equal, 1 if they are not equal. A negative\n         AVERROR code if one or both are invalid."]
    pub fn av_channel_layout_compare(
        chl: *const AVChannelLayout,
        chl1: *const AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @defgroup lavu_frame AVFrame\n @ingroup lavu_data\n\n @{\n AVFrame is an abstraction for reference-counted raw multimedia data."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFrameSideDataType {
    #[doc = " The data is the AVPanScan struct defined in libavcodec."]
    AV_FRAME_DATA_PANSCAN = 0,
    #[doc = " ATSC A53 Part 4 Closed Captions.\n A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.\n The number of bytes of CC data is AVFrameSideData.size."]
    AV_FRAME_DATA_A53_CC = 1,
    #[doc = " Stereoscopic 3d metadata.\n The data is the AVStereo3D struct defined in libavutil/stereo3d.h."]
    AV_FRAME_DATA_STEREO3D = 2,
    #[doc = " The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h."]
    AV_FRAME_DATA_MATRIXENCODING = 3,
    #[doc = " Metadata relevant to a downmix procedure.\n The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h."]
    AV_FRAME_DATA_DOWNMIX_INFO = 4,
    #[doc = " ReplayGain information in the form of the AVReplayGain struct."]
    AV_FRAME_DATA_REPLAYGAIN = 5,
    #[doc = " This side data contains a 3x3 transformation matrix describing an affine\n transformation that needs to be applied to the frame for correct\n presentation.\n\n See libavutil/display.h for a detailed description of the data."]
    AV_FRAME_DATA_DISPLAYMATRIX = 6,
    #[doc = " Active Format Description data consisting of a single byte as specified\n in ETSI TS 101 154 using AVActiveFormatDescription enum."]
    AV_FRAME_DATA_AFD = 7,
    #[doc = " Motion vectors exported by some codecs (on demand through the export_mvs\n flag set in the libavcodec AVCodecContext flags2 option).\n The data is the AVMotionVector struct defined in\n libavutil/motion_vector.h."]
    AV_FRAME_DATA_MOTION_VECTORS = 8,
    #[doc = " Recommmends skipping the specified number of samples. This is exported\n only if the \"skip_manual\" AVOption is set in libavcodec.\n This has the same format as AV_PKT_DATA_SKIP_SAMPLES.\n @code\n u32le number of samples to skip from start of this packet\n u32le number of samples to skip from end of this packet\n u8    reason for start skip\n u8    reason for end   skip (0=padding silence, 1=convergence)\n @endcode"]
    AV_FRAME_DATA_SKIP_SAMPLES = 9,
    #[doc = " This side data must be associated with an audio frame and corresponds to\n enum AVAudioServiceType defined in avcodec.h."]
    AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10,
    #[doc = " Mastering display metadata associated with a video frame. The payload is\n an AVMasteringDisplayMetadata type and contains information about the\n mastering display color volume."]
    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11,
    #[doc = " The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.\n This is set on the first frame of a GOP that has a temporal reference of 0."]
    AV_FRAME_DATA_GOP_TIMECODE = 12,
    #[doc = " The data represents the AVSphericalMapping structure defined in\n libavutil/spherical.h."]
    AV_FRAME_DATA_SPHERICAL = 13,
    #[doc = " Content light level (based on CTA-861.3). This payload contains data in\n the form of the AVContentLightMetadata struct."]
    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14,
    #[doc = " The data contains an ICC profile as an opaque octet buffer following the\n format described by ISO 15076-1 with an optional name defined in the\n metadata key entry \"name\"."]
    AV_FRAME_DATA_ICC_PROFILE = 15,
    #[doc = " Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t\n where the first uint32_t describes how many (1-3) of the other timecodes are used.\n The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n function in libavutil/timecode.h."]
    AV_FRAME_DATA_S12M_TIMECODE = 16,
    #[doc = " HDR dynamic metadata associated with a video frame. The payload is\n an AVDynamicHDRPlus type and contains information for color\n volume transform - application 4 of SMPTE 2094-40:2016 standard."]
    AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17,
    #[doc = " Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of\n array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size."]
    AV_FRAME_DATA_REGIONS_OF_INTEREST = 18,
    #[doc = " Encoding parameters for a video frame, as described by AVVideoEncParams."]
    AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19,
    #[doc = " User data unregistered metadata associated with a video frame.\n This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose\n The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of\n uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte."]
    AV_FRAME_DATA_SEI_UNREGISTERED = 20,
    #[doc = " Film grain parameters for a frame, described by AVFilmGrainParams.\n Must be present for every frame which should have film grain applied."]
    AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21,
    #[doc = " Bounding boxes for object detection and classification,\n as described by AVDetectionBBoxHeader."]
    AV_FRAME_DATA_DETECTION_BBOXES = 22,
    #[doc = " Dolby Vision RPU raw data, suitable for passing to x265\n or other libraries. Array of uint8_t, with NAL emulation\n bytes intact."]
    AV_FRAME_DATA_DOVI_RPU_BUFFER = 23,
    #[doc = " Parsed Dolby Vision metadata, suitable for passing to a software\n implementation. The payload is the AVDOVIMetadata struct defined in\n libavutil/dovi_meta.h."]
    AV_FRAME_DATA_DOVI_METADATA = 24,
    #[doc = " HDR Vivid dynamic metadata associated with a video frame. The payload is\n an AVDynamicHDRVivid type and contains information for color\n volume transform - CUVA 005.1-2021."]
    AV_FRAME_DATA_DYNAMIC_HDR_VIVID = 25,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVActiveFormatDescription {
    AV_AFD_SAME = 8,
    AV_AFD_4_3 = 9,
    AV_AFD_16_9 = 10,
    AV_AFD_14_9 = 11,
    AV_AFD_4_3_SP_14_9 = 13,
    AV_AFD_16_9_SP_14_9 = 14,
    AV_AFD_SP_4_3 = 15,
}
#[doc = " Structure to hold side data for an AVFrame.\n\n sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added\n to the end with a minor bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: usize,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[doc = " Structure describing a single Region Of Interest.\n\n When multiple regions are defined in a single side-data block, they\n should be ordered from most to least important - some encoders are only\n capable of supporting a limited number of distinct regions, so will have\n to truncate the list.\n\n When overlapping regions are defined, the first region containing a given\n area of the frame applies."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRegionOfInterest {
    #[doc = " Must be set to the size of this data structure (that is,\n sizeof(AVRegionOfInterest))."]
    pub self_size: u32,
    #[doc = " Distance in pixels from the top edge of the frame to the top and\n bottom edges and from the left edge of the frame to the left and\n right edges of the rectangle defining this region of interest.\n\n The constraints on a region are encoder dependent, so the region\n actually affected may be slightly larger for alignment or other\n reasons."]
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    #[doc = " Quantisation offset.\n\n Must be in the range -1 to +1.  A value of zero indicates no quality\n change.  A negative value asks for better quality (less quantisation),\n while a positive value asks for worse quality (greater quantisation).\n\n The range is calibrated so that the extreme values indicate the\n largest possible offset - if the rest of the frame is encoded with the\n worst possible quality, an offset of -1 indicates that this region\n should be encoded with the best possible quality anyway.  Intermediate\n values are then interpolated in some codec-dependent way.\n\n For example, in 10-bit H.264 the quantisation parameter varies between\n -12 and 51.  A typical qoffset value of -1/10 therefore indicates that\n this region should be encoded with a QP around one-tenth of the full\n range better than the rest of the frame.  So, if most of the frame\n were to be encoded with a QP of around 30, this region would get a QP\n of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).\n An extreme value of -1 would indicate that this region should be\n encoded with the best possible quality regardless of the treatment of\n the rest of the frame - that is, should be encoded at a QP of -12."]
    pub qoffset: AVRational,
}
#[doc = " This structure describes decoded (raw) audio or video data.\n\n AVFrame must be allocated using av_frame_alloc(). Note that this only\n allocates the AVFrame itself, the buffers for the data must be managed\n through other means (see below).\n AVFrame must be freed with av_frame_free().\n\n AVFrame is typically allocated once and then reused multiple times to hold\n different data (e.g. a single AVFrame to hold frames received from a\n decoder). In such a case, av_frame_unref() will free any references held by\n the frame and reset it to its original clean state before it\n is reused again.\n\n The data described by an AVFrame is usually reference counted through the\n AVBuffer API. The underlying buffer references are stored in AVFrame.buf /\n AVFrame.extended_buf. An AVFrame is considered to be reference counted if at\n least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,\n every single data plane must be contained in one of the buffers in\n AVFrame.buf or AVFrame.extended_buf.\n There may be a single buffer for all the data, or one separate buffer for\n each plane, or anything in between.\n\n sizeof(AVFrame) is not a part of the public ABI, so new fields may be added\n to the end with a minor bump.\n\n Fields can be accessed through AVOptions, the name string used, matches the\n C structure field name for fields accessible through AVOptions. The AVClass\n for AVFrame can be obtained from avcodec_get_frame_class()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFrame {
    #[doc = " pointer to the picture/channel planes.\n This might be different from the first allocated byte. For video,\n it could even point to the end of the image data.\n\n All pointers in data and extended_data must point into one of the\n AVBufferRef in buf or extended_buf.\n\n Some decoders access areas outside 0,0 - width,height, please\n see avcodec_align_dimensions2(). Some filters and swscale can read\n up to 16 bytes beyond the planes, if these filters are to be used,\n then 16 extra bytes must be allocated.\n\n NOTE: Pointers not needed by the format MUST be set to NULL.\n\n @attention In case of video, the data[] pointers can point to the\n end of image data in order to reverse line order, when used in\n combination with negative values in the linesize[] array."]
    pub data: [*mut u8; 8usize],
    #[doc = " For video, a positive or negative value, which is typically indicating\n the size in bytes of each picture line, but it can also be:\n - the negative byte size of lines for vertical flipping\n   (with data[n] pointing to the end of the data\n - a positive or negative multiple of the byte size as for accessing\n   even and odd fields of a frame (possibly flipped)\n\n For audio, only linesize[0] may be set. For planar audio, each channel\n plane must be the same size.\n\n For video the linesizes should be multiples of the CPUs alignment\n preference, this is 16 or 32 for modern desktop CPUs.\n Some code requires such alignment other code can be slower without\n correct alignment, for yet other it makes no difference.\n\n @note The linesize may be larger than the size of usable data -- there\n may be extra padding present for performance reasons.\n\n @attention In case of video, line size values can be negative to achieve\n a vertically inverted iteration over image lines."]
    pub linesize: [::std::os::raw::c_int; 8usize],
    #[doc = " pointers to the data planes/channels.\n\n For video, this should simply point to data[].\n\n For planar audio, each channel has a separate data pointer, and\n linesize[0] contains the size of each channel buffer.\n For packed audio, there is just one data pointer, and linesize[0]\n contains the total size of the buffer for all channels.\n\n Note: Both data and extended_data should always be set in a valid frame,\n but for planar audio with more channels that can fit in data,\n extended_data must be used in order to access all channels."]
    pub extended_data: *mut *mut u8,
    #[doc = " @name Video dimensions\n Video frames only. The coded dimensions (in pixels) of the video frame,\n i.e. the size of the rectangle that contains some well-defined values.\n\n @note The part of the frame intended for display/presentation is further\n restricted by the @ref cropping \"Cropping rectangle\".\n @{"]
    pub width: ::std::os::raw::c_int,
    #[doc = " @name Video dimensions\n Video frames only. The coded dimensions (in pixels) of the video frame,\n i.e. the size of the rectangle that contains some well-defined values.\n\n @note The part of the frame intended for display/presentation is further\n restricted by the @ref cropping \"Cropping rectangle\".\n @{"]
    pub height: ::std::os::raw::c_int,
    #[doc = " number of audio samples (per channel) described by this frame"]
    pub nb_samples: ::std::os::raw::c_int,
    #[doc = " format of the frame, -1 if unknown or unset\n Values correspond to enum AVPixelFormat for video frames,\n enum AVSampleFormat for audio)"]
    pub format: ::std::os::raw::c_int,
    #[doc = " 1 -> keyframe, 0-> not"]
    pub key_frame: ::std::os::raw::c_int,
    #[doc = " Picture type of the frame."]
    pub pict_type: AVPictureType,
    #[doc = " Sample aspect ratio for the video frame, 0/1 if unknown/unspecified."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Presentation timestamp in time_base units (time when frame should be shown to user)."]
    pub pts: i64,
    #[doc = " DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)\n This is also the Presentation time of this AVFrame calculated from\n only AVPacket.dts values without pts values."]
    pub pkt_dts: i64,
    #[doc = " Time base for the timestamps in this frame.\n In the future, this field may be set on frames output by decoders or\n filters, but its value will be by default ignored on input to encoders\n or filters."]
    pub time_base: AVRational,
    #[doc = " picture number in bitstream order"]
    pub coded_picture_number: ::std::os::raw::c_int,
    #[doc = " picture number in display order"]
    pub display_picture_number: ::std::os::raw::c_int,
    #[doc = " quality (between 1 (good) and FF_LAMBDA_MAX (bad))"]
    pub quality: ::std::os::raw::c_int,
    #[doc = " for some private data of the user"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " When decoding, this signals how much the picture must be delayed.\n extra_delay = repeat_pict / (2*fps)"]
    pub repeat_pict: ::std::os::raw::c_int,
    #[doc = " The content of the picture is interlaced."]
    pub interlaced_frame: ::std::os::raw::c_int,
    #[doc = " If the content is interlaced, is top field displayed first."]
    pub top_field_first: ::std::os::raw::c_int,
    #[doc = " Tell user application that palette has changed from previous frame."]
    pub palette_has_changed: ::std::os::raw::c_int,
    #[doc = " reordered opaque 64 bits (generally an integer or a double precision float\n PTS but can be anything).\n The user sets AVCodecContext.reordered_opaque to represent the input at\n that time,\n the decoder reorders values as needed and sets AVFrame.reordered_opaque\n to exactly one of the values provided by the user through AVCodecContext.reordered_opaque"]
    pub reordered_opaque: i64,
    #[doc = " Sample rate of the audio data."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Channel layout of the audio data.\n @deprecated use ch_layout instead"]
    pub channel_layout: u64,
    #[doc = " AVBuffer references backing the data for this frame. All the pointers in\n data and extended_data must point inside one of the buffers in buf or\n extended_buf. This array must be filled contiguously -- if buf[i] is\n non-NULL then buf[j] must also be non-NULL for all j < i.\n\n There may be at most one AVBuffer per data plane, so for video this array\n always contains all the references. For planar audio with more than\n AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in\n this array. Then the extra AVBufferRef pointers are stored in the\n extended_buf array."]
    pub buf: [*mut AVBufferRef; 8usize],
    #[doc = " For planar audio which requires more than AV_NUM_DATA_POINTERS\n AVBufferRef pointers, this array will hold all the references which\n cannot fit into AVFrame.buf.\n\n Note that this is different from AVFrame.extended_data, which always\n contains all the pointers. This array only contains the extra pointers,\n which cannot fit into AVFrame.buf.\n\n This array is always allocated using av_malloc() by whoever constructs\n the frame. It is freed in av_frame_unref()."]
    pub extended_buf: *mut *mut AVBufferRef,
    #[doc = " Number of elements in extended_buf."]
    pub nb_extended_buf: ::std::os::raw::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    #[doc = " Frame flags, a combination of @ref lavu_frame_flags"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " MPEG vs JPEG YUV range.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " frame timestamp estimated using various heuristics, in stream time base\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub best_effort_timestamp: i64,
    #[doc = " reordered pos from the last AVPacket that has been input into the decoder\n - encoding: unused\n - decoding: Read by user."]
    pub pkt_pos: i64,
    #[doc = " duration of the corresponding packet, expressed in\n AVStream->time_base units, 0 if unknown.\n - encoding: unused\n - decoding: Read by user.\n\n @deprecated use duration instead"]
    pub pkt_duration: i64,
    #[doc = " metadata.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub metadata: *mut AVDictionary,
    #[doc = " decode error flags of the frame, set to a combination of\n FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there\n were errors during the decoding.\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub decode_error_flags: ::std::os::raw::c_int,
    #[doc = " number of audio channels, only used for audio.\n - encoding: unused\n - decoding: Read by user.\n @deprecated use ch_layout instead"]
    pub channels: ::std::os::raw::c_int,
    #[doc = " size of the corresponding packet containing the compressed\n frame.\n It is set to a negative value if unknown.\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub pkt_size: ::std::os::raw::c_int,
    #[doc = " For hwaccel-format frames, this should be a reference to the\n AVHWFramesContext describing the frame."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the\n contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when\n the frame is unreferenced. av_frame_copy_props() calls create a new\n reference with av_buffer_ref() for the target frame's opaque_ref field.\n\n This is unrelated to the opaque field, although it serves a similar\n purpose."]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " @anchor cropping\n @name Cropping\n Video frames only. The number of pixels to discard from the the\n top/bottom/left/right border of the frame to obtain the sub-rectangle of\n the frame intended for presentation.\n @{"]
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    #[doc = " AVBufferRef for internal use by a single libav* library.\n Must not be used to transfer data between libraries.\n Has to be NULL when ownership of the frame leaves the respective library.\n\n Code outside the FFmpeg libs should never check or change the contents of the buffer ref.\n\n FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.\n av_frame_copy_props() calls create a new reference with av_buffer_ref()\n for the target frame's private_ref field."]
    pub private_ref: *mut AVBufferRef,
    #[doc = " Channel layout of the audio data."]
    pub ch_layout: AVChannelLayout,
    #[doc = " Duration of the frame, in the same units as pts. 0 if unknown."]
    pub duration: i64,
}
extern "C" {
    #[doc = " Get the name of a colorspace.\n @return a static string identifying the colorspace; can be NULL.\n @deprecated use av_color_space_name()"]
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocate an AVFrame and set its fields to default values.  The resulting\n struct must be freed using av_frame_free().\n\n @return An AVFrame filled with default values or NULL on failure.\n\n @note this only allocates the AVFrame itself, not the data buffers. Those\n must be allocated through other means, e.g. with av_frame_get_buffer() or\n manually."]
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    #[doc = " Free the frame and any dynamically allocated objects in it,\n e.g. extended_data. If the frame is reference counted, it will be\n unreferenced first.\n\n @param frame frame to be freed. The pointer will be set to NULL."]
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    #[doc = " Set up a new reference to the data described by the source frame.\n\n Copy frame properties from src to dst and create a new reference for each\n AVBufferRef from src.\n\n If src is not reference counted, new buffers are allocated and the data is\n copied.\n\n @warning: dst MUST have been either unreferenced with av_frame_unref(dst),\n           or newly allocated with av_frame_alloc() before calling this\n           function, or undefined behavior will occur.\n\n @return 0 on success, a negative AVERROR on error"]
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new frame that references the same data as src.\n\n This is a shortcut for av_frame_alloc()+av_frame_ref().\n\n @return newly created AVFrame on success, NULL on error."]
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    #[doc = " Unreference all the buffers referenced by frame and reset the frame fields."]
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    #[doc = " Move everything contained in src to dst and reset src.\n\n @warning: dst is not unreferenced, but directly overwritten without reading\n           or deallocating its contents. Call av_frame_unref(dst) manually\n           before calling this function to ensure that no memory is leaked."]
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    #[doc = " Allocate new buffer(s) for audio or video data.\n\n The following fields must be set on frame before calling this function:\n - format (pixel format for video, sample format for audio)\n - width and height for video\n - nb_samples and ch_layout for audio\n\n This function will fill AVFrame.data and AVFrame.buf arrays and, if\n necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.\n For planar formats, one buffer will be allocated for each plane.\n\n @warning: if frame already has been allocated, calling this function will\n           leak memory. In addition, undefined behavior can occur in certain\n           cases.\n\n @param frame frame in which to store the new buffers.\n @param align Required buffer size alignment. If equal to 0, alignment will be\n              chosen automatically for the current CPU. It is highly\n              recommended to pass 0 here unless you know what you are doing.\n\n @return 0 on success, a negative AVERROR on error."]
    pub fn av_frame_get_buffer(
        frame: *mut AVFrame,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the frame data is writable.\n\n @return A positive value if the frame data is writable (which is true if and\n only if each of the underlying buffers has only one reference, namely the one\n stored in this frame). Return 0 otherwise.\n\n If 1 is returned the answer is valid until av_buffer_ref() is called on any\n of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).\n\n @see av_frame_make_writable(), av_buffer_is_writable()"]
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure that the frame data is writable, avoiding data copy if possible.\n\n Do nothing if the frame is writable, allocate new buffers and copy the data\n if it is not. Non-refcounted frames behave as non-writable, i.e. a copy\n is always made.\n\n @return 0 on success, a negative AVERROR on error.\n\n @see av_frame_is_writable(), av_buffer_is_writable(),\n av_buffer_make_writable()"]
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the frame data from src to dst.\n\n This function does not allocate anything, dst must be already initialized and\n allocated with the same parameters as src.\n\n This function only copies the frame data (i.e. the contents of the data /\n extended data arrays), not any other properties.\n\n @return >= 0 on success, a negative AVERROR on error."]
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy only \"metadata\" fields from src to dst.\n\n Metadata for the purpose of this function are those fields that do not affect\n the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample\n aspect ratio (for video), but not width/height or channel layout.\n Side data is also copied."]
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the buffer reference a given data plane is stored in.\n\n @param plane index of the data plane of interest in frame->extended_data.\n\n @return the buffer reference that contains the plane or NULL if the input\n frame is not valid."]
    pub fn av_frame_get_plane_buffer(
        frame: *mut AVFrame,
        plane: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Add a new side data to a frame.\n\n @param frame a frame to which the side data should be added\n @param type type of the added side data\n @param size size of the side data\n\n @return newly added side data on success, NULL on error"]
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: usize,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Add a new side data to a frame from an existing AVBufferRef\n\n @param frame a frame to which the side data should be added\n @param type  the type of the added side data\n @param buf   an AVBufferRef to add as side data. The ownership of\n              the reference is transferred to the frame.\n\n @return newly added side data on success, NULL on error. On failure\n         the frame is unchanged and the AVBufferRef remains owned by\n         the caller."]
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " @return a pointer to the side data of a given type on success, NULL if there\n is no side data with such type in this frame."]
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Remove and free all side data instances of the given type."]
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_3 = _bindgen_ty_3::AV_FRAME_CROP_UNALIGNED;
#[repr(i32)]
#[doc = " Flags for frame cropping."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    #[doc = " Apply the maximum possible cropping, even if it requires setting the\n AVFrame.data[] entries to unaligned pointers. Passing unaligned data\n to FFmpeg API is generally not allowed, and causes undefined behavior\n (such as crashes). You can pass unaligned data only to FFmpeg APIs that\n are explicitly documented to accept it. Use this flag only if you\n absolutely know what you are doing."]
    AV_FRAME_CROP_UNALIGNED = 1,
}
extern "C" {
    #[doc = " Crop the given video AVFrame according to its crop_left/crop_top/crop_right/\n crop_bottom fields. If cropping is successful, the function will adjust the\n data pointers and the width/height fields, and set the crop fields to 0.\n\n In all cases, the cropping boundaries will be rounded to the inherent\n alignment of the pixel format. In some cases, such as for opaque hwaccel\n formats, the left/top cropping is ignored. The crop fields are set to 0 even\n if the cropping was rounded or ignored.\n\n @param frame the frame which should be cropped\n @param flags Some combination of AV_FRAME_CROP_* flags, or 0.\n\n @return >= 0 on success, a negative AVERROR on error. If the cropping fields\n were invalid, AVERROR(ERANGE) is returned, and nothing is changed."]
    pub fn av_frame_apply_cropping(
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a string identifying the side data type"]
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHWDeviceType {
    AV_HWDEVICE_TYPE_NONE = 0,
    AV_HWDEVICE_TYPE_VDPAU = 1,
    AV_HWDEVICE_TYPE_CUDA = 2,
    AV_HWDEVICE_TYPE_VAAPI = 3,
    AV_HWDEVICE_TYPE_DXVA2 = 4,
    AV_HWDEVICE_TYPE_QSV = 5,
    AV_HWDEVICE_TYPE_VIDEOTOOLBOX = 6,
    AV_HWDEVICE_TYPE_D3D11VA = 7,
    AV_HWDEVICE_TYPE_DRM = 8,
    AV_HWDEVICE_TYPE_OPENCL = 9,
    AV_HWDEVICE_TYPE_MEDIACODEC = 10,
    AV_HWDEVICE_TYPE_VULKAN = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceInternal {
    _unused: [u8; 0],
}
#[doc = " This struct aggregates all the (hardware/vendor-specific) \"high-level\" state,\n i.e. state that is not tied to a concrete processing configuration.\n E.g., in an API that supports hardware-accelerated encoding and decoding,\n this struct will (if possible) wrap the state that is common to both encoding\n and decoding and from which specific instances of encoders or decoders can be\n derived.\n\n This struct is reference-counted with the AVBuffer mechanism. The\n av_hwdevice_ctx_alloc() constructor yields a reference, whose data field\n points to the actual AVHWDeviceContext. Further objects derived from\n AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with\n specific properties) will hold an internal reference to it. After all the\n references are released, the AVHWDeviceContext itself will be freed,\n optionally invoking a user-specified callback for uninitializing the hardware\n state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWDeviceContext {
    #[doc = " A class for logging. Set by av_hwdevice_ctx_alloc()."]
    pub av_class: *const AVClass,
    #[doc = " Private data used internally by libavutil. Must not be accessed in any\n way by the caller."]
    pub internal: *mut AVHWDeviceInternal,
    #[doc = " This field identifies the underlying API used for hardware access.\n\n This field is set when this struct is allocated and never changed\n afterwards."]
    pub type_: AVHWDeviceType,
    #[doc = " The format-specific data, allocated and freed by libavutil along with\n this context.\n\n Should be cast by the user to the format-specific context defined in the\n corresponding header (hwcontext_*.h) and filled as described in the\n documentation before calling av_hwdevice_ctx_init().\n\n After calling av_hwdevice_ctx_init() this struct should not be modified\n by the caller."]
    pub hwctx: *mut ::std::os::raw::c_void,
    #[doc = " This field may be set by the caller before calling av_hwdevice_ctx_init().\n\n If non-NULL, this callback will be called when the last reference to\n this context is unreferenced, immediately before it is freed.\n\n @note when other objects (e.g an AVHWFramesContext) are derived from this\n       struct, this callback will be invoked after all such child objects\n       are fully uninitialized and their respective destructors invoked."]
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWDeviceContext)>,
    #[doc = " Arbitrary user data, to be used e.g. by the free() callback."]
    pub user_opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesInternal {
    _unused: [u8; 0],
}
#[doc = " This struct describes a set or pool of \"hardware\" frames (i.e. those with\n data not located in normal system memory). All the frames in the pool are\n assumed to be allocated in the same way and interchangeable.\n\n This struct is reference-counted with the AVBuffer mechanism and tied to a\n given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor\n yields a reference, whose data field points to the actual AVHWFramesContext\n struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesContext {
    #[doc = " A class for logging."]
    pub av_class: *const AVClass,
    #[doc = " Private data used internally by libavutil. Must not be accessed in any\n way by the caller."]
    pub internal: *mut AVHWFramesInternal,
    #[doc = " A reference to the parent AVHWDeviceContext. This reference is owned and\n managed by the enclosing AVHWFramesContext, but the caller may derive\n additional references from it."]
    pub device_ref: *mut AVBufferRef,
    #[doc = " The parent AVHWDeviceContext. This is simply a pointer to\n device_ref->data provided for convenience.\n\n Set by libavutil in av_hwframe_ctx_init()."]
    pub device_ctx: *mut AVHWDeviceContext,
    #[doc = " The format-specific data, allocated and freed automatically along with\n this context.\n\n Should be cast by the user to the format-specific context defined in the\n corresponding header (hwframe_*.h) and filled as described in the\n documentation before calling av_hwframe_ctx_init().\n\n After any frames using this context are created, the contents of this\n struct should not be modified by the caller."]
    pub hwctx: *mut ::std::os::raw::c_void,
    #[doc = " This field may be set by the caller before calling av_hwframe_ctx_init().\n\n If non-NULL, this callback will be called when the last reference to\n this context is unreferenced, immediately before it is freed."]
    pub free: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVHWFramesContext)>,
    #[doc = " Arbitrary user data, to be used e.g. by the free() callback."]
    pub user_opaque: *mut ::std::os::raw::c_void,
    #[doc = " A pool from which the frames are allocated by av_hwframe_get_buffer().\n This field may be set by the caller before calling av_hwframe_ctx_init().\n The buffers returned by calling av_buffer_pool_get() on this pool must\n have the properties described in the documentation in the corresponding hw\n type's header (hwcontext_*.h). The pool will be freed strictly before\n this struct's free() callback is invoked.\n\n This field may be NULL, then libavutil will attempt to allocate a pool\n internally. Note that certain device types enforce pools allocated at\n fixed size (frame count), which cannot be extended dynamically. In such a\n case, initial_pool_size must be set appropriately."]
    pub pool: *mut AVBufferPool,
    #[doc = " Initial size of the frame pool. If a device type does not support\n dynamically resizing the pool, then this is also the maximum pool size.\n\n May be set by the caller before calling av_hwframe_ctx_init(). Must be\n set if pool is NULL and the device type does not support dynamic pools."]
    pub initial_pool_size: ::std::os::raw::c_int,
    #[doc = " The pixel format identifying the underlying HW surface type.\n\n Must be a hwaccel format, i.e. the corresponding descriptor must have the\n AV_PIX_FMT_FLAG_HWACCEL flag set.\n\n Must be set by the user before calling av_hwframe_ctx_init()."]
    pub format: AVPixelFormat,
    #[doc = " The pixel format identifying the actual data layout of the hardware\n frames.\n\n Must be set by the caller before calling av_hwframe_ctx_init().\n\n @note when the underlying API does not provide the exact data layout, but\n only the colorspace/bit depth, this field should be set to the fully\n planar version of that format (e.g. for 8-bit 420 YUV it should be\n AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else)."]
    pub sw_format: AVPixelFormat,
    #[doc = " The allocated dimensions of the frames in this pool.\n\n Must be set by the user before calling av_hwframe_ctx_init()."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The allocated dimensions of the frames in this pool.\n\n Must be set by the user before calling av_hwframe_ctx_init()."]
    pub height: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Look up an AVHWDeviceType by name.\n\n @param name String name of the device type (case-insensitive).\n @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if\n         not found."]
    pub fn av_hwdevice_find_type_by_name(name: *const ::std::os::raw::c_char) -> AVHWDeviceType;
}
extern "C" {
    #[doc = " Get the string name of an AVHWDeviceType.\n\n @param type Type from enum AVHWDeviceType.\n @return Pointer to a static string containing the name, or NULL if the type\n         is not valid."]
    pub fn av_hwdevice_get_type_name(type_: AVHWDeviceType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Iterate over supported device types.\n\n @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type\n             returned by this function in subsequent iterations.\n @return The next usable device type from enum AVHWDeviceType, or\n         AV_HWDEVICE_TYPE_NONE if there are no more."]
    pub fn av_hwdevice_iterate_types(prev: AVHWDeviceType) -> AVHWDeviceType;
}
extern "C" {
    #[doc = " Allocate an AVHWDeviceContext for a given hardware type.\n\n @param type the type of the hardware device to allocate.\n @return a reference to the newly created AVHWDeviceContext on success or NULL\n         on failure."]
    pub fn av_hwdevice_ctx_alloc(type_: AVHWDeviceType) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Finalize the device context before use. This function must be called after\n the context is filled with all the required information and before it is\n used in any way.\n\n @param ref a reference to the AVHWDeviceContext\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_hwdevice_ctx_init(ref_: *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a device of the specified type and create an AVHWDeviceContext for it.\n\n This is a convenience function intended to cover the simple cases. Callers\n who need to fine-tune device creation/management should open the device\n manually and then wrap it in an AVHWDeviceContext using\n av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().\n\n The returned context is already initialized and ready for use, the caller\n should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of\n the created AVHWDeviceContext are set by this function and should not be\n touched by the caller.\n\n @param device_ctx On success, a reference to the newly-created device context\n                   will be written here. The reference is owned by the caller\n                   and must be released with av_buffer_unref() when no longer\n                   needed. On failure, NULL will be written to this pointer.\n @param type The type of the device to create.\n @param device A type-specific string identifying the device to open.\n @param opts A dictionary of additional (type-specific) options to use in\n             opening the device. The dictionary remains owned by the caller.\n @param flags currently unused\n\n @return 0 on success, a negative AVERROR code on failure."]
    pub fn av_hwdevice_ctx_create(
        device_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        device: *const ::std::os::raw::c_char,
        opts: *mut AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new device of the specified type from an existing device.\n\n If the source device is a device of the target type or was originally\n derived from such a device (possibly through one or more intermediate\n devices of other types), then this will return a reference to the\n existing device of the same type as is requested.\n\n Otherwise, it will attempt to derive a new device from the given source\n device.  If direct derivation to the new type is not implemented, it will\n attempt the same derivation from each ancestor of the source device in\n turn looking for an implemented derivation method.\n\n @param dst_ctx On success, a reference to the newly-created\n                AVHWDeviceContext.\n @param type    The type of the new device to create.\n @param src_ctx A reference to an existing AVHWDeviceContext which will be\n                used to create the new device.\n @param flags   Currently unused; should be set to zero.\n @return        Zero on success, a negative AVERROR code on failure."]
    pub fn av_hwdevice_ctx_create_derived(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new device of the specified type from an existing device.\n\n This function performs the same action as av_hwdevice_ctx_create_derived,\n however, it is able to set options for the new device to be derived.\n\n @param dst_ctx On success, a reference to the newly-created\n                AVHWDeviceContext.\n @param type    The type of the new device to create.\n @param src_ctx A reference to an existing AVHWDeviceContext which will be\n                used to create the new device.\n @param options Options for the new device to create, same format as in\n                av_hwdevice_ctx_create.\n @param flags   Currently unused; should be set to zero.\n @return        Zero on success, a negative AVERROR code on failure."]
    pub fn av_hwdevice_ctx_create_derived_opts(
        dst_ctx: *mut *mut AVBufferRef,
        type_: AVHWDeviceType,
        src_ctx: *mut AVBufferRef,
        options: *mut AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an AVHWFramesContext tied to a given device context.\n\n @param device_ctx a reference to a AVHWDeviceContext. This function will make\n                   a new reference for internal use, the one passed to the\n                   function remains owned by the caller.\n @return a reference to the newly created AVHWFramesContext on success or NULL\n         on failure."]
    pub fn av_hwframe_ctx_alloc(device_ctx: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Finalize the context before use. This function must be called after the\n context is filled with all the required information and before it is attached\n to any frames.\n\n @param ref a reference to the AVHWFramesContext\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_hwframe_ctx_init(ref_: *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new frame attached to the given AVHWFramesContext.\n\n @param hwframe_ctx a reference to an AVHWFramesContext\n @param frame an empty (freshly allocated or unreffed) frame to be filled with\n              newly allocated buffers.\n @param flags currently unused, should be set to zero\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn av_hwframe_get_buffer(
        hwframe_ctx: *mut AVBufferRef,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy data to or from a hw surface. At least one of dst/src must have an\n AVHWFramesContext attached.\n\n If src has an AVHWFramesContext attached, then the format of dst (if set)\n must use one of the formats returned by av_hwframe_transfer_get_formats(src,\n AV_HWFRAME_TRANSFER_DIRECTION_FROM).\n If dst has an AVHWFramesContext attached, then the format of src must use one\n of the formats returned by av_hwframe_transfer_get_formats(dst,\n AV_HWFRAME_TRANSFER_DIRECTION_TO)\n\n dst may be \"clean\" (i.e. with data/buf pointers unset), in which case the\n data buffers will be allocated by this function using av_frame_get_buffer().\n If dst->format is set, then this format will be used, otherwise (when\n dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.\n\n The two frames must have matching allocated dimensions (i.e. equal to\n AVHWFramesContext.width/height), since not all device types support\n transferring a sub-rectangle of the whole surface. The display dimensions\n (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but\n also have to be equal for both frames. When the display dimensions are\n smaller than the allocated dimensions, the content of the padding in the\n destination frame is unspecified.\n\n @param dst the destination frame. dst is not touched on failure.\n @param src the source frame.\n @param flags currently unused, should be set to zero\n @return 0 on success, a negative AVERROR error code on failure."]
    pub fn av_hwframe_transfer_data(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVHWFrameTransferDirection {
    #[doc = " Transfer the data from the queried hw frame."]
    AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0,
    #[doc = " Transfer the data to the queried hw frame."]
    AV_HWFRAME_TRANSFER_DIRECTION_TO = 1,
}
extern "C" {
    #[doc = " Get a list of possible source or target formats usable in\n av_hwframe_transfer_data().\n\n @param hwframe_ctx the frame context to obtain the information for\n @param dir the direction of the transfer\n @param formats the pointer to the output format list will be written here.\n                The list is terminated with AV_PIX_FMT_NONE and must be freed\n                by the caller when no longer needed using av_free().\n                If this function returns successfully, the format list will\n                have at least one item (not counting the terminator).\n                On failure, the contents of this pointer are unspecified.\n @param flags currently unused, should be set to zero\n @return 0 on success, a negative AVERROR code on failure."]
    pub fn av_hwframe_transfer_get_formats(
        hwframe_ctx: *mut AVBufferRef,
        dir: AVHWFrameTransferDirection,
        formats: *mut *mut AVPixelFormat,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This struct describes the constraints on hardware frames attached to\n a given device with a hardware-specific configuration.  This is returned\n by av_hwdevice_get_hwframe_constraints() and must be freed by\n av_hwframe_constraints_free() after use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWFramesConstraints {
    #[doc = " A list of possible values for format in the hw_frames_ctx,\n terminated by AV_PIX_FMT_NONE.  This member will always be filled."]
    pub valid_hw_formats: *mut AVPixelFormat,
    #[doc = " A list of possible values for sw_format in the hw_frames_ctx,\n terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is\n not known."]
    pub valid_sw_formats: *mut AVPixelFormat,
    #[doc = " The minimum size of frames in this hw_frames_ctx.\n (Zero if not known.)"]
    pub min_width: ::std::os::raw::c_int,
    pub min_height: ::std::os::raw::c_int,
    #[doc = " The maximum size of frames in this hw_frames_ctx.\n (INT_MAX if not known / no limit.)"]
    pub max_width: ::std::os::raw::c_int,
    pub max_height: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Allocate a HW-specific configuration structure for a given HW device.\n After use, the user must free all members as required by the specific\n hardware structure being used, then free the structure itself with\n av_free().\n\n @param device_ctx a reference to the associated AVHWDeviceContext.\n @return The newly created HW-specific configuration structure on\n         success or NULL on failure."]
    pub fn av_hwdevice_hwconfig_alloc(device_ctx: *mut AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the constraints on HW frames given a device and the HW-specific\n configuration to be used with that device.  If no HW-specific\n configuration is provided, returns the maximum possible capabilities\n of the device.\n\n @param ref a reference to the associated AVHWDeviceContext.\n @param hwconfig a filled HW-specific configuration structure, or NULL\n        to return the maximum possible capabilities of the device.\n @return AVHWFramesConstraints structure describing the constraints\n         on the device, or NULL if not available."]
    pub fn av_hwdevice_get_hwframe_constraints(
        ref_: *mut AVBufferRef,
        hwconfig: *const ::std::os::raw::c_void,
    ) -> *mut AVHWFramesConstraints;
}
extern "C" {
    #[doc = " Free an AVHWFrameConstraints structure.\n\n @param constraints The (filled or unfilled) AVHWFrameConstraints structure."]
    pub fn av_hwframe_constraints_free(constraints: *mut *mut AVHWFramesConstraints);
}
pub const AV_HWFRAME_MAP_READ: _bindgen_ty_4 = _bindgen_ty_4::AV_HWFRAME_MAP_READ;
pub const AV_HWFRAME_MAP_WRITE: _bindgen_ty_4 = _bindgen_ty_4::AV_HWFRAME_MAP_WRITE;
pub const AV_HWFRAME_MAP_OVERWRITE: _bindgen_ty_4 = _bindgen_ty_4::AV_HWFRAME_MAP_OVERWRITE;
pub const AV_HWFRAME_MAP_DIRECT: _bindgen_ty_4 = _bindgen_ty_4::AV_HWFRAME_MAP_DIRECT;
#[repr(i32)]
#[doc = " Flags to apply to frame mappings."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    #[doc = " The mapping must be readable."]
    AV_HWFRAME_MAP_READ = 1,
    #[doc = " The mapping must be writeable."]
    AV_HWFRAME_MAP_WRITE = 2,
    #[doc = " The mapped frame will be overwritten completely in subsequent\n operations, so the current frame data need not be loaded.  Any values\n which are not overwritten are unspecified."]
    AV_HWFRAME_MAP_OVERWRITE = 4,
    #[doc = " The mapping must be direct.  That is, there must not be any copying in\n the map or unmap steps.  Note that performance of direct mappings may\n be much lower than normal memory."]
    AV_HWFRAME_MAP_DIRECT = 8,
}
extern "C" {
    #[doc = " Map a hardware frame.\n\n This has a number of different possible effects, depending on the format\n and origin of the src and dst frames.  On input, src should be a usable\n frame with valid buffers and dst should be blank (typically as just created\n by av_frame_alloc()).  src should have an associated hwframe context, and\n dst may optionally have a format and associated hwframe context.\n\n If src was created by mapping a frame from the hwframe context of dst,\n then this function undoes the mapping - dst is replaced by a reference to\n the frame that src was originally mapped from.\n\n If both src and dst have an associated hwframe context, then this function\n attempts to map the src frame from its hardware context to that of dst and\n then fill dst with appropriate data to be usable there.  This will only be\n possible if the hwframe contexts and associated devices are compatible -\n given compatible devices, av_hwframe_ctx_create_derived() can be used to\n create a hwframe context for dst in which mapping should be possible.\n\n If src has a hwframe context but dst does not, then the src frame is\n mapped to normal memory and should thereafter be usable as a normal frame.\n If the format is set on dst, then the mapping will attempt to create dst\n with that format and fail if it is not possible.  If format is unset (is\n AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate\n format to use is (probably the sw_format of the src hwframe context).\n\n A return value of AVERROR(ENOSYS) indicates that the mapping is not\n possible with the given arguments and hwframe setup, while other return\n values indicate that it failed somehow.\n\n On failure, the destination frame will be left blank, except for the\n hw_frames_ctx/format fields thay may have been set by the caller - those will\n be preserved as they were.\n\n @param dst Destination frame, to contain the mapping.\n @param src Source frame, to be mapped.\n @param flags Some combination of AV_HWFRAME_MAP_* flags.\n @return Zero on success, negative AVERROR code on failure."]
    pub fn av_hwframe_map(
        dst: *mut AVFrame,
        src: *const AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and initialise an AVHWFramesContext as a mapping of another existing\n AVHWFramesContext on a different device.\n\n av_hwframe_ctx_init() should not be called after this.\n\n @param derived_frame_ctx  On success, a reference to the newly created\n                           AVHWFramesContext.\n @param derived_device_ctx A reference to the device to create the new\n                           AVHWFramesContext on.\n @param source_frame_ctx   A reference to an existing AVHWFramesContext\n                           which will be mapped to the derived context.\n @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the\n               mapping parameters to apply to frames which are allocated\n               in the derived device.\n @return       Zero on success, negative AVERROR code on failure."]
    pub fn av_hwframe_ctx_create_derived(
        derived_frame_ctx: *mut *mut AVBufferRef,
        format: AVPixelFormat,
        derived_device_ctx: *mut AVBufferRef,
        source_frame_ctx: *mut AVBufferRef,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
impl AVCodecID {
    pub const AV_CODEC_ID_PCM_S16LE: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_AUDIO;
}
impl AVCodecID {
    pub const AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_SUBTITLE;
}
impl AVCodecID {
    pub const AV_CODEC_ID_TTF: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_UNKNOWN;
}
#[repr(i32)]
#[doc = " Identify the syntax and semantics of the bitstream.\n The principle is roughly:\n Two decoders with the same ID can decode the same streams.\n Two encoders with the same ID can encode compatible streams.\n There may be slight deviations from the principle due to implementation\n details.\n\n If you add a codec ID to this list, add it so that\n 1. no value of an existing codec ID changes (that would break ABI),\n 2. it is as close as possible to similar codecs\n\n After adding new codec IDs, do not forget to add an entry to the codec\n descriptor list and bump libavcodec minor version."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVCodecID {
    AV_CODEC_ID_NONE = 0,
    AV_CODEC_ID_MPEG1VIDEO = 1,
    #[doc = "< preferred ID for MPEG-1/2 video decoding"]
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_H261 = 3,
    AV_CODEC_ID_H263 = 4,
    AV_CODEC_ID_RV10 = 5,
    AV_CODEC_ID_RV20 = 6,
    AV_CODEC_ID_MJPEG = 7,
    AV_CODEC_ID_MJPEGB = 8,
    AV_CODEC_ID_LJPEG = 9,
    AV_CODEC_ID_SP5X = 10,
    AV_CODEC_ID_JPEGLS = 11,
    AV_CODEC_ID_MPEG4 = 12,
    AV_CODEC_ID_RAWVIDEO = 13,
    AV_CODEC_ID_MSMPEG4V1 = 14,
    AV_CODEC_ID_MSMPEG4V2 = 15,
    AV_CODEC_ID_MSMPEG4V3 = 16,
    AV_CODEC_ID_WMV1 = 17,
    AV_CODEC_ID_WMV2 = 18,
    AV_CODEC_ID_H263P = 19,
    AV_CODEC_ID_H263I = 20,
    AV_CODEC_ID_FLV1 = 21,
    AV_CODEC_ID_SVQ1 = 22,
    AV_CODEC_ID_SVQ3 = 23,
    AV_CODEC_ID_DVVIDEO = 24,
    AV_CODEC_ID_HUFFYUV = 25,
    AV_CODEC_ID_CYUV = 26,
    AV_CODEC_ID_H264 = 27,
    AV_CODEC_ID_INDEO3 = 28,
    AV_CODEC_ID_VP3 = 29,
    AV_CODEC_ID_THEORA = 30,
    AV_CODEC_ID_ASV1 = 31,
    AV_CODEC_ID_ASV2 = 32,
    AV_CODEC_ID_FFV1 = 33,
    AV_CODEC_ID_4XM = 34,
    AV_CODEC_ID_VCR1 = 35,
    AV_CODEC_ID_CLJR = 36,
    AV_CODEC_ID_MDEC = 37,
    AV_CODEC_ID_ROQ = 38,
    AV_CODEC_ID_INTERPLAY_VIDEO = 39,
    AV_CODEC_ID_XAN_WC3 = 40,
    AV_CODEC_ID_XAN_WC4 = 41,
    AV_CODEC_ID_RPZA = 42,
    AV_CODEC_ID_CINEPAK = 43,
    AV_CODEC_ID_WS_VQA = 44,
    AV_CODEC_ID_MSRLE = 45,
    AV_CODEC_ID_MSVIDEO1 = 46,
    AV_CODEC_ID_IDCIN = 47,
    AV_CODEC_ID_8BPS = 48,
    AV_CODEC_ID_SMC = 49,
    AV_CODEC_ID_FLIC = 50,
    AV_CODEC_ID_TRUEMOTION1 = 51,
    AV_CODEC_ID_VMDVIDEO = 52,
    AV_CODEC_ID_MSZH = 53,
    AV_CODEC_ID_ZLIB = 54,
    AV_CODEC_ID_QTRLE = 55,
    AV_CODEC_ID_TSCC = 56,
    AV_CODEC_ID_ULTI = 57,
    AV_CODEC_ID_QDRAW = 58,
    AV_CODEC_ID_VIXL = 59,
    AV_CODEC_ID_QPEG = 60,
    AV_CODEC_ID_PNG = 61,
    AV_CODEC_ID_PPM = 62,
    AV_CODEC_ID_PBM = 63,
    AV_CODEC_ID_PGM = 64,
    AV_CODEC_ID_PGMYUV = 65,
    AV_CODEC_ID_PAM = 66,
    AV_CODEC_ID_FFVHUFF = 67,
    AV_CODEC_ID_RV30 = 68,
    AV_CODEC_ID_RV40 = 69,
    AV_CODEC_ID_VC1 = 70,
    AV_CODEC_ID_WMV3 = 71,
    AV_CODEC_ID_LOCO = 72,
    AV_CODEC_ID_WNV1 = 73,
    AV_CODEC_ID_AASC = 74,
    AV_CODEC_ID_INDEO2 = 75,
    AV_CODEC_ID_FRAPS = 76,
    AV_CODEC_ID_TRUEMOTION2 = 77,
    AV_CODEC_ID_BMP = 78,
    AV_CODEC_ID_CSCD = 79,
    AV_CODEC_ID_MMVIDEO = 80,
    AV_CODEC_ID_ZMBV = 81,
    AV_CODEC_ID_AVS = 82,
    AV_CODEC_ID_SMACKVIDEO = 83,
    AV_CODEC_ID_NUV = 84,
    AV_CODEC_ID_KMVC = 85,
    AV_CODEC_ID_FLASHSV = 86,
    AV_CODEC_ID_CAVS = 87,
    AV_CODEC_ID_JPEG2000 = 88,
    AV_CODEC_ID_VMNC = 89,
    AV_CODEC_ID_VP5 = 90,
    AV_CODEC_ID_VP6 = 91,
    AV_CODEC_ID_VP6F = 92,
    AV_CODEC_ID_TARGA = 93,
    AV_CODEC_ID_DSICINVIDEO = 94,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 95,
    AV_CODEC_ID_TIFF = 96,
    AV_CODEC_ID_GIF = 97,
    AV_CODEC_ID_DXA = 98,
    AV_CODEC_ID_DNXHD = 99,
    AV_CODEC_ID_THP = 100,
    AV_CODEC_ID_SGI = 101,
    AV_CODEC_ID_C93 = 102,
    AV_CODEC_ID_BETHSOFTVID = 103,
    AV_CODEC_ID_PTX = 104,
    AV_CODEC_ID_TXD = 105,
    AV_CODEC_ID_VP6A = 106,
    AV_CODEC_ID_AMV = 107,
    AV_CODEC_ID_VB = 108,
    AV_CODEC_ID_PCX = 109,
    AV_CODEC_ID_SUNRAST = 110,
    AV_CODEC_ID_INDEO4 = 111,
    AV_CODEC_ID_INDEO5 = 112,
    AV_CODEC_ID_MIMIC = 113,
    AV_CODEC_ID_RL2 = 114,
    AV_CODEC_ID_ESCAPE124 = 115,
    AV_CODEC_ID_DIRAC = 116,
    AV_CODEC_ID_BFI = 117,
    AV_CODEC_ID_CMV = 118,
    AV_CODEC_ID_MOTIONPIXELS = 119,
    AV_CODEC_ID_TGV = 120,
    AV_CODEC_ID_TGQ = 121,
    AV_CODEC_ID_TQI = 122,
    AV_CODEC_ID_AURA = 123,
    AV_CODEC_ID_AURA2 = 124,
    AV_CODEC_ID_V210X = 125,
    AV_CODEC_ID_TMV = 126,
    AV_CODEC_ID_V210 = 127,
    AV_CODEC_ID_DPX = 128,
    AV_CODEC_ID_MAD = 129,
    AV_CODEC_ID_FRWU = 130,
    AV_CODEC_ID_FLASHSV2 = 131,
    AV_CODEC_ID_CDGRAPHICS = 132,
    AV_CODEC_ID_R210 = 133,
    AV_CODEC_ID_ANM = 134,
    AV_CODEC_ID_BINKVIDEO = 135,
    AV_CODEC_ID_IFF_ILBM = 136,
    AV_CODEC_ID_KGV1 = 137,
    AV_CODEC_ID_YOP = 138,
    AV_CODEC_ID_VP8 = 139,
    AV_CODEC_ID_PICTOR = 140,
    AV_CODEC_ID_ANSI = 141,
    AV_CODEC_ID_A64_MULTI = 142,
    AV_CODEC_ID_A64_MULTI5 = 143,
    AV_CODEC_ID_R10K = 144,
    AV_CODEC_ID_MXPEG = 145,
    AV_CODEC_ID_LAGARITH = 146,
    AV_CODEC_ID_PRORES = 147,
    AV_CODEC_ID_JV = 148,
    AV_CODEC_ID_DFA = 149,
    AV_CODEC_ID_WMV3IMAGE = 150,
    AV_CODEC_ID_VC1IMAGE = 151,
    AV_CODEC_ID_UTVIDEO = 152,
    AV_CODEC_ID_BMV_VIDEO = 153,
    AV_CODEC_ID_VBLE = 154,
    AV_CODEC_ID_DXTORY = 155,
    AV_CODEC_ID_V410 = 156,
    AV_CODEC_ID_XWD = 157,
    AV_CODEC_ID_CDXL = 158,
    AV_CODEC_ID_XBM = 159,
    AV_CODEC_ID_ZEROCODEC = 160,
    AV_CODEC_ID_MSS1 = 161,
    AV_CODEC_ID_MSA1 = 162,
    AV_CODEC_ID_TSCC2 = 163,
    AV_CODEC_ID_MTS2 = 164,
    AV_CODEC_ID_CLLC = 165,
    AV_CODEC_ID_MSS2 = 166,
    AV_CODEC_ID_VP9 = 167,
    AV_CODEC_ID_AIC = 168,
    AV_CODEC_ID_ESCAPE130 = 169,
    AV_CODEC_ID_G2M = 170,
    AV_CODEC_ID_WEBP = 171,
    AV_CODEC_ID_HNM4_VIDEO = 172,
    AV_CODEC_ID_HEVC = 173,
    AV_CODEC_ID_FIC = 174,
    AV_CODEC_ID_ALIAS_PIX = 175,
    AV_CODEC_ID_BRENDER_PIX = 176,
    AV_CODEC_ID_PAF_VIDEO = 177,
    AV_CODEC_ID_EXR = 178,
    AV_CODEC_ID_VP7 = 179,
    AV_CODEC_ID_SANM = 180,
    AV_CODEC_ID_SGIRLE = 181,
    AV_CODEC_ID_MVC1 = 182,
    AV_CODEC_ID_MVC2 = 183,
    AV_CODEC_ID_HQX = 184,
    AV_CODEC_ID_TDSC = 185,
    AV_CODEC_ID_HQ_HQA = 186,
    AV_CODEC_ID_HAP = 187,
    AV_CODEC_ID_DDS = 188,
    AV_CODEC_ID_DXV = 189,
    AV_CODEC_ID_SCREENPRESSO = 190,
    AV_CODEC_ID_RSCC = 191,
    AV_CODEC_ID_AVS2 = 192,
    AV_CODEC_ID_PGX = 193,
    AV_CODEC_ID_AVS3 = 194,
    AV_CODEC_ID_MSP2 = 195,
    AV_CODEC_ID_VVC = 196,
    AV_CODEC_ID_Y41P = 197,
    AV_CODEC_ID_AVRP = 198,
    AV_CODEC_ID_012V = 199,
    AV_CODEC_ID_AVUI = 200,
    AV_CODEC_ID_AYUV = 201,
    AV_CODEC_ID_TARGA_Y216 = 202,
    AV_CODEC_ID_V308 = 203,
    AV_CODEC_ID_V408 = 204,
    AV_CODEC_ID_YUV4 = 205,
    AV_CODEC_ID_AVRN = 206,
    AV_CODEC_ID_CPIA = 207,
    AV_CODEC_ID_XFACE = 208,
    AV_CODEC_ID_SNOW = 209,
    AV_CODEC_ID_SMVJPEG = 210,
    AV_CODEC_ID_APNG = 211,
    AV_CODEC_ID_DAALA = 212,
    AV_CODEC_ID_CFHD = 213,
    AV_CODEC_ID_TRUEMOTION2RT = 214,
    AV_CODEC_ID_M101 = 215,
    AV_CODEC_ID_MAGICYUV = 216,
    AV_CODEC_ID_SHEERVIDEO = 217,
    AV_CODEC_ID_YLC = 218,
    AV_CODEC_ID_PSD = 219,
    AV_CODEC_ID_PIXLET = 220,
    AV_CODEC_ID_SPEEDHQ = 221,
    AV_CODEC_ID_FMVC = 222,
    AV_CODEC_ID_SCPR = 223,
    AV_CODEC_ID_CLEARVIDEO = 224,
    AV_CODEC_ID_XPM = 225,
    AV_CODEC_ID_AV1 = 226,
    AV_CODEC_ID_BITPACKED = 227,
    AV_CODEC_ID_MSCC = 228,
    AV_CODEC_ID_SRGC = 229,
    AV_CODEC_ID_SVG = 230,
    AV_CODEC_ID_GDV = 231,
    AV_CODEC_ID_FITS = 232,
    AV_CODEC_ID_IMM4 = 233,
    AV_CODEC_ID_PROSUMER = 234,
    AV_CODEC_ID_MWSC = 235,
    AV_CODEC_ID_WCMV = 236,
    AV_CODEC_ID_RASC = 237,
    AV_CODEC_ID_HYMT = 238,
    AV_CODEC_ID_ARBC = 239,
    AV_CODEC_ID_AGM = 240,
    AV_CODEC_ID_LSCR = 241,
    AV_CODEC_ID_VP4 = 242,
    AV_CODEC_ID_IMM5 = 243,
    AV_CODEC_ID_MVDV = 244,
    AV_CODEC_ID_MVHA = 245,
    AV_CODEC_ID_CDTOONS = 246,
    AV_CODEC_ID_MV30 = 247,
    AV_CODEC_ID_NOTCHLC = 248,
    AV_CODEC_ID_PFM = 249,
    AV_CODEC_ID_MOBICLIP = 250,
    AV_CODEC_ID_PHOTOCD = 251,
    AV_CODEC_ID_IPU = 252,
    AV_CODEC_ID_ARGO = 253,
    AV_CODEC_ID_CRI = 254,
    AV_CODEC_ID_SIMBIOSIS_IMX = 255,
    AV_CODEC_ID_SGA_VIDEO = 256,
    AV_CODEC_ID_GEM = 257,
    AV_CODEC_ID_VBN = 258,
    AV_CODEC_ID_JPEGXL = 259,
    AV_CODEC_ID_QOI = 260,
    AV_CODEC_ID_PHM = 261,
    AV_CODEC_ID_RADIANCE_HDR = 262,
    AV_CODEC_ID_WBMP = 263,
    #[doc = "< A dummy id pointing at the start of audio codecs"]
    AV_CODEC_ID_FIRST_AUDIO = 65536,
    AV_CODEC_ID_PCM_S16BE = 65537,
    AV_CODEC_ID_PCM_U16LE = 65538,
    AV_CODEC_ID_PCM_U16BE = 65539,
    AV_CODEC_ID_PCM_S8 = 65540,
    AV_CODEC_ID_PCM_U8 = 65541,
    AV_CODEC_ID_PCM_MULAW = 65542,
    AV_CODEC_ID_PCM_ALAW = 65543,
    AV_CODEC_ID_PCM_S32LE = 65544,
    AV_CODEC_ID_PCM_S32BE = 65545,
    AV_CODEC_ID_PCM_U32LE = 65546,
    AV_CODEC_ID_PCM_U32BE = 65547,
    AV_CODEC_ID_PCM_S24LE = 65548,
    AV_CODEC_ID_PCM_S24BE = 65549,
    AV_CODEC_ID_PCM_U24LE = 65550,
    AV_CODEC_ID_PCM_U24BE = 65551,
    AV_CODEC_ID_PCM_S24DAUD = 65552,
    AV_CODEC_ID_PCM_ZORK = 65553,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
    AV_CODEC_ID_PCM_DVD = 65555,
    AV_CODEC_ID_PCM_F32BE = 65556,
    AV_CODEC_ID_PCM_F32LE = 65557,
    AV_CODEC_ID_PCM_F64BE = 65558,
    AV_CODEC_ID_PCM_F64LE = 65559,
    AV_CODEC_ID_PCM_BLURAY = 65560,
    AV_CODEC_ID_PCM_LXF = 65561,
    AV_CODEC_ID_S302M = 65562,
    AV_CODEC_ID_PCM_S8_PLANAR = 65563,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 65564,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 65565,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 65566,
    AV_CODEC_ID_PCM_S64LE = 65567,
    AV_CODEC_ID_PCM_S64BE = 65568,
    AV_CODEC_ID_PCM_F16LE = 65569,
    AV_CODEC_ID_PCM_F24LE = 65570,
    AV_CODEC_ID_PCM_VIDC = 65571,
    AV_CODEC_ID_PCM_SGA = 65572,
    AV_CODEC_ID_ADPCM_IMA_QT = 69632,
    AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
    AV_CODEC_ID_ADPCM_IMA_WS = 69636,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
    AV_CODEC_ID_ADPCM_MS = 69638,
    AV_CODEC_ID_ADPCM_4XM = 69639,
    AV_CODEC_ID_ADPCM_XA = 69640,
    AV_CODEC_ID_ADPCM_ADX = 69641,
    AV_CODEC_ID_ADPCM_EA = 69642,
    AV_CODEC_ID_ADPCM_G726 = 69643,
    AV_CODEC_ID_ADPCM_CT = 69644,
    AV_CODEC_ID_ADPCM_SWF = 69645,
    AV_CODEC_ID_ADPCM_YAMAHA = 69646,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
    AV_CODEC_ID_ADPCM_THP = 69650,
    AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
    AV_CODEC_ID_ADPCM_EA_R1 = 69652,
    AV_CODEC_ID_ADPCM_EA_R3 = 69653,
    AV_CODEC_ID_ADPCM_EA_R2 = 69654,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
    AV_CODEC_ID_ADPCM_EA_XAS = 69657,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
    AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
    AV_CODEC_ID_ADPCM_G722 = 69660,
    AV_CODEC_ID_ADPCM_IMA_APC = 69661,
    AV_CODEC_ID_ADPCM_VIMA = 69662,
    AV_CODEC_ID_ADPCM_AFC = 69663,
    AV_CODEC_ID_ADPCM_IMA_OKI = 69664,
    AV_CODEC_ID_ADPCM_DTK = 69665,
    AV_CODEC_ID_ADPCM_IMA_RAD = 69666,
    AV_CODEC_ID_ADPCM_G726LE = 69667,
    AV_CODEC_ID_ADPCM_THP_LE = 69668,
    AV_CODEC_ID_ADPCM_PSX = 69669,
    AV_CODEC_ID_ADPCM_AICA = 69670,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 69671,
    AV_CODEC_ID_ADPCM_MTAF = 69672,
    AV_CODEC_ID_ADPCM_AGM = 69673,
    AV_CODEC_ID_ADPCM_ARGO = 69674,
    AV_CODEC_ID_ADPCM_IMA_SSI = 69675,
    AV_CODEC_ID_ADPCM_ZORK = 69676,
    AV_CODEC_ID_ADPCM_IMA_APM = 69677,
    AV_CODEC_ID_ADPCM_IMA_ALP = 69678,
    AV_CODEC_ID_ADPCM_IMA_MTF = 69679,
    AV_CODEC_ID_ADPCM_IMA_CUNNING = 69680,
    AV_CODEC_ID_ADPCM_IMA_MOFLEX = 69681,
    AV_CODEC_ID_ADPCM_IMA_ACORN = 69682,
    AV_CODEC_ID_AMR_NB = 73728,
    AV_CODEC_ID_AMR_WB = 73729,
    AV_CODEC_ID_RA_144 = 77824,
    AV_CODEC_ID_RA_288 = 77825,
    AV_CODEC_ID_ROQ_DPCM = 81920,
    AV_CODEC_ID_INTERPLAY_DPCM = 81921,
    AV_CODEC_ID_XAN_DPCM = 81922,
    AV_CODEC_ID_SOL_DPCM = 81923,
    AV_CODEC_ID_SDX2_DPCM = 81924,
    AV_CODEC_ID_GREMLIN_DPCM = 81925,
    AV_CODEC_ID_DERF_DPCM = 81926,
    AV_CODEC_ID_MP2 = 86016,
    #[doc = "< preferred ID for decoding MPEG audio layer 1, 2 or 3"]
    AV_CODEC_ID_MP3 = 86017,
    AV_CODEC_ID_AAC = 86018,
    AV_CODEC_ID_AC3 = 86019,
    AV_CODEC_ID_DTS = 86020,
    AV_CODEC_ID_VORBIS = 86021,
    AV_CODEC_ID_DVAUDIO = 86022,
    AV_CODEC_ID_WMAV1 = 86023,
    AV_CODEC_ID_WMAV2 = 86024,
    AV_CODEC_ID_MACE3 = 86025,
    AV_CODEC_ID_MACE6 = 86026,
    AV_CODEC_ID_VMDAUDIO = 86027,
    AV_CODEC_ID_FLAC = 86028,
    AV_CODEC_ID_MP3ADU = 86029,
    AV_CODEC_ID_MP3ON4 = 86030,
    AV_CODEC_ID_SHORTEN = 86031,
    AV_CODEC_ID_ALAC = 86032,
    AV_CODEC_ID_WESTWOOD_SND1 = 86033,
    #[doc = "< as in Berlin toast format"]
    AV_CODEC_ID_GSM = 86034,
    AV_CODEC_ID_QDM2 = 86035,
    AV_CODEC_ID_COOK = 86036,
    AV_CODEC_ID_TRUESPEECH = 86037,
    AV_CODEC_ID_TTA = 86038,
    AV_CODEC_ID_SMACKAUDIO = 86039,
    AV_CODEC_ID_QCELP = 86040,
    AV_CODEC_ID_WAVPACK = 86041,
    AV_CODEC_ID_DSICINAUDIO = 86042,
    AV_CODEC_ID_IMC = 86043,
    AV_CODEC_ID_MUSEPACK7 = 86044,
    AV_CODEC_ID_MLP = 86045,
    AV_CODEC_ID_GSM_MS = 86046,
    AV_CODEC_ID_ATRAC3 = 86047,
    AV_CODEC_ID_APE = 86048,
    AV_CODEC_ID_NELLYMOSER = 86049,
    AV_CODEC_ID_MUSEPACK8 = 86050,
    AV_CODEC_ID_SPEEX = 86051,
    AV_CODEC_ID_WMAVOICE = 86052,
    AV_CODEC_ID_WMAPRO = 86053,
    AV_CODEC_ID_WMALOSSLESS = 86054,
    AV_CODEC_ID_ATRAC3P = 86055,
    AV_CODEC_ID_EAC3 = 86056,
    AV_CODEC_ID_SIPR = 86057,
    AV_CODEC_ID_MP1 = 86058,
    AV_CODEC_ID_TWINVQ = 86059,
    AV_CODEC_ID_TRUEHD = 86060,
    AV_CODEC_ID_MP4ALS = 86061,
    AV_CODEC_ID_ATRAC1 = 86062,
    AV_CODEC_ID_BINKAUDIO_RDFT = 86063,
    AV_CODEC_ID_BINKAUDIO_DCT = 86064,
    AV_CODEC_ID_AAC_LATM = 86065,
    AV_CODEC_ID_QDMC = 86066,
    AV_CODEC_ID_CELT = 86067,
    AV_CODEC_ID_G723_1 = 86068,
    AV_CODEC_ID_G729 = 86069,
    AV_CODEC_ID_8SVX_EXP = 86070,
    AV_CODEC_ID_8SVX_FIB = 86071,
    AV_CODEC_ID_BMV_AUDIO = 86072,
    AV_CODEC_ID_RALF = 86073,
    AV_CODEC_ID_IAC = 86074,
    AV_CODEC_ID_ILBC = 86075,
    AV_CODEC_ID_OPUS = 86076,
    AV_CODEC_ID_COMFORT_NOISE = 86077,
    AV_CODEC_ID_TAK = 86078,
    AV_CODEC_ID_METASOUND = 86079,
    AV_CODEC_ID_PAF_AUDIO = 86080,
    AV_CODEC_ID_ON2AVC = 86081,
    AV_CODEC_ID_DSS_SP = 86082,
    AV_CODEC_ID_CODEC2 = 86083,
    AV_CODEC_ID_FFWAVESYNTH = 86084,
    AV_CODEC_ID_SONIC = 86085,
    AV_CODEC_ID_SONIC_LS = 86086,
    AV_CODEC_ID_EVRC = 86087,
    AV_CODEC_ID_SMV = 86088,
    AV_CODEC_ID_DSD_LSBF = 86089,
    AV_CODEC_ID_DSD_MSBF = 86090,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 86091,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 86092,
    AV_CODEC_ID_4GV = 86093,
    AV_CODEC_ID_INTERPLAY_ACM = 86094,
    AV_CODEC_ID_XMA1 = 86095,
    AV_CODEC_ID_XMA2 = 86096,
    AV_CODEC_ID_DST = 86097,
    AV_CODEC_ID_ATRAC3AL = 86098,
    AV_CODEC_ID_ATRAC3PAL = 86099,
    AV_CODEC_ID_DOLBY_E = 86100,
    AV_CODEC_ID_APTX = 86101,
    AV_CODEC_ID_APTX_HD = 86102,
    AV_CODEC_ID_SBC = 86103,
    AV_CODEC_ID_ATRAC9 = 86104,
    AV_CODEC_ID_HCOM = 86105,
    AV_CODEC_ID_ACELP_KELVIN = 86106,
    AV_CODEC_ID_MPEGH_3D_AUDIO = 86107,
    AV_CODEC_ID_SIREN = 86108,
    AV_CODEC_ID_HCA = 86109,
    AV_CODEC_ID_FASTAUDIO = 86110,
    AV_CODEC_ID_MSNSIREN = 86111,
    AV_CODEC_ID_DFPWM = 86112,
    AV_CODEC_ID_BONK = 86113,
    AV_CODEC_ID_MISC4 = 86114,
    AV_CODEC_ID_APAC = 86115,
    AV_CODEC_ID_FTR = 86116,
    #[doc = "< A dummy ID pointing at the start of subtitle codecs."]
    AV_CODEC_ID_FIRST_SUBTITLE = 94208,
    AV_CODEC_ID_DVB_SUBTITLE = 94209,
    #[doc = "< raw UTF-8 text"]
    AV_CODEC_ID_TEXT = 94210,
    AV_CODEC_ID_XSUB = 94211,
    AV_CODEC_ID_SSA = 94212,
    AV_CODEC_ID_MOV_TEXT = 94213,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
    AV_CODEC_ID_DVB_TELETEXT = 94215,
    AV_CODEC_ID_SRT = 94216,
    AV_CODEC_ID_MICRODVD = 94217,
    AV_CODEC_ID_EIA_608 = 94218,
    AV_CODEC_ID_JACOSUB = 94219,
    AV_CODEC_ID_SAMI = 94220,
    AV_CODEC_ID_REALTEXT = 94221,
    AV_CODEC_ID_STL = 94222,
    AV_CODEC_ID_SUBVIEWER1 = 94223,
    AV_CODEC_ID_SUBVIEWER = 94224,
    AV_CODEC_ID_SUBRIP = 94225,
    AV_CODEC_ID_WEBVTT = 94226,
    AV_CODEC_ID_MPL2 = 94227,
    AV_CODEC_ID_VPLAYER = 94228,
    AV_CODEC_ID_PJS = 94229,
    AV_CODEC_ID_ASS = 94230,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 94231,
    AV_CODEC_ID_TTML = 94232,
    AV_CODEC_ID_ARIB_CAPTION = 94233,
    #[doc = "< A dummy ID pointing at the start of various fake codecs."]
    AV_CODEC_ID_FIRST_UNKNOWN = 98304,
    #[doc = "< Contain timestamp estimated through PCR of program stream."]
    AV_CODEC_ID_SCTE_35 = 98305,
    AV_CODEC_ID_EPG = 98306,
    AV_CODEC_ID_BINTEXT = 98307,
    AV_CODEC_ID_XBIN = 98308,
    AV_CODEC_ID_IDF = 98309,
    AV_CODEC_ID_OTF = 98310,
    AV_CODEC_ID_SMPTE_KLV = 98311,
    AV_CODEC_ID_DVD_NAV = 98312,
    AV_CODEC_ID_TIMED_ID3 = 98313,
    AV_CODEC_ID_BIN_DATA = 98314,
    #[doc = "< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it"]
    AV_CODEC_ID_PROBE = 102400,
    #[doc = "< _FAKE_ codec to indicate a raw MPEG-2 TS\n stream (only used by libavformat)"]
    AV_CODEC_ID_MPEG2TS = 131072,
    #[doc = "< _FAKE_ codec to indicate a MPEG-4 Systems\n stream (only used by libavformat)"]
    AV_CODEC_ID_MPEG4SYSTEMS = 131073,
    #[doc = "< Dummy codec for streams containing only metadata information."]
    AV_CODEC_ID_FFMETADATA = 135168,
    #[doc = "< Passthrough codec, AVFrames wrapped in AVPacket"]
    AV_CODEC_ID_WRAPPED_AVFRAME = 135169,
}
extern "C" {
    #[doc = " Get the type of the given codec."]
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    #[doc = " Get the name of a codec.\n @return  a static string identifying the codec; never NULL"]
    pub fn avcodec_get_name(id: AVCodecID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return codec bits per sample.\n\n @param[in] codec_id the codec\n @return Number of bits per sample or zero if unknown for the given codec."]
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return codec bits per sample.\n Only return non-zero if the bits per sample is exactly correct, not an\n approximation.\n\n @param[in] codec_id the codec\n @return Number of bits per sample or zero if unknown for the given codec."]
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a name for the specified profile, if available.\n\n @param codec_id the ID of the codec to which the requested profile belongs\n @param profile the profile value for which a name is requested\n @return A name for the profile if found, NULL otherwise.\n\n @note unlike av_get_profile_name(), which searches a list of profiles\n       supported by a specific decoder or encoder implementation, this\n       function searches the list of profiles from the AVCodecDescriptor"]
    pub fn avcodec_profile_name(
        codec_id: AVCodecID,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the PCM codec associated with a sample format.\n @param be  endianness, 0 for little, 1 for big,\n            -1 (or anything else) for native\n @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE"]
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: ::std::os::raw::c_int) -> AVCodecID;
}
#[doc = " AVProfile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProfile {
    pub profile: ::std::os::raw::c_int,
    #[doc = "< short name for the profile"]
    pub name: *const ::std::os::raw::c_char,
}
#[doc = " AVCodec."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodec {
    #[doc = " Name of the codec implementation.\n The name is globally unique among encoders and among decoders (but an\n encoder and a decoder can share the same name).\n This is the primary way to find a codec from the user perspective."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive name for the codec, meant to be more human readable than name.\n You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub long_name: *const ::std::os::raw::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    #[doc = " Codec capabilities.\n see AV_CODEC_CAP_*"]
    pub capabilities: ::std::os::raw::c_int,
    #[doc = "< maximum value for lowres supported by the decoder"]
    pub max_lowres: u8,
    #[doc = "< array of supported framerates, or NULL if any, array is terminated by {0,0}"]
    pub supported_framerates: *const AVRational,
    #[doc = "< array of supported pixel formats, or NULL if unknown, array is terminated by -1"]
    pub pix_fmts: *const AVPixelFormat,
    #[doc = "< array of supported audio samplerates, or NULL if unknown, array is terminated by 0"]
    pub supported_samplerates: *const ::std::os::raw::c_int,
    #[doc = "< array of supported sample formats, or NULL if unknown, array is terminated by -1"]
    pub sample_fmts: *const AVSampleFormat,
    #[doc = "< array of support channel layouts, or NULL if unknown. array is terminated by 0"]
    pub channel_layouts: *const u64,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = "< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}"]
    pub profiles: *const AVProfile,
    #[doc = " Group name of the codec implementation.\n This is a short symbolic name of the wrapper backing this codec. A\n wrapper uses some kind of external implementation for the codec, such\n as an external library, or a codec implementation provided by the OS or\n the hardware.\n If this field is NULL, this is a builtin, libavcodec native codec.\n If non-NULL, this will be the suffix in AVCodec.name in most cases\n (usually AVCodec.name will be of the form \"<codec_name>_<wrapper_name>\")."]
    pub wrapper_name: *const ::std::os::raw::c_char,
    #[doc = " Array of supported channel layouts, terminated with a zeroed layout."]
    pub ch_layouts: *const AVChannelLayout,
}
extern "C" {
    #[doc = " Iterate over all registered codecs.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered codec or NULL when the iteration is\n         finished"]
    pub fn av_codec_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with a matching codec ID.\n\n @param id AVCodecID of the requested decoder\n @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder(id: AVCodecID) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered decoder with the specified name.\n\n @param name name of the requested decoder\n @return A decoder if one was found, NULL otherwise."]
    pub fn avcodec_find_decoder_by_name(name: *const ::std::os::raw::c_char) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with a matching codec ID.\n\n @param id AVCodecID of the requested encoder\n @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder(id: AVCodecID) -> *const AVCodec;
}
extern "C" {
    #[doc = " Find a registered encoder with the specified name.\n\n @param name name of the requested encoder\n @return An encoder if one was found, NULL otherwise."]
    pub fn avcodec_find_encoder_by_name(name: *const ::std::os::raw::c_char) -> *const AVCodec;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is an encoder, zero otherwise"]
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a non-zero number if codec is a decoder, zero otherwise"]
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a name for the specified profile, if available.\n\n @param codec the codec that is searched for the given profile\n @param profile the profile value for which a name is requested\n @return A name for the profile if found, NULL otherwise."]
    pub fn av_get_profile_name(
        codec: *const AVCodec,
        profile: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
pub const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX: _bindgen_ty_5 =
    _bindgen_ty_5::AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX;
pub const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX: _bindgen_ty_5 =
    _bindgen_ty_5::AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX;
pub const AV_CODEC_HW_CONFIG_METHOD_INTERNAL: _bindgen_ty_5 =
    _bindgen_ty_5::AV_CODEC_HW_CONFIG_METHOD_INTERNAL;
pub const AV_CODEC_HW_CONFIG_METHOD_AD_HOC: _bindgen_ty_5 =
    _bindgen_ty_5::AV_CODEC_HW_CONFIG_METHOD_AD_HOC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    #[doc = " The codec supports this format via the hw_device_ctx interface.\n\n When selecting this format, AVCodecContext.hw_device_ctx should\n have been set to a device of the specified type before calling\n avcodec_open2()."]
    AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1,
    #[doc = " The codec supports this format via the hw_frames_ctx interface.\n\n When selecting this format for a decoder,\n AVCodecContext.hw_frames_ctx should be set to a suitable frames\n context inside the get_format() callback.  The frames context\n must have been created on a device of the specified type.\n\n When selecting this format for an encoder,\n AVCodecContext.hw_frames_ctx should be set to the context which\n will be used for the input frames before calling avcodec_open2()."]
    AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2,
    #[doc = " The codec supports this format by some internal method.\n\n This format can be selected without any additional configuration -\n no device or frames context is required."]
    AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4,
    #[doc = " The codec supports this format by some ad-hoc method.\n\n Additional settings and/or function calls are required.  See the\n codec-specific documentation for details.  (Methods requiring\n this sort of configuration are deprecated and others should be\n used in preference.)"]
    AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecHWConfig {
    #[doc = " For decoders, a hardware pixel format which that decoder may be\n able to decode to if suitable hardware is available.\n\n For encoders, a pixel format which the encoder may be able to\n accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel\n formats supported by the codec."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible\n setup methods which can be used with this configuration."]
    pub methods: ::std::os::raw::c_int,
    #[doc = " The device type associated with the configuration.\n\n Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and\n AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused."]
    pub device_type: AVHWDeviceType,
}
extern "C" {
    #[doc = " Retrieve supported hardware configurations for a codec.\n\n Values of index from zero to some maximum return the indexed configuration\n descriptor; all other values return NULL.  If the codec does not support\n any hardware configurations then it will always return NULL."]
    pub fn avcodec_get_hw_config(
        codec: *const AVCodec,
        index: ::std::os::raw::c_int,
    ) -> *const AVCodecHWConfig;
}
#[doc = " This struct describes the properties of a single codec described by an\n AVCodecID.\n @see avcodec_descriptor_get()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    #[doc = " Name of the codec described by this descriptor. It is non-empty and\n unique for each codec descriptor. It should contain alphanumeric\n characters and '_' only."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " A more descriptive name for this codec. May be NULL."]
    pub long_name: *const ::std::os::raw::c_char,
    #[doc = " Codec properties, a combination of AV_CODEC_PROP_* flags."]
    pub props: ::std::os::raw::c_int,
    #[doc = " MIME type(s) associated with the codec.\n May be NULL; if not, a NULL-terminated array of MIME types.\n The first item is always non-NULL and is the preferred MIME type."]
    pub mime_types: *const *const ::std::os::raw::c_char,
    #[doc = " If non-NULL, an array of profiles recognized for this codec.\n Terminated with FF_PROFILE_UNKNOWN."]
    pub profiles: *const AVProfile,
}
extern "C" {
    #[doc = " @return descriptor for given codec ID or NULL if no descriptor exists."]
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " Iterate over all codec descriptors known to libavcodec.\n\n @param prev previous descriptor. NULL to get the first descriptor.\n\n @return next descriptor or NULL after the last descriptor"]
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    #[doc = " @return codec descriptor with the given name or NULL if no such descriptor\n         exists."]
    pub fn avcodec_descriptor_get_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const AVCodecDescriptor;
}
#[repr(i32)]
#[doc = " @addtogroup lavc_core"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVFieldOrder {
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    AV_FIELD_TT = 2,
    AV_FIELD_BB = 3,
    AV_FIELD_TB = 4,
    AV_FIELD_BT = 5,
}
#[doc = " This struct describes the properties of an encoded stream.\n\n sizeof(AVCodecParameters) is not a part of the public ABI, this struct must\n be allocated with avcodec_parameters_alloc() and freed with\n avcodec_parameters_free()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVCodecParameters {
    #[doc = " General type of the encoded data."]
    pub codec_type: AVMediaType,
    #[doc = " Specific type of the encoded data (the codec used)."]
    pub codec_id: AVCodecID,
    #[doc = " Additional information about the codec (corresponds to the AVI FOURCC)."]
    pub codec_tag: u32,
    #[doc = " Extra binary data needed for initializing the decoder, codec-dependent.\n\n Must be allocated with av_malloc() and will be freed by\n avcodec_parameters_free(). The allocated size of extradata must be at\n least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding\n bytes zeroed."]
    pub extradata: *mut u8,
    #[doc = " Size of the extradata content in bytes."]
    pub extradata_size: ::std::os::raw::c_int,
    #[doc = " - video: the pixel format, the value corresponds to enum AVPixelFormat.\n - audio: the sample format, the value corresponds to enum AVSampleFormat."]
    pub format: ::std::os::raw::c_int,
    #[doc = " The average bitrate of the encoded data (in bits per second)."]
    pub bit_rate: i64,
    #[doc = " The number of bits per sample in the codedwords.\n\n This is basically the bitrate per sample. It is mandatory for a bunch of\n formats to actually decode them. It's the number of bits for one sample in\n the actual coded bitstream.\n\n This could be for example 4 for ADPCM\n For PCM formats this matches bits_per_raw_sample\n Can be 0"]
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    #[doc = " This is the number of valid bits in each output sample. If the\n sample format has more bits, the least significant bits are additional\n padding bits, which are always 0. Use right shifts to reduce the sample\n to its actual size. For example, audio formats with 24 bit samples will\n have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.\n To get the original sample use \"(int32_t)sample >> 8\".\"\n\n For ADPCM this might be 12 or 16 or similar\n Can be 0"]
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    #[doc = " Codec-specific bitstream restrictions that the stream conforms to."]
    pub profile: ::std::os::raw::c_int,
    pub level: ::std::os::raw::c_int,
    #[doc = " Video only. The dimensions of the video frame in pixels."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " Video only. The aspect ratio (width / height) which a single pixel\n should have when displayed.\n\n When the aspect ratio is unknown / undefined, the numerator should be\n set to 0 (the denominator may have any value)."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Video only. The order of the fields in interlaced video."]
    pub field_order: AVFieldOrder,
    #[doc = " Video only. Additional colorspace characteristics."]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " Video only. Number of delayed frames."]
    pub video_delay: ::std::os::raw::c_int,
    #[doc = " Audio only. The channel layout bitmask. May be 0 if the channel layout is\n unknown or unspecified, otherwise the number of bits set must be equal to\n the channels field.\n @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Audio only. The number of audio channels.\n @deprecated use ch_layout.nb_channels"]
    pub channels: ::std::os::raw::c_int,
    #[doc = " Audio only. The number of audio samples per second."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Audio only. The number of bytes per coded audio frame, required by some\n formats.\n\n Corresponds to nBlockAlign in WAVEFORMATEX."]
    pub block_align: ::std::os::raw::c_int,
    #[doc = " Audio only. Audio frame size, if known. Required by some formats to be static."]
    pub frame_size: ::std::os::raw::c_int,
    #[doc = " Audio only. The amount of padding (in samples) inserted by the encoder at\n the beginning of the audio. I.e. this number of leading decoded samples\n must be discarded by the caller to get the original audio without leading\n padding."]
    pub initial_padding: ::std::os::raw::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to\n the end of the audio. I.e. this number of decoded samples must be\n discarded by the caller from the end of the stream to get the original\n audio without any trailing padding."]
    pub trailing_padding: ::std::os::raw::c_int,
    #[doc = " Audio only. Number of samples to skip after a discontinuity."]
    pub seek_preroll: ::std::os::raw::c_int,
    #[doc = " Audio only. The channel layout and number of channels."]
    pub ch_layout: AVChannelLayout,
}
extern "C" {
    #[doc = " Allocate a new AVCodecParameters and set its fields to default values\n (unknown/invalid/0). The returned struct must be freed with\n avcodec_parameters_free()."]
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    #[doc = " Free an AVCodecParameters instance and everything associated with it and\n write NULL to the supplied pointer."]
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    #[doc = " Copy the contents of src to dst. Any allocated fields in dst are freed and\n replaced with newly allocated duplicates of the corresponding fields in src.\n\n @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function is the same as av_get_audio_frame_duration(), except it works\n with AVCodecParameters instead of an AVCodecContext."]
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @ingroup lavc_decoding"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDiscard {
    #[doc = "< discard nothing"]
    AVDISCARD_NONE = -16,
    #[doc = "< discard useless packets like 0 size packets in avi"]
    AVDISCARD_DEFAULT = 0,
    #[doc = "< discard all non reference"]
    AVDISCARD_NONREF = 8,
    #[doc = "< discard all bidirectional frames"]
    AVDISCARD_BIDIR = 16,
    #[doc = "< discard all non intra frames"]
    AVDISCARD_NONINTRA = 24,
    #[doc = "< discard all frames except keyframes"]
    AVDISCARD_NONKEY = 32,
    #[doc = "< discard all"]
    AVDISCARD_ALL = 48,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVAudioServiceType {
    AV_AUDIO_SERVICE_TYPE_MAIN = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
    #[doc = "< Not part of ABI"]
    AV_AUDIO_SERVICE_TYPE_NB = 9,
}
#[doc = " Pan Scan area.\n This specifies the area which should be displayed.\n Note there may be multiple such areas for one frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPanScan {
    #[doc = " id\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub id: ::std::os::raw::c_int,
    #[doc = " width and height in 1/16 pel\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " position of the top left corner in 1/16 pel for up to 3 fields/frames\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub position: [[i16; 2usize]; 3usize],
}
#[doc = " This structure describes the bitrate properties of an encoded bitstream. It\n roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD\n parameters for H.264/HEVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCPBProperties {
    #[doc = " Maximum bitrate of the stream, in bits per second.\n Zero if unknown or unspecified."]
    pub max_bitrate: i64,
    #[doc = " Minimum bitrate of the stream, in bits per second.\n Zero if unknown or unspecified."]
    pub min_bitrate: i64,
    #[doc = " Average bitrate of the stream, in bits per second.\n Zero if unknown or unspecified."]
    pub avg_bitrate: i64,
    #[doc = " The size of the buffer to which the ratecontrol is applied, in bits.\n Zero if unknown or unspecified."]
    pub buffer_size: i64,
    #[doc = " The delay between the time the packet this structure is associated with\n is received and the time when it should be decoded, in periods of a 27MHz\n clock.\n\n UINT64_MAX when unknown or unspecified."]
    pub vbv_delay: u64,
}
extern "C" {
    #[doc = " Allocate a CPB properties structure and initialize its fields to default\n values.\n\n @param size if non-NULL, the size of the allocated struct will be written\n             here. This is useful for embedding it in side data.\n\n @return the newly allocated struct or NULL on failure"]
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[doc = " This structure supplies correlation between a packet timestamp and a wall clock\n production time. The definition follows the Producer Reference Time ('prft')\n as defined in ISO/IEC 14496-12"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProducerReferenceTime {
    #[doc = " A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime())."]
    pub wallclock: i64,
    pub flags: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Encode extradata length to a buffer. Used by xiph codecs.\n\n @param s buffer to write to; must be at least (v/255+1) bytes long\n @param v size of extradata in bytes\n @return number of bytes written to the buffer."]
    pub fn av_xiphlacing(
        s: *mut ::std::os::raw::c_uchar,
        v: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
#[repr(i32)]
#[doc = " @defgroup lavc_packet AVPacket\n\n Types and functions for working with AVPacket.\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPacketSideDataType {
    #[doc = " An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE\n bytes worth of palette. This side data signals that a new palette is\n present."]
    AV_PKT_DATA_PALETTE = 0,
    #[doc = " The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format\n that the extradata buffer was changed and the receiving side should\n act upon it appropriately. The new extradata is embedded in the side\n data buffer and should be immediately used for processing the current\n frame or packet."]
    AV_PKT_DATA_NEW_EXTRADATA = 1,
    #[doc = " An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:\n @code\n u32le param_flags\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)\n     s32le channel_count\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)\n     u64le channel_layout\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)\n     s32le sample_rate\n if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)\n     s32le width\n     s32le height\n @endcode"]
    AV_PKT_DATA_PARAM_CHANGE = 2,
    #[doc = " An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of\n structures with info about macroblocks relevant to splitting the\n packet into smaller packets on macroblock edges (e.g. as for RFC 2190).\n That is, it does not necessarily contain info about all macroblocks,\n as long as the distance between macroblocks in the info is smaller\n than the target payload size.\n Each MB info structure is 12 bytes, and is laid out as follows:\n @code\n u32le bit offset from the start of the packet\n u8    current quantizer at the start of the macroblock\n u8    GOB number\n u16le macroblock address within the GOB\n u8    horizontal MV predictor\n u8    vertical MV predictor\n u8    horizontal MV predictor for block number 3\n u8    vertical MV predictor for block number 3\n @endcode"]
    AV_PKT_DATA_H263_MB_INFO = 3,
    #[doc = " This side data should be associated with an audio stream and contains\n ReplayGain information in form of the AVReplayGain struct."]
    AV_PKT_DATA_REPLAYGAIN = 4,
    #[doc = " This side data contains a 3x3 transformation matrix describing an affine\n transformation that needs to be applied to the decoded video frames for\n correct presentation.\n\n See libavutil/display.h for a detailed description of the data."]
    AV_PKT_DATA_DISPLAYMATRIX = 5,
    #[doc = " This side data should be associated with a video stream and contains\n Stereoscopic 3D information in form of the AVStereo3D struct."]
    AV_PKT_DATA_STEREO3D = 6,
    #[doc = " This side data should be associated with an audio stream and corresponds\n to enum AVAudioServiceType."]
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,
    #[doc = " This side data contains quality related information from the encoder.\n @code\n u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).\n u8    picture type\n u8    error count\n u16   reserved\n u64le[error count] sum of squared differences between encoder in and output\n @endcode"]
    AV_PKT_DATA_QUALITY_STATS = 8,
    #[doc = " This side data contains an integer value representing the stream index\n of a \"fallback\" track.  A fallback track indicates an alternate\n track to use when the current track can not be decoded for some reason.\n e.g. no decoder available for codec."]
    AV_PKT_DATA_FALLBACK_TRACK = 9,
    #[doc = " This side data corresponds to the AVCPBProperties struct."]
    AV_PKT_DATA_CPB_PROPERTIES = 10,
    #[doc = " Recommmends skipping the specified number of samples\n @code\n u32le number of samples to skip from start of this packet\n u32le number of samples to skip from end of this packet\n u8    reason for start skip\n u8    reason for end   skip (0=padding silence, 1=convergence)\n @endcode"]
    AV_PKT_DATA_SKIP_SAMPLES = 11,
    #[doc = " An AV_PKT_DATA_JP_DUALMONO side data packet indicates that\n the packet may contain \"dual mono\" audio specific to Japanese DTV\n and if it is true, recommends only the selected channel to be used.\n @code\n u8    selected channels (0=mail/left, 1=sub/right, 2=both)\n @endcode"]
    AV_PKT_DATA_JP_DUALMONO = 12,
    #[doc = " A list of zero terminated key/value strings. There is no end marker for\n the list, so it is required to rely on the side data size to stop."]
    AV_PKT_DATA_STRINGS_METADATA = 13,
    #[doc = " Subtitle event position\n @code\n u32le x1\n u32le y1\n u32le x2\n u32le y2\n @endcode"]
    AV_PKT_DATA_SUBTITLE_POSITION = 14,
    #[doc = " Data found in BlockAdditional element of matroska container. There is\n no end marker for the data, so it is required to rely on the side data\n size to recognize the end. 8 byte id (as found in BlockAddId) followed\n by data."]
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15,
    #[doc = " The optional first identifier line of a WebVTT cue."]
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 16,
    #[doc = " The optional settings (rendering instructions) that immediately\n follow the timestamp specifier of a WebVTT cue."]
    AV_PKT_DATA_WEBVTT_SETTINGS = 17,
    #[doc = " A list of zero terminated key/value strings. There is no end marker for\n the list, so it is required to rely on the side data size to stop. This\n side data includes updated metadata which appeared in the stream."]
    AV_PKT_DATA_METADATA_UPDATE = 18,
    #[doc = " MPEGTS stream ID as uint8_t, this is required to pass the stream ID\n information from the demuxer to the corresponding muxer."]
    AV_PKT_DATA_MPEGTS_STREAM_ID = 19,
    #[doc = " Mastering display metadata (based on SMPTE-2086:2014). This metadata\n should be associated with a video stream and contains data in the form\n of the AVMasteringDisplayMetadata struct."]
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20,
    #[doc = " This side data should be associated with a video stream and corresponds\n to the AVSphericalMapping structure."]
    AV_PKT_DATA_SPHERICAL = 21,
    #[doc = " Content light level (based on CTA-861.3). This metadata should be\n associated with a video stream and contains data in the form of the\n AVContentLightMetadata struct."]
    AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22,
    #[doc = " ATSC A53 Part 4 Closed Captions. This metadata should be associated with\n a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.\n The number of bytes of CC data is AVPacketSideData.size."]
    AV_PKT_DATA_A53_CC = 23,
    #[doc = " This side data is encryption initialization data.\n The format is not part of ABI, use av_encryption_init_info_* methods to\n access."]
    AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24,
    #[doc = " This side data contains encryption info for how to decrypt the packet.\n The format is not part of ABI, use av_encryption_info_* methods to access."]
    AV_PKT_DATA_ENCRYPTION_INFO = 25,
    #[doc = " Active Format Description data consisting of a single byte as specified\n in ETSI TS 101 154 using AVActiveFormatDescription enum."]
    AV_PKT_DATA_AFD = 26,
    #[doc = " Producer Reference Time data corresponding to the AVProducerReferenceTime struct,\n usually exported by some encoders (on demand through the prft flag set in the\n AVCodecContext export_side_data field)."]
    AV_PKT_DATA_PRFT = 27,
    #[doc = " ICC profile data consisting of an opaque octet buffer following the\n format described by ISO 15076-1."]
    AV_PKT_DATA_ICC_PROFILE = 28,
    #[doc = " DOVI configuration\n ref:\n dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2\n dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3\n Tags are stored in struct AVDOVIDecoderConfigurationRecord."]
    AV_PKT_DATA_DOVI_CONF = 29,
    #[doc = " Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t\n where the first uint32_t describes how many (1-3) of the other timecodes are used.\n The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n function in libavutil/timecode.h."]
    AV_PKT_DATA_S12M_TIMECODE = 30,
    #[doc = " HDR10+ dynamic metadata associated with a video frame. The metadata is in\n the form of the AVDynamicHDRPlus struct and contains\n information for color volume transform - application 4 of\n SMPTE 2094-40:2016 standard."]
    AV_PKT_DATA_DYNAMIC_HDR10_PLUS = 31,
    #[doc = " The number of side data types.\n This is not part of the public API/ABI in the sense that it may\n change when new side data types are added.\n This must stay the last enum value.\n If its value becomes huge, some code using it\n needs to be updated as it assumes it to be smaller than other limits."]
    AV_PKT_DATA_NB = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: usize,
    pub type_: AVPacketSideDataType,
}
#[doc = " This structure stores compressed data. It is typically exported by demuxers\n and then passed as input to decoders, or received as output from encoders and\n then passed to muxers.\n\n For video, it should typically contain one compressed frame. For audio it may\n contain several compressed frames. Encoders are allowed to output empty\n packets, with no compressed data, containing only side data\n (e.g. to update some stream parameters at the end of encoding).\n\n The semantics of data ownership depends on the buf field.\n If it is set, the packet data is dynamically allocated and is\n valid indefinitely until a call to av_packet_unref() reduces the\n reference count to 0.\n\n If the buf field is not set av_packet_ref() would make a copy instead\n of increasing the reference count.\n\n The side data is always allocated with av_malloc(), copied by\n av_packet_ref() and freed by av_packet_unref().\n\n sizeof(AVPacket) being a part of the public ABI is deprecated. once\n av_init_packet() is removed, new packets will only be able to be allocated\n with av_packet_alloc(), and new fields may be added to the end of the struct\n with a minor bump.\n\n @see av_packet_alloc\n @see av_packet_ref\n @see av_packet_unref"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacket {
    #[doc = " A reference to the reference-counted buffer where the packet data is\n stored.\n May be NULL, then the packet data is not reference-counted."]
    pub buf: *mut AVBufferRef,
    #[doc = " Presentation timestamp in AVStream->time_base units; the time at which\n the decompressed packet will be presented to the user.\n Can be AV_NOPTS_VALUE if it is not stored in the file.\n pts MUST be larger or equal to dts as presentation cannot happen before\n decompression, unless one wants to view hex dumps. Some formats misuse\n the terms dts and pts/cts to mean something different. Such timestamps\n must be converted to true pts/dts before they are stored in AVPacket."]
    pub pts: i64,
    #[doc = " Decompression timestamp in AVStream->time_base units; the time at which\n the packet is decompressed.\n Can be AV_NOPTS_VALUE if it is not stored in the file."]
    pub dts: i64,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub stream_index: ::std::os::raw::c_int,
    #[doc = " A combination of AV_PKT_FLAG values"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Additional packet data that can be provided by the container.\n Packet can contain several types of side information."]
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: ::std::os::raw::c_int,
    #[doc = " Duration of this packet in AVStream->time_base units, 0 if unknown.\n Equals next_pts - this_pts in presentation order."]
    pub duration: i64,
    #[doc = "< byte position in stream, -1 if unknown"]
    pub pos: i64,
    #[doc = " for some private data of the user"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the\n contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when\n the packet is unreferenced. av_packet_copy_props() calls create a new\n reference with av_buffer_ref() for the target packet's opaque_ref field.\n\n This is unrelated to the opaque field, although it serves a similar\n purpose."]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " Time base of the packet's timestamps.\n In the future, this field may be set on packets output by encoders or\n demuxers, but its value will be by default ignored on input to decoders\n or muxers."]
    pub time_base: AVRational,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSideDataParamChangeFlags {
    #[doc = " @deprecated those are not used by any decoder"]
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
    #[doc = " @deprecated those are not used by any decoder"]
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8,
}
extern "C" {
    #[doc = " Allocate an AVPacket and set its fields to default values.  The resulting\n struct must be freed using av_packet_free().\n\n @return An AVPacket filled with default values or NULL on failure.\n\n @note this only allocates the AVPacket itself, not the data buffers. Those\n must be allocated through other means such as av_new_packet.\n\n @see av_new_packet"]
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    #[doc = " Create a new packet that references the same data as src.\n\n This is a shortcut for av_packet_alloc()+av_packet_ref().\n\n @return newly created AVPacket on success, NULL on error.\n\n @see av_packet_alloc\n @see av_packet_ref"]
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    #[doc = " Free the packet, if the packet is reference counted, it will be\n unreferenced first.\n\n @param pkt packet to be freed. The pointer will be set to NULL.\n @note passing NULL is a no-op."]
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    #[doc = " Initialize optional fields of a packet with default values.\n\n Note, this does not touch the data and size members, which have to be\n initialized separately.\n\n @param pkt packet\n\n @see av_packet_alloc\n @see av_packet_unref\n\n @deprecated This function is deprecated. Once it's removed,\nsizeof(AVPacket) will not be a part of the ABI anymore."]
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Allocate the payload of a packet and initialize its fields with\n default values.\n\n @param pkt packet\n @param size wanted payload size\n @return 0 if OK, AVERROR_xxx otherwise"]
    pub fn av_new_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reduce packet size, correctly zeroing padding\n\n @param pkt packet\n @param size new size"]
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Increase packet size, correctly zeroing padding\n\n @param pkt packet\n @param grow_by number of bytes by which to increase the size of the packet"]
    pub fn av_grow_packet(
        pkt: *mut AVPacket,
        grow_by: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a reference-counted packet from av_malloc()ed data.\n\n @param pkt packet to be initialized. This function will set the data, size,\n        and buf fields, all others are left untouched.\n @param data Data allocated by av_malloc() to be used as packet data. If this\n        function returns successfully, the data is owned by the underlying AVBuffer.\n        The caller may not access the data through other means.\n @param size size of data in bytes, without the padding. I.e. the full buffer\n        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.\n\n @return 0 on success, a negative AVERROR on error"]
    pub fn av_packet_from_data(
        pkt: *mut AVPacket,
        data: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate new information of a packet.\n\n @param pkt packet\n @param type side information type\n @param size side information size\n @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Wrap an existing array as a packet side data.\n\n @param pkt packet\n @param type side information type\n @param data the side data array. It must be allocated with the av_malloc()\n             family of functions. The ownership of the data is transferred to\n             pkt.\n @param size side information size\n @return a non-negative number on success, a negative AVERROR code on\n         failure. On failure, the packet is unchanged and the data remains\n         owned by the caller."]
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shrink the already allocated side data buffer\n\n @param pkt packet\n @param type side information type\n @param size new side information size\n @return 0 on success, < 0 on failure"]
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get side information from packet.\n\n @param pkt packet\n @param type desired side information type\n @param size If supplied, *size will be set to the size of the side data\n             or to zero if the desired side data is not present.\n @return pointer to data if present or NULL otherwise"]
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Pack a dictionary for use in side_data.\n\n @param dict The dictionary to pack.\n @param size pointer to store the size of the returned data\n @return pointer to data if successful, NULL otherwise"]
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary, size: *mut usize) -> *mut u8;
}
extern "C" {
    #[doc = " Unpack a dictionary from side_data.\n\n @param data data from side_data\n @param size size of the data\n @param dict the metadata storage dictionary\n @return 0 on success, < 0 on failure"]
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: usize,
        dict: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function to free all the side data stored.\n All the other fields stay untouched.\n\n @param pkt packet"]
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Setup a new reference to the data described by a given packet\n\n If src is reference-counted, setup dst as a new reference to the\n buffer in src. Otherwise allocate a new buffer in dst and copy the\n data from src into it.\n\n All the other fields are copied from src.\n\n @see av_packet_unref\n\n @param dst Destination packet. Will be completely overwritten.\n @param src Source packet\n\n @return 0 on success, a negative AVERROR on error. On error, dst\n         will be blank (as if returned by av_packet_alloc())."]
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wipe the packet.\n\n Unreference the buffer referenced by the packet and reset the\n remaining packet fields to their default values.\n\n @param pkt The packet to be unreferenced."]
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    #[doc = " Move every field in src to dst and reset src.\n\n @see av_packet_unref\n\n @param src Source packet, will be reset\n @param dst Destination packet"]
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    #[doc = " Copy only \"properties\" fields from src to dst.\n\n Properties for the purpose of this function are all the fields\n beside those related to the packet data (buf, data, size)\n\n @param dst Destination packet\n @param src Source packet\n\n @return 0 on success AVERROR on failure."]
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure the data described by a given packet is reference counted.\n\n @note This function does not ensure that the reference will be writable.\n       Use av_packet_make_writable instead for that purpose.\n\n @see av_packet_ref\n @see av_packet_make_writable\n\n @param pkt packet whose data should be made reference counted.\n\n @return 0 on success, a negative AVERROR on error. On failure, the\n         packet is unchanged."]
    pub fn av_packet_make_refcounted(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a writable reference for the data described by a given packet,\n avoiding data copy if possible.\n\n @param pkt Packet whose data should be made writable.\n\n @return 0 on success, a negative AVERROR on failure. On failure, the\n         packet is unchanged."]
    pub fn av_packet_make_writable(pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert valid timing fields (timestamps / durations) in a packet from one\n timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be\n ignored.\n\n @param pkt packet on which the conversion will be performed\n @param tb_src source timebase, in which the timing fields in pkt are\n               expressed\n @param tb_dst destination timebase, to which the timing fields will be\n               converted"]
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
#[doc = " @ingroup lavc_encoding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RcOverride {
    pub start_frame: ::std::os::raw::c_int,
    pub end_frame: ::std::os::raw::c_int,
    pub qscale: ::std::os::raw::c_int,
    pub quality_factor: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
#[doc = " main external API structure.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user\n applications.\n The name string for AVOptions options matches the associated command line\n parameter name and can be found in libavcodec/options_table.h\n The AVOption/command line parameter names differ in some cases from the C\n structure field names for historic reasons or brevity.\n sizeof(AVCodecContext) must not be used outside libav*."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVCodecContext {
    #[doc = " information on struct for av_log\n - set by avcodec_alloc_context3"]
    pub av_class: *const AVClass,
    pub log_level_offset: ::std::os::raw::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    pub codec_id: AVCodecID,
    #[doc = " fourcc (LSB first, so \"ABCD\" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').\n This is used to work around some encoder bugs.\n A demuxer should set this to what is stored in the field used to identify the codec.\n If there are multiple such fields in a container then the demuxer should choose the one\n which maximizes the information about the used codec.\n If the codec tag field in a container is larger than 32 bits then the demuxer should\n remap the longer ID to 32 bits with a table or other structure. Alternatively a new\n extra_codec_tag + size could be added but for this a clear advantage must be demonstrated\n first.\n - encoding: Set by user, if not then the default based on codec_id will be used.\n - decoding: Set by user, will be converted to uppercase by libavcodec during init."]
    pub codec_tag: ::std::os::raw::c_uint,
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " Private context used for internal data.\n\n Unlike priv_data, this is not codec-specific. It is used in general\n libavcodec functions."]
    pub internal: *mut AVCodecInternal,
    #[doc = " Private data of the user, can be used to carry app specific stuff.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " the average bitrate\n - encoding: Set by user; unused for constant quantizer encoding.\n - decoding: Set by user, may be overwritten by libavcodec\n             if this info is available in the stream"]
    pub bit_rate: i64,
    #[doc = " number of bits the bitstream is allowed to diverge from the reference.\n           the reference can be CBR (for CBR pass1) or VBR (for pass2)\n - encoding: Set by user; unused for constant quantizer encoding.\n - decoding: unused"]
    pub bit_rate_tolerance: ::std::os::raw::c_int,
    #[doc = " Global quality for codecs which cannot change it per frame.\n This should be proportional to MPEG-1/2/4 qscale.\n - encoding: Set by user.\n - decoding: unused"]
    pub global_quality: ::std::os::raw::c_int,
    #[doc = " - encoding: Set by user.\n - decoding: unused"]
    pub compression_level: ::std::os::raw::c_int,
    #[doc = " AV_CODEC_FLAG_*.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " AV_CODEC_FLAG2_*\n - encoding: Set by user.\n - decoding: Set by user."]
    pub flags2: ::std::os::raw::c_int,
    #[doc = " some codecs need / can use extradata like Huffman tables.\n MJPEG: Huffman tables\n rv10: additional flags\n MPEG-4: global headers (they can be in the bitstream or here)\n The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger\n than extradata_size to avoid problems if it is read with the bitstream reader.\n The bytewise contents of extradata must not depend on the architecture or CPU endianness.\n Must be allocated with the av_malloc() family of functions.\n - encoding: Set/allocated/freed by libavcodec.\n - decoding: Set/allocated/freed by user."]
    pub extradata: *mut u8,
    pub extradata_size: ::std::os::raw::c_int,
    #[doc = " This is the fundamental unit of time (in seconds) in terms\n of which frame timestamps are represented. For fixed-fps content,\n timebase should be 1/framerate and timestamp increments should be\n identically 1.\n This often, but not always is the inverse of the frame rate or field rate\n for video. 1/time_base is not the average frame rate if the frame rate is not\n constant.\n\n Like containers, elementary streams also can store timestamps, 1/time_base\n is the unit in which these timestamps are specified.\n As example of such codec time base see ISO/IEC 14496-2:2001(E)\n vop_time_increment_resolution and fixed_vop_rate\n (fixed_vop_rate == 0 implies that it is different from the framerate)\n\n - encoding: MUST be set by user.\n - decoding: the use of this field for decoding is deprecated.\n             Use framerate instead."]
    pub time_base: AVRational,
    #[doc = " For some codecs, the time base is closer to the field rate than the frame rate.\n Most notably, H.264 and MPEG-2 specify time_base as half of frame duration\n if no telecine is used ...\n\n Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2."]
    pub ticks_per_frame: ::std::os::raw::c_int,
    #[doc = " Codec delay.\n\n Encoding: Number of frames delay there will be from the encoder input to\n           the decoder output. (we assume the decoder matches the spec)\n Decoding: Number of frames delay in addition to what a standard decoder\n           as specified in the spec would produce.\n\n Video:\n   Number of frames the decoded output will be delayed relative to the\n   encoded input.\n\n Audio:\n   For encoding, this field is unused (see initial_padding).\n\n   For decoding, this is the number of samples the decoder needs to\n   output before the decoder's output is valid. When seeking, you should\n   start decoding this many samples prior to your desired seek point.\n\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub delay: ::std::os::raw::c_int,
    #[doc = " picture width / height.\n\n @note Those fields may not match the values of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: MUST be set by user.\n - decoding: May be set by the user before opening the decoder if known e.g.\n             from the container. Some decoders will require the dimensions\n             to be set by the caller. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub width: ::std::os::raw::c_int,
    #[doc = " picture width / height.\n\n @note Those fields may not match the values of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: MUST be set by user.\n - decoding: May be set by the user before opening the decoder if known e.g.\n             from the container. Some decoders will require the dimensions\n             to be set by the caller. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub height: ::std::os::raw::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when\n the decoded frame is cropped before being output or lowres is enabled.\n\n @note Those field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: unused\n - decoding: May be set by the user before opening the decoder if known\n             e.g. from the container. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub coded_width: ::std::os::raw::c_int,
    #[doc = " Bitstream width / height, may be different from width/height e.g. when\n the decoded frame is cropped before being output or lowres is enabled.\n\n @note Those field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: unused\n - decoding: May be set by the user before opening the decoder if known\n             e.g. from the container. During decoding, the decoder may\n             overwrite those values as required while parsing the data."]
    pub coded_height: ::std::os::raw::c_int,
    #[doc = " the number of pictures in a group of pictures, or 0 for intra_only\n - encoding: Set by user.\n - decoding: unused"]
    pub gop_size: ::std::os::raw::c_int,
    #[doc = " Pixel format, see AV_PIX_FMT_xxx.\n May be set by the demuxer if known from headers.\n May be overridden by the decoder if it knows better.\n\n @note This field may not match the value of the last\n AVFrame output by avcodec_receive_frame() due frame\n reordering.\n\n - encoding: Set by user.\n - decoding: Set by user if known, overridden by libavcodec while\n             parsing the data."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " If non NULL, 'draw_horiz_band' is called by the libavcodec\n decoder to draw a horizontal band. It improves cache usage. Not\n all codecs can do that. You must check the codec capabilities\n beforehand.\n When multithreading is used, it may be called from multiple threads\n at the same time; threads might draw different parts of the same AVFrame,\n or multiple AVFrames, and there is no guarantee that slices will be drawn\n in order.\n The function is also used by hardware acceleration APIs.\n It is called at least once during frame decoding to pass\n the data needed for hardware render.\n In that mode instead of pixel data, AVFrame points to\n a structure specific to the acceleration API. The application\n reads the structure and can change some fields to indicate progress\n or mark state.\n - encoding: unused\n - decoding: Set by user.\n @param height the height of the slice\n @param y the y position of the slice\n @param type 1->top field, 2->bottom field, 3->frame\n @param offset offset into the AVFrame.data from which the slice should be read"]
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Callback to negotiate the pixel format. Decoding only, may be set by the\n caller before avcodec_open2().\n\n Called by some decoders to select the pixel format that will be used for\n the output frames. This is mainly used to set up hardware acceleration,\n then the provided format list contains the corresponding hwaccel pixel\n formats alongside the \"software\" one. The software pixel format may also\n be retrieved from \\ref sw_pix_fmt.\n\n This callback will be called when the coded frame properties (such as\n resolution, pixel format, etc.) change and more than one output format is\n supported for those new properties. If a hardware pixel format is chosen\n and initialization for it fails, the callback may be called again\n immediately.\n\n This callback may be called from different threads if the decoder is\n multi-threaded, but not from more than one thread simultaneously.\n\n @param fmt list of formats which may be used in the current\n            configuration, terminated by AV_PIX_FMT_NONE.\n @warning Behavior is undefined if the callback returns a value other\n          than one of the formats in fmt or AV_PIX_FMT_NONE.\n @return the chosen format or AV_PIX_FMT_NONE"]
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    #[doc = " maximum number of B-frames between non-B-frames\n Note: The output will be delayed by max_b_frames+1 relative to the input.\n - encoding: Set by user.\n - decoding: unused"]
    pub max_b_frames: ::std::os::raw::c_int,
    #[doc = " qscale factor between IP and B-frames\n If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).\n If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).\n - encoding: Set by user.\n - decoding: unused"]
    pub b_quant_factor: f32,
    #[doc = " qscale offset between IP and B-frames\n - encoding: Set by user.\n - decoding: unused"]
    pub b_quant_offset: f32,
    #[doc = " Size of the frame reordering buffer in the decoder.\n For MPEG-2 it is 1 IPB or 0 low delay IP.\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub has_b_frames: ::std::os::raw::c_int,
    #[doc = " qscale factor between P- and I-frames\n If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).\n If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).\n - encoding: Set by user.\n - decoding: unused"]
    pub i_quant_factor: f32,
    #[doc = " qscale offset between P and I-frames\n - encoding: Set by user.\n - decoding: unused"]
    pub i_quant_offset: f32,
    #[doc = " luminance masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub lumi_masking: f32,
    #[doc = " temporary complexity masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub temporal_cplx_masking: f32,
    #[doc = " spatial complexity masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub spatial_cplx_masking: f32,
    #[doc = " p block masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub p_masking: f32,
    #[doc = " darkness masking (0-> disabled)\n - encoding: Set by user.\n - decoding: unused"]
    pub dark_masking: f32,
    #[doc = " slice count\n - encoding: Set by libavcodec.\n - decoding: Set by user (or 0)."]
    pub slice_count: ::std::os::raw::c_int,
    #[doc = " slice offsets in the frame in bytes\n - encoding: Set/allocated by libavcodec.\n - decoding: Set/allocated by user (or NULL)."]
    pub slice_offset: *mut ::std::os::raw::c_int,
    #[doc = " sample aspect ratio (0 if unknown)\n That is the width of a pixel divided by the height of the pixel.\n Numerator and denominator must be relatively prime and smaller than 256 for some video standards.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " motion estimation comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_cmp: ::std::os::raw::c_int,
    #[doc = " subpixel motion estimation comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_sub_cmp: ::std::os::raw::c_int,
    #[doc = " macroblock comparison function (not supported yet)\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_cmp: ::std::os::raw::c_int,
    #[doc = " interlaced DCT comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub ildct_cmp: ::std::os::raw::c_int,
    #[doc = " ME diamond size & shape\n - encoding: Set by user.\n - decoding: unused"]
    pub dia_size: ::std::os::raw::c_int,
    #[doc = " amount of previous MV predictors (2a+1 x 2a+1 square)\n - encoding: Set by user.\n - decoding: unused"]
    pub last_predictor_count: ::std::os::raw::c_int,
    #[doc = " motion estimation prepass comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub me_pre_cmp: ::std::os::raw::c_int,
    #[doc = " ME prepass diamond size & shape\n - encoding: Set by user.\n - decoding: unused"]
    pub pre_dia_size: ::std::os::raw::c_int,
    #[doc = " subpel ME quality\n - encoding: Set by user.\n - decoding: unused"]
    pub me_subpel_quality: ::std::os::raw::c_int,
    #[doc = " maximum motion estimation search range in subpel units\n If 0 then no limit.\n\n - encoding: Set by user.\n - decoding: unused"]
    pub me_range: ::std::os::raw::c_int,
    #[doc = " slice flags\n - encoding: unused\n - decoding: Set by user."]
    pub slice_flags: ::std::os::raw::c_int,
    #[doc = " macroblock decision mode\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_decision: ::std::os::raw::c_int,
    #[doc = " custom intra quantization matrix\n Must be allocated with the av_malloc() family of functions, and will be freed in\n avcodec_free_context().\n - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.\n - decoding: Set/allocated/freed by libavcodec."]
    pub intra_matrix: *mut u16,
    #[doc = " custom inter quantization matrix\n Must be allocated with the av_malloc() family of functions, and will be freed in\n avcodec_free_context().\n - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.\n - decoding: Set/allocated/freed by libavcodec."]
    pub inter_matrix: *mut u16,
    #[doc = " precision of the intra DC coefficient - 8\n - encoding: Set by user.\n - decoding: Set by libavcodec"]
    pub intra_dc_precision: ::std::os::raw::c_int,
    #[doc = " Number of macroblock rows at the top which are skipped.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_top: ::std::os::raw::c_int,
    #[doc = " Number of macroblock rows at the bottom which are skipped.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_bottom: ::std::os::raw::c_int,
    #[doc = " minimum MB Lagrange multiplier\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_lmin: ::std::os::raw::c_int,
    #[doc = " maximum MB Lagrange multiplier\n - encoding: Set by user.\n - decoding: unused"]
    pub mb_lmax: ::std::os::raw::c_int,
    #[doc = " - encoding: Set by user.\n - decoding: unused"]
    pub bidir_refine: ::std::os::raw::c_int,
    #[doc = " minimum GOP size\n - encoding: Set by user.\n - decoding: unused"]
    pub keyint_min: ::std::os::raw::c_int,
    #[doc = " number of reference frames\n - encoding: Set by user.\n - decoding: Set by lavc."]
    pub refs: ::std::os::raw::c_int,
    #[doc = " Note: Value depends upon the compare function used for fullpel ME.\n - encoding: Set by user.\n - decoding: unused"]
    pub mv0_threshold: ::std::os::raw::c_int,
    #[doc = " Chromaticity coordinates of the source primaries.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_primaries: AVColorPrimaries,
    #[doc = " Color Transfer Characteristic.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    #[doc = " MPEG vs JPEG YUV range.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    #[doc = " This defines the location of chroma samples.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub chroma_sample_location: AVChromaLocation,
    #[doc = " Number of slices.\n Indicates number of picture subdivisions. Used for parallelized\n decoding.\n - encoding: Set by user\n - decoding: unused"]
    pub slices: ::std::os::raw::c_int,
    #[doc = " Field order\n - encoding: set by libavcodec\n - decoding: Set by user."]
    pub field_order: AVFieldOrder,
    #[doc = "< samples per second"]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " number of audio channels\n @deprecated use ch_layout.nb_channels"]
    pub channels: ::std::os::raw::c_int,
    #[doc = "< sample format"]
    pub sample_fmt: AVSampleFormat,
    #[doc = " Number of samples per channel in an audio frame.\n\n - encoding: set by libavcodec in avcodec_open2(). Each submitted frame\n   except the last must contain exactly frame_size samples per channel.\n   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the\n   frame size is not restricted.\n - decoding: may be set by some decoders to indicate constant frame size"]
    pub frame_size: ::std::os::raw::c_int,
    #[doc = " Frame counter, set by libavcodec.\n\n - decoding: total number of frames returned from the decoder so far.\n - encoding: total number of frames passed to the encoder so far.\n\n   @note the counter is not incremented if encoding/decoding resulted in\n   an error."]
    pub frame_number: ::std::os::raw::c_int,
    #[doc = " number of bytes per packet if constant and known or 0\n Used by some WAV based audio codecs."]
    pub block_align: ::std::os::raw::c_int,
    #[doc = " Audio cutoff bandwidth (0 means \"automatic\")\n - encoding: Set by user.\n - decoding: unused"]
    pub cutoff: ::std::os::raw::c_int,
    #[doc = " Audio channel layout.\n - encoding: set by user.\n - decoding: set by user, may be overwritten by libavcodec.\n @deprecated use ch_layout"]
    pub channel_layout: u64,
    #[doc = " Request decoder to use this channel layout if it can (0 for default)\n - encoding: unused\n - decoding: Set by user.\n @deprecated use \"downmix\" codec private option"]
    pub request_channel_layout: u64,
    #[doc = " Type of service that the audio stream conveys.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub audio_service_type: AVAudioServiceType,
    #[doc = " desired sample format\n - encoding: Not used.\n - decoding: Set by user.\n Decoder will decode to this format if it can."]
    pub request_sample_fmt: AVSampleFormat,
    #[doc = " This callback is called at the beginning of each frame to get data\n buffer(s) for it. There may be one contiguous buffer for all the data or\n there may be a buffer per each data plane or anything in between. What\n this means is, you may set however many entries in buf[] you feel necessary.\n Each buffer must be reference-counted using the AVBuffer API (see description\n of buf[] below).\n\n The following fields will be set in the frame before this callback is\n called:\n - format\n - width, height (video only)\n - sample_rate, channel_layout, nb_samples (audio only)\n Their values may differ from the corresponding values in\n AVCodecContext. This callback must use the frame values, not the codec\n context values, to calculate the required buffer size.\n\n This callback must fill the following fields in the frame:\n - data[]\n - linesize[]\n - extended_data:\n   * if the data is planar audio with more than 8 channels, then this\n     callback must allocate and fill extended_data to contain all pointers\n     to all data planes. data[] must hold as many pointers as it can.\n     extended_data must be allocated with av_malloc() and will be freed in\n     av_frame_unref().\n   * otherwise extended_data must point to data\n - buf[] must contain one or more pointers to AVBufferRef structures. Each of\n   the frame's data and extended_data pointers must be contained in these. That\n   is, one AVBufferRef for each allocated chunk of memory, not necessarily one\n   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),\n   and av_buffer_ref().\n - extended_buf and nb_extended_buf must be allocated with av_malloc() by\n   this callback and filled with the extra buffers if there are more\n   buffers than buf[] can hold. extended_buf will be freed in\n   av_frame_unref().\n\n If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call\n avcodec_default_get_buffer2() instead of providing buffers allocated by\n some other means.\n\n Each data plane must be aligned to the maximum required by the target\n CPU.\n\n @see avcodec_default_get_buffer2()\n\n Video:\n\n If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused\n (read and/or written to if it is writable) later by libavcodec.\n\n avcodec_align_dimensions2() should be used to find the required width and\n height, as they normally need to be rounded up to the next multiple of 16.\n\n Some decoders do not support linesizes changing between frames.\n\n If frame multithreading is used, this callback may be called from a\n different thread, but not from more than one at once. Does not need to be\n reentrant.\n\n @see avcodec_align_dimensions2()\n\n Audio:\n\n Decoders request a buffer of a particular size by setting\n AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,\n however, utilize only part of the buffer by setting AVFrame.nb_samples\n to a smaller value in the output frame.\n\n As a convenience, av_samples_get_buffer_size() and\n av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()\n functions to find the required data size and to fill data pointers and\n linesize. In AVFrame.linesize, only linesize[0] may be set for audio\n since all planes must be the same size.\n\n @see av_samples_get_buffer_size(), av_samples_fill_arrays()\n\n - encoding: unused\n - decoding: Set by libavcodec, user can override."]
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            frame: *mut AVFrame,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< amount of qscale change between easy & hard scenes (0.0-1.0)"]
    pub qcompress: f32,
    #[doc = "< amount of qscale smoothing over time (0.0-1.0)"]
    pub qblur: f32,
    #[doc = " minimum quantizer\n - encoding: Set by user.\n - decoding: unused"]
    pub qmin: ::std::os::raw::c_int,
    #[doc = " maximum quantizer\n - encoding: Set by user.\n - decoding: unused"]
    pub qmax: ::std::os::raw::c_int,
    #[doc = " maximum quantizer difference between frames\n - encoding: Set by user.\n - decoding: unused"]
    pub max_qdiff: ::std::os::raw::c_int,
    #[doc = " decoder bitstream buffer size\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_buffer_size: ::std::os::raw::c_int,
    #[doc = " ratecontrol override, see RcOverride\n - encoding: Allocated/set/freed by user.\n - decoding: unused"]
    pub rc_override_count: ::std::os::raw::c_int,
    pub rc_override: *mut RcOverride,
    #[doc = " maximum bitrate\n - encoding: Set by user.\n - decoding: Set by user, may be overwritten by libavcodec."]
    pub rc_max_rate: i64,
    #[doc = " minimum bitrate\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_min_rate: i64,
    #[doc = " Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.\n - encoding: Set by user.\n - decoding: unused."]
    pub rc_max_available_vbv_use: f32,
    #[doc = " Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.\n - encoding: Set by user.\n - decoding: unused."]
    pub rc_min_vbv_overflow_use: f32,
    #[doc = " Number of bits which should be loaded into the rc buffer before decoding starts.\n - encoding: Set by user.\n - decoding: unused"]
    pub rc_initial_buffer_occupancy: ::std::os::raw::c_int,
    #[doc = " trellis RD quantization\n - encoding: Set by user.\n - decoding: unused"]
    pub trellis: ::std::os::raw::c_int,
    #[doc = " pass1 encoding statistics output buffer\n - encoding: Set by libavcodec.\n - decoding: unused"]
    pub stats_out: *mut ::std::os::raw::c_char,
    #[doc = " pass2 encoding statistics input buffer\n Concatenated stuff from stats_out of pass1 should be placed here.\n - encoding: Allocated/set/freed by user.\n - decoding: unused"]
    pub stats_in: *mut ::std::os::raw::c_char,
    #[doc = " Work around bugs in encoders which sometimes cannot be detected automatically.\n - encoding: Set by user\n - decoding: Set by user"]
    pub workaround_bugs: ::std::os::raw::c_int,
    #[doc = " strictly follow the standard (MPEG-4, ...).\n - encoding: Set by user.\n - decoding: Set by user.\n Setting this to STRICT or higher means the encoder and decoder will\n generally do stupid things, whereas setting it to unofficial or lower\n will mean the encoder might produce output that is not supported by all\n spec-compliant decoders. Decoders don't differentiate between normal,\n unofficial and experimental (that is, they always try to decode things\n when they can) unless they are explicitly asked to behave stupidly\n (=strictly conform to the specs)\n This may only be set to one of the FF_COMPLIANCE_* values in defs.h."]
    pub strict_std_compliance: ::std::os::raw::c_int,
    #[doc = " error concealment flags\n - encoding: unused\n - decoding: Set by user."]
    pub error_concealment: ::std::os::raw::c_int,
    #[doc = " debug\n - encoding: Set by user.\n - decoding: Set by user."]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Error recognition; may misdetect some more or less valid parts as errors.\n This is a bitfield of the AV_EF_* values defined in defs.h.\n\n - encoding: Set by user.\n - decoding: Set by user."]
    pub err_recognition: ::std::os::raw::c_int,
    #[doc = " opaque 64-bit number (generally a PTS) that will be reordered and\n output in AVFrame.reordered_opaque\n - encoding: Set by libavcodec to the reordered_opaque of the input\n             frame corresponding to the last returned packet. Only\n             supported by encoders with the\n             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.\n - decoding: Set by user."]
    pub reordered_opaque: i64,
    #[doc = " Hardware accelerator in use\n - encoding: unused.\n - decoding: Set by libavcodec"]
    pub hwaccel: *const AVHWAccel,
    #[doc = " Legacy hardware accelerator context.\n\n For some hardware acceleration methods, the caller may use this field to\n signal hwaccel-specific data to the codec. The struct pointed to by this\n pointer is hwaccel-dependent and defined in the respective header. Please\n refer to the FFmpeg HW accelerator documentation to know how to fill\n this.\n\n In most cases this field is optional - the necessary information may also\n be provided to libavcodec through @ref hw_frames_ctx or @ref\n hw_device_ctx (see avcodec_get_hw_config()). However, in some cases it\n may be the only method of signalling some (optional) information.\n\n The struct and its contents are owned by the caller.\n\n - encoding: May be set by the caller before avcodec_open2(). Must remain\n             valid until avcodec_free_context().\n - decoding: May be set by the caller in the get_format() callback.\n             Must remain valid until the next get_format() call,\n             or avcodec_free_context() (whichever comes first)."]
    pub hwaccel_context: *mut ::std::os::raw::c_void,
    #[doc = " error\n - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.\n - decoding: unused"]
    pub error: [u64; 8usize],
    #[doc = " DCT algorithm, see FF_DCT_* below\n - encoding: Set by user.\n - decoding: unused"]
    pub dct_algo: ::std::os::raw::c_int,
    #[doc = " IDCT algorithm, see FF_IDCT_* below.\n - encoding: Set by user.\n - decoding: Set by user."]
    pub idct_algo: ::std::os::raw::c_int,
    #[doc = " bits per sample/pixel from the demuxer (needed for huffyuv).\n - encoding: Set by libavcodec.\n - decoding: Set by user."]
    pub bits_per_coded_sample: ::std::os::raw::c_int,
    #[doc = " Bits per sample/pixel of internal libavcodec pixel/sample format.\n - encoding: set by user.\n - decoding: set by libavcodec."]
    pub bits_per_raw_sample: ::std::os::raw::c_int,
    #[doc = " low resolution decoding, 1-> 1/2 size, 2->1/4 size\n - encoding: unused\n - decoding: Set by user."]
    pub lowres: ::std::os::raw::c_int,
    #[doc = " thread count\n is used to decide how many independent tasks should be passed to execute()\n - encoding: Set by user.\n - decoding: Set by user."]
    pub thread_count: ::std::os::raw::c_int,
    #[doc = " Which multithreading methods to use.\n Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,\n so clients which cannot provide future frames should not use it.\n\n - encoding: Set by user, otherwise the default is used.\n - decoding: Set by user, otherwise the default is used."]
    pub thread_type: ::std::os::raw::c_int,
    #[doc = " Which multithreading methods are in use by the codec.\n - encoding: Set by libavcodec.\n - decoding: Set by libavcodec."]
    pub active_thread_type: ::std::os::raw::c_int,
    #[doc = " Set by the client if its custom get_buffer() callback can be called\n synchronously from another thread, which allows faster multithreaded decoding.\n draw_horiz_band() will be called from other threads regardless of this setting.\n Ignored if the default get_buffer() is used.\n - encoding: Set by user.\n - decoding: Set by user.\n\n @deprecated the custom get_buffer2() callback should always be\n   thread-safe. Thread-unsafe get_buffer2() implementations will be\n   invalid starting with LIBAVCODEC_VERSION_MAJOR=60; in other words,\n   libavcodec will behave as if this field was always set to 1.\n   Callers that want to be forward compatible with future libavcodec\n   versions should wrap access to this field in\n     #if LIBAVCODEC_VERSION_MAJOR < 60"]
    pub thread_safe_callbacks: ::std::os::raw::c_int,
    #[doc = " The codec may call this to execute several independent things.\n It will return only after finishing all tasks.\n The user may replace this with some multithreaded implementation,\n the default implementation will execute the parts serially.\n @param count the number of things to execute\n - encoding: Set by libavcodec, user can override.\n - decoding: Set by libavcodec, user can override."]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " The codec may call this to execute several independent things.\n It will return only after finishing all tasks.\n The user may replace this with some multithreaded implementation,\n the default implementation will execute the parts serially.\n @param c context passed also to func\n @param count the number of things to execute\n @param arg2 argument passed unchanged to func\n @param ret return values of executed functions, must have space for \"count\" values. May be NULL.\n @param func function that will be called count times, with jobnr from 0 to count-1.\n             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no\n             two instances of func executing at the same time will have the same threadnr.\n @return always 0 currently, but code should handle a future improvement where when any call to func\n         returns < 0 no further calls to func may be done and < 0 is returned.\n - encoding: Set by libavcodec, user can override.\n - decoding: Set by libavcodec, user can override."]
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut ::std::os::raw::c_void,
                    jobnr: ::std::os::raw::c_int,
                    threadnr: ::std::os::raw::c_int,
                ) -> ::std::os::raw::c_int,
            >,
            arg2: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " noise vs. sse weight for the nsse comparison function\n - encoding: Set by user.\n - decoding: unused"]
    pub nsse_weight: ::std::os::raw::c_int,
    #[doc = " profile\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub profile: ::std::os::raw::c_int,
    #[doc = " level\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub level: ::std::os::raw::c_int,
    #[doc = " Skip loop filtering for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_loop_filter: AVDiscard,
    #[doc = " Skip IDCT/dequantization for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_idct: AVDiscard,
    #[doc = " Skip decoding for selected frames.\n - encoding: unused\n - decoding: Set by user."]
    pub skip_frame: AVDiscard,
    #[doc = " Header containing style information for text subtitles.\n For SUBTITLE_ASS subtitle type, it should contain the whole ASS\n [Script Info] and [V4+ Styles] section, plus the [Events] line and\n the Format line following. It shouldn't include any Dialogue line.\n - encoding: Set/allocated/freed by user (before avcodec_open2())\n - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())"]
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: ::std::os::raw::c_int,
    #[doc = " Audio only. The number of \"priming\" samples (padding) inserted by the\n encoder at the beginning of the audio. I.e. this number of leading\n decoded samples must be discarded by the caller to get the original audio\n without leading padding.\n\n - decoding: unused\n - encoding: Set by libavcodec. The timestamps on the output packets are\n             adjusted by the encoder so that they always refer to the\n             first sample of the data actually contained in the packet,\n             including any added padding.  E.g. if the timebase is\n             1/samplerate and the timestamp of the first input sample is\n             0, the timestamp of the first output packet will be\n             -initial_padding."]
    pub initial_padding: ::std::os::raw::c_int,
    #[doc = " - decoding: For codecs that store a framerate value in the compressed\n             bitstream, the decoder may export it here. { 0, 1} when\n             unknown.\n - encoding: May be used to signal the framerate of CFR content to an\n             encoder."]
    pub framerate: AVRational,
    #[doc = " Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.\n - encoding: unused.\n - decoding: Set by libavcodec before calling get_format()"]
    pub sw_pix_fmt: AVPixelFormat,
    #[doc = " Timebase in which pkt_dts/pts and AVPacket.dts/pts are.\n - encoding unused.\n - decoding set by user."]
    pub pkt_timebase: AVRational,
    #[doc = " AVCodecDescriptor\n - encoding: unused.\n - decoding: set by libavcodec."]
    pub codec_descriptor: *const AVCodecDescriptor,
    #[doc = " Current statistics for PTS correction.\n - decoding: maintained and used by libavcodec, not intended to be used by user apps\n - encoding: unused"]
    pub pts_correction_num_faulty_pts: i64,
    #[doc = " Number of incorrect PTS values so far"]
    pub pts_correction_num_faulty_dts: i64,
    #[doc = " Number of incorrect DTS values so far"]
    pub pts_correction_last_pts: i64,
    #[doc = " PTS of the last frame"]
    pub pts_correction_last_dts: i64,
    #[doc = " Character encoding of the input subtitles file.\n - decoding: set by user\n - encoding: unused"]
    pub sub_charenc: *mut ::std::os::raw::c_char,
    #[doc = " Subtitles character encoding mode. Formats or codecs might be adjusting\n this setting (if they are doing the conversion themselves for instance).\n - decoding: set by libavcodec\n - encoding: unused"]
    pub sub_charenc_mode: ::std::os::raw::c_int,
    #[doc = " Skip processing alpha if supported by codec.\n Note that if the format uses pre-multiplied alpha (common with VP6,\n and recommended due to better video quality/compression)\n the image will look as if alpha-blended onto a black background.\n However for formats that do not use pre-multiplied alpha\n there might be serious artefacts (though e.g. libswscale currently\n assumes pre-multiplied alpha anyway).\n\n - decoding: set by user\n - encoding: unused"]
    pub skip_alpha: ::std::os::raw::c_int,
    #[doc = " Number of samples to skip after a discontinuity\n - decoding: unused\n - encoding: set by libavcodec"]
    pub seek_preroll: ::std::os::raw::c_int,
    #[doc = " @deprecated unused"]
    pub debug_mv: ::std::os::raw::c_int,
    #[doc = " custom intra quantization matrix\n - encoding: Set by user, can be NULL.\n - decoding: unused."]
    pub chroma_intra_matrix: *mut u16,
    #[doc = " dump format separator.\n can be \", \" or \"\\n      \" or anything else\n - encoding: Set by user.\n - decoding: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " ',' separated list of allowed decoders.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " Properties of the stream that gets decoded\n - encoding: unused\n - decoding: set by libavcodec"]
    pub properties: ::std::os::raw::c_uint,
    #[doc = " Additional data associated with the entire coded stream.\n\n - decoding: unused\n - encoding: may be set by libavcodec after avcodec_open2()."]
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: ::std::os::raw::c_int,
    #[doc = " A reference to the AVHWFramesContext describing the input (for encoding)\n or output (decoding) frames. The reference is set by the caller and\n afterwards owned (and freed) by libavcodec - it should never be read by\n the caller after being set.\n\n - decoding: This field should be set by the caller from the get_format()\n             callback. The previous reference (if any) will always be\n             unreffed by libavcodec before the get_format() call.\n\n             If the default get_buffer2() is used with a hwaccel pixel\n             format, then this AVHWFramesContext will be used for\n             allocating the frame buffers.\n\n - encoding: For hardware encoders configured to use a hwaccel pixel\n             format, this field should be set by the caller to a reference\n             to the AVHWFramesContext describing input frames.\n             AVHWFramesContext.format must be equal to\n             AVCodecContext.pix_fmt.\n\n             This field should be set before avcodec_open2() is called."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " @deprecated unused"]
    pub sub_text_format: ::std::os::raw::c_int,
    #[doc = " Audio only. The amount of padding (in samples) appended by the encoder to\n the end of the audio. I.e. this number of decoded samples must be\n discarded by the caller from the end of the stream to get the original\n audio without any trailing padding.\n\n - decoding: unused\n - encoding: unused"]
    pub trailing_padding: ::std::os::raw::c_int,
    #[doc = " The number of pixels per image to maximally accept.\n\n - decoding: set by user\n - encoding: set by user"]
    pub max_pixels: i64,
    #[doc = " A reference to the AVHWDeviceContext describing the device which will\n be used by a hardware encoder/decoder.  The reference is set by the\n caller and afterwards owned (and freed) by libavcodec.\n\n This should be used if either the codec device does not require\n hardware frames or any that are used are to be allocated internally by\n libavcodec.  If the user wishes to supply any of the frames used as\n encoder input or decoder output then hw_frames_ctx should be used\n instead.  When hw_frames_ctx is set in get_format() for a decoder, this\n field will be ignored while decoding the associated stream segment, but\n may again be used on a following one after another get_format() call.\n\n For both encoders and decoders this field should be set before\n avcodec_open2() is called and must not be written to thereafter.\n\n Note that some decoders may require this field to be set initially in\n order to support hw_frames_ctx at all - in that case, all frames\n contexts used must be created on the same device."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated\n decoding (if active).\n - encoding: unused\n - decoding: Set by user (either before avcodec_open2(), or in the\n             AVCodecContext.get_format callback)"]
    pub hwaccel_flags: ::std::os::raw::c_int,
    #[doc = " Video decoding only. Certain video codecs support cropping, meaning that\n only a sub-rectangle of the decoded frame is intended for display.  This\n option controls how cropping is handled by libavcodec.\n\n When set to 1 (the default), libavcodec will apply cropping internally.\n I.e. it will modify the output frame width/height fields and offset the\n data pointers (only by as much as possible while preserving alignment, or\n by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that\n the frames output by the decoder refer only to the cropped area. The\n crop_* fields of the output frames will be zero.\n\n When set to 0, the width/height fields of the output frames will be set\n to the coded dimensions and the crop_* fields will describe the cropping\n rectangle. Applying the cropping is left to the caller.\n\n @warning When hardware acceleration with opaque output frames is used,\n libavcodec is unable to apply cropping from the top/left border.\n\n @note when this option is set to zero, the width/height fields of the\n AVCodecContext and output AVFrames have different meanings. The codec\n context fields store display dimensions (with the coded dimensions in\n coded_width/height), while the frame fields store the coded dimensions\n (with the display dimensions being determined by the crop_* fields)."]
    pub apply_cropping: ::std::os::raw::c_int,
    pub extra_hw_frames: ::std::os::raw::c_int,
    #[doc = " The percentage of damaged samples to discard a frame.\n\n - decoding: set by user\n - encoding: unused"]
    pub discard_damaged_percentage: ::std::os::raw::c_int,
    #[doc = " The number of samples per frame to maximally accept.\n\n - decoding: set by user\n - encoding: set by user"]
    pub max_samples: i64,
    #[doc = " Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of\n metadata exported in frame, packet, or coded stream side data by\n decoders and encoders.\n\n - decoding: set by user\n - encoding: set by user"]
    pub export_side_data: ::std::os::raw::c_int,
    #[doc = " This callback is called at the beginning of each packet to get a data\n buffer for it.\n\n The following field will be set in the packet before this callback is\n called:\n - size\n This callback must use the above value to calculate the required buffer size,\n which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes.\n\n In some specific cases, the encoder may not use the entire buffer allocated by this\n callback. This will be reflected in the size value in the packet once returned by\n avcodec_receive_packet().\n\n This callback must fill the following fields in the packet:\n - data: alignment requirements for AVPacket apply, if any. Some architectures and\n   encoders may benefit from having aligned data.\n - buf: must contain a pointer to an AVBufferRef structure. The packet's\n   data pointer must be contained in it. See: av_buffer_create(), av_buffer_alloc(),\n   and av_buffer_ref().\n\n If AV_CODEC_CAP_DR1 is not set then get_encode_buffer() must call\n avcodec_default_get_encode_buffer() instead of providing a buffer allocated by\n some other means.\n\n The flags field may contain a combination of AV_GET_ENCODE_BUFFER_FLAG_ flags.\n They may be used for example to hint what use the buffer may get after being\n created.\n Implementations of this callback may ignore flags they don't understand.\n If AV_GET_ENCODE_BUFFER_FLAG_REF is set in flags then the packet may be reused\n (read and/or written to if it is writable) later by libavcodec.\n\n This callback must be thread-safe, as when frame threading is used, it may\n be called from multiple threads simultaneously.\n\n @see avcodec_default_get_encode_buffer()\n\n - encoding: Set by libavcodec, user can override.\n - decoding: unused"]
    pub get_encode_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            pkt: *mut AVPacket,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Audio channel layout.\n - encoding: must be set by the caller, to one of AVCodec.ch_layouts.\n - decoding: may be set by the caller if known e.g. from the container.\n             The decoder can then override during decoding as needed."]
    pub ch_layout: AVChannelLayout,
}
#[doc = " @defgroup lavc_hwaccel AVHWAccel\n\n @note  Nothing in this structure should be accessed by the user.  At some\n        point in future it will not be externally visible at all.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHWAccel {
    #[doc = " Name of the hardware accelerated codec.\n The name is globally unique among encoders and among decoders (but an\n encoder and a decoder can share the same name)."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Type of codec implemented by the hardware accelerator.\n\n See AVMEDIA_TYPE_xxx"]
    pub type_: AVMediaType,
    #[doc = " Codec implemented by the hardware accelerator.\n\n See AV_CODEC_ID_xxx"]
    pub id: AVCodecID,
    #[doc = " Supported pixel format.\n\n Only hardware accelerated formats are supported here."]
    pub pix_fmt: AVPixelFormat,
    #[doc = " Hardware accelerated codec capabilities.\n see AV_HWACCEL_CODEC_CAP_*"]
    pub capabilities: ::std::os::raw::c_int,
    #[doc = " Allocate a custom buffer"]
    pub alloc_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            frame: *mut AVFrame,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called at the beginning of each frame or field picture.\n\n Meaningful frame information (codec specific) is guaranteed to\n be parsed at this point. This function is mandatory.\n\n Note that buf can be NULL along with buf_size set to 0.\n Otherwise, this means the whole frame is available at this point.\n\n @param avctx the codec context\n @param buf the frame data buffer base\n @param buf_size the size of the frame in bytes\n @return zero if successful, a negative value otherwise"]
    pub start_frame: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Callback for parameter data (SPS/PPS/VPS etc).\n\n Useful for hardware decoders which keep persistent state about the\n video parameters, and need to receive any changes to update that state.\n\n @param avctx the codec context\n @param type the nal unit type\n @param buf the nal unit data buffer\n @param buf_size the size of the nal unit in bytes\n @return zero if successful, a negative value otherwise"]
    pub decode_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            type_: ::std::os::raw::c_int,
            buf: *const u8,
            buf_size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Callback for each slice.\n\n Meaningful slice information (codec specific) is guaranteed to\n be parsed at this point. This function is mandatory.\n\n @param avctx the codec context\n @param buf the slice data buffer base\n @param buf_size the size of the slice in bytes\n @return zero if successful, a negative value otherwise"]
    pub decode_slice: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called at the end of each frame or field picture.\n\n The whole picture is parsed at this point and can now be sent\n to the hardware accelerator. This function is mandatory.\n\n @param avctx the codec context\n @return zero if successful, a negative value otherwise"]
    pub end_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Size of per-frame hardware accelerator private data.\n\n Private data is allocated with av_mallocz() before\n AVCodecContext.get_buffer() and deallocated after\n AVCodecContext.release_buffer()."]
    pub frame_priv_data_size: ::std::os::raw::c_int,
    #[doc = " Initialize the hwaccel private data.\n\n This will be called from ff_get_format(), after hwaccel and\n hwaccel_context are set and the hwaccel private data in AVCodecInternal\n is allocated."]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Uninitialize the hwaccel private data.\n\n This will be called from get_format() or avcodec_close(), after hwaccel\n and hwaccel_context are already uninitialized."]
    pub uninit: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Size of the private data to allocate in\n AVCodecInternal.hwaccel_priv_data."]
    pub priv_data_size: ::std::os::raw::c_int,
    #[doc = " Internal hwaccel capabilities."]
    pub caps_internal: ::std::os::raw::c_int,
    #[doc = " Fill the given hw_frames context with current codec parameters. Called\n from get_format. Refer to avcodec_get_hw_frames_parameters() for\n details.\n\n This CAN be called before AVHWAccel.init is called, and you must assume\n that avctx->hwaccel_priv_data is invalid."]
    pub frame_params: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            hw_frames_ctx: *mut AVBufferRef,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(i32)]
#[doc = " @}"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVSubtitleType {
    SUBTITLE_NONE = 0,
    #[doc = "< A bitmap, pict will be set"]
    SUBTITLE_BITMAP = 1,
    #[doc = " Plain text, the text field must be set by the decoder and is\n authoritative. ass and pict fields may contain approximations."]
    SUBTITLE_TEXT = 2,
    #[doc = " Formatted text, the ass field must be set by the decoder and is\n authoritative. pict and text fields may contain approximations."]
    SUBTITLE_ASS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitleRect {
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< top left corner  of pict, undefined when pict is not set"]
    pub y: ::std::os::raw::c_int,
    #[doc = "< width            of pict, undefined when pict is not set"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< height           of pict, undefined when pict is not set"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< number of colors in pict, undefined when pict is not set"]
    pub nb_colors: ::std::os::raw::c_int,
    #[doc = " data+linesize for the bitmap of this subtitle.\n Can be set for text/ass as well once they are rendered."]
    pub data: [*mut u8; 4usize],
    pub linesize: [::std::os::raw::c_int; 4usize],
    pub type_: AVSubtitleType,
    #[doc = "< 0 terminated plain UTF-8 text"]
    pub text: *mut ::std::os::raw::c_char,
    #[doc = " 0 terminated ASS/SSA compatible event line.\n The presentation of this is unaffected by the other values in this\n struct."]
    pub ass: *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: ::std::os::raw::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    #[doc = "< Same as packet pts, in AV_TIME_BASE"]
    pub pts: i64,
}
extern "C" {
    #[doc = " Return the LIBAVCODEC_VERSION_INT constant."]
    pub fn avcodec_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavcodec build-time configuration."]
    pub fn avcodec_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavcodec license."]
    pub fn avcodec_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocate an AVCodecContext and set its fields to default values. The\n resulting struct should be freed with avcodec_free_context().\n\n @param codec if non-NULL, allocate private data and initialize defaults\n              for the given codec. It is illegal to then call avcodec_open2()\n              with a different codec.\n              If NULL, then the codec-specific defaults won't be initialized,\n              which may result in suboptimal default settings (this is\n              important mainly for encoders, e.g. libx264).\n\n @return An AVCodecContext filled with default values or NULL on failure."]
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    #[doc = " Free the codec context and everything associated with it and write NULL to\n the provided pointer."]
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVCodecContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " @deprecated This function should not be used."]
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Get the AVClass for AVSubtitleRect. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Fill the parameters struct based on the values from the supplied codec\n context. Any allocated fields in par are freed and replaced with duplicates\n of the corresponding fields in codec.\n\n @return >= 0 on success, a negative AVERROR code on failure"]
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill the codec context based on the values from the supplied codec\n parameters. Any allocated fields in codec that have a corresponding field in\n par are freed and replaced with duplicates of the corresponding field in par.\n Fields in codec that do not have a counterpart in par are not touched.\n\n @return >= 0 on success, a negative AVERROR code on failure."]
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the AVCodecContext to use the given AVCodec. Prior to using this\n function the context has to be allocated with avcodec_alloc_context3().\n\n The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),\n avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for\n retrieving a codec.\n\n @note Always call this function before using decoding routines (such as\n @ref avcodec_receive_frame()).\n\n @code\n av_dict_set(&opts, \"b\", \"2.5M\", 0);\n codec = avcodec_find_decoder(AV_CODEC_ID_H264);\n if (!codec)\n     exit(1);\n\n context = avcodec_alloc_context3(codec);\n\n if (avcodec_open2(context, codec, opts) < 0)\n     exit(1);\n @endcode\n\n @param avctx The context to initialize.\n @param codec The codec to open this context for. If a non-NULL codec has been\n              previously passed to avcodec_alloc_context3() or\n              for this context, then this parameter MUST be either NULL or\n              equal to the previously passed codec.\n @param options A dictionary filled with AVCodecContext and codec-private options.\n                On return this object will be filled with options that were not found.\n\n @return zero on success, a negative value on error\n @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),\n      av_dict_set(), av_opt_find()."]
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a given AVCodecContext and free all the data associated with it\n (but not the AVCodecContext itself).\n\n Calling this function on an AVCodecContext that hasn't been opened will free\n the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL\n codec. Subsequent calls will do nothing.\n\n @note Do not use this function. Use avcodec_free_context() to destroy a\n codec context (either open or closed). Opening and closing a codec context\n multiple times is not supported anymore -- use multiple codec contexts\n instead."]
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all allocated data in the given subtitle struct.\n\n @param sub AVSubtitle to free."]
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_buffer2(). It is made public so\n it can be called by custom get_buffer2() implementations for decoders without\n AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The default callback for AVCodecContext.get_encode_buffer(). It is made public so\n it can be called by custom get_encode_buffer() implementations for encoders without\n AV_CODEC_CAP_DR1 set."]
    pub fn avcodec_default_get_encode_buffer(
        s: *mut AVCodecContext,
        pkt: *mut AVPacket,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory\n buffer that is acceptable for the codec if you do not use any horizontal\n padding.\n\n May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Modify width and height values so that they will result in a memory\n buffer that is acceptable for the codec if you also ensure that all\n line sizes are a multiple of the respective linesize_align[i].\n\n May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."]
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        linesize_align: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Converts AVChromaLocation to swscale x/y chroma position.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position\n @deprecated Use av_chroma_location_enum_to_pos() instead."]
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        pos: AVChromaLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts swscale x/y chroma position to AVChromaLocation.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position\n @deprecated Use av_chroma_location_pos_to_enum() instead."]
    pub fn avcodec_chroma_pos_to_enum(
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    #[doc = " Decode a subtitle message.\n Return a negative value on error, otherwise return the number of bytes used.\n If no subtitle could be decompressed, got_sub_ptr is zero.\n Otherwise, the subtitle is stored in *sub.\n Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for\n simplicity, because the performance difference is expected to be negligible\n and reusing a get_buffer written for video codecs would probably perform badly\n due to a potentially very different allocation pattern.\n\n Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n and output. This means that for some packets they will not immediately\n produce decoded output and need to be flushed at the end of decoding to get\n all the decoded data. Flushing is done by calling this function with packets\n with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n returning subtitles. It is safe to flush even those decoders that are not\n marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n before packets may be fed to the decoder.\n\n @param avctx the codec context\n @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,\n                 must be freed with avsubtitle_free if *got_sub_ptr is set.\n @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.\n @param[in] avpkt The input AVPacket containing the input buffer."]
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut ::std::os::raw::c_int,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Supply raw packet data as input to a decoder.\n\n Internally, this call will copy relevant AVCodecContext fields, which can\n influence decoding per-packet, and apply them when the packet is actually\n decoded. (For example AVCodecContext.skip_frame, which might direct the\n decoder to drop the frame contained by the packet sent with this function.)\n\n @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n          larger than the actual read bytes because some optimized bitstream\n          readers read 32 or 64 bits at once and could read over the end.\n\n @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n       before packets may be fed to the decoder.\n\n @param avctx codec context\n @param[in] avpkt The input AVPacket. Usually, this will be a single video\n                  frame, or several complete audio frames.\n                  Ownership of the packet remains with the caller, and the\n                  decoder will not write to the packet. The decoder may create\n                  a reference to the packet data (or copy it if the packet is\n                  not reference-counted).\n                  Unlike with older APIs, the packet is always fully consumed,\n                  and if it contains multiple frames (e.g. some audio codecs),\n                  will require you to call avcodec_receive_frame() multiple\n                  times afterwards before you can send a new packet.\n                  It can be NULL (or an AVPacket with data set to NULL and\n                  size set to 0); in this case, it is considered a flush\n                  packet, which signals the end of the stream. Sending the\n                  first flush packet will return success. Subsequent ones are\n                  unnecessary and will return AVERROR_EOF. If the decoder\n                  still has frames buffered, it will return them after sending\n                  a flush packet.\n\n @return 0 on success, otherwise negative error code:\n      AVERROR(EAGAIN):   input is not accepted in the current state - user\n                         must read output with avcodec_receive_frame() (once\n                         all output is read, the packet should be resent, and\n                         the call will not fail with EAGAIN).\n      AVERROR_EOF:       the decoder has been flushed, and no new packets can\n                         be sent to it (also returned if more than 1 flush\n                         packet is sent)\n      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush\n      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar\n      other errors: legitimate decoding errors"]
    pub fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return decoded output data from a decoder or encoder (when the\n AV_CODEC_FLAG_RECON_FRAME flag is used).\n\n @param avctx codec context\n @param frame This will be set to a reference-counted video or audio\n              frame (depending on the decoder type) allocated by the\n              codec. Note that the function will always call\n              av_frame_unref(frame) before doing anything else.\n\n @return\n      0:                 success, a frame was returned\n      AVERROR(EAGAIN):   output is not available in this state - user must try\n                         to send new input\n      AVERROR_EOF:       the codec has been fully flushed, and there will be\n                         no more output frames\n      AVERROR(EINVAL):   codec not opened, or it is an encoder without\n                         the AV_CODEC_FLAG_RECON_FRAME flag enabled\n      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters\n                               with respect to first decoded frame. Applicable\n                               when flag AV_CODEC_FLAG_DROPCHANGED is set.\n      other negative values: legitimate decoding errors"]
    pub fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()\n to retrieve buffered output packets.\n\n @param avctx     codec context\n @param[in] frame AVFrame containing the raw audio or video frame to be encoded.\n                  Ownership of the frame remains with the caller, and the\n                  encoder will not write to the frame. The encoder may create\n                  a reference to the frame data (or copy it if the frame is\n                  not reference-counted).\n                  It can be NULL, in which case it is considered a flush\n                  packet.  This signals the end of the stream. If the encoder\n                  still has packets buffered, it will return them after this\n                  call. Once flushing mode has been entered, additional flush\n                  packets are ignored, and sending frames will return\n                  AVERROR_EOF.\n\n                  For audio:\n                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n                  can have any number of samples.\n                  If it is not set, frame->nb_samples must be equal to\n                  avctx->frame_size for all frames except the last.\n                  The final frame may be smaller than avctx->frame_size.\n @return 0 on success, otherwise negative error code:\n      AVERROR(EAGAIN):   input is not accepted in the current state - user\n                         must read output with avcodec_receive_packet() (once\n                         all output is read, the packet should be resent, and\n                         the call will not fail with EAGAIN).\n      AVERROR_EOF:       the encoder has been flushed, and no new frames can\n                         be sent to it\n      AVERROR(EINVAL):   codec not opened, it is a decoder, or requires flush\n      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar\n      other errors: legitimate encoding errors"]
    pub fn avcodec_send_frame(
        avctx: *mut AVCodecContext,
        frame: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read encoded data from the encoder.\n\n @param avctx codec context\n @param avpkt This will be set to a reference-counted packet allocated by the\n              encoder. Note that the function will always call\n              av_packet_unref(avpkt) before doing anything else.\n @return 0 on success, otherwise negative error code:\n      AVERROR(EAGAIN):   output is not available in the current state - user\n                         must try to send input\n      AVERROR_EOF:       the encoder has been fully flushed, and there will be\n                         no more output packets\n      AVERROR(EINVAL):   codec not opened, or it is a decoder\n      other errors: legitimate encoding errors"]
    pub fn avcodec_receive_packet(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and return a AVHWFramesContext with values adequate for hardware\n decoding. This is meant to get called from the get_format callback, and is\n a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.\n This API is for decoding with certain hardware acceleration modes/APIs only.\n\n The returned AVHWFramesContext is not initialized. The caller must do this\n with av_hwframe_ctx_init().\n\n Calling this function is not a requirement, but makes it simpler to avoid\n codec or hardware API specific details when manually allocating frames.\n\n Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,\n which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes\n it unnecessary to call this function or having to care about\n AVHWFramesContext initialization at all.\n\n There are a number of requirements for calling this function:\n\n - It must be called from get_format with the same avctx parameter that was\n   passed to get_format. Calling it outside of get_format is not allowed, and\n   can trigger undefined behavior.\n - The function is not always supported (see description of return values).\n   Even if this function returns successfully, hwaccel initialization could\n   fail later. (The degree to which implementations check whether the stream\n   is actually supported varies. Some do this check only after the user's\n   get_format callback returns.)\n - The hw_pix_fmt must be one of the choices suggested by get_format. If the\n   user decides to use a AVHWFramesContext prepared with this API function,\n   the user must return the same hw_pix_fmt from get_format.\n - The device_ref passed to this function must support the given hw_pix_fmt.\n - After calling this API function, it is the user's responsibility to\n   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),\n   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done\n   before returning from get_format (this is implied by the normal\n   AVCodecContext.hw_frames_ctx API rules).\n - The AVHWFramesContext parameters may change every time time get_format is\n   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So\n   you are inherently required to go through this process again on every\n   get_format call.\n - It is perfectly possible to call this function without actually using\n   the resulting AVHWFramesContext. One use-case might be trying to reuse a\n   previously initialized AVHWFramesContext, and calling this API function\n   only to test whether the required frame parameters have changed.\n - Fields that use dynamically allocated values of any kind must not be set\n   by the user unless setting them is explicitly allowed by the documentation.\n   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,\n   the new free callback must call the potentially set previous free callback.\n   This API call may set any dynamically allocated fields, including the free\n   callback.\n\n The function will set at least the following fields on AVHWFramesContext\n (potentially more, depending on hwaccel API):\n\n - All fields set by av_hwframe_ctx_alloc().\n - Set the format field to hw_pix_fmt.\n - Set the sw_format field to the most suited and most versatile format. (An\n   implication is that this will prefer generic formats over opaque formats\n   with arbitrary restrictions, if possible.)\n - Set the width/height fields to the coded frame size, rounded up to the\n   API-specific minimum alignment.\n - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size\n   field to the number of maximum reference surfaces possible with the codec,\n   plus 1 surface for the user to work (meaning the user can safely reference\n   at most 1 decoded surface at a time), plus additional buffering introduced\n   by frame threading. If the hwaccel does not require pre-allocation, the\n   field is left to 0, and the decoder will allocate new surfaces on demand\n   during decoding.\n - Possibly AVHWFramesContext.hwctx fields, depending on the underlying\n   hardware API.\n\n Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but\n with basic frame parameters set.\n\n The function is stateless, and does not change the AVCodecContext or the\n device_ref AVHWDeviceContext.\n\n @param avctx The context which is currently calling get_format, and which\n              implicitly contains all state needed for filling the returned\n              AVHWFramesContext properly.\n @param device_ref A reference to the AVHWDeviceContext describing the device\n                   which will be used by the hardware decoder.\n @param hw_pix_fmt The hwaccel format you are going to return from get_format.\n @param out_frames_ref On success, set to a reference to an _uninitialized_\n                       AVHWFramesContext, created from the given device_ref.\n                       Fields will be set to values required for decoding.\n                       Not changed if an error is returned.\n @return zero on success, a negative value on error. The following error codes\n         have special semantics:\n      AVERROR(ENOENT): the decoder does not support this functionality. Setup\n                       is always manual, or it is a decoder which does not\n                       support setting AVCodecContext.hw_frames_ctx at all,\n                       or it is a software format.\n      AVERROR(EINVAL): it is known that hardware decoding is not supported for\n                       this configuration, or the device_ref is not supported\n                       for the hwaccel referenced by hw_pix_fmt."]
    pub fn avcodec_get_hw_frames_parameters(
        avctx: *mut AVCodecContext,
        device_ref: *mut AVBufferRef,
        hw_pix_fmt: AVPixelFormat,
        out_frames_ref: *mut *mut AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @defgroup lavc_parsing Frame parsing\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVPictureStructure {
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    AV_PICTURE_STRUCTURE_FRAME = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParserContext {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub parser: *const AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: ::std::os::raw::c_int,
    #[doc = " This field is used for proper frame duration computation in lavf.\n It signals, how much longer the frame duration of the current frame\n is compared to normal frame duration.\n\n frame_duration = (1 + repeat_pict) * time_base\n\n It is used by codecs like H.264 to display telecined material."]
    pub repeat_pict: ::std::os::raw::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: ::std::os::raw::c_int,
    pub cur_frame_start_index: ::std::os::raw::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: ::std::os::raw::c_int,
    #[doc = "< byte offset from starting packet start"]
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    #[doc = " Set by parser to 1 for key frames and 0 for non-key frames.\n It is initialized to -1, so if the parser doesn't set this flag,\n old-style fallback using AV_PICTURE_TYPE_I picture type as key frames\n will be used."]
    pub key_frame: ::std::os::raw::c_int,
    #[doc = " Synchronization point for start of timestamp generation.\n\n Set to >0 for sync point, 0 for no sync point and <0 for undefined\n (default).\n\n For example, this corresponds to presence of H.264 buffering period\n SEI message."]
    pub dts_sync_point: ::std::os::raw::c_int,
    #[doc = " Offset of the current timestamp against last timestamp sync point in\n units of AVCodecContext.time_base.\n\n Set to INT_MIN when dts_sync_point unused. Otherwise, it must\n contain a valid timestamp offset.\n\n Note that the timestamp of sync point has usually a nonzero\n dts_ref_dts_delta, which refers to the previous sync point. Offset of\n the next frame after timestamp sync point will be usually 1.\n\n For example, this corresponds to H.264 cpb_removal_delay."]
    pub dts_ref_dts_delta: ::std::os::raw::c_int,
    #[doc = " Presentation delay of current frame in units of AVCodecContext.time_base.\n\n Set to INT_MIN when dts_sync_point unused. Otherwise, it must\n contain valid non-negative timestamp delta (presentation time of a frame\n must not lie in the past).\n\n This delay represents the difference between decoding and presentation\n time of the frame.\n\n For example, this corresponds to H.264 dpb_output_delay."]
    pub pts_dts_delta: ::std::os::raw::c_int,
    #[doc = " Position of the packet in file.\n\n Analogous to cur_frame_pts/dts"]
    pub cur_frame_pos: [i64; 4usize],
    #[doc = " Byte position of currently parsed frame in stream."]
    pub pos: i64,
    #[doc = " Previous frame byte position."]
    pub last_pos: i64,
    #[doc = " Duration of the current frame.\n For audio, this is in units of 1 / AVCodecContext.sample_rate.\n For all other types, this is in units of AVCodecContext.time_base."]
    pub duration: ::std::os::raw::c_int,
    pub field_order: AVFieldOrder,
    #[doc = " Indicate whether a picture is coded as a frame, top field or bottom field.\n\n For example, H.264 field_pic_flag equal to 0 corresponds to\n AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag\n equal to 1 and bottom_field_flag equal to 0 corresponds to\n AV_PICTURE_STRUCTURE_TOP_FIELD."]
    pub picture_structure: AVPictureStructure,
    #[doc = " Picture number incremented in presentation or output order.\n This field may be reinitialized at the first picture of a new sequence.\n\n For example, this corresponds to H.264 PicOrderCnt."]
    pub output_picture_number: ::std::os::raw::c_int,
    #[doc = " Dimensions of the decoded video intended for presentation."]
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    #[doc = " Dimensions of the coded video."]
    pub coded_width: ::std::os::raw::c_int,
    pub coded_height: ::std::os::raw::c_int,
    #[doc = " The format of the coded data, corresponds to enum AVPixelFormat for video\n and for enum AVSampleFormat for audio.\n\n Note that a decoder can have considerable freedom in how exactly it\n decodes the data, so the format reported here might be different from the\n one returned by a decoder."]
    pub format: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecParser {
    pub codec_ids: [::std::os::raw::c_int; 7usize],
    pub priv_data_size: ::std::os::raw::c_int,
    pub parser_init: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecParserContext) -> ::std::os::raw::c_int,
    >,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut ::std::os::raw::c_int,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            buf: *const u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    #[doc = " Iterate over all registered codec parsers.\n\n @param opaque a pointer where libavcodec will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered codec parser or NULL when the iteration is\n         finished"]
    pub fn av_parser_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVCodecParser;
}
extern "C" {
    pub fn av_parser_init(codec_id: ::std::os::raw::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    #[doc = " Parse a packet.\n\n @param s             parser context.\n @param avctx         codec context.\n @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.\n @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.\n @param buf           input buffer.\n @param buf_size      buffer size in bytes without the padding. I.e. the full buffer\nsize is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.\nTo signal EOF, this should be 0 (so that the last frame\ncan be output).\n @param pts           input presentation timestamp.\n @param dts           input decoding timestamp.\n @param pos           input byte position in stream.\n @return the number of bytes of the input bitstream used.\n\n Example:\n @code\n   while(in_len){\n       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,\n                                        in_data, in_len,\n                                        pts, dts, pos);\n       in_data += len;\n       in_len  -= len;\n\n       if(size)\n          decode_frame(data, size);\n   }\n @endcode"]
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut ::std::os::raw::c_int,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    #[doc = " @addtogroup lavc_encoding\n @{"]
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: ::std::os::raw::c_int,
        sub: *const AVSubtitle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a value representing the fourCC code associated to the\n pixel format pix_fmt, or 0 if no associated fourCC code can be\n found."]
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Find the best pixel format to convert to given a certain source pixel\n format.  When converting from one pixel format to another, information loss\n may occur.  For example, when converting from RGB24 to GRAY, the color\n information will be lost. Similarly, other losses occur when converting from\n some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of\n the given pixel formats should be used to suffer the least amount of loss.\n The pixel formats from which it chooses one, are determined by the\n pix_fmt_list parameter.\n\n\n @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.\n @return The best pixel format to convert to or -1 if none was found."]
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " @}"]
    pub fn avcodec_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        enc: *mut AVCodecContext,
        encode: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut ::std::os::raw::c_void,
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill AVFrame audio data and linesize pointers.\n\n The buffer buf must be a preallocated buffer with a size big enough\n to contain the specified samples amount. The filled AVFrame data\n pointers will point to this buffer.\n\n AVFrame extended_data channel pointers are allocated if necessary for\n planar audio.\n\n @param frame       the AVFrame\n                    frame->nb_samples must be set prior to calling the\n                    function. This function fills in frame->data,\n                    frame->extended_data, frame->linesize[0].\n @param nb_channels channel count\n @param sample_fmt  sample format\n @param buf         buffer to use for frame data\n @param buf_size    size of buffer\n @param align       plane size sample alignment (0 = default)\n @return            >=0 on success, negative error code on failure\n @todo return the size in bytes required to store the samples in\n case of success, at the next libavutil bump"]
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the internal codec state / flush internal buffers. Should be called\n e.g. when seeking or when switching to a different stream.\n\n @note for decoders, this function just releases any references the decoder\n might keep internally, but the caller's references remain valid.\n\n @note for encoders, this function will only do something if the encoder\n declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder\n will drain any remaining packets, and can then be re-used for a different\n stream (as opposed to sending a null frame which will leave the encoder\n in a permanent EOF state after draining). This can be desirable if the\n cost of tearing down and replacing the encoder instance is high."]
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    #[doc = " Return audio frame duration.\n\n @param avctx        codec context\n @param frame_bytes  size of the frame, or 0 if unknown\n @return             frame duration, in samples, if known. 0 if not able to\n                     determine."]
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same behaviour av_fast_malloc but the buffer has additional\n AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.\n\n In addition the whole buffer will initially and after resizes\n be 0-initialized so that no uninitialized data will ever appear."]
    pub fn av_fast_padded_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Same behaviour av_fast_padded_malloc except that buffer will always\n be 0-initialized after call."]
    pub fn av_fast_padded_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " @return a positive value if s is open (i.e. avcodec_open2() was called on it\n with no corresponding avcodec_close()), 0 otherwise."]
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut u16;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut u16, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime32_s(_Buffer: *mut u16, _SizeInWords: usize, _Time: *const __time32_t)
        -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime64_s(_Buffer: *mut u16, _SizeInWords: usize, _Time: *const __time64_t)
        -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut u16) -> *mut u16;
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
extern "C" {
    pub fn __daylight() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxSize: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(
        _Ts: *mut _timespec32,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _timespec64_get(
        _Ts: *mut _timespec64,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(
        _Tm: *mut tm,
        _Milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tzset();
}
#[doc = " Callback for checking whether to abort blocking functions.\n AVERROR_EXIT is returned in this case by the interrupted\n function. During blocking operations, callback is called with\n opaque as parameter. If the callback returns 1, the\n blocking operation will be aborted.\n\n No members can be added to this struct without a major bump, if\n new elements have been added after this struct in AVFormatContext\n or AVIOContext."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOInterruptCB {
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(i32)]
#[doc = " Directory entry types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVIODirEntryType {
    AVIO_ENTRY_UNKNOWN = 0,
    AVIO_ENTRY_BLOCK_DEVICE = 1,
    AVIO_ENTRY_CHARACTER_DEVICE = 2,
    AVIO_ENTRY_DIRECTORY = 3,
    AVIO_ENTRY_NAMED_PIPE = 4,
    AVIO_ENTRY_SYMBOLIC_LINK = 5,
    AVIO_ENTRY_SOCKET = 6,
    AVIO_ENTRY_FILE = 7,
    AVIO_ENTRY_SERVER = 8,
    AVIO_ENTRY_SHARE = 9,
    AVIO_ENTRY_WORKGROUP = 10,
}
#[doc = " Describes single entry of the directory.\n\n Only name and type fields are guaranteed be set.\n Rest of fields are protocol or/and platform dependent and might be unknown."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirEntry {
    #[doc = "< Filename"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Type of the entry"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< Set to 1 when name is encoded with UTF-8, 0 otherwise.\nName can be encoded with UTF-8 even though 0 is set."]
    pub utf8: ::std::os::raw::c_int,
    #[doc = "< File size in bytes, -1 if unknown."]
    pub size: i64,
    #[doc = "< Time of last modification in microseconds since unix\nepoch, -1 if unknown."]
    pub modification_timestamp: i64,
    #[doc = "< Time of last access in microseconds since unix epoch,\n-1 if unknown."]
    pub access_timestamp: i64,
    #[doc = "< Time of last status change in microseconds since unix\nepoch, -1 if unknown."]
    pub status_change_timestamp: i64,
    #[doc = "< User ID of owner, -1 if unknown."]
    pub user_id: i64,
    #[doc = "< Group ID of owner, -1 if unknown."]
    pub group_id: i64,
    #[doc = "< Unix file mode, -1 if unknown."]
    pub filemode: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[repr(i32)]
#[doc = " Different data types that can be returned via the AVIO\n write_data_type callback."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVIODataMarkerType {
    #[doc = " Header data; this needs to be present for the stream to be decodeable."]
    AVIO_DATA_MARKER_HEADER = 0,
    #[doc = " A point in the output bytestream where a decoder can start decoding\n (i.e. a keyframe). A demuxer/decoder given the data flagged with\n AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,\n should give decodeable results."]
    AVIO_DATA_MARKER_SYNC_POINT = 1,
    #[doc = " A point in the output bytestream where a demuxer can start parsing\n (for non self synchronizing bytestream formats). That is, any\n non-keyframe packet start point."]
    AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
    #[doc = " This is any, unlabelled data. It can either be a muxer not marking\n any positions at all, it can be an actual boundary/sync point\n that the muxer chooses not to mark, or a later part of a packet/fragment\n that is cut into multiple write callbacks due to limited IO buffer size."]
    AVIO_DATA_MARKER_UNKNOWN = 3,
    #[doc = " Trailer data, which doesn't contain actual content, but only for\n finalizing the output file."]
    AVIO_DATA_MARKER_TRAILER = 4,
    #[doc = " A point in the output bytestream where the underlying AVIOContext might\n flush the buffer depending on latency or buffering requirements. Typically\n means the end of a packet."]
    AVIO_DATA_MARKER_FLUSH_POINT = 5,
}
#[doc = " Bytestream IO Context.\n New public fields can be added with minor version bumps.\n Removal, reordering and changes to existing public fields require\n a major version bump.\n sizeof(AVIOContext) must not be used outside libav*.\n\n @note None of the function pointers in AVIOContext should be called\n       directly, they should only be set by the client application\n       when implementing custom I/O. Normally these are set to the\n       function pointers specified in avio_alloc_context()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIOContext {
    #[doc = " A class for private options.\n\n If this AVIOContext is created by avio_open2(), av_class is set and\n passes the options down to protocols.\n\n If this AVIOContext is manually allocated, then av_class may be set by\n the caller.\n\n warning -- this field can be NULL, be sure to not pass this AVIOContext\n to any av_opt_* functions in that case."]
    pub av_class: *const AVClass,
    #[doc = "< Start of the buffer."]
    pub buffer: *mut ::std::os::raw::c_uchar,
    #[doc = "< Maximum buffer size"]
    pub buffer_size: ::std::os::raw::c_int,
    #[doc = "< Current position in the buffer"]
    pub buf_ptr: *mut ::std::os::raw::c_uchar,
    #[doc = "< End of the data, may be less than\nbuffer+buffer_size if the read function returned\nless data than requested, e.g. for streams where\nno more data has been received yet."]
    pub buf_end: *mut ::std::os::raw::c_uchar,
    #[doc = "< A private pointer, passed to the read/write/seek/...\nfunctions."]
    pub opaque: *mut ::std::os::raw::c_void,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            offset: i64,
            whence: ::std::os::raw::c_int,
        ) -> i64,
    >,
    #[doc = "< position in the file of the current buffer"]
    pub pos: i64,
    #[doc = "< true if was unable to read due to error or eof"]
    pub eof_reached: ::std::os::raw::c_int,
    #[doc = "< contains the error code or 0 if no error happened"]
    pub error: ::std::os::raw::c_int,
    #[doc = "< true if open for writing"]
    pub write_flag: ::std::os::raw::c_int,
    pub max_packet_size: ::std::os::raw::c_int,
    #[doc = "< Try to buffer at least this amount of data\nbefore flushing it."]
    pub min_packet_size: ::std::os::raw::c_int,
    pub checksum: ::std::os::raw::c_ulong,
    pub checksum_ptr: *mut ::std::os::raw::c_uchar,
    pub update_checksum: ::std::option::Option<
        unsafe extern "C" fn(
            checksum: ::std::os::raw::c_ulong,
            buf: *const u8,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_ulong,
    >,
    #[doc = " Pause or resume playback for network streaming protocols - e.g. MMS."]
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            pause: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Seek to a given timestamp in stream with the specified stream_index.\n Needed for some network streaming protocols which don't support seeking\n to byte position."]
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            stream_index: ::std::os::raw::c_int,
            timestamp: i64,
            flags: ::std::os::raw::c_int,
        ) -> i64,
    >,
    #[doc = " A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable."]
    pub seekable: ::std::os::raw::c_int,
    #[doc = " avio_read and avio_write should if possible be satisfied directly\n instead of going through a buffer, and avio_seek will always\n call the underlying seek function directly."]
    pub direct: ::std::os::raw::c_int,
    #[doc = " ',' separated list of allowed protocols."]
    pub protocol_whitelist: *const ::std::os::raw::c_char,
    #[doc = " ',' separated list of disallowed protocols."]
    pub protocol_blacklist: *const ::std::os::raw::c_char,
    #[doc = " A callback that is used instead of write_packet."]
    pub write_data_type: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            buf: *mut u8,
            buf_size: ::std::os::raw::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,\n but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly\n small chunks of data returned from the callback)."]
    pub ignore_boundary_point: ::std::os::raw::c_int,
    #[doc = " @deprecated field utilized privately by libavformat. For a public\n             statistic of how many bytes were written out, see\n             AVIOContext::bytes_written."]
    pub written: i64,
    #[doc = " Maximum reached position before a backward seek in the write buffer,\n used keeping track of already written data for a later flush."]
    pub buf_ptr_max: *mut ::std::os::raw::c_uchar,
    #[doc = " Read-only statistic of bytes read for this AVIOContext."]
    pub bytes_read: i64,
    #[doc = " Read-only statistic of bytes written for this AVIOContext."]
    pub bytes_written: i64,
}
extern "C" {
    #[doc = " Return the name of the protocol that will handle the passed URL.\n\n NULL is returned if no protocol could be found for the given URL.\n\n @return Name of the protocol or NULL."]
    pub fn avio_find_protocol_name(
        url: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return AVIO_FLAG_* access flags corresponding to the access permissions\n of the resource in url, or a negative value corresponding to an\n AVERROR code in case of failure. The returned access flags are\n masked by the value in flags.\n\n @note This function is intrinsically unsafe, in the sense that the\n checked resource may change its existence or permission status from\n one call to another. Thus you should not trust the returned value,\n unless you are sure that no other processes are accessing the\n checked resource."]
    pub fn avio_check(
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open directory for reading.\n\n @param s       directory read context. Pointer to a NULL pointer must be passed.\n @param url     directory to be listed.\n @param options A dictionary filled with protocol-private options. On return\n                this parameter will be destroyed and replaced with a dictionary\n                containing options that were not found. May be NULL.\n @return >=0 on success or negative on error."]
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const ::std::os::raw::c_char,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get next directory entry.\n\n Returned entry must be freed with avio_free_directory_entry(). In particular\n it may outlive AVIODirContext.\n\n @param s         directory read context.\n @param[out] next next entry or NULL when no more entries.\n @return >=0 on success or negative on error. End of list is not considered an\n             error."]
    pub fn avio_read_dir(
        s: *mut AVIODirContext,
        next: *mut *mut AVIODirEntry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close directory.\n\n @note Entries created using avio_read_dir() are not deleted and must be\n freeded with avio_free_directory_entry().\n\n @param s         directory read context.\n @return >=0 on success or negative on error."]
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free entry allocated by avio_read_dir().\n\n @param entry entry to be freed."]
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    #[doc = " Allocate and initialize an AVIOContext for buffered I/O. It must be later\n freed with avio_context_free().\n\n @param buffer Memory block for input/output operations via AVIOContext.\n        The buffer must be allocated with av_malloc() and friends.\n        It may be freed and replaced with a new buffer by libavformat.\n        AVIOContext.buffer holds the buffer currently in use,\n        which must be later freed with av_free().\n @param buffer_size The buffer size is very important for performance.\n        For protocols with fixed blocksize it should be set to this blocksize.\n        For others a typical size is a cache page, e.g. 4kb.\n @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.\n @param opaque An opaque pointer to user-specific data.\n @param read_packet  A function for refilling the buffer, may be NULL.\n                     For stream protocols, must never return 0 but rather\n                     a proper AVERROR code.\n @param write_packet A function for writing the buffer contents, may be NULL.\n        The function may not change the input buffers content.\n @param seek A function for seeking to specified byte position, may be NULL.\n\n @return Allocated AVIOContext or NULL on failure."]
    pub fn avio_alloc_context(
        buffer: *mut ::std::os::raw::c_uchar,
        buffer_size: ::std::os::raw::c_int,
        write_flag: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
        read_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                buf: *mut u8,
                buf_size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        write_packet: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                buf: *mut u8,
                buf_size: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        seek: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                offset: i64,
                whence: ::std::os::raw::c_int,
            ) -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    #[doc = " Free the supplied IO context and everything associated with it.\n\n @param s Double pointer to the IO context. This function will write NULL\n into s."]
    pub fn avio_context_free(s: *mut *mut AVIOContext);
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: ::std::os::raw::c_int);
}
extern "C" {
    pub fn avio_write(
        s: *mut AVIOContext,
        buf: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Write a NULL-terminated string.\n @return number of bytes written."]
    pub fn avio_put_str(
        s: *mut AVIOContext,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an UTF-8 string to UTF-16LE and write it.\n @param s the AVIOContext\n @param str NULL-terminated UTF-8 string\n\n @return number of bytes written."]
    pub fn avio_put_str16le(
        s: *mut AVIOContext,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an UTF-8 string to UTF-16BE and write it.\n @param s the AVIOContext\n @param str NULL-terminated UTF-8 string\n\n @return number of bytes written."]
    pub fn avio_put_str16be(
        s: *mut AVIOContext,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark the written bytestream as a specific type.\n\n Zero-length ranges are omitted from the output.\n\n @param time the stream time the current bytestream pos corresponds to\n             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not\n             applicable\n @param type the kind of data written starting at the current pos"]
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    #[doc = " fseek() equivalent for AVIOContext.\n @return new position or AVERROR."]
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: ::std::os::raw::c_int) -> i64;
}
extern "C" {
    #[doc = " Skip given number of bytes forward\n @return new position or AVERROR."]
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    #[doc = " Get the filesize.\n @return filesize or AVERROR"]
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    #[doc = " Similar to feof() but also returns nonzero on read errors.\n @return non zero if and only if at end of file or a read error happened when reading."]
    pub fn avio_feof(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes a formatted string to the context taking a va_list.\n @return number of bytes written, < 0 on error."]
    pub fn avio_vprintf(
        s: *mut AVIOContext,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes a formatted string to the context.\n @return number of bytes written, < 0 on error."]
    pub fn avio_printf(
        s: *mut AVIOContext,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a NULL terminated array of strings to the context.\n Usually you don't need to use this function directly but its macro wrapper,\n avio_print."]
    pub fn avio_print_string_array(
        s: *mut AVIOContext,
        strings: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Force flushing of buffered data.\n\n For write streams, force the buffered data to be immediately written to the output,\n without to wait to fill the internal buffer.\n\n For read streams, discard all currently buffered data, and advance the\n reported file position to that of the underlying stream. This does not\n read new data, and does not perform any seeks."]
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    #[doc = " Read size bytes from AVIOContext into buf.\n @return number of bytes read or AVERROR"]
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed\n to read fewer bytes than requested. The missing bytes can be read in the next\n call. This always tries to read at least 1 byte.\n Useful to reduce latency in certain cases.\n @return number of bytes read or AVERROR"]
    pub fn avio_read_partial(
        s: *mut AVIOContext,
        buf: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Functions for reading from AVIOContext\n @{\n\n @note return 0 if EOF, so you cannot use it if EOF handling is\n       necessary"]
    pub fn avio_r8(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    #[doc = " Read a string from pb into buf. The reading will terminate when either\n a NULL character was encountered, maxlen bytes have been read, or nothing\n more can be read from pb. The result is guaranteed to be NULL-terminated, it\n will be truncated if buf is too small.\n Note that the string is not interpreted or validated in any way, it\n might get truncated in the middle of a sequence for multi-byte encodings.\n\n @return number of bytes read (is always <= maxlen).\n If reading ends on EOF or error, the return value will be one more than\n bytes actually read."]
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a UTF-16 string from pb and convert it to UTF-8.\n The reading will terminate when either a null or invalid character was\n encountered or maxlen bytes have been read.\n @return number of bytes read (is always <= maxlen)"]
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and initialize a AVIOContext for accessing the\n resource indicated by url.\n @note When the resource indicated by url has been opened in\n read+write mode, the AVIOContext can be used only for writing.\n\n @param s Used to return the pointer to the created AVIOContext.\n In case of failure the pointed to value is set to NULL.\n @param url resource to access\n @param flags flags which control how the resource indicated by url\n is to be opened\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code in case of failure"]
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and initialize a AVIOContext for accessing the\n resource indicated by url.\n @note When the resource indicated by url has been opened in\n read+write mode, the AVIOContext can be used only for writing.\n\n @param s Used to return the pointer to the created AVIOContext.\n In case of failure the pointed to value is set to NULL.\n @param url resource to access\n @param flags flags which control how the resource indicated by url\n is to be opened\n @param int_cb an interrupt callback to be used at the protocols level\n @param options  A dictionary filled with protocol-private options. On return\n this parameter will be destroyed and replaced with a dict containing options\n that were not found. May be NULL.\n @return >= 0 in case of success, a negative value corresponding to an\n AVERROR code in case of failure"]
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close the resource accessed by the AVIOContext s and free it.\n This function can only be used if s was opened by avio_open().\n\n The internal buffer is automatically flushed before closing the\n resource.\n\n @return 0 on success, an AVERROR < 0 on error.\n @see avio_closep"]
    pub fn avio_close(s: *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close the resource accessed by the AVIOContext *s, free it\n and set the pointer pointing to it to NULL.\n This function can only be used if s was opened by avio_open().\n\n The internal buffer is automatically flushed before closing the\n resource.\n\n @return 0 on success, an AVERROR < 0 on error.\n @see avio_close"]
    pub fn avio_closep(s: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a write only memory stream.\n\n @param s new IO context\n @return zero if no error."]
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the written size and a pointer to the buffer.\n The AVIOContext stream is left intact.\n The buffer must NOT be freed.\n No padding is added to the buffer.\n\n @param s IO context\n @param pbuffer pointer to a byte buffer\n @return the length of the byte buffer"]
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the written size and a pointer to the buffer. The buffer\n must be freed with av_free().\n Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.\n\n @param s IO context\n @param pbuffer pointer to a byte buffer\n @return the length of the byte buffer"]
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate through names of available protocols.\n\n @param opaque A private pointer representing current protocol.\n        It must be a pointer to NULL on first iteration and will\n        be updated by successive calls to avio_enum_protocols.\n @param output If set to 1, iterate over output protocols,\n               otherwise over input protocols.\n\n @return A static string containing the name of current protocol or NULL"]
    pub fn avio_enum_protocols(
        opaque: *mut *mut ::std::os::raw::c_void,
        output: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get AVClass by names of available protocols.\n\n @return A AVClass of input protocol name or NULL"]
    pub fn avio_protocol_get_class(name: *const ::std::os::raw::c_char) -> *const AVClass;
}
extern "C" {
    #[doc = " Pause and resume playing - only meaningful if using a network streaming\n protocol (e.g. MMS).\n\n @param h     IO context from which to call the read_pause function pointer\n @param pause 1 for pause, 0 for resume"]
    pub fn avio_pause(h: *mut AVIOContext, pause: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seek to a given timestamp relative to some component stream.\n Only meaningful if using a network streaming protocol (e.g. MMS.).\n\n @param h IO context from which to call the seek function pointers\n @param stream_index The stream index that the timestamp is relative to.\n        If stream_index is (-1) the timestamp should be in AV_TIME_BASE\n        units from the beginning of the presentation.\n        If a stream_index >= 0 is used and the protocol does not support\n        seeking based on component streams, the call will fail.\n @param timestamp timestamp in AVStream.time_base units\n        or if there is no stream specified then in AV_TIME_BASE units.\n @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE\n        and AVSEEK_FLAG_ANY. The protocol may silently ignore\n        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will\n        fail if used and not supported.\n @return >= 0 on success\n @see AVInputFormat::read_seek"]
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: ::std::os::raw::c_int,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> i64;
}
extern "C" {
    #[doc = " Read contents of h into print buffer, up to max_size bytes, or up to EOF.\n\n @return 0 for success (max_size bytes read or EOF reached), negative error\n code otherwise"]
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Accept and allocate a client context on a server context.\n @param  s the server context\n @param  c the client context, must be unallocated\n @return   >= 0 on success or a negative value corresponding\n           to an AVERROR on failure"]
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform one step of the protocol handshake to accept a new client.\n This function must be called on a client returned by avio_accept() before\n using it as a read/write context.\n It is separate from avio_accept() because it may block.\n A step of the handshake is defined by places where the application may\n decide to change the proceedings.\n For example, on a protocol with a request header and a reply header, each\n one can constitute a step because the application may use the parameters\n from the request to change parameters in the reply; or each individual\n chunk of the request can constitute a step.\n If the handshake is already finished, avio_handshake() does nothing and\n returns 0 immediately.\n\n @param  c the client context to perform the handshake on\n @return   0   on a complete and successful handshake\n           > 0 if the handshake progressed, but is not complete\n           < 0 for an AVERROR code"]
    pub fn avio_handshake(c: *mut AVIOContext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceInfoList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDeviceCapabilitiesQuery {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and read the payload of a packet and initialize its\n fields with default values.\n\n @param s    associated IO context\n @param pkt packet\n @param size desired payload size\n @return >0 (read size) if OK, AVERROR_xxx otherwise"]
    pub fn av_get_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data and append it to the current content of the AVPacket.\n If pkt->size is 0 this is identical to av_get_packet.\n Note that this uses av_grow_packet and thus involves a realloc\n which is inefficient. Thus this function should only be used\n when there is no reasonable way to know (an upper bound of)\n the final size.\n\n @param s    associated IO context\n @param pkt packet\n @param size amount of data to read\n @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data\n         will not be lost even if an error occurs."]
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
#[doc = " This structure contains the data a format has to probe a file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProbeData {
    pub filename: *const ::std::os::raw::c_char,
    #[doc = "< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero."]
    pub buf: *mut ::std::os::raw::c_uchar,
    #[doc = "< Size of buf except extra allocated bytes"]
    pub buf_size: ::std::os::raw::c_int,
    #[doc = "< mime_type, when known."]
    pub mime_type: *const ::std::os::raw::c_char,
}
#[doc = " @addtogroup lavf_encoding\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOutputFormat {
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive name for the format, meant to be more human-readable\n than name. You should use the NULL_IF_CONFIG_SMALL() macro\n to define it."]
    pub long_name: *const ::std::os::raw::c_char,
    pub mime_type: *const ::std::os::raw::c_char,
    #[doc = "< comma-separated filename extensions"]
    pub extensions: *const ::std::os::raw::c_char,
    #[doc = "< default audio codec"]
    pub audio_codec: AVCodecID,
    #[doc = "< default video codec"]
    pub video_codec: AVCodecID,
    #[doc = "< default subtitle codec"]
    pub subtitle_codec: AVCodecID,
    #[doc = " can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,\n AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,\n AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,\n AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " List of supported codec_id-codec_tag pairs, ordered by \"better\n choice first\". The arrays are all terminated by AV_CODEC_ID_NONE."]
    pub codec_tag: *const *const AVCodecTag,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = " No fields below this line are part of the public API. They\n may not be used outside of libavformat and can be changed and\n removed at will.\n New public fields should be added right above.\n\n/\n/**\n size of private data so that it can be allocated in the wrapper"]
    pub priv_data_size: ::std::os::raw::c_int,
    #[doc = " Internal flags. See FF_FMT_FLAG_* in internal.h."]
    pub flags_internal: ::std::os::raw::c_int,
    pub write_header: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,\n pkt can be NULL in order to flush data buffered in the muxer.\n When flushing, return 0 if there still is more data to flush,\n or 1 if everything was flushed and there is no more buffered\n data."]
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            pkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_trailer: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " A format-specific function for interleavement.\n If unset, packets will be interleaved by dts.\n\n @param s           An AVFormatContext for output. pkt will be added to\n                    resp. taken from its packet buffer.\n @param[in,out] pkt A packet to be interleaved if has_packet is set;\n                    also used to return packets. If no packet is returned\n                    (e.g. on error), pkt is blank on return.\n @param flush       1 if no further packets are available as input and\n                    all remaining packets should be output.\n @param has_packet  If set, pkt contains a packet to be interleaved\n                    on input; otherwise pkt is blank on input.\n @return 1 if a packet was output, 0 if no packet could be output,\n         < 0 if an error occurred"]
    pub interleave_packet: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pkt: *mut AVPacket,
            flush: ::std::os::raw::c_int,
            has_packet: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Test if the given codec can be stored in this container.\n\n @return 1 if the codec is supported, 0 if it is not.\n         A negative number if unknown.\n         MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC"]
    pub query_codec: ::std::option::Option<
        unsafe extern "C" fn(
            id: AVCodecID,
            std_compliance: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_output_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream: ::std::os::raw::c_int,
            dts: *mut i64,
            wall: *mut i64,
        ),
    >,
    #[doc = " Allows sending messages from application to device."]
    pub control_message: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            type_: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
            data_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Write an uncoded AVFrame.\n\n See av_write_uncoded_frame() for details.\n\n The library will free *frame afterwards, but the muxer can prevent it\n by setting the pointer to NULL."]
    pub write_uncoded_frame: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            frame: *mut *mut AVFrame,
            flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Returns device list with it properties.\n @see avdevice_list_devices() for more details."]
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< default data codec"]
    pub data_codec: AVCodecID,
    #[doc = " Initialize format. May allocate data here, and set any AVFormatContext or\n AVStream parameters that need to be set before packets are sent.\n This method must not write output.\n\n Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure\n\n Any allocations made here must be freed in deinit()."]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Deinitialize format. If present, this is called whenever the muxer is being\n destroyed, regardless of whether or not the header has been written.\n\n If a trailer is being written, this is called after write_trailer().\n\n This is called if init() fails as well."]
    pub deinit: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext)>,
    #[doc = " Set up any necessary bitstream filtering and extract any extra data needed\n for the global header.\n\n @note pkt might have been directly forwarded by a meta-muxer; therefore\n       pkt->stream_index as well as the pkt's timebase might be invalid.\n Return 0 if more packets from this stream must be checked; 1 if not."]
    pub check_bitstream: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            st: *mut AVStream,
            pkt: *const AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " @addtogroup lavf_decoding\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVInputFormat {
    #[doc = " A comma separated list of short names for the format. New names\n may be appended with a minor bump."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive name for the format, meant to be more human-readable\n than name. You should use the NULL_IF_CONFIG_SMALL() macro\n to define it."]
    pub long_name: *const ::std::os::raw::c_char,
    #[doc = " Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,\n AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,\n AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " If extensions are defined, then no probe is done. You should\n usually not use extension format guessing because it is not\n reliable enough"]
    pub extensions: *const ::std::os::raw::c_char,
    pub codec_tag: *const *const AVCodecTag,
    #[doc = "< AVClass for the private context"]
    pub priv_class: *const AVClass,
    #[doc = " Comma-separated list of mime types.\n It is used check for matching mime types while probing.\n @see av_probe_input_format2"]
    pub mime_type: *const ::std::os::raw::c_char,
    #[doc = " No fields below this line are part of the public API. They\n may not be used outside of libavformat and can be changed and\n removed at will.\n New public fields should be added right above.\n\n/\n/**\n Raw demuxers store their codec ID here."]
    pub raw_codec_id: ::std::os::raw::c_int,
    #[doc = " Size of private data so that it can be allocated in the wrapper."]
    pub priv_data_size: ::std::os::raw::c_int,
    #[doc = " Internal flags. See FF_FMT_FLAG_* in internal.h."]
    pub flags_internal: ::std::os::raw::c_int,
    #[doc = " Tell if a given file has a chance of being parsed as this format.\n The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes\n big so you do not have to check for that unless you need more."]
    pub read_probe: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const AVProbeData) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read the format header and initialize the AVFormatContext\n structure. Return 0 if OK. 'avformat_new_stream' should be\n called to create new streams."]
    pub read_header: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Read one packet and put it in 'pkt'. pts and flags are also\n set. 'avformat_new_stream' can be called only if the flag\n AVFMTCTX_NOHEADER is used and only in the calling thread (not in a\n background thread).\n @return 0 on success, < 0 on error.\n         Upon returning an error, pkt must be unreferenced by the caller."]
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            pkt: *mut AVPacket,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Close the stream. The AVFormatContext and AVStreams are not\n freed by this function"]
    pub read_close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Seek to a given timestamp relative to the frames in\n stream component stream_index.\n @param stream_index Must not be -1.\n @param flags Selects which direction should be preferred if no exact\n              match is available.\n @return >= 0 on success (but not necessarily the new offset)"]
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            timestamp: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get the next timestamp in stream[stream_index].time_base units.\n @return the timestamp or AV_NOPTS_VALUE if an error occurred"]
    pub read_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    #[doc = " Start/resume playing - only meaningful if using a network-based format\n (RTSP)."]
    pub read_play: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Pause playing - only meaningful if using a network-based format\n (RTSP)."]
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Seek to timestamp ts.\n Seeking will be done so that the point from which all active streams\n can be presented successfully will be closest to ts and within min/max_ts.\n Active streams are all streams that have AVStream.discard < AVDISCARD_ALL."]
    pub read_seek2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: ::std::os::raw::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Returns device list with it properties.\n @see avdevice_list_devices() for more details."]
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            device_list: *mut AVDeviceInfoList,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(i32)]
#[doc = " @}"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVStreamParseType {
    AVSTREAM_PARSE_NONE = 0,
    #[doc = "< full parsing and repack"]
    AVSTREAM_PARSE_FULL = 1,
    #[doc = "< Only parse headers, do not repack."]
    AVSTREAM_PARSE_HEADERS = 2,
    #[doc = "< full parsing and interpolation of timestamps for frames not starting on a packet boundary"]
    AVSTREAM_PARSE_TIMESTAMPS = 3,
    #[doc = "< full parsing and repack of the first frame only, only implemented for H.264 currently"]
    AVSTREAM_PARSE_FULL_ONCE = 4,
    #[doc = "< full parsing and repack with timestamp and position generation by parser for raw\nthis assumes that each packet in the file contains no demuxer level headers and\njust codec level data, otherwise position generation would fail"]
    AVSTREAM_PARSE_FULL_RAW = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVIndexEntry {
    pub pos: i64,
    #[doc = "<\n Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available\n when seeking to this entry. That means preferable PTS on keyframe based formats.\n But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better\n is known"]
    pub timestamp: i64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Minimum distance between this and the previous keyframe, used to avoid unneeded searching."]
    pub min_distance: ::std::os::raw::c_int,
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @return The AV_DISPOSITION_* flag corresponding to disp or a negative error\n         code if disp does not correspond to a known stream disposition."]
    pub fn av_disposition_from_string(disp: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param disposition a combination of AV_DISPOSITION_* values\n @return The string description corresponding to the lowest set bit in\n         disposition. NULL when the lowest set bit does not correspond\n         to a known disposition or when disposition is 0."]
    pub fn av_disposition_to_string(
        disposition: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " Stream structure.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVStream) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStream {
    #[doc = "< stream index in AVFormatContext"]
    pub index: ::std::os::raw::c_int,
    #[doc = " Format-specific stream ID.\n decoding: set by libavformat\n encoding: set by the user, replaced by libavformat if left unset"]
    pub id: ::std::os::raw::c_int,
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " This is the fundamental unit of time (in seconds) in terms\n of which frame timestamps are represented.\n\n decoding: set by libavformat\n encoding: May be set by the caller before avformat_write_header() to\n           provide a hint to the muxer about the desired timebase. In\n           avformat_write_header(), the muxer will overwrite this field\n           with the timebase that will actually be used for the timestamps\n           written into the file (which may or may not be related to the\n           user-provided one, depending on the format)."]
    pub time_base: AVRational,
    #[doc = " Decoding: pts of the first frame of the stream in presentation order, in stream time base.\n Only set this if you are absolutely 100% sure that the value you set\n it to really is the pts of the first frame.\n This may be undefined (AV_NOPTS_VALUE).\n @note The ASF header does NOT contain a correct start_time the ASF\n demuxer must NOT set this."]
    pub start_time: i64,
    #[doc = " Decoding: duration of the stream, in stream time base.\n If a source file does not specify a duration, but does specify\n a bitrate, this value will be estimated from bitrate and file size.\n\n Encoding: May be set by the caller before avformat_write_header() to\n provide a hint to the muxer about the estimated duration."]
    pub duration: i64,
    #[doc = "< number of frames in this stream if known or 0"]
    pub nb_frames: i64,
    #[doc = " Stream disposition - a combination of AV_DISPOSITION_* flags.\n - demuxing: set by libavformat when creating the stream or in\n             avformat_find_stream_info().\n - muxing: may be set by the caller before avformat_write_header()."]
    pub disposition: ::std::os::raw::c_int,
    #[doc = "< Selects which packets can be discarded at will and do not need to be demuxed."]
    pub discard: AVDiscard,
    #[doc = " sample aspect ratio (0 if unknown)\n - encoding: Set by user.\n - decoding: Set by libavformat."]
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    #[doc = " Average framerate\n\n - demuxing: May be set by libavformat when creating the stream or in\n             avformat_find_stream_info().\n - muxing: May be set by the caller before avformat_write_header()."]
    pub avg_frame_rate: AVRational,
    #[doc = " For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet\n will contain the attached picture.\n\n decoding: set by libavformat, must not be modified by the caller.\n encoding: unused"]
    pub attached_pic: AVPacket,
    #[doc = " An array of side data that applies to the whole stream (i.e. the\n container does not allow it to change between packets).\n\n There may be no overlap between the side data in this array and side data\n in the packets. I.e. a given side data is either exported by the muxer\n (demuxing) / set by the caller (muxing) in this array, then it never\n appears in the packets, or the side data is exported / sent through\n the packets (always in the first packet where the value becomes known or\n changes), then it does not appear in this array.\n\n - demuxing: Set by libavformat when the stream is created.\n - muxing: May be set by the caller before avformat_write_header().\n\n Freed by libavformat in avformat_free_context().\n\n @see av_format_inject_global_side_data()"]
    pub side_data: *mut AVPacketSideData,
    #[doc = " The number of elements in the AVStream.side_data array."]
    pub nb_side_data: ::std::os::raw::c_int,
    #[doc = " Flags indicating events happening on the stream, a combination of\n AVSTREAM_EVENT_FLAG_*.\n\n - demuxing: may be set by the demuxer in avformat_open_input(),\n   avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n   by the user once the event has been handled.\n - muxing: may be set by the user after avformat_write_header(). to\n   indicate a user-triggered event.  The muxer will clear the flags for\n   events it has handled in av_[interleaved]_write_frame()."]
    pub event_flags: ::std::os::raw::c_int,
    #[doc = " Real base framerate of the stream.\n This is the lowest framerate with which all timestamps can be\n represented accurately (it is the least common multiple of all\n framerates in the stream). Note, this value is just a guess!\n For example, if the time base is 1/90000 and all frames have either\n approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1."]
    pub r_frame_rate: AVRational,
    #[doc = " Codec parameters associated with this stream. Allocated and freed by\n libavformat in avformat_new_stream() and avformat_free_context()\n respectively.\n\n - demuxing: filled by libavformat on stream creation or in\n             avformat_find_stream_info()\n - muxing: filled by the caller before avformat_write_header()"]
    pub codecpar: *mut AVCodecParameters,
    #[doc = " Number of bits in timestamps. Used for wrapping control.\n\n - demuxing: set by libavformat\n - muxing: set by libavformat\n"]
    pub pts_wrap_bits: ::std::os::raw::c_int,
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    #[doc = " Returns the pts of the last muxed packet + its duration\n\n the retuned value is undefined when used with a demuxer."]
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
#[doc = " New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVProgram) must not be used outside libav*."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVProgram {
    pub id: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    #[doc = "< selects which program to discard and which to feed to the caller"]
    pub discard: AVDiscard,
    pub stream_index: *mut ::std::os::raw::c_uint,
    pub nb_stream_indexes: ::std::os::raw::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: ::std::os::raw::c_int,
    pub pmt_pid: ::std::os::raw::c_int,
    pub pcr_pid: ::std::os::raw::c_int,
    pub pmt_version: ::std::os::raw::c_int,
    #[doc = " All fields below this line are not part of the public API. They\n may not be used outside of libavformat and can be changed and\n removed at will.\n New public fields should be added right above.\n"]
    pub start_time: i64,
    pub end_time: i64,
    #[doc = "< reference dts for wrap detection"]
    pub pts_wrap_reference: i64,
    #[doc = "< behavior on wrap detection"]
    pub pts_wrap_behavior: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVChapter {
    #[doc = "< unique ID to identify the chapter"]
    pub id: i64,
    #[doc = "< time base in which the start/end timestamps are specified"]
    pub time_base: AVRational,
    #[doc = "< chapter start/end time in time_base units"]
    pub start: i64,
    #[doc = "< chapter start/end time in time_base units"]
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[doc = " Callback used by devices to communicate with application."]
pub type av_format_control_message = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type AVOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int,
>;
#[repr(i32)]
#[doc = " The duration of a video can be estimated through various ways, and this enum can be used\n to know how the duration was estimated."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVDurationEstimationMethod {
    #[doc = "< Duration accurately estimated from PTSes"]
    AVFMT_DURATION_FROM_PTS = 0,
    #[doc = "< Duration estimated from a stream with a known duration"]
    AVFMT_DURATION_FROM_STREAM = 1,
    #[doc = "< Duration estimated from bitrate (less accurate)"]
    AVFMT_DURATION_FROM_BITRATE = 2,
}
#[doc = " Format I/O context.\n New fields can be added to the end with minor version bumps.\n Removal, reordering and changes to existing fields require a major\n version bump.\n sizeof(AVFormatContext) must not be used outside libav*, use\n avformat_alloc_context() to create an AVFormatContext.\n\n Fields can be accessed through AVOptions (av_opt*),\n the name string used matches the associated command line parameter name and\n can be found in libavformat/options_table.h.\n The AVOption/command line parameter names differ in some cases from the C\n structure field names for historic reasons or brevity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatContext {
    #[doc = " A class for logging and @ref avoptions. Set by avformat_alloc_context().\n Exports (de)muxer private options if they exist."]
    pub av_class: *const AVClass,
    #[doc = " The input container format.\n\n Demuxing only, set by avformat_open_input()."]
    pub iformat: *const AVInputFormat,
    #[doc = " The output container format.\n\n Muxing only, must be set by the caller before avformat_write_header()."]
    pub oformat: *const AVOutputFormat,
    #[doc = " Format private data. This is an AVOptions-enabled struct\n if and only if iformat/oformat.priv_class is not NULL.\n\n - muxing: set by avformat_write_header()\n - demuxing: set by avformat_open_input()"]
    pub priv_data: *mut ::std::os::raw::c_void,
    #[doc = " I/O context.\n\n - demuxing: either set by the user before avformat_open_input() (then\n             the user must close it manually) or set by avformat_open_input().\n - muxing: set by the user before avformat_write_header(). The caller must\n           take care of closing / freeing the IO context.\n\n Do NOT set this field if AVFMT_NOFILE flag is set in\n iformat/oformat.flags. In such a case, the (de)muxer will handle\n I/O in some other way and this field will be NULL."]
    pub pb: *mut AVIOContext,
    #[doc = " Flags signalling stream properties. A combination of AVFMTCTX_*.\n Set by libavformat."]
    pub ctx_flags: ::std::os::raw::c_int,
    #[doc = " Number of elements in AVFormatContext.streams.\n\n Set by avformat_new_stream(), must not be modified by any other code."]
    pub nb_streams: ::std::os::raw::c_uint,
    #[doc = " A list of all streams in the file. New streams are created with\n avformat_new_stream().\n\n - demuxing: streams are created by libavformat in avformat_open_input().\n             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also\n             appear in av_read_frame().\n - muxing: streams are created by the user before avformat_write_header().\n\n Freed by libavformat in avformat_free_context()."]
    pub streams: *mut *mut AVStream,
    #[doc = " input or output URL. Unlike the old filename field, this field has no\n length restriction.\n\n - demuxing: set by avformat_open_input(), initialized to an empty\n             string if url parameter was NULL in avformat_open_input().\n - muxing: may be set by the caller before calling avformat_write_header()\n           (or avformat_init_output() if that is called first) to a string\n           which is freeable by av_free(). Set to an empty string if it\n           was NULL in avformat_init_output().\n\n Freed by libavformat in avformat_free_context()."]
    pub url: *mut ::std::os::raw::c_char,
    #[doc = " Position of the first frame of the component, in\n AV_TIME_BASE fractional seconds. NEVER set this value directly:\n It is deduced from the AVStream values.\n\n Demuxing only, set by libavformat."]
    pub start_time: i64,
    #[doc = " Duration of the stream, in AV_TIME_BASE fractional\n seconds. Only set this value if you know none of the individual stream\n durations and also do not set any of them. This is deduced from the\n AVStream values if not set.\n\n Demuxing only, set by libavformat."]
    pub duration: i64,
    #[doc = " Total stream bitrate in bit/s, 0 if not\n available. Never set it directly if the file_size and the\n duration are known as FFmpeg can compute it automatically."]
    pub bit_rate: i64,
    pub packet_size: ::std::os::raw::c_uint,
    pub max_delay: ::std::os::raw::c_int,
    #[doc = " Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.\n Set by the user before avformat_open_input() / avformat_write_header()."]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Maximum number of bytes read from input in order to determine stream\n properties. Used when reading the global header and in\n avformat_find_stream_info().\n\n Demuxing only, set by the caller before avformat_open_input().\n\n @note this is \\e not  used for determining the \\ref AVInputFormat\n       \"input format\"\n @sa format_probesize"]
    pub probesize: i64,
    #[doc = " Maximum duration (in AV_TIME_BASE units) of the data read\n from input in avformat_find_stream_info().\n Demuxing only, set by the caller before avformat_find_stream_info().\n Can be set to 0 to let avformat choose using a heuristic."]
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: ::std::os::raw::c_int,
    pub nb_programs: ::std::os::raw::c_uint,
    pub programs: *mut *mut AVProgram,
    #[doc = " Forced video codec_id.\n Demuxing: Set by user."]
    pub video_codec_id: AVCodecID,
    #[doc = " Forced audio codec_id.\n Demuxing: Set by user."]
    pub audio_codec_id: AVCodecID,
    #[doc = " Forced subtitle codec_id.\n Demuxing: Set by user."]
    pub subtitle_codec_id: AVCodecID,
    #[doc = " Maximum amount of memory in bytes to use for the index of each stream.\n If the index exceeds this size, entries will be discarded as\n needed to maintain a smaller size. This can lead to slower or less\n accurate seeking (depends on demuxer).\n Demuxers for which a full in-memory index is mandatory will ignore\n this.\n - muxing: unused\n - demuxing: set by user"]
    pub max_index_size: ::std::os::raw::c_uint,
    #[doc = " Maximum amount of memory in bytes to use for buffering frames\n obtained from realtime capture devices."]
    pub max_picture_buffer: ::std::os::raw::c_uint,
    #[doc = " Number of chapters in AVChapter array.\n When muxing, chapters are normally written in the file header,\n so nb_chapters should normally be initialized before write_header\n is called. Some muxers (e.g. mov and mkv) can also write chapters\n in the trailer.  To write chapters in the trailer, nb_chapters\n must be zero when write_header is called and non-zero when\n write_trailer is called.\n - muxing: set by user\n - demuxing: set by libavformat"]
    pub nb_chapters: ::std::os::raw::c_uint,
    pub chapters: *mut *mut AVChapter,
    #[doc = " Metadata that applies to the whole file.\n\n - demuxing: set by libavformat in avformat_open_input()\n - muxing: may be set by the caller before avformat_write_header()\n\n Freed by libavformat in avformat_free_context()."]
    pub metadata: *mut AVDictionary,
    #[doc = " Start time of the stream in real world time, in microseconds\n since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the\n stream was captured at this real world time.\n - muxing: Set by the caller before avformat_write_header(). If set to\n           either 0 or AV_NOPTS_VALUE, then the current wall-time will\n           be used.\n - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that\n             the value may become known after some number of frames\n             have been received."]
    pub start_time_realtime: i64,
    #[doc = " The number of frames used for determining the framerate in\n avformat_find_stream_info().\n Demuxing only, set by the caller before avformat_find_stream_info()."]
    pub fps_probe_size: ::std::os::raw::c_int,
    #[doc = " Error recognition; higher values will detect more errors but may\n misdetect some more or less valid parts as errors.\n Demuxing only, set by the caller before avformat_open_input()."]
    pub error_recognition: ::std::os::raw::c_int,
    #[doc = " Custom interrupt callbacks for the I/O layer.\n\n demuxing: set by the user before avformat_open_input().\n muxing: set by the user before avformat_write_header()\n (mainly useful for AVFMT_NOFILE formats). The callback\n should also be passed to avio_open2() if it's used to\n open the file."]
    pub interrupt_callback: AVIOInterruptCB,
    #[doc = " Flags to enable debugging."]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Maximum buffering duration for interleaving.\n\n To ensure all the streams are interleaved correctly,\n av_interleaved_write_frame() will wait until it has at least one packet\n for each stream before actually writing any packets to the output file.\n When some streams are \"sparse\" (i.e. there are large gaps between\n successive packets), this can result in excessive buffering.\n\n This field specifies the maximum difference between the timestamps of the\n first and the last packet in the muxing queue, above which libavformat\n will output a packet regardless of whether it has queued a packet for all\n the streams.\n\n Muxing only, set by the caller before avformat_write_header()."]
    pub max_interleave_delta: i64,
    #[doc = " Allow non-standard and experimental extension\n @see AVCodecContext.strict_std_compliance"]
    pub strict_std_compliance: ::std::os::raw::c_int,
    #[doc = " Flags indicating events happening on the file, a combination of\n AVFMT_EVENT_FLAG_*.\n\n - demuxing: may be set by the demuxer in avformat_open_input(),\n   avformat_find_stream_info() and av_read_frame(). Flags must be cleared\n   by the user once the event has been handled.\n - muxing: may be set by the user after avformat_write_header() to\n   indicate a user-triggered event.  The muxer will clear the flags for\n   events it has handled in av_[interleaved]_write_frame()."]
    pub event_flags: ::std::os::raw::c_int,
    #[doc = " Maximum number of packets to read while waiting for the first timestamp.\n Decoding only."]
    pub max_ts_probe: ::std::os::raw::c_int,
    #[doc = " Avoid negative timestamps during muxing.\n Any value of the AVFMT_AVOID_NEG_TS_* constants.\n Note, this works better when using av_interleaved_write_frame().\n - muxing: Set by user\n - demuxing: unused"]
    pub avoid_negative_ts: ::std::os::raw::c_int,
    #[doc = " Transport stream id.\n This will be moved into demuxer private options. Thus no API/ABI compatibility"]
    pub ts_id: ::std::os::raw::c_int,
    #[doc = " Audio preload in microseconds.\n Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n - encoding: Set by user\n - decoding: unused"]
    pub audio_preload: ::std::os::raw::c_int,
    #[doc = " Max chunk time in microseconds.\n Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n - encoding: Set by user\n - decoding: unused"]
    pub max_chunk_duration: ::std::os::raw::c_int,
    #[doc = " Max chunk size in bytes\n Note, not all formats support this and unpredictable things may happen if it is used when not supported.\n - encoding: Set by user\n - decoding: unused"]
    pub max_chunk_size: ::std::os::raw::c_int,
    #[doc = " forces the use of wallclock timestamps as pts/dts of packets\n This has undefined results in the presence of B frames.\n - encoding: unused\n - decoding: Set by user"]
    pub use_wallclock_as_timestamps: ::std::os::raw::c_int,
    #[doc = " avio flags, used to force AVIO_FLAG_DIRECT.\n - encoding: unused\n - decoding: Set by user"]
    pub avio_flags: ::std::os::raw::c_int,
    #[doc = " The duration field can be estimated through various ways, and this field can be used\n to know how the duration was estimated.\n - encoding: unused\n - decoding: Read by user"]
    pub duration_estimation_method: AVDurationEstimationMethod,
    #[doc = " Skip initial bytes when opening stream\n - encoding: unused\n - decoding: Set by user"]
    pub skip_initial_bytes: i64,
    #[doc = " Correct single timestamp overflows\n - encoding: unused\n - decoding: Set by user"]
    pub correct_ts_overflow: ::std::os::raw::c_uint,
    #[doc = " Force seeking to any (also non key) frames.\n - encoding: unused\n - decoding: Set by user"]
    pub seek2any: ::std::os::raw::c_int,
    #[doc = " Flush the I/O context after each packet.\n - encoding: Set by user\n - decoding: unused"]
    pub flush_packets: ::std::os::raw::c_int,
    #[doc = " format probing score.\n The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes\n the format.\n - encoding: unused\n - decoding: set by avformat, read by user"]
    pub probe_score: ::std::os::raw::c_int,
    #[doc = " Maximum number of bytes read from input in order to identify the\n \\ref AVInputFormat \"input format\". Only used when the format is not set\n explicitly by the caller.\n\n Demuxing only, set by the caller before avformat_open_input().\n\n @sa probesize"]
    pub format_probesize: ::std::os::raw::c_int,
    #[doc = " ',' separated list of allowed decoders.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub codec_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " ',' separated list of allowed demuxers.\n If NULL then all are allowed\n - encoding: unused\n - decoding: set by user"]
    pub format_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " IO repositioned flag.\n This is set by avformat when the underlaying IO context read pointer\n is repositioned, for example when doing byte based seeking.\n Demuxers can use the flag to detect such changes."]
    pub io_repositioned: ::std::os::raw::c_int,
    #[doc = " Forced video codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub video_codec: *const AVCodec,
    #[doc = " Forced audio codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub audio_codec: *const AVCodec,
    #[doc = " Forced subtitle codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub subtitle_codec: *const AVCodec,
    #[doc = " Forced data codec.\n This allows forcing a specific decoder, even when there are multiple with\n the same codec_id.\n Demuxing: Set by user"]
    pub data_codec: *const AVCodec,
    #[doc = " Number of bytes to be written as padding in a metadata header.\n Demuxing: Unused.\n Muxing: Set by user via av_format_set_metadata_header_padding."]
    pub metadata_header_padding: ::std::os::raw::c_int,
    #[doc = " User data.\n This is a place for some private data of the user."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Callback used by devices to communicate with application."]
    pub control_message_cb: av_format_control_message,
    #[doc = " Output timestamp offset, in microseconds.\n Muxing: set by user"]
    pub output_ts_offset: i64,
    #[doc = " dump format separator.\n can be \", \" or \"\\n      \" or anything else\n - muxing: Set by user.\n - demuxing: Set by user."]
    pub dump_separator: *mut u8,
    #[doc = " Forced Data codec_id.\n Demuxing: Set by user."]
    pub data_codec_id: AVCodecID,
    #[doc = " ',' separated list of allowed protocols.\n - encoding: unused\n - decoding: set by user"]
    pub protocol_whitelist: *mut ::std::os::raw::c_char,
    #[doc = " A callback for opening new IO streams.\n\n Whenever a muxer or a demuxer needs to open an IO stream (typically from\n avformat_open_input() for demuxers, but for certain formats can happen at\n other times as well), it will call this callback to obtain an IO context.\n\n @param s the format context\n @param pb on success, the newly opened IO context should be returned here\n @param url the url to open\n @param flags a combination of AVIO_FLAG_*\n @param options a dictionary of additional options, with the same\n                semantics as in avio_open2()\n @return 0 on success, a negative AVERROR code on failure\n\n @note Certain muxers and demuxers do nesting, i.e. they open one or more\n additional internal format contexts. Thus the AVFormatContext pointer\n passed to this callback may be different from the one facing the caller.\n It will, however, have the same 'opaque' field."]
    pub io_open: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
            options: *mut *mut AVDictionary,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A callback for closing the streams opened with AVFormatContext.io_open()."]
    pub io_close:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    #[doc = " ',' separated list of disallowed protocols.\n - encoding: unused\n - decoding: set by user"]
    pub protocol_blacklist: *mut ::std::os::raw::c_char,
    #[doc = " The maximum number of streams.\n - encoding: unused\n - decoding: set by user"]
    pub max_streams: ::std::os::raw::c_int,
    #[doc = " Skip duration calcuation in estimate_timings_from_pts.\n - encoding: unused\n - decoding: set by user"]
    pub skip_estimate_duration_from_pts: ::std::os::raw::c_int,
    #[doc = " Maximum number of packets that can be probed\n - encoding: unused\n - decoding: set by user"]
    pub max_probe_packets: ::std::os::raw::c_int,
    #[doc = " A callback for closing the streams opened with AVFormatContext.io_open().\n\n Using this is preferred over io_close, because this can return an error.\n Therefore this callback is used instead of io_close by the generic\n libavformat code if io_close is NULL or the default.\n\n @param s the format context\n @param pb IO context to be closed and freed\n @return 0 on success, a negative AVERROR code on failure"]
    pub io_close2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut AVIOContext,
        ) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    #[doc = " This function will cause global side data to be injected in the next packet\n of each stream as well as after any subsequent seek."]
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    #[doc = " Returns the method used to set ctx->duration.\n\n @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE."]
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
extern "C" {
    #[doc = " Return the LIBAVFORMAT_VERSION_INT constant."]
    pub fn avformat_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavformat build-time configuration."]
    pub fn avformat_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavformat license."]
    pub fn avformat_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Do global initialization of network libraries. This is optional,\n and not recommended anymore.\n\n This functions only exists to work around thread-safety issues\n with older GnuTLS or OpenSSL libraries. If libavformat is linked\n to newer versions of those libraries, or if you do not use them,\n calling this function is unnecessary. Otherwise, you need to call\n this function before any other threads using them are started.\n\n This function will be deprecated once support for older GnuTLS and\n OpenSSL libraries is removed, and this function has no purpose\n anymore."]
    pub fn avformat_network_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Undo the initialization done by avformat_network_init. Call it only\n once for each time you called avformat_network_init."]
    pub fn avformat_network_deinit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over all registered muxers.\n\n @param opaque a pointer where libavformat will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered muxer or NULL when the iteration is\n         finished"]
    pub fn av_muxer_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVOutputFormat;
}
extern "C" {
    #[doc = " Iterate over all registered demuxers.\n\n @param opaque a pointer where libavformat will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the next registered demuxer or NULL when the iteration is\n         finished"]
    pub fn av_demuxer_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Allocate an AVFormatContext.\n avformat_free_context() can be used to free the context and everything\n allocated by the framework within it."]
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    #[doc = " Free an AVFormatContext and all its streams.\n @param s context to free"]
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    #[doc = " Get the AVClass for AVFormatContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Get the AVClass for AVStream. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn av_stream_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Add a new stream to a media file.\n\n When demuxing, it is called by the demuxer in read_header(). If the\n flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also\n be called in read_packet().\n\n When muxing, should be called by the user before avformat_write_header().\n\n User is required to call avformat_free_context() to clean up the allocation\n by avformat_new_stream().\n\n @param s media file handle\n @param c unused, does nothing\n\n @return newly created stream or NULL on error."]
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    #[doc = " Wrap an existing array as stream side data.\n\n @param st stream\n @param type side information type\n @param data the side data array. It must be allocated with the av_malloc()\n             family of functions. The ownership of the data is transferred to\n             st.\n @param size side information size\n @return zero on success, a negative AVERROR code on failure. On failure,\n         the stream is unchanged and the data remains owned by the caller."]
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate new information from stream.\n\n @param stream stream\n @param type desired side information type\n @param size side information size\n @return pointer to fresh allocated data or NULL otherwise"]
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get side information from stream.\n\n @param stream stream\n @param type desired side information type\n @param size If supplied, *size will be set to the size of the side data\n             or to zero if the desired side data is not present.\n @return pointer to data if present or NULL otherwise"]
    pub fn av_stream_get_side_data(
        stream: *const AVStream,
        type_: AVPacketSideDataType,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: ::std::os::raw::c_int) -> *mut AVProgram;
}
extern "C" {
    #[doc = " Allocate an AVFormatContext for an output format.\n avformat_free_context() can be used to free the context and\n everything allocated by the framework within it.\n\n @param *ctx is set to the created format context, or to NULL in\n case of failure\n @param oformat format to use for allocating the context, if NULL\n format_name and filename are used instead\n @param format_name the name of output format to use for allocating the\n context, if NULL filename is used instead\n @param filename the name of the filename to use for allocating the\n context, may be NULL\n @return >= 0 in case of success, a negative AVERROR code in case of\n failure"]
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *const AVOutputFormat,
        format_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find AVInputFormat based on the short name of the input format."]
    pub fn av_find_input_format(short_name: *const ::std::os::raw::c_char) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format.\n\n @param pd        data to be probed\n @param is_opened Whether the file is already opened; determines whether\n                  demuxers with or without AVFMT_NOFILE are probed."]
    pub fn av_probe_input_format(
        pd: *const AVProbeData,
        is_opened: ::std::os::raw::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format.\n\n @param pd        data to be probed\n @param is_opened Whether the file is already opened; determines whether\n                  demuxers with or without AVFMT_NOFILE are probed.\n @param score_max A probe score larger that this is required to accept a\n                  detection, the variable is set to the actual detection\n                  score afterwards.\n                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended\n                  to retry with a larger probe buffer."]
    pub fn av_probe_input_format2(
        pd: *const AVProbeData,
        is_opened: ::std::os::raw::c_int,
        score_max: *mut ::std::os::raw::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Guess the file format.\n\n @param is_opened Whether the file is already opened; determines whether\n                  demuxers with or without AVFMT_NOFILE are probed.\n @param score_ret The score of the best detection."]
    pub fn av_probe_input_format3(
        pd: *const AVProbeData,
        is_opened: ::std::os::raw::c_int,
        score_ret: *mut ::std::os::raw::c_int,
    ) -> *const AVInputFormat;
}
extern "C" {
    #[doc = " Probe a bytestream to determine the input format. Each time a probe returns\n with a score that is too low, the probe buffer size is increased and another\n attempt is made. When the maximum probe size is reached, the input format\n with the highest score is returned.\n\n @param pb the bytestream to probe\n @param fmt the input format is put here\n @param url the url of the stream\n @param logctx the log context\n @param offset the offset within the bytestream to probe from\n @param max_probe_size the maximum probe buffer size (zero for default)\n @return the score in case of success, a negative value corresponding to an\n         the maximal score is AVPROBE_SCORE_MAX\n AVERROR code otherwise"]
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *const AVInputFormat,
        url: *const ::std::os::raw::c_char,
        logctx: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_uint,
        max_probe_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like av_probe_input_buffer2() but returns 0 on success"]
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *const AVInputFormat,
        url: *const ::std::os::raw::c_char,
        logctx: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_uint,
        max_probe_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open an input stream and read the header. The codecs are not opened.\n The stream must be closed with avformat_close_input().\n\n @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).\n           May be a pointer to NULL, in which case an AVFormatContext is allocated by this\n           function and written into ps.\n           Note that a user-supplied AVFormatContext will be freed on failure.\n @param url URL of the stream to open.\n @param fmt If non-NULL, this parameter forces a specific input format.\n            Otherwise the format is autodetected.\n @param options  A dictionary filled with AVFormatContext and demuxer-private options.\n                 On return this parameter will be destroyed and replaced with a dict containing\n                 options that were not found. May be NULL.\n\n @return 0 on success, a negative AVERROR on failure.\n\n @note If you want to use custom IO, preallocate the format context and set its pb field."]
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const ::std::os::raw::c_char,
        fmt: *const AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read packets of a media file to get stream information. This\n is useful for file formats with no headers such as MPEG. This\n function also computes the real framerate in case of MPEG-2 repeat\n frame mode.\n The logical file position is not changed by this function;\n examined packets may be buffered for later processing.\n\n @param ic media file handle\n @param options  If non-NULL, an ic.nb_streams long array of pointers to\n                 dictionaries, where i-th member contains options for\n                 codec corresponding to i-th stream.\n                 On return each dictionary will be filled with options that were not found.\n @return >=0 if OK, AVERROR_xxx on error\n\n @note this function isn't guaranteed to open all the codecs, so\n       options being non-empty at return is a perfectly normal behavior.\n\n @todo Let the user decide somehow what information is needed so that\n       we do not waste time getting stuff the user does not need."]
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the programs which belong to a given stream.\n\n @param ic    media file handle\n @param last  the last found program, the search will start after this\n              program, or from the beginning if it is NULL\n @param s     stream index\n @return the next program which belongs to s, NULL if no program is found or\n         the last program is not among the programs of ic."]
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: ::std::os::raw::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Find the \"best\" stream in the file.\n The best stream is determined according to various heuristics as the most\n likely to be what the user expects.\n If the decoder parameter is non-NULL, av_find_best_stream will find the\n default decoder for the stream's codec; streams for which no decoder can\n be found are ignored.\n\n @param ic                media file handle\n @param type              stream type: video, audio, subtitles, etc.\n @param wanted_stream_nb  user-requested stream number,\n                          or -1 for automatic selection\n @param related_stream    try to find a stream related (eg. in the same\n                          program) to this one, or -1 if none\n @param decoder_ret       if non-NULL, returns the decoder for the\n                          selected stream\n @param flags             flags; none are currently defined\n @return  the non-negative stream number in case of success,\n          AVERROR_STREAM_NOT_FOUND if no stream with the requested type\n          could be found,\n          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder\n @note  If av_find_best_stream returns successfully and decoder_ret is not\n        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec."]
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: ::std::os::raw::c_int,
        related_stream: ::std::os::raw::c_int,
        decoder_ret: *mut *const AVCodec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the next frame of a stream.\n This function returns what is stored in the file, and does not validate\n that what is there are valid frames for the decoder. It will split what is\n stored in the file into frames and return one for each call. It will not\n omit invalid data between valid frames so as to give the decoder the maximum\n information possible for decoding.\n\n On success, the returned packet is reference-counted (pkt->buf is set) and\n valid indefinitely. The packet must be freed with av_packet_unref() when\n it is no longer needed. For video, the packet contains exactly one frame.\n For audio, it contains an integer number of frames if each frame has\n a known fixed size (e.g. PCM or ADPCM data). If the audio frames have\n a variable size (e.g. MPEG audio), then it contains one frame.\n\n pkt->pts, pkt->dts and pkt->duration are always set to correct\n values in AVStream.time_base units (and guessed if the format cannot\n provide them). pkt->pts can be AV_NOPTS_VALUE if the video format\n has B-frames, so it is better to rely on pkt->dts if you do not\n decompress the payload.\n\n @return 0 if OK, < 0 on error or end of file. On error, pkt will be blank\n         (as if it came from av_packet_alloc()).\n\n @note pkt will be initialized, so it may be uninitialized, but it must not\n       contain data that needs to be freed."]
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seek to the keyframe at timestamp.\n 'timestamp' in 'stream_index'.\n\n @param s media file handle\n @param stream_index If stream_index is (-1), a default\n stream is selected, and timestamp is automatically converted\n from AV_TIME_BASE units to the stream specific time_base.\n @param timestamp Timestamp in AVStream.time_base units\n        or, if no stream is specified, in AV_TIME_BASE units.\n @param flags flags which select direction and seeking mode\n @return >= 0 on success"]
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seek to timestamp ts.\n Seeking will be done so that the point from which all active streams\n can be presented successfully will be closest to ts and within min/max_ts.\n Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.\n\n If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and\n are the file position (this may not be supported by all demuxers).\n If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames\n in the stream with stream_index (this may not be supported by all demuxers).\n Otherwise all timestamps are in units of the stream selected by stream_index\n or if stream_index is -1, in AV_TIME_BASE units.\n If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as\n keyframes (this may not be supported by all demuxers).\n If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.\n\n @param s media file handle\n @param stream_index index of the stream which is used as time base reference\n @param min_ts smallest acceptable timestamp\n @param ts target timestamp\n @param max_ts largest acceptable timestamp\n @param flags flags\n @return >=0 on success, error code otherwise\n\n @note This is part of the new seek API which is still under construction."]
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Discard all internally buffered data. This can be useful when dealing with\n discontinuities in the byte stream. Generally works only with formats that\n can resync. This includes headerless formats like MPEG-TS/TS but should also\n work with NUT, Ogg and in a limited way AVI for example.\n\n The set of streams, the detected duration, stream parameters and codecs do\n not change when calling this function. If you want a complete reset, it's\n better to open a new AVFormatContext.\n\n This does not flush the AVIOContext (s->pb). If necessary, call\n avio_flush(s->pb) before calling this function.\n\n @param s media file handle\n @return >=0 on success, error code otherwise"]
    pub fn avformat_flush(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start playing a network-based stream (e.g. RTSP stream) at the\n current position."]
    pub fn av_read_play(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause a network-based stream (e.g. RTSP stream).\n\n Use av_read_play() to resume it."]
    pub fn av_read_pause(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close an opened input AVFormatContext. Free it and all its contents\n and set *s to NULL."]
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    #[doc = " Allocate the stream private data and write the stream header to\n an output media file.\n\n @param s Media file handle, must be allocated with avformat_alloc_context().\n          Its oformat field must be set to the desired output format;\n          Its pb field must be set to an already opened AVIOContext.\n @param options  An AVDictionary filled with AVFormatContext and muxer-private options.\n                 On return this parameter will be destroyed and replaced with a dict containing\n                 options that were not found. May be NULL.\n\n @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,\n         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,\n         negative AVERROR on failure.\n\n @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output."]
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate the stream private data and initialize the codec, but do not write the header.\n May optionally be used before avformat_write_header to initialize stream parameters\n before actually writing the header.\n If using this function, do not pass the same options to avformat_write_header.\n\n @param s Media file handle, must be allocated with avformat_alloc_context().\n          Its oformat field must be set to the desired output format;\n          Its pb field must be set to an already opened AVIOContext.\n @param options  An AVDictionary filled with AVFormatContext and muxer-private options.\n                 On return this parameter will be destroyed and replaced with a dict containing\n                 options that were not found. May be NULL.\n\n @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,\n         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,\n         negative AVERROR on failure.\n\n @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header."]
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a packet to an output media file.\n\n This function passes the packet directly to the muxer, without any buffering\n or reordering. The caller is responsible for correctly interleaving the\n packets if the format requires it. Callers that want libavformat to handle\n the interleaving should call av_interleaved_write_frame() instead of this\n function.\n\n @param s media file handle\n @param pkt The packet containing the data to be written. Note that unlike\n            av_interleaved_write_frame(), this function does not take\n            ownership of the packet passed to it (though some muxers may make\n            an internal reference to the input packet).\n            <br>\n            This parameter can be NULL (at any time, not just at the end), in\n            order to immediately flush data buffered within the muxer, for\n            muxers that buffer up data internally before writing it to the\n            output.\n            <br>\n            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n            set to the index of the corresponding stream in @ref\n            AVFormatContext.streams \"s->streams\".\n            <br>\n            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n            must be set to correct values in the stream's timebase (unless the\n            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n            they can be set to AV_NOPTS_VALUE).\n            The dts for subsequent packets passed to this function must be strictly\n            increasing when compared in their respective timebases (unless the\n            output format is flagged with the AVFMT_TS_NONSTRICT, then they\n            merely have to be nondecreasing).  @ref AVPacket.duration\n            \"duration\") should also be set if known.\n @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush\n\n @see av_interleaved_write_frame()"]
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a packet to an output media file ensuring correct interleaving.\n\n This function will buffer the packets internally as needed to make sure the\n packets in the output file are properly interleaved, usually ordered by\n increasing dts. Callers doing their own interleaving should call\n av_write_frame() instead of this function.\n\n Using this function instead of av_write_frame() can give muxers advance\n knowledge of future packets, improving e.g. the behaviour of the mp4\n muxer for VFR content in fragmenting mode.\n\n @param s media file handle\n @param pkt The packet containing the data to be written.\n            <br>\n            If the packet is reference-counted, this function will take\n            ownership of this reference and unreference it later when it sees\n            fit. If the packet is not reference-counted, libavformat will\n            make a copy.\n            The returned packet will be blank (as if returned from\n            av_packet_alloc()), even on error.\n            <br>\n            This parameter can be NULL (at any time, not just at the end), to\n            flush the interleaving queues.\n            <br>\n            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n            set to the index of the corresponding stream in @ref\n            AVFormatContext.streams \"s->streams\".\n            <br>\n            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n            must be set to correct values in the stream's timebase (unless the\n            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n            they can be set to AV_NOPTS_VALUE).\n            The dts for subsequent packets in one stream must be strictly\n            increasing (unless the output format is flagged with the\n            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).\n            @ref AVPacket.duration \"duration\" should also be set if known.\n\n @return 0 on success, a negative AVERROR on error.\n\n @see av_write_frame(), AVFormatContext.max_interleave_delta"]
    pub fn av_interleaved_write_frame(
        s: *mut AVFormatContext,
        pkt: *mut AVPacket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an uncoded frame to an output media file.\n\n The frame must be correctly interleaved according to the container\n specification; if not, av_interleaved_write_uncoded_frame() must be used.\n\n See av_interleaved_write_uncoded_frame() for details."]
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an uncoded frame to an output media file.\n\n If the muxer supports it, this function makes it possible to write an AVFrame\n structure directly, without encoding it into a packet.\n It is mostly useful for devices and similar special muxers that use raw\n video or PCM data and will not serialize it into a byte stream.\n\n To test whether it is possible to use it with a given muxer and stream,\n use av_write_uncoded_frame_query().\n\n The caller gives up ownership of the frame and must not access it\n afterwards.\n\n @return  >=0 for success, a negative code on error"]
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test whether a muxer supports uncoded frame.\n\n @return  >=0 if an uncoded frame can be written to that muxer and stream,\n          <0 if not"]
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write the stream trailer to an output media file and free the\n file private data.\n\n May only be called after a successful call to avformat_write_header.\n\n @param s media file handle\n @return 0 if OK, AVERROR_xxx on error"]
    pub fn av_write_trailer(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the output format in the list of registered output formats\n which best matches the provided parameters, or return NULL if\n there is no match.\n\n @param short_name if non-NULL checks if short_name matches with the\n names of the registered formats\n @param filename if non-NULL checks if filename terminates with the\n extensions of the registered formats\n @param mime_type if non-NULL checks if mime_type matches with the\n MIME type of the registered formats"]
    pub fn av_guess_format(
        short_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        mime_type: *const ::std::os::raw::c_char,
    ) -> *const AVOutputFormat;
}
extern "C" {
    #[doc = " Guess the codec ID based upon muxer and filename."]
    pub fn av_guess_codec(
        fmt: *const AVOutputFormat,
        short_name: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        mime_type: *const ::std::os::raw::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    #[doc = " Get timing information for the data currently output.\n The exact meaning of \"currently output\" depends on the format.\n It is mostly relevant for devices that have an internal buffer and/or\n work in real time.\n @param s          media file handle\n @param stream     stream in the media file\n @param[out] dts   DTS of the last packet output for the stream, in stream\n                   time_base units\n @param[out] wall  absolute time when that packet whas output,\n                   in microsecond\n @return  0 if OK, AVERROR(ENOSYS) if the format does not support it\n Note: some formats or devices may not allow to measure dts and wall\n atomically."]
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: ::std::os::raw::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a nice hexadecimal dump of a buffer to the specified file stream.\n\n @param f The file stream pointer where the dump should be sent to.\n @param buf buffer\n @param size buffer size\n\n @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2"]
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Send a nice hexadecimal dump of a buffer to the log.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n pointer to an AVClass struct.\n @param level The importance level of the message, lower values signifying\n higher importance.\n @param buf buffer\n @param size buffer size\n\n @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2"]
    pub fn av_hex_dump_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        buf: *const u8,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Send a nice dump of a packet to the specified file stream.\n\n @param f The file stream pointer where the dump should be sent to.\n @param pkt packet to dump\n @param dump_payload True if the payload must be displayed, too.\n @param st AVStream that the packet belongs to"]
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: ::std::os::raw::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    #[doc = " Send a nice dump of a packet to the log.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n pointer to an AVClass struct.\n @param level The importance level of the message, lower values signifying\n higher importance.\n @param pkt packet to dump\n @param dump_payload True if the payload must be displayed, too.\n @param st AVStream that the packet belongs to"]
    pub fn av_pkt_dump_log2(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        pkt: *const AVPacket,
        dump_payload: ::std::os::raw::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    #[doc = " Get the AVCodecID for the given codec tag tag.\n If no codec id is found returns AV_CODEC_ID_NONE.\n\n @param tags list of supported codec_id-codec_tag pairs, as stored\n in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n @param tag  codec tag to match to a codec ID"]
    pub fn av_codec_get_id(
        tags: *const *const AVCodecTag,
        tag: ::std::os::raw::c_uint,
    ) -> AVCodecID;
}
extern "C" {
    #[doc = " Get the codec tag for the given codec id id.\n If no codec tag is found returns 0.\n\n @param tags list of supported codec_id-codec_tag pairs, as stored\n in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n @param id   codec ID to match to a codec tag"]
    pub fn av_codec_get_tag(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the codec tag for the given codec id.\n\n @param tags list of supported codec_id - codec_tag pairs, as stored\n in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n @param id codec id that should be searched for in the list\n @param tag A pointer to the found tag\n @return 0 if id was not found in tags, > 0 if it was found"]
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the index for a specific timestamp.\n\n @param st        stream that the timestamp belongs to\n @param timestamp timestamp to retrieve the index for\n @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond\n                 to the timestamp which is <= the requested one, if backward\n                 is 0, then it will be >=\n              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise\n @return < 0 if no such timestamp could be found"]
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the index entry count for the given AVStream.\n\n @param st stream\n @return the number of index entries in the stream"]
    pub fn avformat_index_get_entries_count(st: *const AVStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the AVIndexEntry corresponding to the given index.\n\n @param st          Stream containing the requested AVIndexEntry.\n @param idx         The desired index.\n @return A pointer to the requested AVIndexEntry if it exists, NULL otherwise.\n\n @note The pointer returned by this function is only guaranteed to be valid\n       until any function that takes the stream or the parent AVFormatContext\n       as input argument is called."]
    pub fn avformat_index_get_entry(
        st: *mut AVStream,
        idx: ::std::os::raw::c_int,
    ) -> *const AVIndexEntry;
}
extern "C" {
    #[doc = " Get the AVIndexEntry corresponding to the given timestamp.\n\n @param st          Stream containing the requested AVIndexEntry.\n @param timestamp   Timestamp to retrieve the index entry for.\n @param flags       If AVSEEK_FLAG_BACKWARD then the returned entry will correspond\n                    to the timestamp which is <= the requested one, if backward\n                    is 0, then it will be >=\n                    if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise.\n @return A pointer to the requested AVIndexEntry if it exists, NULL otherwise.\n\n @note The pointer returned by this function is only guaranteed to be valid\n       until any function that takes the stream or the parent AVFormatContext\n       as input argument is called."]
    pub fn avformat_index_get_entry_from_timestamp(
        st: *mut AVStream,
        wanted_timestamp: i64,
        flags: ::std::os::raw::c_int,
    ) -> *const AVIndexEntry;
}
extern "C" {
    #[doc = " Add an index entry into a sorted list. Update the entry if the list\n already contains it.\n\n @param timestamp timestamp in the time base of the given stream"]
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: ::std::os::raw::c_int,
        distance: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Split a URL string into components.\n\n The pointers to buffers for storing individual components may be null,\n in order to ignore that component. Buffers for components not found are\n set to empty strings. If the port is not found, it is set to a negative\n value.\n\n @param proto the buffer for the protocol\n @param proto_size the size of the proto buffer\n @param authorization the buffer for the authorization\n @param authorization_size the size of the authorization buffer\n @param hostname the buffer for the host name\n @param hostname_size the size of the hostname buffer\n @param port_ptr a pointer to store the port number in\n @param path the buffer for the path\n @param path_size the size of the path buffer\n @param url the URL to split"]
    pub fn av_url_split(
        proto: *mut ::std::os::raw::c_char,
        proto_size: ::std::os::raw::c_int,
        authorization: *mut ::std::os::raw::c_char,
        authorization_size: ::std::os::raw::c_int,
        hostname: *mut ::std::os::raw::c_char,
        hostname_size: ::std::os::raw::c_int,
        port_ptr: *mut ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        path_size: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Print detailed information about the input or output format, such as\n duration, bitrate, streams, container, programs, metadata, side data,\n codec and time base.\n\n @param ic        the context to analyze\n @param index     index of the stream to dump information about\n @param url       the URL to print, such as source or destination file\n @param is_output Select whether the specified context is an input(0) or output(1)"]
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
        is_output: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return in 'buf' the path with '%d' replaced by a number.\n\n Also handles the '%0nd' format where 'n' is the total number\n of digits and '%%'.\n\n @param buf destination buffer\n @param buf_size destination buffer size\n @param path numbered sequence string\n @param number frame number\n @param flags AV_FRAME_FILENAME_FLAGS_*\n @return 0 if OK, -1 on format error"]
    pub fn av_get_frame_filename2(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether filename actually is a numbered sequence generator.\n\n @param filename possible numbered sequence string\n @return 1 if a valid numbered sequence string, 0 otherwise"]
    pub fn av_filename_number_test(
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate an SDP for an RTP session.\n\n Note, this overwrites the id values of AVStreams in the muxer contexts\n for getting unique dynamic payload types.\n\n @param ac array of AVFormatContexts describing the RTP streams. If the\n           array is composed by only one context, such context can contain\n           multiple AVStreams (one AVStream per RTP stream). Otherwise,\n           all the contexts in the array (an AVCodecContext per RTP stream)\n           must contain only one AVStream.\n @param n_files number of AVCodecContexts contained in ac\n @param buf buffer where the SDP will be stored (must be allocated by\n            the caller)\n @param size the size of the buffer\n @return 0 if OK, AVERROR_xxx on error"]
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a positive value if the given filename has one of the given\n extensions, 0 otherwise.\n\n @param filename   file name to check against the given extensions\n @param extensions a comma-separated list of filename extensions"]
    pub fn av_match_ext(
        filename: *const ::std::os::raw::c_char,
        extensions: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if the given container can store a codec.\n\n @param ofmt           container to check for compatibility\n @param codec_id       codec to potentially store in container\n @param std_compliance standards compliance level, one of FF_COMPLIANCE_*\n\n @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.\n         A negative number if this information is not available."]
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup riff_fourcc RIFF FourCCs\n @{\n Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are\n meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the\n following code:\n @code\n uint32_t tag = MKTAG('H', '2', '6', '4');\n const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };\n enum AVCodecID id = av_codec_get_id(table, tag);\n @endcode\n/\n/**\n @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID."]
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping RIFF FourCCs for audio to AVCodecID."]
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping MOV FourCCs for video to libavcodec AVCodecID."]
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " @return the table mapping MOV FourCCs for audio to AVCodecID."]
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    #[doc = " Guess the sample aspect ratio of a frame, based on both the stream and the\n frame aspect ratio.\n\n Since the frame aspect ratio is set by the codec but the stream aspect ratio\n is set by the demuxer, these two may not be equal. This function tries to\n return the value that you should use if you would like to display the frame.\n\n Basic logic is to use the stream aspect ratio if it is set to something sane\n otherwise use the frame aspect ratio. This way a container setting, which is\n usually easy to modify can override the coded value in the frames.\n\n @param format the format context which the stream is part of\n @param stream the stream which the frame is part of\n @param frame the frame with the aspect ratio to be determined\n @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea"]
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    #[doc = " Guess the frame rate, based on both the container and codec information.\n\n @param ctx the format context which the stream is part of\n @param stream the stream which the frame is part of\n @param frame the frame for which the frame rate should be determined, may be NULL\n @return the guessed (valid) frame rate, 0/1 if no idea"]
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    #[doc = " Check if the stream st contained in s is matched by the stream specifier\n spec.\n\n See the \"stream specifiers\" chapter in the documentation for the syntax\n of spec.\n\n @return  >0 if st is matched by spec;\n          0  if st is not matched by spec;\n          AVERROR code if spec is invalid\n\n @note  A stream specifier can match several streams in the format."]
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVTimebaseSource {
    AVFMT_TBCF_AUTO = -1,
    AVFMT_TBCF_DECODER = 0,
    AVFMT_TBCF_DEMUXER = 1,
    AVFMT_TBCF_R_FRAMERATE = 2,
}
extern "C" {
    #[doc = " Transfer internal timing information from one stream to another.\n\n This function is useful when doing stream copy.\n\n @param ofmt     target output format for ost\n @param ost      output stream which needs timings copy and adjustments\n @param ist      reference input stream to copy timings from\n @param copy_tb  define from where the stream codec timebase needs to be imported"]
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the internal codec timebase from a stream.\n\n @param st  input stream to extract the timebase from"]
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVComponentDescriptor {
    #[doc = " Which of the 4 planes contains the component."]
    pub plane: ::std::os::raw::c_int,
    #[doc = " Number of elements between 2 horizontally consecutive pixels.\n Elements are bits for bitstream formats, bytes otherwise."]
    pub step: ::std::os::raw::c_int,
    #[doc = " Number of elements before the component of the first pixel.\n Elements are bits for bitstream formats, bytes otherwise."]
    pub offset: ::std::os::raw::c_int,
    #[doc = " Number of least significant bits that must be shifted away\n to get the value."]
    pub shift: ::std::os::raw::c_int,
    #[doc = " Number of bits in the component."]
    pub depth: ::std::os::raw::c_int,
}
#[doc = " Descriptor that unambiguously describes how the bits of a pixel are\n stored in the up to 4 data planes of an image. It also stores the\n subsampling factors and number of components.\n\n @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV\n       and all the YUV variants) AVPixFmtDescriptor just stores how values\n       are stored not what these values represent."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVPixFmtDescriptor {
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< The number of components each pixel has, (1-4)"]
    pub nb_components: u8,
    #[doc = " Amount to shift the luma width right to find the chroma width.\n For YV12 this is 1 for example.\n chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)\n The note above is needed to ensure rounding up.\n This value only refers to the chroma components."]
    pub log2_chroma_w: u8,
    #[doc = " Amount to shift the luma height right to find the chroma height.\n For YV12 this is 1 for example.\n chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)\n The note above is needed to ensure rounding up.\n This value only refers to the chroma components."]
    pub log2_chroma_h: u8,
    #[doc = " Combination of AV_PIX_FMT_FLAG_... flags."]
    pub flags: u64,
    #[doc = " Parameters that describe how pixels are packed.\n If the format has 1 or 2 components, then luma is 0.\n If the format has 3 or 4 components:\n   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;\n   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.\n\n If present, the Alpha channel is always the last component."]
    pub comp: [AVComponentDescriptor; 4usize],
    #[doc = " Alternative comma-separated names."]
    pub alias: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " Return the number of bits per pixel used by the pixel format\n described by pixdesc. Note that this is not the same as the number\n of bits per sample.\n\n The returned number of bits refers to the number of bits actually\n used for storing the pixel information, that is padding bits are\n not counted."]
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of bits per pixel for the pixel format\n described by pixdesc, including any padding or unused bits."]
    pub fn av_get_padded_bits_per_pixel(
        pixdesc: *const AVPixFmtDescriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a pixel format descriptor for provided pixel format or NULL if\n this pixel format is unknown."]
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " Iterate over all pixel format descriptors known to libavutil.\n\n @param prev previous descriptor. NULL to get the first descriptor.\n\n @return next descriptor or NULL after the last descriptor"]
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc\n is not a valid pointer to a pixel format descriptor."]
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Utility function to access log2_chroma_w log2_chroma_h from\n the pixel format AVPixFmtDescriptor.\n\n @param[in]  pix_fmt the pixel format\n @param[out] h_shift store log2_chroma_w (horizontal/width shift)\n @param[out] v_shift store log2_chroma_h (vertical/height shift)\n\n @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format"]
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut ::std::os::raw::c_int,
        v_shift: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a\n valid pixel format."]
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color range or NULL if unknown."]
    pub fn av_color_range_name(range: AVColorRange) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorRange value for name or an AVError if not found."]
    pub fn av_color_range_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color primaries or NULL if unknown."]
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorPrimaries value for name or an AVError if not found."]
    pub fn av_color_primaries_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color transfer or NULL if unknown."]
    pub fn av_color_transfer_name(
        transfer: AVColorTransferCharacteristic,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorTransferCharacteristic value for name or an AVError if not found."]
    pub fn av_color_transfer_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color space or NULL if unknown."]
    pub fn av_color_space_name(space: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorSpace value for name or an AVError if not found."]
    pub fn av_color_space_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided chroma location or NULL if unknown."]
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVChromaLocation value for name or an AVError if not found."]
    pub fn av_chroma_location_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts AVChromaLocation to swscale x/y chroma position.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position"]
    pub fn av_chroma_location_enum_to_pos(
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        pos: AVChromaLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts swscale x/y chroma position to AVChromaLocation.\n\n The positions represent the chroma (0,0) position in a coordinates system\n with luma (0,0) representing the origin and luma(1,1) representing 256,256\n\n @param xpos  horizontal chroma sample position\n @param ypos  vertical   chroma sample position"]
    pub fn av_chroma_location_pos_to_enum(
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    ) -> AVChromaLocation;
}
extern "C" {
    #[doc = " Return the pixel format corresponding to name.\n\n If there is no pixel format with name name, then looks for a\n pixel format with the name corresponding to the native endian\n format of name.\n For example in a little-endian system, first looks for \"gray16\",\n then for \"gray16le\".\n\n Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."]
    pub fn av_get_pix_fmt(name: *const ::std::os::raw::c_char) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Return the short name for a pixel format, NULL in case pix_fmt is\n unknown.\n\n @see av_get_pix_fmt(), av_get_pix_fmt_string()"]
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Print in buf the string corresponding to the pixel format with\n number pix_fmt, or a header if pix_fmt is negative.\n\n @param buf the buffer where to write the string\n @param buf_size the size of buf\n @param pix_fmt the number of the pixel format to print the\n corresponding info string, or a negative value to print the\n corresponding header."]
    pub fn av_get_pix_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a line from an image, and write the values of the\n pixel format component c to dst.\n\n @param data the array containing the pointers to the planes of the image\n @param linesize the array containing the linesizes of the image\n @param desc the pixel format descriptor for the image\n @param x the horizontal coordinate of the first pixel to read\n @param y the vertical coordinate of the first pixel to read\n @param w the width of the line to read, that is the number of\n values to write to dst\n @param read_pal_component if not zero and the format is a paletted\n format writes the values corresponding to the palette\n component c in data[1] to dst, rather than the palette indexes in\n data[0]. The behavior is undefined if the format is not paletted.\n @param dst_element_size size of elements in dst array (2 or 4 byte)"]
    pub fn av_read_image_line2(
        dst: *mut ::std::os::raw::c_void,
        data: *mut *const u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        read_pal_component: ::std::os::raw::c_int,
        dst_element_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        read_pal_component: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Write the values from src to the pixel format component c of an\n image line.\n\n @param src array containing the values to write\n @param data the array containing the pointers to the planes of the\n image to write into. It is supposed to be zeroed.\n @param linesize the array containing the linesizes of the image\n @param desc the pixel format descriptor for the image\n @param x the horizontal coordinate of the first pixel to write\n @param y the vertical coordinate of the first pixel to write\n @param w the width of the line to write, that is the number of\n values to write to the image line\n @param src_element_size size of elements in src array (2 or 4 byte)"]
    pub fn av_write_image_line2(
        src: *const ::std::os::raw::c_void,
        data: *mut *mut u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        src_element_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Utility function to swap the endianness of a pixel format.\n\n @param[in]  pix_fmt the pixel format\n\n @return pixel format with swapped endianness if it exists,\n otherwise AV_PIX_FMT_NONE"]
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific\n pixel format to another.\n When converting from one pixel format to another, information loss may occur.\n For example, when converting from RGB24 to GRAY, the color information will\n be lost. Similarly, other losses occur when converting from some formats to\n other formats. These losses can involve loss of chroma, but also loss of\n resolution, loss of color depth, loss due to the color space conversion, loss\n of the alpha bits or loss due to color quantization.\n av_get_fix_fmt_loss() informs you about the various types of losses\n which will occur when converting from one pixel format to another.\n\n @param[in] dst_pix_fmt destination pixel format\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @return Combination of flags informing you what kind of losses will occur\n (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific\n pixel format to another.\n When converting from one pixel format to another, information loss may occur.\n For example, when converting from RGB24 to GRAY, the color information will\n be lost. Similarly, other losses occur when converting from some formats to\n other formats. These losses can involve loss of chroma, but also loss of\n resolution, loss of color depth, loss due to the color space conversion, loss\n of the alpha bits or loss due to color quantization.\n av_get_fix_fmt_loss() informs you about the various types of losses\n which will occur when converting from one pixel format to another.\n\n @param[in] dst_pix_fmt destination pixel format\n @param[in] src_pix_fmt source pixel format\n @param[in] has_alpha Whether the source pixel format alpha channel is used.\n @return Combination of flags informing you what kind of losses will occur\n (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute the max pixel step for each plane of an image with a\n format described by pixdesc.\n\n The pixel step is the distance in bytes between the first byte of\n the group of bytes which describe a pixel component and the first\n byte of the successive group in the same plane for the same\n component.\n\n @param max_pixsteps an array which is filled with the max pixel step\n for each plane. Since a plane may contain different pixel\n components, the computed max_pixsteps[plane] is relative to the\n component in the plane with the max pixel step.\n @param max_pixstep_comps an array which is filled with the component\n for each plane which has the max pixel step. May be NULL."]
    pub fn av_image_fill_max_pixsteps(
        max_pixsteps: *mut ::std::os::raw::c_int,
        max_pixstep_comps: *mut ::std::os::raw::c_int,
        pixdesc: *const AVPixFmtDescriptor,
    );
}
extern "C" {
    #[doc = " Compute the size of an image line with format pix_fmt and width\n width for the plane plane.\n\n @return the computed size in bytes"]
    pub fn av_image_get_linesize(
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        plane: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane linesizes for an image with pixel format pix_fmt and\n width width.\n\n @param linesizes array to be filled with the linesize for each plane\n @return >= 0 in case of success, a negative error code otherwise"]
    pub fn av_image_fill_linesizes(
        linesizes: *mut ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane sizes for an image with pixel format pix_fmt and height height.\n\n @param size the array to be filled with the size of each image plane\n @param linesizes the array containing the linesize for each\n        plane, should be filled by av_image_fill_linesizes()\n @return >= 0 in case of success, a negative error code otherwise\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_fill_linesizes()."]
    pub fn av_image_fill_plane_sizes(
        size: *mut usize,
        pix_fmt: AVPixelFormat,
        height: ::std::os::raw::c_int,
        linesizes: *const isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers for an image with pixel format pix_fmt and\n height height.\n\n @param data pointers array to be filled with the pointer for each image plane\n @param ptr the pointer to a buffer which will contain the image\n @param linesizes the array containing the linesize for each\n plane, should be filled by av_image_fill_linesizes()\n @return the size in bytes required for the image buffer, a negative\n error code in case of failure"]
    pub fn av_image_fill_pointers(
        data: *mut *mut u8,
        pix_fmt: AVPixelFormat,
        height: ::std::os::raw::c_int,
        ptr: *mut u8,
        linesizes: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an image with size w and h and pixel format pix_fmt, and\n fill pointers and linesizes accordingly.\n The allocated image buffer has to be freed by using\n av_freep(&pointers[0]).\n\n @param align the value to use for buffer size alignment\n @return the size in bytes required for the image buffer, a negative\n error code in case of failure"]
    pub fn av_image_alloc(
        pointers: *mut *mut u8,
        linesizes: *mut ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy image plane from src to dst.\n That is, copy \"height\" number of lines of \"bytewidth\" bytes each.\n The first byte of each successive line is separated by *_linesize\n bytes.\n\n bytewidth must be contained by both absolute values of dst_linesize\n and src_linesize, otherwise the function behavior is undefined.\n\n @param dst_linesize linesize for the image plane in dst\n @param src_linesize linesize for the image plane in src"]
    pub fn av_image_copy_plane(
        dst: *mut u8,
        dst_linesize: ::std::os::raw::c_int,
        src: *const u8,
        src_linesize: ::std::os::raw::c_int,
        bytewidth: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n available, this function will use special functionality for reading from such\n memory, which may result in greatly improved performance compared to plain\n av_image_copy_plane().\n\n bytewidth must be contained by both absolute values of dst_linesize\n and src_linesize, otherwise the function behavior is undefined.\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_copy_plane().\n @note On x86, the linesizes currently need to be aligned to the cacheline\n       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_plane_uc_from(
        dst: *mut u8,
        dst_linesize: isize,
        src: *const u8,
        src_linesize: isize,
        bytewidth: isize,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Copy image in src_data to dst_data.\n\n @param dst_linesizes linesizes for the image in dst_data\n @param src_linesizes linesizes for the image in src_data"]
    pub fn av_image_copy(
        dst_data: *mut *mut u8,
        dst_linesizes: *mut ::std::os::raw::c_int,
        src_data: *mut *const u8,
        src_linesizes: *const ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n available, this function will use special functionality for reading from such\n memory, which may result in greatly improved performance compared to plain\n av_image_copy().\n\n The data pointers and the linesizes must be aligned to the maximum required\n by the CPU architecture.\n\n @note The linesize parameters have the type ptrdiff_t here, while they are\n       int for av_image_copy().\n @note On x86, the linesizes currently need to be aligned to the cacheline\n       size (i.e. 64) to get improved performance."]
    pub fn av_image_copy_uc_from(
        dst_data: *mut *mut u8,
        dst_linesizes: *const isize,
        src_data: *mut *const u8,
        src_linesizes: *const isize,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Setup the data pointers and linesizes based on the specified image\n parameters and the provided array.\n\n The fields of the given image are filled in by using the src\n address which points to the image data buffer. Depending on the\n specified pixel format, one or multiple image data pointers and\n line sizes will be set.  If a planar format is specified, several\n pointers will be set pointing to the different picture planes and\n the line sizes of the different planes will be stored in the\n lines_sizes array. Call with src == NULL to get the required\n size for the src buffer.\n\n To allocate the buffer and fill in the dst_data and dst_linesize in\n one call, use av_image_alloc().\n\n @param dst_data      data pointers to be filled in\n @param dst_linesize  linesizes for the image in dst_data to be filled in\n @param src           buffer which will contain or contains the actual image data, can be NULL\n @param pix_fmt       the pixel format of the image\n @param width         the width of the image in pixels\n @param height        the height of the image in pixels\n @param align         the value used in src for linesize alignment\n @return the size in bytes required for src, a negative error code\n in case of failure"]
    pub fn av_image_fill_arrays(
        dst_data: *mut *mut u8,
        dst_linesize: *mut ::std::os::raw::c_int,
        src: *const u8,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the size in bytes of the amount of data required to store an\n image with the given parameters.\n\n @param pix_fmt  the pixel format of the image\n @param width    the width of the image in pixels\n @param height   the height of the image in pixels\n @param align    the assumed linesize alignment\n @return the buffer size in bytes, a negative error code in case of failure"]
    pub fn av_image_get_buffer_size(
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy image data from an image into a buffer.\n\n av_image_get_buffer_size() can be used to compute the required size\n for the buffer to fill.\n\n @param dst           a buffer into which picture data will be copied\n @param dst_size      the size in bytes of dst\n @param src_data      pointers containing the source image data\n @param src_linesize  linesizes for the image in src_data\n @param pix_fmt       the pixel format of the source image\n @param width         the width of the source image in pixels\n @param height        the height of the source image in pixels\n @param align         the assumed linesize alignment for dst\n @return the number of bytes written to dst, or a negative value\n (error code) on error"]
    pub fn av_image_copy_to_buffer(
        dst: *mut u8,
        dst_size: ::std::os::raw::c_int,
        src_data: *const *const u8,
        src_linesize: *const ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all\n bytes of the image can be addressed with a signed int.\n\n @param w the width of the picture\n @param h the height of the picture\n @param log_offset the offset to sum to the log level for logging with log_ctx\n @param log_ctx the parent logging context, it may be NULL\n @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size(
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given dimension of an image is valid, meaning that all\n bytes of a plane of an image with the specified pix_fmt can be addressed\n with a signed int.\n\n @param w the width of the picture\n @param h the height of the picture\n @param max_pixels the maximum number of pixels the user wants to accept\n @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.\n @param log_offset the offset to sum to the log level for logging with log_ctx\n @param log_ctx the parent logging context, it may be NULL\n @return >= 0 if valid, a negative error code otherwise"]
    pub fn av_image_check_size2(
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        max_pixels: i64,
        pix_fmt: AVPixelFormat,
        log_offset: ::std::os::raw::c_int,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the given sample aspect ratio of an image is valid.\n\n It is considered invalid if the denominator is 0 or if applying the ratio\n to the image size would make the smaller dimension less than 1. If the\n sar numerator is 0, it is considered unknown and will return as valid.\n\n @param w width of the image\n @param h height of the image\n @param sar sample aspect ratio of the image\n @return 0 if valid, a negative AVERROR code otherwise"]
    pub fn av_image_check_sar(
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        sar: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrite the image data with black. This is suitable for filling a\n sub-rectangle of an image, meaning the padding between the right most pixel\n and the left most pixel on the next line will not be overwritten. For some\n formats, the image size might be rounded up due to inherent alignment.\n\n If the pixel format has alpha, the alpha is cleared to opaque.\n\n This can return an error if the pixel format is not supported. Normally, all\n non-hwaccel pixel formats should be supported.\n\n Passing NULL for dst_data is allowed. Then the function returns whether the\n operation would have succeeded. (It can return an error if the pix_fmt is\n not supported.)\n\n @param dst_data      data pointers to destination image\n @param dst_linesize  linesizes for the destination image\n @param pix_fmt       the pixel format of the image\n @param range         the color range of the image (important for colorspaces such as YUV)\n @param width         the width of the image in pixels\n @param height        the height of the image in pixels\n @return 0 if the image data was cleared, a negative AVERROR code otherwise"]
    pub fn av_image_fill_black(
        dst_data: *mut *mut u8,
        dst_linesize: *const isize,
        pix_fmt: AVPixelFormat,
        range: AVColorRange,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[doc = " @defgroup avoptions AVOptions\n @ingroup lavu_data\n @{\n AVOptions provide a generic system to declare options on arbitrary structs\n (\"objects\"). An option can have a help text, a type and a range of possible\n values. Options may then be enumerated, read and written to.\n\n @section avoptions_implement Implementing AVOptions\n This section describes how to add AVOptions capabilities to a struct.\n\n All AVOptions-related information is stored in an AVClass. Therefore\n the first member of the struct should be a pointer to an AVClass describing it.\n The option field of the AVClass must be set to a NULL-terminated static array\n of AVOptions. Each AVOption must have a non-empty name, a type, a default\n value and for number-type AVOptions also a range of allowed values. It must\n also declare an offset in bytes from the start of the struct, where the field\n associated with this AVOption is located. Other fields in the AVOption struct\n should also be set when applicable, but are not required.\n\n The following example illustrates an AVOptions-enabled struct:\n @code\n typedef struct test_struct {\n     const AVClass *class;\n     int      int_opt;\n     char    *str_opt;\n     uint8_t *bin_opt;\n     int      bin_len;\n } test_struct;\n\n static const AVOption test_options[] = {\n   { \"test_int\", \"This is a test option of int type.\", offsetof(test_struct, int_opt),\n     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },\n   { \"test_str\", \"This is a test option of string type.\", offsetof(test_struct, str_opt),\n     AV_OPT_TYPE_STRING },\n   { \"test_bin\", \"This is a test option of binary type.\", offsetof(test_struct, bin_opt),\n     AV_OPT_TYPE_BINARY },\n   { NULL },\n };\n\n static const AVClass test_class = {\n     .class_name = \"test class\",\n     .item_name  = av_default_item_name,\n     .option     = test_options,\n     .version    = LIBAVUTIL_VERSION_INT,\n };\n @endcode\n\n Next, when allocating your struct, you must ensure that the AVClass pointer\n is set to the correct value. Then, av_opt_set_defaults() can be called to\n initialize defaults. After that the struct is ready to be used with the\n AVOptions API.\n\n When cleaning up, you may use the av_opt_free() function to automatically\n free all the allocated string and binary options.\n\n Continuing with the above example:\n\n @code\n test_struct *alloc_test_struct(void)\n {\n     test_struct *ret = av_mallocz(sizeof(*ret));\n     ret->class = &test_class;\n     av_opt_set_defaults(ret);\n     return ret;\n }\n void free_test_struct(test_struct **foo)\n {\n     av_opt_free(*foo);\n     av_freep(foo);\n }\n @endcode\n\n @subsection avoptions_implement_nesting Nesting\n      It may happen that an AVOptions-enabled struct contains another\n      AVOptions-enabled struct as a member (e.g. AVCodecContext in\n      libavcodec exports generic options, while its priv_data field exports\n      codec-specific options). In such a case, it is possible to set up the\n      parent struct to export a child's options. To do that, simply\n      implement AVClass.child_next() and AVClass.child_class_iterate() in the\n      parent struct's AVClass.\n      Assuming that the test_struct from above now also contains a\n      child_struct field:\n\n      @code\n      typedef struct child_struct {\n          AVClass *class;\n          int flags_opt;\n      } child_struct;\n      static const AVOption child_opts[] = {\n          { \"test_flags\", \"This is a test option of flags type.\",\n            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },\n          { NULL },\n      };\n      static const AVClass child_class = {\n          .class_name = \"child class\",\n          .item_name  = av_default_item_name,\n          .option     = child_opts,\n          .version    = LIBAVUTIL_VERSION_INT,\n      };\n\n      void *child_next(void *obj, void *prev)\n      {\n          test_struct *t = obj;\n          if (!prev && t->child_struct)\n              return t->child_struct;\n          return NULL\n      }\n      const AVClass child_class_iterate(void **iter)\n      {\n          const AVClass *c = *iter ? NULL : &child_class;\n          *iter = (void*)(uintptr_t)c;\n          return c;\n      }\n      @endcode\n      Putting child_next() and child_class_iterate() as defined above into\n      test_class will now make child_struct's options accessible through\n      test_struct (again, proper setup as described above needs to be done on\n      child_struct right after it is created).\n\n      From the above example it might not be clear why both child_next()\n      and child_class_iterate() are needed. The distinction is that child_next()\n      iterates over actually existing objects, while child_class_iterate()\n      iterates over all possible child classes. E.g. if an AVCodecContext\n      was initialized to use a codec which has private options, then its\n      child_next() will return AVCodecContext.priv_data and finish\n      iterating. OTOH child_class_iterate() on AVCodecContext.av_class will\n      iterate over all available codecs with private options.\n\n @subsection avoptions_implement_named_constants Named constants\n      It is possible to create named constants for options. Simply set the unit\n      field of the option the constants should apply to a string and\n      create the constants themselves as options of type AV_OPT_TYPE_CONST\n      with their unit field set to the same string.\n      Their default_val field should contain the value of the named\n      constant.\n      For example, to add some named constants for the test_flags option\n      above, put the following into the child_opts array:\n      @code\n      { \"test_flags\", \"This is a test option of flags type.\",\n        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, \"test_unit\" },\n      { \"flag1\", \"This is a flag with value 16\", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, \"test_unit\" },\n      @endcode\n\n @section avoptions_use Using AVOptions\n This section deals with accessing options in an AVOptions-enabled struct.\n Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or\n AVFormatContext in libavformat.\n\n @subsection avoptions_use_examine Examining AVOptions\n The basic functions for examining options are av_opt_next(), which iterates\n over all options defined for one object, and av_opt_find(), which searches\n for an option with the given name.\n\n The situation is more complicated with nesting. An AVOptions-enabled struct\n may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag\n to av_opt_find() will make the function search children recursively.\n\n For enumerating there are basically two cases. The first is when you want to\n get all options that may potentially exist on the struct and its children\n (e.g.  when constructing documentation). In that case you should call\n av_opt_child_class_iterate() recursively on the parent struct's AVClass.  The\n second case is when you have an already initialized struct with all its\n children and you want to get all options that can be actually written or read\n from it. In that case you should call av_opt_child_next() recursively (and\n av_opt_next() on each result).\n\n @subsection avoptions_use_get_set Reading and writing AVOptions\n When setting options, you often have a string read directly from the\n user. In such a case, simply passing it to av_opt_set() is enough. For\n non-string type options, av_opt_set() will parse the string according to the\n option type.\n\n Similarly av_opt_get() will read any option type and convert it to a string\n which will be returned. Do not forget that the string is allocated, so you\n have to free it with av_free().\n\n In some cases it may be more convenient to put all options into an\n AVDictionary and call av_opt_set_dict() on it. A specific case of this\n are the format/codec open functions in lavf/lavc which take a dictionary\n filled with option as a parameter. This makes it possible to set some options\n that cannot be set otherwise, since e.g. the input file format is not known\n before the file is actually opened."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AVOptionType {
    AV_OPT_TYPE_FLAGS = 0,
    AV_OPT_TYPE_INT = 1,
    AV_OPT_TYPE_INT64 = 2,
    AV_OPT_TYPE_DOUBLE = 3,
    AV_OPT_TYPE_FLOAT = 4,
    AV_OPT_TYPE_STRING = 5,
    AV_OPT_TYPE_RATIONAL = 6,
    #[doc = "< offset must point to a pointer immediately followed by an int for the length"]
    AV_OPT_TYPE_BINARY = 7,
    AV_OPT_TYPE_DICT = 8,
    AV_OPT_TYPE_UINT64 = 9,
    AV_OPT_TYPE_CONST = 10,
    #[doc = "< offset must point to two consecutive integers"]
    AV_OPT_TYPE_IMAGE_SIZE = 11,
    AV_OPT_TYPE_PIXEL_FMT = 12,
    AV_OPT_TYPE_SAMPLE_FMT = 13,
    #[doc = "< offset must point to AVRational"]
    AV_OPT_TYPE_VIDEO_RATE = 14,
    AV_OPT_TYPE_DURATION = 15,
    AV_OPT_TYPE_COLOR = 16,
    AV_OPT_TYPE_CHANNEL_LAYOUT = 17,
    AV_OPT_TYPE_BOOL = 18,
    AV_OPT_TYPE_CHLAYOUT = 19,
}
#[doc = " AVOption"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVOption {
    pub name: *const ::std::os::raw::c_char,
    #[doc = " short English help text\n @todo What about other languages?"]
    pub help: *const ::std::os::raw::c_char,
    #[doc = " The offset relative to the context structure where the option\n value is stored. It should be 0 for named constants."]
    pub offset: ::std::os::raw::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    #[doc = "< minimum valid value for the option"]
    pub min: f64,
    #[doc = "< maximum valid value for the option"]
    pub max: f64,
    pub flags: ::std::os::raw::c_int,
    #[doc = " The logical unit to which the option belongs. Non-constant\n options and corresponding named constants share the same\n unit. May be NULL."]
    pub unit: *const ::std::os::raw::c_char,
}
#[doc = " the default value for scalar options"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVOption__bindgen_ty_1 {
    pub i64_: i64,
    pub dbl: f64,
    pub str_: *const ::std::os::raw::c_char,
    pub q: AVRational,
}
#[doc = " A single allowed range of values, or a single allowed value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRange {
    pub str_: *const ::std::os::raw::c_char,
    #[doc = " Value range.\n For string ranges this represents the min/max length.\n For dimensions this represents the min/max pixel count or width/height in multi-component case."]
    pub value_min: f64,
    #[doc = " Value range.\n For string ranges this represents the min/max length.\n For dimensions this represents the min/max pixel count or width/height in multi-component case."]
    pub value_max: f64,
    #[doc = " Value's component range.\n For string this represents the unicode range for chars, 0-127 limits to ASCII."]
    pub component_min: f64,
    #[doc = " Value's component range.\n For string this represents the unicode range for chars, 0-127 limits to ASCII."]
    pub component_max: f64,
    #[doc = " Range flag.\n If set to 1 the struct encodes a range, if set to 0 a single value."]
    pub is_range: ::std::os::raw::c_int,
}
#[doc = " List of AVOptionRange structs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    #[doc = " Array of option ranges.\n\n Most of option types use just one component.\n Following describes multi-component option types:\n\n AV_OPT_TYPE_IMAGE_SIZE:\n component index 0: range of pixel count (width * height).\n component index 1: range of width.\n component index 2: range of height.\n\n @note To obtain multi-component version of this structure, user must\n       provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or\n       av_opt_query_ranges_default function.\n\n Multi-component range can be read as in following example:\n\n @code\n int range_index, component_index;\n AVOptionRanges *ranges;\n AVOptionRange *range[3]; //may require more than 3 in the future.\n av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);\n for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {\n     for (component_index = 0; component_index < ranges->nb_components; component_index++)\n         range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];\n     //do something with range here.\n }\n av_opt_freep_ranges(&ranges);\n @endcode"]
    pub range: *mut *mut AVOptionRange,
    #[doc = " Number of ranges per component."]
    pub nb_ranges: ::std::os::raw::c_int,
    #[doc = " Number of componentes."]
    pub nb_components: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Show the obj options.\n\n @param req_flags requested flags for the options to show. Show only the\n options for which it is opt->flags & req_flags.\n @param rej_flags rejected flags for the options to show. Show only the\n options for which it is !(opt->flags & req_flags).\n @param av_log_obj log context to use for showing the options"]
    pub fn av_opt_show2(
        obj: *mut ::std::os::raw::c_void,
        av_log_obj: *mut ::std::os::raw::c_void,
        req_flags: ::std::os::raw::c_int,
        rej_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the values of all AVOption fields to their default values.\n\n @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)"]
    pub fn av_opt_set_defaults(s: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Set the values of all AVOption fields to their default values. Only these\n AVOption fields for which (opt->flags & mask) == flags will have their\n default applied to s.\n\n @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)\n @param mask combination of AV_OPT_FLAG_*\n @param flags combination of AV_OPT_FLAG_*"]
    pub fn av_opt_set_defaults2(
        s: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Parse the key/value pairs list in opts. For each key/value pair\n found, stores the value in the field in ctx that is named like the\n key. ctx must be an AVClass context, storing is done using\n AVOptions.\n\n @param opts options string to parse, may be NULL\n @param key_val_sep a 0-terminated list of characters used to\n separate key from value\n @param pairs_sep a 0-terminated list of characters used to separate\n two pairs from each other\n @return the number of successfully set key/value pairs, or a negative\n value corresponding to an AVERROR code in case of error:\n AVERROR(EINVAL) if opts cannot be parsed,\n the error code issued by av_opt_set() if a key/value pair\n cannot be set"]
    pub fn av_set_options_string(
        ctx: *mut ::std::os::raw::c_void,
        opts: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse the key-value pairs list in opts. For each key=value pair found,\n set the value of the corresponding option in ctx.\n\n @param ctx          the AVClass object to set options on\n @param opts         the options string, key-value pairs separated by a\n                     delimiter\n @param shorthand    a NULL-terminated array of options names for shorthand\n                     notation: if the first field in opts has no key part,\n                     the key is taken from the first element of shorthand;\n                     then again for the second, etc., until either opts is\n                     finished, shorthand is finished or a named option is\n                     found; after that, all options must be named\n @param key_val_sep  a 0-terminated list of characters used to separate\n                     key from value, for example '='\n @param pairs_sep    a 0-terminated list of characters used to separate\n                     two pairs from each other, for example ':' or ','\n @return  the number of successfully set key=value pairs, or a negative\n          value corresponding to an AVERROR code in case of error:\n          AVERROR(EINVAL) if opts cannot be parsed,\n          the error code issued by av_set_string3() if a key/value pair\n          cannot be set\n\n Options names must use only the following characters: a-z A-Z 0-9 - . / _\n Separators must use characters distinct from option names and from each\n other."]
    pub fn av_opt_set_from_string(
        ctx: *mut ::std::os::raw::c_void,
        opts: *const ::std::os::raw::c_char,
        shorthand: *const *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all allocated objects in obj."]
    pub fn av_opt_free(obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Check whether a particular flag is set in a flags field.\n\n @param field_name the name of the flag field option\n @param flag_name the name of the flag to check\n @return non-zero if the flag is set, zero if the flag isn't set,\n         isn't of the right type, or the flags field doesn't exist."]
    pub fn av_opt_flag_is_set(
        obj: *mut ::std::os::raw::c_void,
        field_name: *const ::std::os::raw::c_char,
        flag_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set all the options from a given dictionary on an object.\n\n @param obj a struct whose first element is a pointer to AVClass\n @param options options to process. This dictionary will be freed and replaced\n                by a new one containing all options not found in obj.\n                Of course this new dictionary needs to be freed by caller\n                with av_dict_free().\n\n @return 0 on success, a negative AVERROR if some option was found in obj,\n         but could not be set.\n\n @see av_dict_copy()"]
    pub fn av_opt_set_dict(
        obj: *mut ::std::os::raw::c_void,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set all the options from a given dictionary on an object.\n\n @param obj a struct whose first element is a pointer to AVClass\n @param options options to process. This dictionary will be freed and replaced\n                by a new one containing all options not found in obj.\n                Of course this new dictionary needs to be freed by caller\n                with av_dict_free().\n @param search_flags A combination of AV_OPT_SEARCH_*.\n\n @return 0 on success, a negative AVERROR if some option was found in obj,\n         but could not be set.\n\n @see av_dict_copy()"]
    pub fn av_opt_set_dict2(
        obj: *mut ::std::os::raw::c_void,
        options: *mut *mut AVDictionary,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Extract a key-value pair from the beginning of a string.\n\n @param ropts        pointer to the options string, will be updated to\n                     point to the rest of the string (one of the pairs_sep\n                     or the final NUL)\n @param key_val_sep  a 0-terminated list of characters used to separate\n                     key from value, for example '='\n @param pairs_sep    a 0-terminated list of characters used to separate\n                     two pairs from each other, for example ':' or ','\n @param flags        flags; see the AV_OPT_FLAG_* values below\n @param rkey         parsed key; must be freed using av_free()\n @param rval         parsed value; must be freed using av_free()\n\n @return  >=0 for success, or a negative value corresponding to an\n          AVERROR code in case of error; in particular:\n          AVERROR(EINVAL) if no key is present\n"]
    pub fn av_opt_get_key_value(
        ropts: *mut *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        rkey: *mut *mut ::std::os::raw::c_char,
        rval: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_6 = _bindgen_ty_6::AV_OPT_FLAG_IMPLICIT_KEY;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    #[doc = " Accept to parse a value without a key; the key will then be returned\n as NULL."]
    AV_OPT_FLAG_IMPLICIT_KEY = 1,
}
extern "C" {
    #[doc = " @defgroup opt_eval_funcs Evaluating option strings\n @{\n This group of functions can be used to evaluate option strings\n and get numbers out of them. They do the same thing as av_opt_set(),\n except the result is written into the caller-supplied pointer.\n\n @param obj a struct whose first element is a pointer to AVClass.\n @param o an option for which the string is to be evaluated.\n @param val string to be evaluated.\n @param *_out value of the string will be written here.\n\n @return 0 on success, a negative number on failure."]
    pub fn av_opt_eval_flags(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        flags_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        int_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        int64_out: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        float_out: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        double_out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
        val: *const ::std::os::raw::c_char,
        q_out: *mut AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for an option in an object. Consider only options which\n have all the specified flags set.\n\n @param[in] obj A pointer to a struct whose first element is a\n                pointer to an AVClass.\n                Alternatively a double pointer to an AVClass, if\n                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n @param[in] name The name of the option to look for.\n @param[in] unit When searching for named constants, name of the unit\n                 it belongs to.\n @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n @param search_flags A combination of AV_OPT_SEARCH_*.\n\n @return A pointer to the option found, or NULL if no option\n         was found.\n\n @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable\n directly with av_opt_set(). Use special calls which take an options\n AVDictionary (e.g. avformat_open_input()) to set options found with this\n flag."]
    pub fn av_opt_find(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        opt_flags: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
    ) -> *const AVOption;
}
extern "C" {
    #[doc = " Look for an option in an object. Consider only options which\n have all the specified flags set.\n\n @param[in] obj A pointer to a struct whose first element is a\n                pointer to an AVClass.\n                Alternatively a double pointer to an AVClass, if\n                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n @param[in] name The name of the option to look for.\n @param[in] unit When searching for named constants, name of the unit\n                 it belongs to.\n @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n @param search_flags A combination of AV_OPT_SEARCH_*.\n @param[out] target_obj if non-NULL, an object to which the option belongs will be\n written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present\n in search_flags. This parameter is ignored if search_flags contain\n AV_OPT_SEARCH_FAKE_OBJ.\n\n @return A pointer to the option found, or NULL if no option\n         was found."]
    pub fn av_opt_find2(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        opt_flags: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
        target_obj: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVOption;
}
extern "C" {
    #[doc = " Iterate over all AVOptions belonging to obj.\n\n @param obj an AVOptions-enabled struct or a double pointer to an\n            AVClass describing it.\n @param prev result of the previous call to av_opt_next() on this object\n             or NULL\n @return next AVOption or NULL"]
    pub fn av_opt_next(
        obj: *const ::std::os::raw::c_void,
        prev: *const AVOption,
    ) -> *const AVOption;
}
extern "C" {
    #[doc = " Iterate over AVOptions-enabled children of obj.\n\n @param prev result of a previous call to this function or NULL\n @return next AVOptions-enabled child or NULL"]
    pub fn av_opt_child_next(
        obj: *mut ::std::os::raw::c_void,
        prev: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Iterate over potential AVOptions-enabled children of parent.\n\n @param iter a pointer where iteration state is stored.\n @return AVClass corresponding to next potential child or NULL"]
    pub fn av_opt_child_class_iterate(
        parent: *const AVClass,
        iter: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVClass;
}
extern "C" {
    #[doc = " @defgroup opt_set_funcs Option setting functions\n @{\n Those functions set the field of obj with the given name to value.\n\n @param[in] obj A struct whose first element is a pointer to an AVClass.\n @param[in] name the name of the field to set\n @param[in] val The value to set. In case of av_opt_set() if the field is not\n of a string type, then the given string is parsed.\n SI postfixes and some named scalars are supported.\n If the field is of a numeric type, it has to be a numeric or named\n scalar. Behavior with more than one scalar and +- infix operators\n is undefined.\n If the field is of a flags type, it has to be a sequence of numeric\n scalars or named flags separated by '+' or '-'. Prefixing a flag\n with '+' causes it to be set without affecting the other flags;\n similarly, '-' unsets a flag.\n If the field is of a dictionary type, it has to be a ':' separated list of\n key=value parameters. Values containing ':' special characters must be\n escaped.\n @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n is passed here, then the option may be set on a child of obj.\n\n @return 0 if the value has been set, or an AVERROR code in case of\n error:\n AVERROR_OPTION_NOT_FOUND if no matching option exists\n AVERROR(ERANGE) if the value is out of range\n AVERROR(EINVAL) if the value is not valid"]
    pub fn av_opt_set(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_int(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: i64,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_double(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: f64,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_q(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: AVRational,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const u8,
        size: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        fmt: AVPixelFormat,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        fmt: AVSampleFormat,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: AVRational,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        ch_layout: i64,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_set_chlayout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        layout: *const AVChannelLayout,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @note Any old dictionary present is discarded and replaced with a copy of the new one. The\n caller still owns val is and responsible for freeing it."]
    pub fn av_opt_set_dict_val(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        val: *const AVDictionary,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup opt_get_funcs Option getting functions\n @{\n Those functions get a value of the option with the given name from an object.\n\n @param[in] obj a struct whose first element is a pointer to an AVClass.\n @param[in] name name of the option to get.\n @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n is passed here, then the option may be found in a child of obj.\n @param[out] out_val value of the option will be written here\n @return >=0 on success, a negative error code otherwise\n/\n/**\n @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n\n @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n and is set to NULL, *out_val will be set to NULL instead of an allocated\n empty string."]
    pub fn av_opt_get(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_int(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_double(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_q(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        w_out: *mut ::std::os::raw::c_int,
        h_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_fmt: *mut AVPixelFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_fmt: *mut AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        ch_layout: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_opt_get_chlayout(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        layout: *mut AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param[out] out_val The returned dictionary is a copy of the actual value and must\n be freed with av_dict_free() by the caller"]
    pub fn av_opt_get_dict_val(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
        out_val: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}\n/\n/**\n Gets a pointer to the requested field in a struct.\n This function allows accessing a struct even when its fields are moved or\n renamed since the application making the access has been compiled,\n\n @returns a pointer to the field, it can be cast to the correct type and read\n          or written to."]
    pub fn av_opt_ptr(
        avclass: *const AVClass,
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free an AVOptionRanges struct and set it to NULL."]
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    #[doc = " Get a list of allowed ranges for the given option.\n\n The returned list may depend on other fields in obj like for example profile.\n\n @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n\n The result must be freed with av_opt_freep_ranges.\n\n @return number of compontents returned on success, a negative errro code otherwise"]
    pub fn av_opt_query_ranges(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy options from src object into dest object.\n\n The underlying AVClass of both src and dest must coincide. The guarantee\n below does not apply if this is not fulfilled.\n\n Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.\n Original memory allocated for such options is freed unless both src and dest options points to the same memory.\n\n Even on error it is guaranteed that allocated options from src and dest\n no longer alias each other afterwards; in particular calling av_opt_free()\n on both src and dest is safe afterwards if dest has been memdup'ed from src.\n\n @param dest Object to copy from\n @param src  Object to copy into\n @return 0 on success, negative on error"]
    pub fn av_opt_copy(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a default list of allowed ranges for the given option.\n\n This list is constructed without using the AVClass.query_ranges() callback\n and can be used as fallback from within the callback.\n\n @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n\n The result must be freed with av_opt_free_ranges.\n\n @return number of compontents returned on success, a negative errro code otherwise"]
    pub fn av_opt_query_ranges_default(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if given option is set to its default value.\n\n Options o must belong to the obj. This function must not be called to check child's options state.\n @see av_opt_is_set_to_default_by_name().\n\n @param obj  AVClass object to check option on\n @param o    option to be checked\n @return     >0 when option is set to its default,\n              0 when option is not set its default,\n             <0 on error"]
    pub fn av_opt_is_set_to_default(
        obj: *mut ::std::os::raw::c_void,
        o: *const AVOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if given option is set to its default value.\n\n @param obj          AVClass object to check option on\n @param name         option name\n @param search_flags combination of AV_OPT_SEARCH_*\n @return             >0 when option is set to its default,\n                     0 when option is not set its default,\n                     <0 on error"]
    pub fn av_opt_is_set_to_default_by_name(
        obj: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        search_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize object's options.\n\n Create a string containing object's serialized options.\n Such string may be passed back to av_opt_set_from_string() in order to restore option values.\n A key/value or pairs separator occurring in the serialized value or\n name string are escaped through the av_escape() function.\n\n @param[in]  obj           AVClass object to serialize\n @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)\n @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags\n @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.\n                           Buffer must be freed by the caller when is no longer needed.\n @param[in]  key_val_sep   character used to separate key from value\n @param[in]  pairs_sep     character used to separate two pairs from each other\n @return                   >= 0 on success, negative on error\n @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
    pub fn av_opt_serialize(
        obj: *mut ::std::os::raw::c_void,
        opt_flags: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current time in microseconds."]
    pub fn av_gettime() -> i64;
}
extern "C" {
    #[doc = " Get the current time in microseconds since some unspecified starting point.\n On platforms that support it, the time comes from a monotonic clock\n This property makes this time source ideal for measuring relative time.\n The returned values may not be monotonic on platforms where a monotonic\n clock is not available."]
    pub fn av_gettime_relative() -> i64;
}
extern "C" {
    #[doc = " Indicates with a boolean result if the av_gettime_relative() time source\n is monotonic."]
    pub fn av_gettime_relative_is_monotonic() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sleep for a period of time.  Although the duration is expressed in\n microseconds, the actual delay may be rounded to the precision of the\n system timer.\n\n @param  usec Number of microseconds to sleep.\n @return zero on success or (negative) error code."]
    pub fn av_usleep(usec: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup libsws libswscale\n Color conversion and scaling library.\n\n @{\n\n Return the LIBSWSCALE_VERSION_INT constant."]
    pub fn swscale_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libswscale build-time configuration."]
    pub fn swscale_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libswscale license."]
    pub fn swscale_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a pointer to yuv<->rgb coefficients for the given colorspace\n suitable for sws_setColorspaceDetails().\n\n @param colorspace One of the SWS_CS_* macros. If invalid,\n SWS_CS_DEFAULT is used."]
    pub fn sws_getCoefficients(colorspace: ::std::os::raw::c_int) -> *const ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsVector {
    #[doc = "< pointer to the list of coefficients"]
    pub coeff: *mut f64,
    #[doc = "< number of coefficients in the vector"]
    pub length: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported input format, 0\n otherwise."]
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported output format, 0\n otherwise."]
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param[in]  pix_fmt the pixel format\n @return a positive value if an endianness conversion for pix_fmt is\n supported, 0 otherwise."]
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an empty SwsContext. This must be filled and passed to\n sws_init_context(). For filling see AVOptions, options.c and\n sws_setColorspaceDetails()."]
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    #[doc = " Initialize the swscaler context sws_context.\n\n @return zero or positive value on success, a negative value on\n error"]
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the swscaler context swsContext.\n If swsContext is NULL, then does nothing."]
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    #[doc = " Allocate and return an SwsContext. You need it to perform\n scaling/conversion operations using sws_scale().\n\n @param srcW the width of the source image\n @param srcH the height of the source image\n @param srcFormat the source image format\n @param dstW the width of the destination image\n @param dstH the height of the destination image\n @param dstFormat the destination image format\n @param flags specify which algorithm and options to use for rescaling\n @param param extra parameters to tune the used scaler\n              For SWS_BICUBIC param[0] and [1] tune the shape of the basis\n              function, param[0] tunes f(1) and param[1] f´(1)\n              For SWS_GAUSS param[0] tunes the exponent and thus cutoff\n              frequency\n              For SWS_LANCZOS param[0] tunes the width of the window function\n @return a pointer to an allocated context, or NULL in case of error\n @note this function is to be removed after a saner alternative is\n       written"]
    pub fn sws_getContext(
        srcW: ::std::os::raw::c_int,
        srcH: ::std::os::raw::c_int,
        srcFormat: AVPixelFormat,
        dstW: ::std::os::raw::c_int,
        dstH: ::std::os::raw::c_int,
        dstFormat: AVPixelFormat,
        flags: ::std::os::raw::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Scale the image slice in srcSlice and put the resulting scaled\n slice in the image in dst. A slice is a sequence of consecutive\n rows in an image.\n\n Slices have to be provided in sequential order, either in\n top-bottom or bottom-top order. If slices are provided in\n non-sequential order the behavior of the function is undefined.\n\n @param c         the scaling context previously created with\n                  sws_getContext()\n @param srcSlice  the array containing the pointers to the planes of\n                  the source slice\n @param srcStride the array containing the strides for each plane of\n                  the source image\n @param srcSliceY the position in the source image of the slice to\n                  process, that is the number (counted starting from\n                  zero) in the image of the first row of the slice\n @param srcSliceH the height of the source slice, that is the number\n                  of rows in the slice\n @param dst       the array containing the pointers to the planes of\n                  the destination image\n @param dstStride the array containing the strides for each plane of\n                  the destination image\n @return          the height of the output slice"]
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const ::std::os::raw::c_int,
        srcSliceY: ::std::os::raw::c_int,
        srcSliceH: ::std::os::raw::c_int,
        dst: *const *mut u8,
        dstStride: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Scale source data from src and write the output to dst.\n\n This is merely a convenience wrapper around\n - sws_frame_start()\n - sws_send_slice(0, src->height)\n - sws_receive_slice(0, dst->height)\n - sws_frame_end()\n\n @param dst The destination frame. See documentation for sws_frame_start() for\n            more details.\n @param src The source frame.\n\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn sws_scale_frame(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the scaling process for a given pair of source/destination frames.\n Must be called before any calls to sws_send_slice() and sws_receive_slice().\n\n This function will retain references to src and dst, so they must both use\n refcounted buffers (if allocated by the caller, in case of dst).\n\n @param dst The destination frame.\n\n            The data buffers may either be already allocated by the caller or\n            left clear, in which case they will be allocated by the scaler.\n            The latter may have performance advantages - e.g. in certain cases\n            some output planes may be references to input planes, rather than\n            copies.\n\n            Output data will be written into this frame in successful\n            sws_receive_slice() calls.\n @param src The source frame. The data buffers must be allocated, but the\n            frame data does not have to be ready at this point. Data\n            availability is then signalled by sws_send_slice().\n @return 0 on success, a negative AVERROR code on failure\n\n @see sws_frame_end()"]
    pub fn sws_frame_start(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finish the scaling process for a pair of source/destination frames previously\n submitted with sws_frame_start(). Must be called after all sws_send_slice()\n and sws_receive_slice() calls are done, before any new sws_frame_start()\n calls."]
    pub fn sws_frame_end(c: *mut SwsContext);
}
extern "C" {
    #[doc = " Indicate that a horizontal slice of input data is available in the source\n frame previously provided to sws_frame_start(). The slices may be provided in\n any order, but may not overlap. For vertically subsampled pixel formats, the\n slices must be aligned according to subsampling.\n\n @param slice_start first row of the slice\n @param slice_height number of rows in the slice\n\n @return a non-negative number on success, a negative AVERROR code on failure."]
    pub fn sws_send_slice(
        c: *mut SwsContext,
        slice_start: ::std::os::raw::c_uint,
        slice_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request a horizontal slice of the output data to be written into the frame\n previously provided to sws_frame_start().\n\n @param slice_start first row of the slice; must be a multiple of\n                    sws_receive_slice_alignment()\n @param slice_height number of rows in the slice; must be a multiple of\n                     sws_receive_slice_alignment(), except for the last slice\n                     (i.e. when slice_start+slice_height is equal to output\n                     frame height)\n\n @return a non-negative number if the data was successfully written into the output\n         AVERROR(EAGAIN) if more input data needs to be provided before the\n                         output can be produced\n         another negative AVERROR code on other kinds of scaling failure"]
    pub fn sws_receive_slice(
        c: *mut SwsContext,
        slice_start: ::std::os::raw::c_uint,
        slice_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return alignment required for output slices requested with sws_receive_slice().\n         Slice offsets and sizes passed to sws_receive_slice() must be\n         multiples of the value returned from this function."]
    pub fn sws_receive_slice_alignment(c: *const SwsContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)\n @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)\n @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]\n @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]\n @param brightness 16.16 fixed point brightness correction\n @param contrast 16.16 fixed point contrast correction\n @param saturation 16.16 fixed point saturation correction\n#if LIBSWSCALE_VERSION_MAJOR > 6\n @return negative error code on error, non negative otherwise\n#else\n @return -1 if not supported\n#endif"]
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const ::std::os::raw::c_int,
        srcRange: ::std::os::raw::c_int,
        table: *const ::std::os::raw::c_int,
        dstRange: ::std::os::raw::c_int,
        brightness: ::std::os::raw::c_int,
        contrast: ::std::os::raw::c_int,
        saturation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "#if LIBSWSCALE_VERSION_MAJOR > 6\n @return negative error code on error, non negative otherwise\n#else\n @return -1 if not supported\n#endif"]
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut ::std::os::raw::c_int,
        srcRange: *mut ::std::os::raw::c_int,
        table: *mut *mut ::std::os::raw::c_int,
        dstRange: *mut ::std::os::raw::c_int,
        brightness: *mut ::std::os::raw::c_int,
        contrast: *mut ::std::os::raw::c_int,
        saturation: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and return an uninitialized vector with length coefficients."]
    pub fn sws_allocVec(length: ::std::os::raw::c_int) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Return a normalized Gaussian curve used to filter stuff\n quality = 3 is high quality, lower is lower quality."]
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Scale all the coefficients of a by the scalar value."]
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    #[doc = " Scale all the coefficients of a so that their sum equals height."]
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: ::std::os::raw::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    #[doc = " Check if context can be reused, otherwise reallocate a new one.\n\n If context is NULL, just calls sws_getContext() to get a new\n context. Otherwise, checks if the parameters are the ones already\n saved in context. If that is the case, returns the current\n context. Otherwise, frees context and gets a new context with\n the new parameters.\n\n Be warned that srcFilter and dstFilter are not checked, they\n are assumed to remain the same."]
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: ::std::os::raw::c_int,
        srcH: ::std::os::raw::c_int,
        srcFormat: AVPixelFormat,
        dstW: ::std::os::raw::c_int,
        dstH: ::std::os::raw::c_int,
        dstFormat: AVPixelFormat,
        flags: ::std::os::raw::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.\n\n The output frame will have the same packed format as the palette.\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: ::std::os::raw::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.\n\n With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: ::std::os::raw::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Get the AVClass for swsContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn sws_get_class() -> *const AVClass;
}
extern "C" {
    #[doc = " Fill the provided buffer with a string containing an error string\n corresponding to the AVERROR code errnum.\n\n @param errbuf         a buffer\n @param errbuf_size    size in bytes of errbuf\n @param errnum         error code to describe\n @return the buffer in input, filled with the error description\n @see av_strerror()"]
    pub fn _av_make_error_string(
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
        errnum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NET_ADDRESS_INFO_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct URLContext {
    pub _address: u8,
}
